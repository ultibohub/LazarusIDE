<?xml version="1.0" encoding="UTF-8"?>
<fpdoc-descriptions>
  <package name="lcl">
    <!--
      ====================================================================
        Controls
      ====================================================================
     -->
    <module name="controls">
      <short>
        Contains types, constants, classes, and routines used to implement visual controls.
      </short>
      <descr>
        <p>
          <file>controls.pp</file> contains classes, types, constants, and routines used to implement visual controls used in the Lazarus Component Library (<b>LCL</b>). Most of the classes are base classes, or used in the implementation of controls defined in others units.
        </p>
        <p>
          The following components are added to the <b>Common Controls</b> tab in the Lazarus IDE component palette:
        </p>
        <ul>
          <li>TImageList</li>
        </ul>
        <p>
          The following components are registered but not displayed on the  Lazarus IDE component palette:
        </p>
        <ul>
          <li>TCustomControl</li>
          <li>TGraphicControl</li>
        </ul>
        <p>
          This file is part of the Lazarus Component Library (LCL).
        </p>
      </descr>

      <!-- unresolved external references; interface uses clause -->
      <element name="Classes"/>
      <element name="SysUtils"/>
      <element name="TypInfo"/>
      <element name="Types"/>
      <element name="Laz_AVL_Tree"/>
      <element name="LCLStrConsts"/>
      <element name="LCLType"/>
      <element name="LCLProc"/>
      <element name="Graphics"/>
      <element name="LMessages"/>
      <element name="LCLIntf"/>
      <element name="InterfaceBase"/>
      <element name="ImgList"/>
      <element name="PropertyStorage"/>
      <element name="Menus"/>
      <element name="ActnList"/>
      <element name="LCLClasses"/>
      <element name="LResources"/>
      <element name="LCLPlatformDef"/>
      <element name="GraphType"/>
      <element name="UITypes"/>
      <element name="LazMethodList"/>
      <element name="LazLoggerBase"/>
      <element name="LazTracer"/>
      <element name="LazUtilities"/>

      <!-- included from controlconsts.inc -->
      <element name="CM_BASE">
        <short>Starting value for control message constants defined in the LCL.</short>
      </element>
      <element name="CM_LCLOFFSET">
        <short>Control message constant.</short>
      </element>
      <element name="CM_ACTIVATE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_DEACTIVATE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_GOTFOCUS">
        <short>Control message constant.</short>
      </element>
      <element name="CM_LOSTFOCUS">
        <short>Control message constant.</short>
      </element>
      <element name="CM_CANCELMODE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_DIALOGKEY">
        <short>Control message constant.</short>
      </element>
      <element name="CM_DIALOGCHAR">
        <short>Control message constant.</short>
      </element>
      <element name="CM_FOCUSCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_PARENTFONTCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_PARENTCOLORCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_HITTEST">
        <short>Control message constant.</short>
      </element>
      <element name="CM_VISIBLECHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_ENABLEDCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_COLORCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_FONTCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_CURSORCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_CTL3DCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_PARENTCTL3DCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_TEXTCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_MOUSEENTER">
        <short>Control message constant.</short>
      </element>
      <element name="CM_MOUSELEAVE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_MENUCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_APPKEYDOWN">
        <short>Control message constant.</short>
      </element>
      <element name="CM_APPSYSCOMMAND">
        <short>Control message constant.</short>
      </element>
      <element name="CM_BUTTONPRESSED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_SHOWINGCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_ENTER">
        <short>Control message constant.</short>
      </element>
      <element name="CM_EXIT">
        <short>Control message constant.</short>
      </element>
      <element name="CM_DESIGNHITTEST">
        <short>Control message constant.</short>
      </element>
      <element name="CM_ICONCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_WANTSPECIALKEY">
        <short>Control message constant.</short>
      </element>
      <element name="CM_INVOKEHELP">
        <short>Control message constant.</short>
      </element>
      <element name="CM_WINDOWHOOK">
        <short>Control message constant.</short>
      </element>
      <element name="CM_RELEASE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_SHOWHINTCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_PARENTSHOWHINTCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_SYSCOLORCHANGE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_WININICHANGE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_FONTCHANGE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_TIMECHANGE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_TABSTOPCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_UIACTIVATE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_UIDEACTIVATE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_DOCWINDOWACTIVATE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_CONTROLLISTCHANGE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_GETDATALINK">
        <short>Control message constant.</short>
      </element>
      <element name="CM_CHILDKEY">
        <short>Control message constant.</short>
      </element>
      <element name="CM_DRAG">
        <short>Control message constant.</short>
      </element>
      <element name="CM_HINTSHOW">
        <short>Control message constant.</short>
      </element>
      <element name="CM_DIALOGHANDLE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_ISTOOLCONTROL">
        <short>Control message constant.</short>
      </element>
      <element name="CM_RECREATEWND">
        <short>Control message constant.</short>
      </element>
      <element name="CM_INVALIDATE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_SYSFONTCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_CONTROLCHANGE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_CHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_DOCKCLIENT">
        <short>Control message constant.</short>
      </element>
      <element name="CM_UNDOCKCLIENT">
        <short>Control message constant.</short>
      </element>
      <element name="CM_FLOAT">
        <short>Control message constant.</short>
      </element>
      <element name="CM_BORDERCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_BIDIMODECHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_PARENTBIDIMODECHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_ALLCHILDRENFLIPPED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_ACTIONUPDATE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_ACTIONEXECUTE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_HINTSHOWPAUSE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_DOCKNOTIFICATION">
        <short>Control message constant.</short>
      </element>
      <element name="CM_MOUSEWHEEL">
        <short>Control message constant.</short>
      </element>
      <element name="CM_ISSHORTCUT">
        <short>Control message constant.</short>
      </element>
      <element name="CM_UPDATEACTIONS">
        <short>Control message constant.</short>
      </element>
      <element name="CM_INVALIDATEDOCKHOST">
        <short>Control message constant.</short>
      </element>
      <element name="CM_SETACTIVECONTROL">
        <short>Control message constant.</short>
      </element>
      <element name="CM_POPUPHWNDDESTROY">
        <short>Control message constant.</short>
      </element>
      <element name="CM_CREATEPOPUP">
        <short>Control message constant.</short>
      </element>
      <element name="CM_DESTROYHANDLE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_MOUSEACTIVATE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_CONTROLLISTCHANGING">
        <short>Control message constant.</short>
      </element>
      <element name="CM_BUFFEREDPRINTCLIENT">
        <short>Control message constant.</short>
      </element>
      <element name="CM_UNTHEMECONTROL">
        <short>Control message constant.</short>
      </element>
      <element name="CM_DOUBLEBUFFEREDCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_PARENTDOUBLEBUFFEREDCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_THEMECHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_GESTURE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_CUSTOMGESTURESCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_GESTUREMANAGERCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_STANDARDGESTURESCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_INPUTLANGCHANGE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_TABLETOPTIONSCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_PARENTTABLETOPTIONSCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_APPSHOWBTNGLYPHCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_APPSHOWMENUGLYPHCHANGED">
        <short>Control message constant.</short>
      </element>

      <!-- included from controlconsts.inc -->
      <element name="CN_BASE">
        <short>Starting value for control notification messages in the LCL.</short>
      </element>
      <element name="CN_CHARTOITEM">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_COMMAND">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_COMPAREITEM">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_CTLCOLORBTN">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_CTLCOLORDLG">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_CTLCOLOREDIT">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_CTLCOLORLISTBOX">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_CTLCOLORMSGBOX">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_CTLCOLORSCROLLBAR">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_CTLCOLORSTATIC">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_DELETEITEM">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_DRAWITEM">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_HSCROLL">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_MEASUREITEM">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_PARENTNOTIFY">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_VKEYTOITEM">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_VSCROLL">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_KEYDOWN">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_KEYUP">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_CHAR">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_SYSKEYUP">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_SYSKEYDOWN">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_SYSCHAR">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_NOTIFY">
        <short>Control notification message constant.</short>
      </element>

      <element name="mrNone">
        <short>Modal dialog left with None button.</short>
      </element>
      <element name="mrOK">
        <short>Modal dialog left with OK button.</short>
      </element>
      <element name="mrCancel">
        <short>Modal dialog left with Cancel button.</short>
      </element>
      <element name="mrAbort">
        <short>Modal dialog aborted.</short>
      </element>
      <element name="mrRetry">
        <short>Modal dialog left with Retry button.</short>
      </element>
      <element name="mrIgnore">
        <short>Modal dialog left with Ignore button.</short>
      </element>
      <element name="mrYes">
        <short>Modal dialog left with Yes button.</short>
      </element>
      <element name="mrNo">
        <short>Modal dialog left with No button.</short>
      </element>
      <element name="mrAll">
        <short>Modal dialog left with All button.</short>
      </element>
      <element name="mrNoToAll">
        <short>Modal dialog left with NoToAll button.</short>
      </element>
      <element name="mrYesToAll">
        <short>Modal dialog left with YesToAll button.</short>
      </element>
      <element name="mrClose">
        <short>Modal dialog left with Close button.</short>
      </element>
      <element name="mrLast">
        <short>Last (highest) value of modal results.</short>
      </element>

      <element name="GetModalResultStr">
        <short>
          Deprecated; Use the ModalResultStr array from the <file>UITypes</file> unit  directly.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="GetModalResultStr.Result">
        <short/>
      </element>
      <element name="GetModalResultStr.ModalResult">
        <short/>
      </element>

      <element name="ModalResultStr">
        <short>
          Gets the string representation for a modal result value.
        </short>
        <descr>
          <p>
            <var>ModalResultStr</var> is an indexed <var>ShortString</var> property used to get the string representation for the specified TModalResult constant. The read access specifier for the property has been deprecated; Use the ModalResultStr array from the <file>UITypes</file> unit  directly.
          </p>
        </descr>
        <seealso>
          <link id="#lcl.uitypes.ModalResultStr">ModalResultStr</link>
          <link id="#lcl.uitypes.TModalResult">TModalResult</link>
        </seealso>
      </element>

      <element name="fsSurface">
        <short>
          Alias to the fsSurface constant in the <file>GraphType</file> unit.
        </short>
      </element>

      <element name="fsBorder">
        <short>
          Alias to the fsBorder constant in the <file>GraphType</file> unit.
        </short>
      </element>

      <element name="bvNone">
        <short>
          Alias to the bvNone constant in the <file>GraphType</file> unit.
        </short>
      </element>

      <element name="bvLowered">
        <short>
          Alias to the bvLowered constant in the <file>GraphType</file> unit.
        </short>
      </element>

      <element name="bvRaised">
        <short>
          Alias to the bvRaised constant in the <file>GraphType</file> unit.
        </short>
      </element>

      <element name="bvSpace">
        <short>
          Alias to the bvSpace constant in the <file>GraphType</file> unit.
        </short>
      </element>

      <element name="ssModifier">
        <short>Defines the key used for shortcuts on different platforms.</short>
        <descr>
          <p>
            <var>ssModifier</var> is a constant which defines the modifier for keyboard shortcuts,  like Ctrl+C (Copy), Ctrl+Z (UnDo), Ctrl+X (Cut), and Ctrl+V (paste). Mac and iOS use the Meta key (instead of the Ctrl key) for those shortcuts.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="GUID_ObjInspInterface">
        <short>GUID for the Object Inspector in the Lazaurus IDE.</short>
        <descr>
          Value is '{37417989-8C8F-4A2D-9D26-0FA377E8D8CC}'
        </descr>
        <seealso/>
      </element>

      <element name="IObjInspInterface">
        <short>Defines an interface used in the Lazarus Object Inspector.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="IObjInspInterface.AllowAdd">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="IObjInspInterface.AllowAdd.Result">
        <short/>
      </element>

      <element name="IObjInspInterface.AllowDelete">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="IObjInspInterface.AllowDelete.Result">
         <short/>
      </element>

      <element name="TWinControlClass">
        <short>
          <var>TWinControlClass</var> - class of <var>TWinControl</var>.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlClass">
        <short>
          <var>TControlClass</var> - class of <var>TControl</var>.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TCMMouseWheel">
        <short>Defines a structure used for mouse wheel control messages.</short>
        <descr>
          <p>Holds mouse wheel details that include:</p>
          <ul>
            <li>the Message associated with the wheel</li>
            <li>the shift state (i.e. whether Shift, Alt, Control keys have been pressed)</li>
            <li>the mouse position</li>
            <li>the message Result</li>
          </ul>
        </descr>
        <seealso/>
      </element>

      <element name="TCMMouseWheel.Msg">
        <short>The exact Message ID (WM_MOUSEWHEEL?).</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCMMouseWheel.ShiftState">
        <short>State of the modifier for keys and mouse buttons.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCMMouseWheel.Unused">
        <short>Inserted for alignment only.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCMMouseWheel.WheelData">
        <short>
          Number of notches or units the mouse wheel was turned. Negative for mouse wheel up movements.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCMMouseWheel.Pos">
        <short>Mouse position as a TSmallPoint value.</short>
      </element>
      <element name="TCMMouseWheel.XPos">
        <short>Mouse X position as a SmallInt value.</short>
      </element>
      <element name="TCMMouseWheel.YPos">
        <short>Mouse Y position as a SmallInt value.</short>
      </element>
      <element name="TCMMouseWheel.Result">
        <short>
          Result for the mouse wheel message. Zero (0) indicates the message was handled.
        </short>
      </element>

      <element  name="TCMHitTest">
        <short>Alias for the TLMNCHitTest type.</short>
        <descr/>
        <seealso>
          <link id="#lcl.lmessages.TLMNCHitTest"/>
        </seealso>
      </element>

      <element  name="TCMDesignHitTest">
        <short>Alias for the TLMMouse type.</short>
        <descr/>
        <seealso>
          <link id="#lcl.lmessages.TLMMouse"/>
        </seealso>
      </element>

      <element name="TCMControlChange">
        <short>Contains values representing a Control Change Message.</short>
        <descr>
          <p>
            <var>TCMControlChange</var> is a record type which contains values representing the arguments and the result for a Control Change Message. <var>TCMControlChange</var> is the type passed to the <var>CMControlChange</var> method in <var>TCustomFlowPanel</var>.
          </p>
        </descr>
        <seealso>
          <link id="#lcl.extctrls.TCustomFlowPanel.CMControlChange">TCustomFlowPanel.CMControlChange</link>
        </seealso>
      </element>
      <element name="TCMControlChange.Msg">
        <short>Mouse message constant for the change notification.</short>
      </element>
      <element name="TCMControlChange.Control">
        <short>Control to receive the change message.</short>
      </element>
      <element name="TCMControlChange.Inserting">
        <short>Indicates if the control message is an insert operation.</short>
      </element>
      <element name="TCMControlChange.Result">
        <short>Result for the control change message.</short>
      </element>

      <element name="TCMChanged">
        <short>Not used in the current LCL implementation.</short>
      </element>
      <element name="TCMChanged.Msg">
        <short/>
      </element>
      <element name="TCMChanged.Unused">
        <short/>
      </element>
      <element name="TCMChanged.Child">
        <short/>
      </element>
      <element name="TCMChanged.Result">
        <short/>
      </element>

      <element name="TCMControlListChange">
        <short>Not used in the current LCL implementation.</short>
      </element>
      <element name="TCMControlListChange.Msg">
        <short/>
      </element>
      <element name="TCMControlListChange.Control">
        <short/>
      </element>
      <element name="TCMControlListChange.Inserting">
        <short/>
      </element>
      <element name="TCMControlListChange.Result">
        <short/>
      </element>

      <element name="TCMDialogChar">
        <short>Alias for the TLMKey type.</short>
        <seealso>
          <link id="#lcl.lmessages.TLMKey"/>
        </seealso>
        <notes><note>Used in LazReport controls.</note></notes>
      </element>

      <element name="TCMDialogKey">
        <short>Alias for the TLMKey type.</short>
        <seealso>
          <link id="#lcl.lmessages.TLMKey"/>
        </seealso>
        <notes><note>Used in the jvcllaz package.</note></notes>
      </element>

      <element name="TCMEnter">
        <short>Alias for the TLMEnter type.</short>
        <seealso>
          <link id="#lcl.lmessages.TLMEnter">TLMEnter</link>
        </seealso>
      </element>

      <element name="TCMExit">
        <short>Alias for the TLMExit type.</short>
        <seealso>
          <link id="#lcl.lmessages.TLMExit"/>
        </seealso>
      </element>

      <element name="TCMCancelMode">
        <short>Contains information representing a CM_CANCELMODE control message.</short>
        <notes><note>Used in the jvcllaz package.</note></notes>
      </element>
      <element name="TCMCancelMode.Msg">
        <short/>
      </element>
      <element name="TCMCancelMode.Unused">
        <short/>
      </element>
      <element name="TCMCancelMode.Sender">
        <short/>
      </element>
      <element name="TCMCancelMode.Result">
        <short/>
      </element>

      <element name="TCMChildKey">
        <short>Not used in the current LCL implementation.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCMChildKey.Msg">
        <short/>
      </element>
      <element name="TCMChildKey.Unused"/>
      <element name="TCMChildKey.CharCode">
        <short>VK_XXX constants for TLMKeyDown/Up, ASCII for TLMChar.</short>
      </element>
      <element name="TCMChildKey.Sender">
        <short/>
      </element>
      <element name="TCMChildKey.Result">
        <short/>
      </element>

      <element name="TAlign">
        <short>Alignment options for a control, within its Parent control.</short>
        <descr>
          <p>
            <var>TAlign</var> is an enumeration type with values that indicate the alignment for a control within its Parent. The enumeration includes the following values and meanings:
          </p>
          <dl>
            <dt>alNone</dt>
            <dd>fixed position and extent</dd>
            <dt>alTop</dt>
            <dd>stacked at top, full width</dd>
            <dt>alBottom</dt>
            <dd>stacked at bottom, full width</dd>
            <dt>alLeft</dt>
            <dd>stacked at left, full height</dd>
            <dt>alRight</dt>
            <dd>stacked at right, full height</dd>
            <dt>alClient</dt>
            <dd>filling entire remaining client area</dd>
            <dt>alCustom</dt>
            <dd>other alignment, in drag-dock: notebook</dd>
          </dl>
          <p>
            At most, one control can have alClient alignment for a given form or container.
          </p>
          <p>
            The order of multiple controls with the same (stackable) alignment is determined by their Left and/or Top coordinate. The precedence of conflicting alignment requests (e.g. one at top, one at right) is resolved.
          </p>
        </descr>
      </element>
      <element name="TAlign.alNone">
        <short>Control has fixed size and position.</short>
      </element>
      <element name="TAlign.alTop">
        <short>Control stacked at top, full width.</short>
      </element>
      <element name="TAlign.alBottom">
        <short>Control stacked at bottom, full width.</short>
      </element>
      <element name="TAlign.alLeft">
        <short>Control stacked at left, full height.</short>
      </element>
      <element name="TAlign.alRight">
        <short>Control stacked at right, full height.</short>
      </element>
      <element name="TAlign.alClient">
        <short>Control fills remaining client area.</short>
      </element>
      <element name="TAlign.alCustom">
        <short>Control has special alignment.</short>
        <descr/>
      </element>

      <element name="TAlignSet">
        <short>Set of alignment options.</short>
        <seealso>
          <link id="#lcl.controls.TAlign">TAlign</link>
        </seealso>
      </element>

      <element name="TAnchorKind">
        <short>The control side to be anchored.</short>
        <descr>
          With the TAnchorSideReference value asrCenter, the sides mean horizontal or vertical alignment of the control's center.
        </descr>
      </element>
      <element name="TAnchorKind.akTop">
        <short>Top side (or center vertically).</short>
      </element>
      <element name="TAnchorKind.akLeft">
        <short>Left side (or center horizontally).</short>
      </element>
      <element name="TAnchorKind.akRight">
        <short>Right side (or center horizontally).</short>
      </element>
      <element name="TAnchorKind.akBottom">
        <short>Bottom side (or center vertically).</short>
      </element>

      <element name="TAnchors">
        <short>Set type used to store values from the TAnchorKind enumeration.</short>
        <descr>
          <p>
            TAnchors is the the type used to implement the Anchors property in TControl and descendent classes.
          </p>
        </descr>
        <seealso>
          <link id="TAnchorKind"/>
          <link id="TControl.Anchors"/>
        </seealso>
      </element>

      <element name="TAnchorSideReference">
        <short>The side of another control, to which this control's side is anchored.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TAnchorSideReference.asrTop">
        <short>Anchor to the top side.</short>
      </element>
      <element name="TAnchorSideReference.asrBottom">
        <short>Anchor to the bottom side.</short>
      </element>
      <element name="TAnchorSideReference.asrCenter">
        <short>Anchor to the center of the other control.</short>
      </element>

      <element name="asrLeft">
        <short>Anchor to the left side (=asrTop).</short>
        <descr/>
        <seealso/>
      </element>

      <element name="asrRight">
        <short>Anchor to the right side (=asrBottom).</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TCaption">
        <short>A string type used for the caption on a control: may be translated.</short>
      </element>

      <element name="TCursor">
        <short>Defines the range of values used for cursor shapes.</short>
        <descr>
          <p>
            <var>TCursor</var> is an Integer type which defines the range of values used for cursor shapes. <var>TCursor</var> includes the following values:
          </p>
          <p><b>Standard Cursors</b></p>
          <dl>
            <dt>crDefault</dt>
            <dd>TCursor(0) - current cursor unchanged</dd>
            <dt>crNone</dt>
            <dd>TCursor(-1) - hide cursor</dd>
            <dt>crArrow</dt>
            <dd>TCursor(-2) - normal cursor</dd>
            <dt>crCross</dt>
            <dd>TCursor(-3) - graphics cursor, for pixel or rectangle selection</dd>
            <dt>crIBeam</dt>
            <dd>TCursor(-4) - text cursor, for setting insertion point</dd>
          </dl>
          <p><b>Sizing Cursors</b></p>
          <dl>
            <dt>crSize</dt>
            <dd>TCursor(-22)</dd>
            <dt>crSizeAll</dt>
            <dd>TCursor(-22)</dd>
            <dt>crSizeNESW</dt>
            <dd>TCursor(-6) - diagonal north east - south west</dd>
            <dt>crSizeNS</dt>
            <dd>TCursor(-7)</dd>
            <dt>crSizeNWSE</dt>
            <dd>TCursor(-8)</dd>
            <dt>crSizeWE</dt>
            <dd>TCursor(-9)</dd>
            <dt>crSizeNW</dt>
            <dd>TCursor(-23)</dd>
            <dt>crSizeN</dt>
            <dd>TCursor(-24)</dd>
            <dt>crSizeNE</dt>
            <dd>TCursor(-25)</dd>
            <dt>crSizeW</dt>
            <dd>TCursor(-26)</dd>
            <dt>crSizeE</dt>
            <dd>TCursor(-27)</dd>
            <dt>crSizeSW</dt>
            <dd>TCursor(-28)</dd>
            <dt>crSizeS</dt>
            <dd>TCursor(-29)</dd>
            <dt>crSizeSE</dt>
            <dd>TCursor(-30)</dd>
          </dl>
          <p><b>Drag and Drop Cursors</b></p>
          <dl>
            <dt>crDrag</dt>
            <dd>TCursor(-12) - dragging, drop allowed</dd>
            <dt>crNoDrop</dt>
            <dd>TCursor(-13) - dragging, drop disallowed/rejected</dd>
            <dt>crMultiDrag</dt>
            <dd>TCursor(-16) - dragging multiple items</dd>
            <dt>crNo</dt>
            <dd>TCursor(-18)</dd>
            <dt>Splitter Cursors</dt>
            <dd></dd>
            <dt>crHSplit</dt>
            <dd>TCursor(-14)</dd>
            <dt>crVSplit</dt>
            <dd>TCursor(-15)</dd>
          </dl>
          <p><b>Other  Cursors</b></p>
          <dl>
            <dt>crUpArrow</dt>
            <dd>TCursor(-10)</dd>
            <dt>crHourGlass</dt>
            <dd>TCursor(-11) - busy</dd>
            <dt>crSQLWait</dt>
            <dd>TCursor(-17)</dd>
            <dt>crAppStart</dt>
            <dd>TCursor(-19)</dd>
            <dt>crHelp</dt>
            <dd>TCursor(-20)</dd>
            <dt>crHandPoint</dt>
            <dd>TCursor(-21)</dd>
          </dl>
        </descr>
      </element>

      <element name="TFormStyle">
        <short>Defines special form behavior.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TFormStyle.fsNormal">
        <short>An ordinary (overlapping) form.</short>
      </element>
      <element name="TFormStyle.fsMDIChild">
        <short>The form is an MDI child.</short>
      </element>
      <element name="TFormStyle.fsMDIForm">
        <short>The form is an MDI parent form, containing MDI child forms.</short>
      </element>
      <element name="TFormStyle.fsStayOnTop">
        <short>The form is in the foreground, on top of all other application forms.</short>
      </element>
      <element name="TFormStyle.fsSplash">
        <short>The form is used as a Splash form.</short>
        <descr>
          <p>
            Signifies that the form cannot become the main form in an application. Implies that the form responds to fewer messages; generally, paint messages and little else. May affect the border style and even the window class used for the form on some widget sets.
          </p>
        </descr>
      </element>
      <element name="TFormStyle.fsSystemStayOnTop">
        <short>The form stays system-wide on top.</short>
        <descr>
          <p>
            Used in forms for a modal system dialogs Prevents another form from having a higher Z-order value than the current one. Generally treated the same as fsStayOnTop except for MacOS Cocoa, because... you know, Mac! Think different!
          </p>
        </descr>
      </element>

      <element name="TFormBorderStyle">
        <short>Represents border styles available for a Form.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TFormBorderStyle.bsNone">
        <short>No border at all.</short>
      </element>
      <element name="TFormBorderStyle.bsSingle">
        <short>Single line border, the form cannot be resized.</short>
      </element>
      <element name="TFormBorderStyle.bsSizeable">
        <short>The form can be resized (standard).</short>
      </element>
      <element name="TFormBorderStyle.bsDialog">
        <short>The form is a dialog, cannot be resized.</short>
      </element>
      <element name="TFormBorderStyle.bsToolWindow">
        <short>Single line border, small caption, not resizable.</short>
      </element>
      <element name="TFormBorderStyle.bsSizeToolWin">
        <short>Small caption, form can be resized.</short>
      </element>

      <element name="TBorderStyle">
        <short>Possible types of borders (with or without border).</short>
        <seealso>
          <link id="#lcl.controls.TFormBorderStyle">TFormBorderStyle</link>
        </seealso>
      </element>

      <element name="TControlBorderStyle">
        <short>Possible types of control borders (with or without border).</short>
        <descr>
          A subset of TFormBorderStyle, listing only the styles available to a control that is not a form.
        </descr>
        <seealso>
          <link id="#lcl.controls.TFormBorderStyle">TFormBorderStyle</link>
        </seealso>
      </element>

      <element name="TControlRoleForForm">
        <short>Possible default actions on special keys.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlRoleForForm.crffDefault">
        <short>This control is notified when the user presses Return.</short>
      </element>
      <element name="TControlRoleForForm.crffCancel">
        <short>This control is notified when the user presses Escape.</short>
      </element>

      <element name="TControlRolesForForm">
        <short>Set type used to store values from the TControlRoleForForm enumeration.</short>
        <descr>
          <p>
            TControlRolesForForm is the type returned from the TCustomForm.GetRolesForControl method.
          </p>
        </descr>
        <seealso>
          <link id="TControlRoleForForm"/>
          <link id="#lcl.forms.TCustomForm">TCustomForm</link>
        </seealso>
      </element>

      <element name="TBevelCut">
        <short>Alias for the TGraphicsBevelCut type.</short>
        <descr>
          <p>
            TBevelCut is the type used to represent bevel styles passed as arguments to methods in widgetset classes.
          </p>
        </descr>
        <seealso>
          <link id="#lazutils.graphtype.TGraphicsBevelCut">TGraphicsBevelCut</link>
        </seealso>
      </element>

      <element name="TMouseButton">
        <short>Enumeration of recognized mouse buttons.</short>
        <descr>
          <p>
            These are <b>logical</b> buttons; the left and right physical buttons can be swapped for left-handed users.
          </p>
        </descr>
      </element>
      <element name="TMouseButton.mbLeft">
        <short>
          Represents the left mouse button. It might be physically the right button if the system is configured to act like that, for example for a left handled person.
        </short>
      </element>
      <element name="TMouseButton.mbRight">
        <short>
          Represents the right mouse button. It might be physically the left button if the system is configured to act like that, for example for a left handled person.
        </short>
      </element>
      <element name="TMouseButton.mbMiddle">
        <short>Represents the middle mouse button.</short>
      </element>
      <element name="TMouseButton.mbExtra1">
        <short>Represents the first extra mouse button.</short>
      </element>
      <element name="TMouseButton.mbExtra2">
        <short>Represents the second extra mouse button.</short>
      </element>

      <element name="fsAllStayOnTop">
        <short>Set of form styles, which make a form stay on top.</short>
        <descr/>
        <seealso>
          <link id="TFormStyle"/>
        </seealso>
      </element>

      <element name="fsAllNonSystemStayOnTop">
        <short>
          Set of form styles, except those which make a form stay on top of all other forms of the system.
        </short>
        <seealso>
          <link id="TFormStyle"/>
        </seealso>
      </element>

      <element name="crHigh">
        <short>Highest defined cursor constant (0).</short>
      </element>
      <element name="crDefault">
        <short>Indicates that the default cursor from the system should be utilized.</short>
      </element>
      <element name="crNone">
        <short>Indicates that the cursor should be invisible.</short>
      </element>
      <element name="crArrow">
        <short>The Arrow cursor, which is the most common and the default one in most cases.</short>
      </element>
      <element name="crCross">
        <short>A cursor utilized for graphics, for pixel or rectangle selection, often in the shape of a cross.</short>
      </element>
      <element name="crIBeam">
        <short>A text cursor, for setting insertion point. Often used in text editors.</short>
      </element>
      <element name="crSize">
        <short>A generic sizing cursor, to indicate that here one may drag to resize something. Is the same as crSizeAll.</short>
      </element>
      <element name="crSizeNESW">
        <short>A cursor for resizing which runs diagonally from NorthEast to SouthWest (-6).</short>
      </element>
      <element name="crSizeNS">
        <short>A cursor for resizing which cursor runs from North to South (-7).</short>
      </element>
      <element name="crSizeNWSE">
        <short>A cursor for resizing which cursor runs from NorthWest to SouthEast.</short>
      </element>
      <element name="crSizeWE">
        <short>A cursor for resizing which has an arrow with two points, one to the left and another to the right, to indicate resizing possibility in both directions.</short>
      </element>
      <element name="crSizeNW">
        <short>A cursor for resizing which has an arrow pointing to the left-top corner, to indicate resizing possibility in this direction.</short>
      </element>
      <element name="crSizeN">
        <short>A cursor for resizing which has an arrow pointing upwards, to indicate resizing possibility in this direction.</short>
      </element>
      <element name="crSizeNE">
        <short>A cursor for resizing which has an arrow pointing to the right-top corner, to indicate resizing possibility in this direction.</short>
      </element>
      <element name="crSizeW">
        <short>A cursor for resizing which has an arrow pointing to the left, to indicate resizing possibility in this direction.</short>
      </element>
      <element name="crSizeE">
        <short>A cursor for resizing which has an arrow pointing to the right, to indicate resizing possibility in this direction.</short>
      </element>
      <element name="crSizeSW">
        <short>A cursor for resizing which has an arrow pointing to the left-bottom corner, to indicate resizing possibility in this direction.</short>
      </element>
      <element name="crSizeS">
        <short>A cursor for resizing which has an arrow pointing downwards, to indicate resizing possibility in this direction.</short>
      </element>
      <element name="crSizeSE">
        <short>A cursor for resizing which has an arrow pointing to the right-bottom corner, to indicate resizing possibility in this direction.</short>
      </element>
      <element name="crUpArrow">
        <short>Up Arrow cursor constant (-10).</short>
      </element>
      <element name="crHourGlass">
        <short>Busy cursor constant, utilized to indicate that one should wait while an action is done.</short>
      </element>
      <element name="crDrag">
        <short>A cursor to indicate that one can drop a dragged item in this area.</short>
      </element>
      <element name="crNoDrop">
        <short>A cursor to indicate that one cannot drop a dragged item in this area.</short>
      </element>
      <element name="crHSplit">
        <short>Horizontal Splitter cursor constant (-14).</short>
      </element>
      <element name="crVSplit">
        <short>Vertical Split cursor constant (-15).</short>
      </element>
      <element name="crMultiDrag">
        <short>Multiple Object dragging cursor constant (-16).</short>
      </element>
      <element name="crSQLWait">
        <short>Waiting for SQL cursor constant (-17).</short>
      </element>
      <element name="crNo">
        <short>Shows a negative sign. See also <link id="crNoDrop"/>.
        </short>
      </element>
      <element name="crAppStart">
        <short>Application starting cursor.</short>
      </element>
      <element name="crHelp">
        <short>"What's This" Help cursor constant (-20).</short>
      </element>
      <element name="crHandPoint">
        <short>Pointing hand cursor constant (-21).</short>
      </element>
      <element name="crSizeAll">
        <short>All Directions sizing cursor constant (-22).</short>
      </element>
      <element name="crLow">
        <short>Lowest defined cursor constant (-30).</short>
      </element>

      <element name="TCaptureMouseButtons">
        <short>Set type used to store TMouseButton values.</short>
        <descr>
          <p>
            <var>TCaptureMouseButtons</var> is a set type used to store <var>TMouseButton</var> enumeration values. TCaptureMouseButtons is the type used to implement the <var>CaptureMouseButtons</var> property in <var>TControl</var>.
          </p>
        </descr>
        <seealso>
          <link id="TMouseButton"/>
          <link id="TControl.CaptureMouseButtons"/>
        </seealso>
      </element>

      <element name="TWndMethod">
        <short>Method type for WindowProc handlers.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWndMethod.TheMessage">
        <short>Message with the command constant and key code processed in the handler.</short>
      </element>

      <element name="TControlStyleType">
        <short>TControlStyleType - enumerated type describing features of the Control.</short>
      </element>
      <element name="TControlStyleType.csAcceptsControls">
        <short>
          Indicates that one can add child controls to this control in the form designer.
        </short>
      </element>
      <element name="TControlStyleType.csCaptureMouse">
        <short>Control focus and style changes when under the mouse cursor.</short>
      </element>
      <element name="TControlStyleType.csDesignInteractive">
        <short>wants mouse events in design mode.</short>
      </element>
      <element name="TControlStyleType.csClickEvents">
        <short>Control responds to single mouse clicks.</short>
      </element>
      <element name="TControlStyleType.csFramed">
        <short>Control has a 3D frame; used on scroll bars in the current LCL version.</short>
      </element>
      <element name="TControlStyleType.csSetCaption">
        <short>As long as Name=Text, changing the Name will set the Caption.</short>
        <descr>
          <p>
            When, for example, a button's Name and Caption have the value 'Button1' and the Name is changed to 'Button2' then the Caption is changed as well. When Name and Caption differ, this flag has no effect. This flag has no effect when loading the control using the LCL component streaming mechanism.
          </p>
        </descr>
      </element>
      <element name="TControlStyleType.csOpaque">
        <short>
          Control is drawn with a non-transparent background; implementation is widgetset-specific.
        </short>
      </element>
      <element name="TControlStyleType.csDoubleClicks">
        <short>Indicates that the control understands mouse double clicks.</short>
      </element>
      <element name="TControlStyleType.csTripleClicks">
        <short>Indicates that the control understands mouse triple clicks.</short>
      </element>
      <element name="TControlStyleType.csQuadClicks">
        <short>Indicates that the control understands mouse quadruple clicks.</short>
      </element>
      <element name="TControlStyleType.csFixedWidth">
        <short>Indicates that the control cannot change its width.</short>
      </element>
      <element name="TControlStyleType.csFixedHeight">
        <short>Indicates that the control cannot change its height (e.g. combobox).</short>
      </element>
      <element name="TControlStyleType.csNoDesignVisible">
        <short>Indicates that the control is invisible in the form designer.</short>
      </element>
      <element name="TControlStyleType.csReplicatable">
        <short>Control can be drawn using the TWinControl.PaintTo method.</short>
      </element>
      <element name="TControlStyleType.csNoStdEvents">
        <short>Key messages are handler by widgetset classes instead of control events.</short>
      </element>
      <element name="TControlStyleType.csDisplayDragImage">
        <short>Display images from the drag imagelist during drag operation over control.</short>
      </element>
      <element name="TControlStyleType.csReflector">
        <short>
          Control responds to size, focus, and dialog messages and can be used as an ActiveX control (Windows).
        </short>
      </element>
      <element name="TControlStyleType.csActionClient">
        <short>Control includes support for TBasicAction.</short>
      </element>
      <element name="TControlStyleType.csMenuEvents">
        <short>Control responds to menu and menu item events.</short>
      </element>
      <element name="TControlStyleType.csNoFocus">
        <short>
          Indicates that the control cannot receive focus.
        </short>
      </element>
      <element name="TControlStyleType.csNeedsBorderPaint">
        <short>[not implemented]</short>
      </element>
      <element name="TControlStyleType.csParentBackground">
        <short>[not implemented]</short>
      </element>
      <element name="TControlStyleType.csDesignNoSmoothResize">
        <short>no WYSIWYG resizing in designer.</short>
      </element>
      <element name="TControlStyleType.csDesignFixedBounds">
        <short>control can not be moved nor resized in designer.</short>
      </element>
      <element name="TControlStyleType.csHasDefaultAction">
        <short>control implements useful ExecuteDefaultAction.</short>
      </element>
      <element name="TControlStyleType.csHasCancelAction">
        <short>control implements useful ExecuteCancelAction.</short>
      </element>
      <element name="TControlStyleType.csNoDesignSelectable">
        <short>control can not be selected at design time.</short>
      </element>
      <element name="TControlStyleType.csOwnedChildrenNotSelectable">
        <short>child controls owned by this control are NOT selectable in the designer.</short>
      </element>
      <element name="TControlStyleType.csAutoSize0x0">
        <short>if the preferred size is 0x0 then control is shrunk to 0x0</short>
      </element>
      <element name="TControlStyleType.csAutoSizeKeepChildLeft">
        <short>when AutoSize=true do not move children horizontally.</short>
      </element>
      <element name="TControlStyleType.csAutoSizeKeepChildTop">
        <short>when AutoSize=true do not move children vertically.</short>
      </element>
      <element name="TControlStyleType.csRequiresKeyboardInput">
        <short>
          Indicates that a control requires keyboard input to be utilized by the user.
        </short>
        <descr>
          <p>
            Indicates that a control requires keyboard input to be utilized by the user. This information is utilized in Android and other platforms to activate the virtual keyboard when the control receives. Used primarily for devices that do not have a hardware keyboard.
          </p>
        </descr>
      </element>

      <element name="TControlStyle">
        <short>Set type used to store values from the TControlStyleType enumeration.</short>
        <descr>
          <p>
            TControlStyle is the type used to implement the ControlStyle property in TControl and descendent classes.
          </p>
        </descr>
        <seealso>
          <link id="TControlStyleType"/>
          <link id="TControl.ControlStyle"/>
        </seealso>
      </element>

      <element name="csMultiClicks">
        <short>Set of styles which require/provide multiple clicks on a control.</short>
      </element>

      <element name="TControlStateType">
        <short>State flags of a Control.</short>
        <descr>
          <p>
            TControlStateType is an enumeration type which contains values that represent  state information for control class instances, including:
          </p>
          <ul>
            <li>csLButtonDown</li>
            <li>csClicked</li>
            <li>csPalette</li>
            <li>csReadingState</li>
            <li>csAlignmentNeeded</li>
            <li>csFocusing</li>
            <li>csCreating</li>
            <li>csPaintCopy</li>
            <li>csCustomPaint</li>
            <li>csDestroyingHandle</li>
            <li>csDocking</li>
            <li>csVisibleSetInLoading</li>
          </ul>
          <p>
            Values from the TControlStateType enumeration are stored in the TControlState type, and used to implement the ControlState property in TControl.
          </p>
        </descr>
        <seealso>
          <link id="TControlState"/>
          <link id="TControl.ControlState"/>
        </seealso>
      </element>
      <element name="TControlStateType.csLButtonDown">
        <short>Indicates the Left mouse button was down for the control.</short>
      </element>
      <element name="TControlStateType.csClicked">
        <short>Indicates the control was clicked; occurs after button down/up processing.</short>
      </element>
      <element name="TControlStateType.csPalette">
        <short>Palettes are not currently implemented in LCL.</short>
      </element>
      <element name="TControlStateType.csReadingState">
        <short>Indicates the ReadState method has been called for the control.</short>
      </element>
      <element name="TControlStateType.csFocusing">
        <short>Indicates the focus for the control has been changed.</short>
      </element>
      <element name="TControlStateType.csCreating">
        <short>Introduced for Delphi compatibility; not used in LCL.</short>
      </element>
      <element name="TControlStateType.csPaintCopy">
        <short>Indicates a device context was copied  in PaintControls.</short>
      </element>
      <element name="TControlStateType.csCustomPaint">
        <short>
          Indicates a custom paint method is used to draw the control; determines the handler called to paint the control.
        </short>
      </element>
      <element name="TControlStateType.csDestroyingHandle">
        <short>Used to suppress message processing when the control is freed.</short>
      </element>
      <element name="TControlStateType.csDocking">
        <short>Indicates the Dock method has been called for a control.</short>
      </element>
      <element name="TControlStateType.csVisibleSetInLoading">
        <short>
        Indicates the control is being loaded using the LCL component streaming mechanism.
        </short>
      </element>

      <element name="TControlState">
        <short>Set of Control States allowed in a control.</short>
        <seealso>
          <link id="TControlStateType"/>
        </seealso>
      </element>

      <element name="TControlCanvas">
        <short>
          Base class which provides a canvas property used in graphic controls.
        </short>
        <descr>
          <p>
            <var>TControlCanvas</var> is a <var>TCanvas</var> descendant that implements the base class which provides a canvas used in graphic controls. TControlCanvas extends the ancestor class  by including a property representing the <var>TControl</var> associated with the canvas, a window handle for the associated control, and the device context for the handle.
          </p>
          <p>
            TControlCanvas is used in the implementation of classes like <var>TGraphicControl</var> and <var>TCustomControl</var>, and other visual controls.
          </p>
        </descr>
        <seealso>
          <link id="#lcl.graphics.TCanvas">TCanvas</link>
          <link id="TGraphicControl"/>
          <link id="TCustomControl"/>
        </seealso>
      </element>

      <element name="TControlCanvas.FControl"/>
      <element name="TControlCanvas.FDeviceContext"/>
      <element name="TControlCanvas.FWindowHandle"/>

      <element name="TControlCanvas.SetControl">
        <short>Sets the value for the Control property.</short>
        <descr/>
        <seealso>
          <link id="TControlCanvas.Control"/>
        </seealso>
      </element>
      <element name="TControlCanvas.SetControl.AControl">
        <short>New value for the property.</short>
      </element>

      <element name="TControlCanvas.CreateHandle">
        <short>Ensures that a handle exists for the class instance.</short>
        <descr>
          <p>
            Calls the inherited method on entry when a value has not been assigned to the Control property.
          </p>
          <p>
            Otherwise, Control is used to check for an existing device context (HDC) for the class instance. When assigned, its value is copied into the Handle for the control.When not assigned, the HandleNeeded method in TWinControl is called to create the window handle and get its device context. If Control is not derived from TWinControl, its Parent is used to call the HandleNeeded method.
          </p>
          <p>
            This is done to prevent resource leaks that might occur when directly accessing he window Handle before it has actually been allocated (recursive calls to the method).
          </p>
          <p>
            If the device context remains unassigned, the GetDeviceContext method in Control is called to get the device context for the window Handle.
          </p>
        </descr>
        <seealso>
          <link id="TControlCanvas.Control"/>
          <link id="TWinControl.HandleNeeded"/>
          <link id="TWinControl.Handle"/>
          <link id="TControl.GetDeviceContext"/>
          <link id="#lcl.graphics.TCanvas.CreateHandle">TCanvas.CreateHandle</link>
        </seealso>
      </element>

      <element name="TControlCanvas.GetDefaultColor">
        <short>Gets the color value used for clDefault.</short>
        <descr>
          <p>
            <var>GetDefaultColor</var> is overridden in <var>TControlCanvas</var> to ensure that the <var>Control</var> is used (when assigned) to retrieve the default color. If Control is not assigned, the inherited method is called to get the default color value.
          </p>
        </descr>
        <seealso>
          <link id="TControlCanvas.Control"/>
          <link id="#lcl.graphics.TCanvas.GetDefaultColor">TCanvas.GetDefaultColor</link>
          <link id="#lcl.controls.TControl.GetDefaultColor">TControl.GetDefaultColor</link>
        </seealso>
      </element>
      <element name="TControlCanvas.GetDefaultColor.Result">
        <short/>
      </element>
      <element name="TControlCanvas.GetDefaultColor.ADefaultColorType">
        <short/>
      </element>

      <element name="TControlCanvas.Create">
        <short>Constructor for the class instance.</short>
        <descr>
          <p>
            <var>Create</var> is the overridden constructor for the class instance. Create calls the inherited constructor, and sets the default unassigned values for the device context, window handle, and control used in the class instance. The device context and window handle are maintained in methods which use the respective members. Use the <var>Control</var> property to set the owner for the class instance.
          </p>
        </descr>
        <seealso>
          <link id="TControlCanvas.Control"/>
          <link id="TControlCanvas.Destroy"/>
        </seealso>
      </element>

      <element name="TControlCanvas.Destroy">
        <short>Destructor for the class instance.</short>
        <descr>
          <p>
            <var>Destroy</var> is the overridden destructor for the class instance. Destroy ensures that a device context allocated for the window handle in <var>Control</var> is freed prior calling the inherited destructor.
          </p>
        </descr>
        <seealso>
          <link id="TControlCanvas.Control"/>
          <link id="TControlCanvas.Create"/>
        </seealso>
      </element>

      <element name="TControlCanvas.FreeHandle">
        <short>
          Frees the Handle for the control canvas, and its device context when assigned.
        </short>
        <descr>
          <p>
            <var>FreeHandle</var> is an overridden method in TControlCanvas. It calls the inherited method on entry to set the value in <var>Handle</var> to 0 (the unassigned value). If a device context (DC) has been allocated for the window handle (HWND), the <var>ReleaseDC</var> routine is called to release the device context.
          </p>
            <p>
              FreeHandle is called when a new value is assigned to the <var>Control</var> property, or when the class instance is freed.
            </p>
        </descr>
        <seealso>
          <link id="TControlCanvas.Destroy"/>
          <link id="TControlCanvas.Control"/>
          <link id="#lcl.graphics.TCanvas.Handle">TCanvas.Handle</link>
          <link id="#lcl.graphics.TCanvas.FreeHandle">TCanvas.FreeHandle</link>
          <link id="#lcl.lclintf.ReleaseDC">ReleaseDC</link>
        </seealso>
      </element>

      <element name="TControlCanvas.ControlIsPainting">
        <short>Indicates if the Control has called but not completed its Paint method.</short>
        <descr>
          <p>
            <var>ControlIsPainting</var> is a <var>Boolean</var> function which indicates if the <var>Control</var> has called but not completed its <var>Paint</var> method. ControlIsPainting returns <b>True</b> when the Control has been assigned (contains a non-Nil value) and its <var>IsProcessingPaintMsg</var> method returns <b>True</b>.
          </p>
          <p>
            ControlIsPainting is used in the implementation of the <var>CreateHandle</var> method.
          </p>
        </descr>
        <seealso>
          <link id="TControl.IsProcessingPaintMsg"/>
        </seealso>
      </element>
      <element name="TControlCanvas.ControlIsPainting.Result">
        <short>True when the Control has been assigned is repainting.</short>
      </element>

      <element name="TControlCanvas.Control">
        <short>The Control object for which the Canvas is used.</short>
        <descr>
          <p>
            <var>Control</var> is a <var>TControl</var> property which represents the control associated with the canvas in the class instance. Setting the value in Control causes an existing Window handle (and its device context) in the class instance to be freed. The handle and its device context are recreated (eventually) when the control is displayed.
          </p>
        </descr>
        <seealso>
          <link id="TControl"/>
        </seealso>
      </element>

      <element name="PHintInfo">
        <short>Pointer to a THintInfo instance.</short>
        <descr>
          <p>
            <var>PHintInfo</var> is a <var>Pointer</var> to a <var>THintInfo</var> instance. PHintInfo is the type passed as an argument to the <var>TControlShowHintEvent</var> event handler procedure, and the <var>DoOnShowHint</var> method in <var>TControl</var>.
          </p>
        </descr>
        <seealso>
          <link id="THintInfo"/>
          <link id="TControlShowHintEvent"/>
          <link id="TControl.DoOnShowHint"/>
        </seealso>
      </element>

      <element name="THintInfo">
        <short>
          Contains content and state information for Hints displayed for a window or control.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="THintInfo.HintControl">
        <short>Control for the hint display.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="THintInfo.HintWindowClass">
        <short>Window class for the hint display.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="THintInfo.HintPos">
        <short>TPoint with the screen coordinates for the hint display.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="THintInfo.HintMaxWidth">
        <short>Maximum width for the hint.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="THintInfo.HintColor">
        <short>Color for the hint window.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="THintInfo.CursorRect">
        <short>Rectangle with the coordinates and size for the cursor.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="THintInfo.CursorPos">
        <short>TPoint with the location for the mouse cursor.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="THintInfo.ReshowTimeout">
        <short>
          If set to a value greater than Zero (0), call after value milliseconds OnShowHint again.
        </short>
        <descr>
          Used to update the hint text display after the specified delay while it is showing.
        </descr>
        <seealso/>
      </element>

      <element name="THintInfo.HideTimeout">
        <short>Duration in milliseconds for the hint display.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="THintInfo.HintStr">
        <short>
          String value displayed as a hint for the associated control.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="THintInfo.HintData">
        <short>
          Pointer to the data used to derive the hint text.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TImageListHelper">
        <short>
          Helper class for TCustomImageList useful for images on TControl instances.
        </short>
        <descr>
          <p>
            <var>TImageListHelper</var> is a helper class for <var>TCustomImageList</var>. TImageListHelper extends TCustomImageList to provide additional properties and methods that are useful when working with <var>TControl</var> class instances.
          </p>
          <p>
            Use the overloaded <var>DrawForControl</var> method to render an image from the multiple resolution image list to a control canvas.
          </p>
          <p>
            Use the <var>ResolutionForControl</var> property to access a scaled image resolution with images of a specified width used on a control instance.
          </p>
        </descr>
        <seealso>
          <link id="TImageListHelper.DrawForControl"/>
          <link id="TImageListHelper.ResolutionForControl"/>
          <link id="#lcl.imglist.TCustomImageList">TCustomImageList</link>
          <link id="TControl"/>
        </seealso>
      </element>

      <element name="TImageListHelper.GetResolutionForControl">
        <short>Gets the value for the ResolutionForControl property.</short>
        <descr/>
        <seealso>
          <link id="TImageListHelper.ResolutionForControl"/>
        </seealso>
      </element>
      <element name="TImageListHelper.GetResolutionForControl.Result">
        <short>Value for the property.</short>
      </element>
      <element name="TImageListHelper.GetResolutionForControl.AImageWidth">
        <short>ImageWidth desired in the scaled image resolution.</short>
      </element>
      <element name="TImageListHelper.GetResolutionForControl.AControl">
        <short>
          Control which provides the PPI display density for scaled images in the resolution.
        </short>
      </element>

      <element name="TImageListHelper.DrawForControl">
        <short>
          Draws an image scaled to the display density (PPI) for the specified control.
        </short>
        <descr>
          <p>
            <var>DrawForControl</var> is an overloaded procedure used to draw the specified image scaled to the display density (PPI) for the specified control. DrawForControl calls the <var>DrawForPPI</var> method in the image list to render the selected image using the display density and drawing effect required.
          </p>
          <p>
            <var>ACanvas</var> contains the control canvas where the image is drawn. <var>AX</var> and <var>AY</var> contains the left and top coordinates on the canvas where the image is drawn.
          </p>
          <p>
            <var>AIndex</var> specifies the ordinal position in the scaled image list for the image drawn in the method.
          </p>
          <p>
            <var>AImageWidthAt96PPI</var> contains the width for the image at 96 PPI. The actual image width is scaled to the display density using scaling factor required for the control.
          </p>
          <p>
            <var>AControl</var> contains the <var>TControl</var> instance that provides the display density and canvas scaling factor required for the image.
          </p>
          <p>
            When <var>AEnabled</var> is <b>True</b>, the image is drawn using its Enabled state. Otherwise, it is rendered using the disabled state.
          </p>
          <p>
            <var>ADrawEffect</var> contains the <var>TGraphicsDrawEffect</var> used when rendering the image to the control canvas.
          </p>
        </descr>
        <seealso>
          <link id="#lcl.imglist.TCustomImageList.DrawForPPI">TCustomImageList.DrawForPPI</link>
        </seealso>
      </element>
      <element name="TImageListHelper.DrawForControl.ACanvas">
        <short>Canvas where the image is drawn.</short>
      </element>
      <element name="TImageListHelper.DrawForControl.AX">
        <short>Horizontal position on the canvas where the image is drawn.</short>
      </element>
      <element name="TImageListHelper.DrawForControl.AY">
        <short>Vertical position on the canvas where the image is drawn.</short>
      </element>
      <element name="TImageListHelper.DrawForControl.AIndex">
        <short>Ordinal position for the image drawn in the method.</short>
      </element>
      <element name="TImageListHelper.DrawForControl.AImageWidthAt96PPI">
        <short>Image width using the standard display density.</short>
      </element>
      <element name="TImageListHelper.DrawForControl.AControl">
        <short>
          Control with the display density (Font PPI) and canvas scaling factor used in the method.
        </short>
      </element>
      <element name="TImageListHelper.DrawForControl.AEnabled">
        <short>Indicates the image is drawn in the enabled state when True.</short>
      </element>
      <element name="TImageListHelper.DrawForControl.ADrawEffect">
        <short>Indicates the TGraphicsDrawEffect applied to the image.</short>
      </element>

      <element name="TImageListHelper.ResolutionForControl">
        <short>
          Provides access to an image resolution with the specified width scaled to the display density for a control.
        </short>
        <descr>
          <p>
            <var>ResolutionForControl</var> is a read-only <var>TScaledImageListResolution</var> property which provides access to a scaled image resolution suitable for the control in <var>AControl</var>. <var>AImageWidth</var> contains the image width requested from the multi-resolution image list. <var>AControl</var> contains the <var>TControl</var> instance which provides the display density (PPI) and the scaling factor used to generate the scaled image resolution.
          </p>
        </descr>
        <seealso>
          <link id="#lcl.imglist.TScaledImageListResolution">TScaledImageListResolution</link>
          <link id="TControl"/>
          <link id="TControlCanvas"/>
        </seealso>
      </element>
      <element name="TImageListHelper.ResolutionForControl.AImageWidth">
        <short>Image width requested in the image list </short>
      </element>
      <element name="TImageListHelper.ResolutionForControl.AControl">
        <short>
          Control which provides the display density and scaling factor for the scaled image resolution.
        </short>
      </element>

      <element name="TDragImageListResolution">
        <short>
          Implements an image list resolution with features used in Drag and Drop operations.
        </short>
        <descr>
          <p>
            <var>TDragImageListResolution</var> is a <var>TCustomImageListResolution</var> descendant which implements an image list resolution with features used in Drag and Drop operations. TDragImageListResolution is used in the implementation of <var>TDragImageList</var>.
          </p>
        </descr>
        <seealso>
          <link id="TDragImageList.DraggingResolution"/>
          <link id="TDragImageList.Resolution"/>
        </seealso>
      </element>

      <element name="TDragImageListResolution.FDragging"/>
      <element name="TDragImageListResolution.FDragHotspot"/>
      <element name="TDragImageListResolution.FOldCursor"/>
      <element name="TDragImageListResolution.FLastDragPos"/>
      <element name="TDragImageListResolution.FLockedWindow"/>

      <element name="TDragImageListResolution.GetImageList">
        <short>Gets the value for the ImageList property.</short>
        <descr/>
        <seealso>
          <link id="TDragImageListResolution.ImageList"/>
        </seealso>
      </element>
      <element name="TDragImageListResolution.GetImageList.Result">
        <short>Value for the property.</short>
      </element>

      <element name="TDragImageListResolution.WSRegisterClass"  link="#lcl.lclclasses.TLCLComponent.WSRegisterClass"/>

      <element name="TDragImageListResolution.ImageList">
        <short>List with images used in Drag and Drop operations.</short>
        <descr>
          <p>
            <var>ImageList</var> is a read-only <var>TDragImageList</var> property which provides access to the images used for Drag and Drag operations, and methods used to render the images.
          </p>
        </descr>
        <seealso>
          <link id="TDragImageList"/>
          <link id="TControl.GetDragImages"/>
          <link id="TControl.ControlStyle"/>
          <link id="TControlStyleType"/>"
        </seealso>
      </element>

      <element name="TDragImageListResolution.Create">
        <short>Constructor for the class instance.</short>
        <descr>
          <p>
            <var>Create</var> is the overridden constructor for <var>TDragImageListResolution</var>. Create calls the inherited constructor using TheOwner as the owner for the class instance. Create sets the initial the values for internal members in the class instance.
          </p>
        </descr>
        <seealso>
          <link id="#rtl.classes.TComponent.Create">TComponent.Create</link>
        </seealso>
      </element>
      <element name="TDragImageListResolution.Create.TheOwner">
        <short>Owner of the new class instance.</short>
      </element>

      <element name="TDragImageListResolution.GetHotSpot">
        <short>Gets the HotSpot for the image resolution.</short>
        <descr>
          <p>
            <var>GetHotSpot</var> is an overridden <var>TPoint</var> function which gets the <var>HotSpot</var> for the image list resolution. GetHotSpot uses the value from the <var>DragHotspot</var> property. It contains the screen coordinates where the Drag and Drop operation was started. X is is the horizontal position, and Y is the vertical position in the <var>TPoint</var> type.
          </p>
        </descr>
        <seealso>
          <link id="TDragImageListResolution.DragHotspot"/>
        </seealso>
      </element>
      <element name="TDragImageListResolution.GetHotSpot.Result">
        <short>Value for the HotSpot.</short>
      </element>

      <element name="TDragImageListResolution.BeginDrag">
        <short>
          Starts display of images in the resolution for a Drag and Drop operation.
        </short>
        <descr>
          <p>
            <var>BeginDrag</var> is a <var>Boolean</var> function used to start display of images in the resolution for a Drag and Drop operation. The return value is <b>True</b> if the widgetset successfully received the BeginDrag notification.
          </p>
          <remark>
            Please note: No actions are performed in the method if the widgetset class does note successfully start the drag operation.
          </remark>
          <p>
            BeginDrag calls the <var>DragLock</var> method to lock the window handle for the control, and to start displaying the drag image for the operation. The current screen cursor is captured, and the <var>DragCursor</var> in <var>ImageList</var> is displayed for the operation.
          </p>
        </descr>
        <seealso>
          <link id="TDragImageListResolution.Dragging"/>
          <link id="TDragImageListResolution.EndDrag"/>
          <link id="TDragImageListResolution.DragLock"/>
          <link id="TDragImageListResolution.ImageList"/>
          <link id="TDragImageList.DragCursor"/>
        </seealso>
      </element>
      <element name="TDragImageListResolution.BeginDrag.Result">
        <short>True if the Drag operation was successfully started.</short>
      </element>
      <element name="TDragImageListResolution.BeginDrag.Window">
        <short>Window handle where images are displayed for the operation.</short>
      </element>
      <element name="TDragImageListResolution.BeginDrag.X">
        <short>Horizontal screen position where the operation was started.</short>
      </element>
      <element name="TDragImageListResolution.BeginDrag.Y">
        <short>Vertical screen position where the operation was started.</short>
      </element>

      <element name="TDragImageListResolution.DragLock">
        <short>
          Shows the Drag image and optionally locks the Window handle during the Drag operation.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDragImageListResolution.DragLock.Result">
        <short>
          True if the drag operation was started or the drag image position was updated.
        </short>
      </element>
      <element name="TDragImageListResolution.DragLock.Window">
        <short>Window handle used as the lock handle when not already assigned.</short>
      </element>
      <element name="TDragImageListResolution.DragLock.X">
        <short>Horizontal coordinate for the drag image.</short>
      </element>
      <element name="TDragImageListResolution.DragLock.Y">
        <short>Vertical coordinate for the drag image.</short>
      </element>

      <element name="TDragImageListResolution.DragMove">
        <short>Moves the dragging image to the specified position.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDragImageListResolution.DragMove.Result">
        <short/>
      </element>
      <element name="TDragImageListResolution.DragMove.X">
        <short/>
      </element>
      <element name="TDragImageListResolution.DragMove.Y">
        <short/>
      </element>

      <element name="TDragImageListResolution.DragUnlock">
        <short>Hides the Drag image and removes the update lock for the Window.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDragImageListResolution.EndDrag">
        <short>Removes the drag lock and restores the saved cursor when the drag operation has ended.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDragImageListResolution.EndDrag.Result">
        <short/>
      </element>

      <element name="TDragImageListResolution.HideDragImage">
        <short>Notifies the widgetset class to hide the drag image.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDragImageListResolution.ShowDragImage">
        <short>Notifies the widgetset class to display the drag image.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDragImageListResolution.DragHotspot">
        <short>Contains the mouse position for the drag image.</short>
        <descr>
          DragHotspot is a TPoint property which contains the mouse position for the Drag hostspot. The value in DragHotspot is updated when TDragImageList sets the image used for the resolution, and in the BeginDrag method.
        </descr>
        <seealso/>
      </element>

      <element name="TDragImageListResolution.Dragging">
        <short>Indicates that BeginDrag has been called for the image resolution.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDragImageList">
        <short>A list of Images used during Drag operations.</short>
        <descr>
          <p>
            A drag image is shown when a DragImageList is supplied at all, <b>and</b> when no accepting target is under the mouse, or the source control style includes csDisplayDragImage, or AlwaysShowDragImage is set in the DragObject.
          </p>
          <p>
            In drag-dock operations typically no drag image is shown, since the DockRect frame already gives all required visual feedback.
          </p>
          <p>
            This is a general overview of the usage of this class:
          </p>
          <ul>
            <li>
              SetDragImage selects an image from the list, and defines the hotspot within this image. (the hotspot typically is the offset of the mouse position to the origin of the dragged control)
            </li>
            <li>BeginDrag starts dragging, the image is shown at the starting location.</li>
            <li>DragMove moves the image.</li>
            <li>EndDrag stops dragging, the image is removed from the screen.</li>
          </ul>
        </descr>
      </element>

      <element name="TDragImageList.FDragCursor"/>
      <element name="TDragImageList.FDragging"/>
      <element name="TDragImageList.FDragHotspot"/>
      <element name="TDragImageList.FImageIndex"/>

      <element name="TDragImageList.FLastDragPos">
        <short>Remember position where the image was painted.</short>
      </element>

      <element name="TDragImageList.FLockedWindow">
        <short>The window whose updates are locked while dragging.</short>
      </element>

      <element name="TDragImageList.FOldCursor"/>

      <element name="TDragImageList.SetDragCursor">
        <short>Sets the value for the DragCursor property.</short>
        <descr/>
        <seealso>
          <link id="TDragImageList.DragCursor"/>
        </seealso>
      </element>
      <element name="TDragImageList.SetDragCursor.AValue">
        <short>New value for the DragCursor property.</short>
      </element>

      <element name="TDragImageList.GetDragHotSpot">
        <short>Gets the value for the DragHostSpot property.</short>
        <descr/>
        <seealso>
          <link id="TDragImageList.DragHotSpot"/>
          <link id="#lcl.imglist.TCustomImageList.GetHotSpot"/>
        </seealso>
      </element>
      <element name="TDragImageList.GetDragHotSpot.Result">
        <short>Value for the DragHostSpot property.</short>
      </element>

      <element name="TDragImageList.SetDragHotspot">
        <short>Sets the value for the DragHostSpot property.</short>
        <descr/>
        <seealso>
          <link id="TDragImageList.DragHotSpot"/>
        </seealso>
      </element>
      <element name="TDragImageList.SetDragHotspot.ADragHotSpot">
        <short>New value for the DragHostSpot property.</short>
      </element>

      <element name="TDragImageList.WSRegisterClass"  link="#lcl.lclclasses.TLCLComponent.WSRegisterClass"/>

      <element name="TDragImageList.Initialize">
        <short>initializes the cursor shape and image index for the list.</short>
        <descr>
          <p>
            Initialize is an overridden method in TDragImageList. It calls the inherited method on entry. It sets the default values in DragCursor (crNone) and the internal selected image index (0).
          </p>
        </descr>
        <seealso>
          <link id="#lcl.imglist.TCustomImageList.Initialize">TCustomImageList.Initialize</link>
        </seealso>
      </element>

      <element name="TDragImageList.BeginDrag">
        <short>Start dragging an image; returns True if successful.</short>
        <descr>
          Locks a window for updates, remembers the current cursor shape, and sets the new cursor shape.
        </descr>
        <seealso/>
      </element>
      <element name="TDragImageList.BeginDrag.Result">
        <short>True if successful.</short>
      </element>
      <element name="TDragImageList.BeginDrag.Window">
        <short>The associated window.</short>
      </element>
      <element name="TDragImageList.BeginDrag.X">
        <short>The mouse position.</short>
      </element>
      <element name="TDragImageList.BeginDrag.Y">
        <short>The mouse position.</short>
      </element>

      <element name="TDragImageList.DragLock">
        <short>Show drag image during drag operation.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDragImageList.DragLock.Result">
        <short>True if Dragging and image shown.</short>
      </element>
      <element name="TDragImageList.DragLock.Window">
        <short>The locked window.</short>
      </element>
      <element name="TDragImageList.DragLock.XPos">
        <short>The mouse position.</short>
      </element>
      <element name="TDragImageList.DragLock.YPos">
        <short>The mouse position.</short>
      </element>

      <element name="TDragImageList.DragMove">
        <short>Shows the drag image at a new location.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDragImageList.DragMove.Result">
        <short>True if Dragging and image moved.</short>
      </element>
      <element name="TDragImageList.DragMove.X">
        <short>The new mouse position.</short>
      </element>
      <element name="TDragImageList.DragMove.Y">
        <short>The new mouse position.</short>
      </element>

      <element name="TDragImageList.DragUnlock">
        <short>Hide the drag image.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDragImageList.EndDrag">
        <short>Finish dragging of the image, restore the old cursor shape.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDragImageList.EndDrag.Result">
        <short>True when dragging was started before.</short>
      </element>

      <element name="TDragImageList.HideDragImage">
        <short>Hides the drag image without unlocking the window.</short>
        <descr>
          <p>
            Calls the <var>HideDragImage</var> method in <var>DraggingResolution</var>. No actions are performed in the method when an image resolution is not available in  the DraggingResolution property.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TDragImageList.SetDragImage">
        <short>Set index of dragged image and hotspot.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDragImageList.SetDragImage.Result">
        <short>Always True.</short>
      </element>
      <element name="TDragImageList.SetDragImage.Index">
        <short>List index of the image to use.</short>
      </element>
      <element name="TDragImageList.SetDragImage.HotSpotX">
        <short>Offset from mouse position to image position.</short>
      </element>
      <element name="TDragImageList.SetDragImage.HotSpotY">
        <short>Offset from mouse position to image position.</short>
      </element>

      <element name="TDragImageList.ShowDragImage">
        <short>Displays the drag image.</short>
        <descr>
          <p>
            Calls the <var>ShowDragImage</var> method in <var>DraggingResolution</var>. No actions are performed in the method when an image resolution is not available in  the DraggingResolution property.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TDragImageList.DragCursor">
        <short>The cursor shape to use while dragging.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDragImageList.DragHotspot">
        <short>
          The position of the HotSpot image, i.e. the offset to the mouse position while dragging.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDragImageList.Dragging">
        <short>True if dragging in progress.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDragImageList.DraggingResolution">
        <short>Gets the scaled image resolution with the drag images for the list.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDragImageList.Resolution">
        <short>Gets the image resolution for the specified image width.</short>
        <descr>
          <p>
            <var>Resolution</var> is a read-only indexed <var>TDragImageListResolution</var> property which provides the image resolution for images with the width specified in <var>AImageWidth</var>. Reading the property value causes the image resolution to be cast to the required <var>TDragImageListResolution</var> type.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TDragImageList.Resolution.AImageWidth">
        <short>Image width requested in the image resolution.</short>
      </element>

      <element name="TKeyEvent">
        <short>Defines an event handler for key events.</short>
        <descr>
          <p>
            <var>TKeyEvent</var> is an object procedure type which specifies a handler for key events.
          </p>
          <p>
            <var>TKeyEvent</var> is the type used to implement the <var>OnKeyDown</var> and <var>OnKeyUp</var> event handlers in <var>TWinControl</var>. Applications must implement an object procedure using the signature for the event, and assign it to the event handler to respond to the notification.
          </p>
          <p>
            See <link id="TKeyPressEvent"/> for the handler used to implement OnKeyPress events.
          </p>
        </descr>
      </element>
      <seealso>
        <link id="TWinControl.OnKeyDown"/>
        <link id="TWinControl.OnKeyUp"/>
        <link id="TControl.AddHandlerOnKeyDown"/>
        <link id="TControl.AddHandlerOnKeyUp"/>
        <link id="TKeyPressEvent"/>
      </seealso>
      <element name="TKeyEvent.Sender">
        <short>TObject for the key event.</short>
      </element>
      <element name="TKeyEvent.Key">
        <short>ScanCode for the key in the event.</short>
      </element>
      <element name="TKeyEvent.Shift">
        <short>TShiftState modifier for the specified key.</short>
      </element>

      <element name="TKeyPressEvent">
        <short>Specifies an event handler for key press events.</short>
        <descr>
          <p>
            <var>TKeyPressEvent</var> is an object procedure type that defines an event handler for key press events.
          </p>
          <p>
            <var>TKeyPressEvent</var> is the type used to implement the <var>OnKeyPress</var> event handler in <var>TWinControl</var>. Applications must implement an object procedure using the signature for the event handler, and assign it to the property to respond to the event notification.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.OnKeyPress"/>
        </seealso>
      </element>
      <element name="TKeyPressEvent.Sender">
        <short>TObject for the event notification.</short>
      </element>
      <element name="TKeyPressEvent.Key">
        <short>Character value for the key press in the event notification.</short>
      </element>

      <element name="TUTF8KeyPressEvent">
        <short>Specifies an event handler for UTF-8-encoded key press events.</short>
        <descr>
          <p>
            <var>TUTF8KeyPressEvent</var> is an object procedure type which specifies an event handler for UTF-8-encoded key press events.
          </p>
          <p>
            <var>TUTF8KeyPressEvent</var> is the type used to implement the <var>OnUTF8KeyPress</var> event handler in <var>TWinControl</var>. Applications must implement an object procedure using the signature for the event handler, and assign it to the property to respond to the event notification.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.OnUTF8KeyPress"/>
        </seealso>
      </element>
      <element name="TUTF8KeyPressEvent.Sender">
        <short>TObject for the event notification.</short>
      </element>
      <element name="TUTF8KeyPressEvent.UTF8Key">
        <short>Value for the UTF-8-encoded character in the key press event.</short>
      </element>

      <element name="TMouseEvent">
        <short>Specifies an event handler used to respond to mouse button events.</short>
        <descr>
          <p>
            <var>TMouseEvent</var> is an object procedure type which specifies an event handler for mouse button events.
          </p>
          <p>
            <var>TMouseEvent</var> is the type used to implement the <var>OnMouseDown</var> and <var>OnMouseUp</var> event handlers in <var>TControl</var>. Applications must implement an object procedure using the signature for the event handler, and assign it to the property to respond to the event notification.
          </p>
        </descr>
        <seealso>
          <link id="TControl.OnMouseDown"/>
          <link id="TControl.OnMouseUp"/>
        </seealso>
      </element>
      <element name="TMouseEvent.Sender">
        <short>TObject for the event notification.</short>
      </element>
      <element name="TMouseEvent.Button">
        <short>Mouse button for the event notification.</short>
      </element>
      <element name="TMouseEvent.Shift">
        <short>Modifier applied to the mouse button.</short>
      </element>
      <element name="TMouseEvent.X">
        <short>Horizontal position for the mouse cursor in the button event.</short>
      </element>
      <element name="TMouseEvent.Y">
        <short>Vertical position for the mouse cursor in the button event.</short>
      </element>

      <element name="TMouseMoveEvent">
        <short>Specifies an event handler used to respond to mouse movement events.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TMouseMoveEvent.Sender">
        <short>TObject for the event notification.</short>
      </element>
      <element name="TMouseMoveEvent.Shift">
        <short>Key modifier in effect for the event.</short>
      </element>
      <element name="TMouseMoveEvent.X">
        <short>Horizontal mouse coordinates.</short>
      </element>
      <element name="TMouseMoveEvent.Y">
        <short>Vertical mouse coordinates.</short>
      </element>

      <element name="TMouseWheelEvent">
        <short>Specifies an event handler used to respond to mouse wheel events.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TMouseWheelEvent.Sender">
        <short>The control under the mouse.</short>
      </element>
      <element name="TMouseWheelEvent.Shift">
        <short>State of the modifier keys and mouse buttons.</short>
      </element>
      <element name="TMouseWheelEvent.WheelDelta">
        <short>How many notches the wheel has been turned.</short>
      </element>
      <element name="TMouseWheelEvent.MousePos">
        <short>The mouse position, in client coordinates.</short>
      </element>
      <element name="TMouseWheelEvent.Handled">
        <short>Set Handled to True when the event was handled.</short>
      </element>

      <element name="TMouseWheelUpDownEvent">
        <short>Type of OnMouseWheelUp/Down event handlers.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TMouseWheelUpDownEvent.Sender">
        <short>The control under the mouse.</short>
      </element>
      <element name="TMouseWheelUpDownEvent.Shift">
        <short>State of the modifier keys and mouse buttons.</short>
      </element>
      <element name="TMouseWheelUpDownEvent.MousePos">
        <short>The mouse position, in client coordinates.</short>
      </element>
      <element name="TMouseWheelUpDownEvent.Handled">
        <short>Set Handled to True when the event was handled.</short>
      </element>

      <element name="TGetDockCaptionEvent">
        <short>Specifies an event handler used to get the caption for a docked control.</short>
        <descr>
          <p>
            <var>TGetDockCaptionEvent</var> is an object procedure type which specifies an event handler used to get the caption for a docked control. It allows a value other than the Caption for a control to be displayed when a control is docked.
          </p>
          <p>
            Use <var>AControl</var> to examine properties for the docked control. Assign a value to the <var>ACaption</var> argument to set the docking caption for the control.
          </p>
          <p>
            <var>TGetDockCaptionEvent</var> is the type used to implement the <var>OnGetDockCaption</var> event handler in <var>TWinControl</var>. Applications must implement an object procedure using the signature for the type, and assign it to the property to allow responding to the event notification.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.OnGetDockCaption"/>
          <link id="TWinControl."/>
        </seealso>
      </element>
      <element name="TGetDockCaptionEvent.Sender">
        <short>TObject for the event notification.</short>
      </element>
      <element name="TGetDockCaptionEvent.AControl">
        <short>Control with the default caption value.</short>
      </element>
      <element name="TGetDockCaptionEvent.ACaption">
        <short>Caption to use for the docked control.</short>
      </element>

      <element name="TDragKind">
        <short>Indicates whether the control performs drag-drop or drag-dock.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDragKind.dkDrag">
        <short>Control is dragged for dropping.</short>
      </element>
      <element name="TDragKind.dkDock">
        <short>Control is dragged for docking.</short>
      </element>

      <element name="TDragMode">
        <short>Indicates whether dragging can start automatically.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDragMode.dmManual">
        <short>Dragging can start only by explicit code.</short>
      </element>
      <element name="TDragMode.dmAutomatic">
        <short>Dragging starts when the left mouse button is pressed on the control.</short>
      </element>

      <element name="TDragState">
        <short>Values representing State changes while dragging.</short>
        <descr>
          These values are sent in drag messages, allowing the control to perform special actions when the mouse moves over, enters, or leaves the control.
        </descr>
        <seealso/>
      </element>
      <element name="TDragState.dsDragEnter">
        <short>Mouse has just entered the control.</short>
      </element>
      <element name="TDragState.dsDragLeave">
        <short>Mouse has just left the control.</short>
      </element>
      <element name="TDragState.dsDragMove">
        <short>Mouse is moving over the control.</short>
      </element>

      <element name="TDragMessage">
        <short>Message types used in DragManager.</short>
        <descr>
          <p>
            All messages are sent to the target control, except dmDragDrop and dmDragCancel is sent to the source control.
          </p>
          <dl>
            <dt>dmDragEnter</dt>
            <dd>Mouse enters control</dd>
            <dt>dmDragLeave</dt>
            <dd>Mouse leaves control</dd>
            <dt>dmDragMove</dt>
            <dd>Mouse moves over control (after dmDragEnter)</dd>
            <dt>dmDragDrop</dt>
            <dd>Control dropped</dd>
            <dt>dmDragCancel</dt>
            <dd>Dragging aborted</dd>
            <dt>dmFindTarget</dt>
            <dd>Find child control under the mouse</dd>
          </dl>
        </descr>
      </element>
      <element name="TDragMessage.dmDragEnter">
        <short>mouse enters control.</short>
      </element>
      <element name="TDragMessage.dmDragLeave">
        <short>mouse leaves control.</short>
      </element>
      <element name="TDragMessage.dmDragMove">
        <short>mouse moves over control (after dmDragEnter).</short>
      </element>
      <element name="TDragMessage.dmDragDrop">
        <short>control dropped.</short>
      </element>
      <element name="TDragMessage.dmDragCancel">
        <short>dragging aborted.</short>
      </element>
      <element name="TDragMessage.dmFindTarget">
        <short>find possible target control under the mouse.</short>
      </element>

      <element name="TDragOverEvent">
        <short>The type of an OnDragOver handler.</short>
        <descr>
          <p>An OnDragOver event is sent by a control, when an object is dragged over it.
            The handler can specify whether a drop will be accepted or rejected.</p>
          <remark>
            <var>Source</var> is polymorphic, can be either the DragObject or the dragged control! This depends on DragObject.AutoCreated, for no sane reason.
          </remark>
        </descr>
        <seealso>
          <link id="TDockOverEvent"/>
        </seealso>
      </element>
      <element name="TDragOverEvent.Sender">
        <short>The possible drop target (control).</short>
      </element>
      <element name="TDragOverEvent.Source">
        <short>The object (TDragObject or TControl) being dragged.</short>
      </element>
      <element name="TDragOverEvent.X">
        <short>X coordinate of the mouse on screen.</short>
      </element>
      <element name="TDragOverEvent.Y">
        <short>Y coordinate of the mouse on screen.</short>
      </element>
      <element name="TDragOverEvent.State">
        <short>The current DragState (entering, leaving or moving over the target).</short>
      </element>
      <element name="TDragOverEvent.Accept">
        <short>Set Accept to False to reject an drop (default is True).</short>
      </element>

      <element name="TDragDropEvent">
        <short>The type of an OnDragDrop notification handler.</short>
        <descr>
          An OnDragDrop event is generated by the target control, on the drop of a dragged object.
        </descr>
        <seealso>
          <link id="TDockDropEvent"/>
          <link id="TEndDragEvent"/>
          <link id="TControl.OnDragDrop"/>
        </seealso>
      </element>
      <element name="TDragDropEvent.Sender">
        <short>The target control of the drop.</short>
      </element>
      <element name="TDragDropEvent.Source">
        <short>The dragged control.</short>
      </element>
      <element name="TDragDropEvent.X">
        <short>The <b>client</b> coordinates of the drop.</short>
      </element>
      <element name="TDragDropEvent.Y">
        <short>The <b>client</b> coordinates of the drop.</short>
      </element>

      <element name="TStartDragEvent">
        <short>The type of an OnStartDrag handler.</short>
        <descr>
          <p>
            An OnStartDrag event is generated for a control when it is dragged and its DragKind is dkDrag. The handler can provide a specific DragDrop object. Otherwise, a standard TDragDropObjectEx is automatically created by the DragManager.
          </p>
        </descr>
        <seealso>
          <link id="TStartDragEvent"/>
        </seealso>
      </element>
      <element name="TStartDragEvent.Sender">
        <short>The control to be dragged.</short>
      </element>
      <element name="TStartDragEvent.DragObject">
        <short>Supply your own DragObject, or leave it <b>Nil</b> for automatic creation.</short>
      </element>

      <element name="TEndDragEvent">
        <short>The type of an OnEndDrag handler.</short>
        <descr>
          <p>
            An OnEndDrag event is sent for a dragged control, when the drag operation is finished. This happens regardless of whether the operation was drag-drop or drag-dock, and whether the operation ended with a drop or was cancelled.
          </p>
          <p>
            Check for an unassigned value in Target  to distinguish between a drop and a cancelled operation (Nil).
          </p>
        </descr>
        <seealso>
          <link id="TDragDropEvent"/>
          <link id="TDockDropEvent"/>
        </seealso>
      </element>
      <element name="TEndDragEvent.Sender">
        <short>The dragged control.</short>
      </element>
      <element name="TEndDragEvent.Target">
        <short>The drop target (control), or <b>Nil</b> if cancelled.</short>
      </element>
      <element name="TEndDragEvent.X">
        <short>The mouse coordinate, in client coordinates if dropped, else in screen coordinates.</short>
      </element>
      <element name="TEndDragEvent.Y">
        <short>The mouse coordinate, in client coordinates if dropped, else in screen coordinates.</short>
      </element>

      <element name="TDragObject">
        <short>Base class for managing drag operations and user feedback.</short>
        <descr>
          <p>
            Every dragging operation has an associated DragObject, holding references to the source and target controls, and other parameters for the customization of the visual user feedback.
          </p>
          <p>
            A default <var>DragObject</var> is created automatically when a dragging operation starts, and is destroyed when the operation has ended;  you do not need to  maintain it. But an application can provide a customized <var>DragObject</var> in the <link id="TControl.OnStartDrag"/> or <link id="TControl.OnStartDock"/> handlers for the source control (the one being dragged).
          </p>
          <remark>
            AutoCreated DragObjects imply different behavior in the DragOver and DragDrop events, where the Source becomes the dragged control, while the DragObject itself is passed as Source.
          </remark>
          <p>
            <var>TDragObject</var> is the ancestor of a whole tree of dragging objects, with the main branches supporting either drag-drop or drag-dock operations. The type of the operation is determined using the <link id="TControl.DragKind"/> property in the source control.
          </p>
          <remark>
            In contrast to the Delphi implementation, Lazarus has moved a couple of methods into the drag performers; these methods are no longer available for customization.
          </remark>
          <p>
            A Lazarus DragObject mainly supplies the cursor and images, used in visual user feedback. Drag-drop operations typically signal acceptance of an possible drop by variations of the mouse cursor, and optionally can attach to it shapes of the dragged object(s). Drag-dock operations instead show a docking rectangle, that snaps to possible target locations when the mouse moves over docksites.
          </p>
        </descr>
        <seealso>
          <link id="TDragControlObject"/>
          <link id="TDragDockObject"/>
        </seealso>
      </element>

      <element name="TDragObject.FAlwaysShowDragImages"/>
      <element name="TDragObject.FDragPos"/>
      <element name="TDragObject.FControl"/>
      <element name="TDragObject.FDragTarget"/>
      <element name="TDragObject.FDragTargetPos"/>
      <element name="TDragObject.FAutoFree"/>
      <element name="TDragObject.FAutoCreated"/>
      <element name="TDragObject.FDropped"/>

      <element name="TDragObject.EndDrag">
        <short>Called when a dragging operation ends.</short>
        <descr>
          The default implementation calls Control.DoEndDrag, which in turn invokes an OnEndDrag handler.
        </descr>
      </element>
      <element name="TDragObject.EndDrag.Target">
        <short>The control onto which the dragged object is dropped (can be Nil).</short>
      </element>
      <element name="TDragObject.EndDrag.X">
        <short>Horizontal mouse coordinate when the method is called.</short>
      </element>
      <element name="TDragObject.EndDrag.Y">
        <short>Vertical mouse coordinate when the method is called.</short>
      </element>

      <element name="TDragObject.GetDragImages">
        <short>Returns a list of images for dragging.</short>
        <descr>
          <p>
            The returned <link id="TDragImageList"/> provides methods for the selection and display of an image shown while dragging. This implementation returns <b>Nil</b>, and must be overridden (e.g. in <var>TDragControlObject</var>).
          </p>
        </descr>
        <seealso>
          <link id="TDragControlObject"/>
        </seealso>
      </element>
      <element name="TDragObject.GetDragImages.Result">
        <short>The ImageList to use, is <b>Nil</b> by default!</short>
      </element>

      <element name="TDragObject.GetDragCursor">
        <short>Returns the dragging cursor type (shape).</short>
        <descr>
          In drag-drop operations the cursor signals acceptance or rejection of an drop, depending on Accepted.
        </descr>
        <seealso/>
      </element>
      <element name="TDragObject.GetDragCursor.Result">
        <short>The cursor to show.</short>
      </element>
      <element name="TDragObject.GetDragCursor.Accepted">
        <short>Which cursor to return (rejected:crNoDrop or accepted:crDrag).</short>
      </element>
      <element name="TDragObject.GetDragCursor.X">
        <short/>
      </element>
      <element name="TDragObject.GetDragCursor.Y">
        <short/>
      </element>

      <element name="TDragObject.Create">
        <short>Remembers the dragged control.</short>
        <descr/>
        <seealso>
          <link id="#rtl.system.TObject.Create">TObject.Create</link>
        </seealso>
      </element>
      <element name="TDragObject.Create.AControl">
        <short>The control being dragged.</short>
      </element>

      <element name="TDragObject.AutoCreate">
        <short>
          Special constructor which enforces destruction of the object at the end of the dragging operation.
        </short>
        <descr>
          <p>
            This constructor sets the <var>AutoCreated</var> and <var>AutoFree</var> flags. <var>AutoFree</var> is tested by the <var>DragManager</var> at the end of the dragging operation.
          </p>
        </descr>
      </element>
      <element name="TDragObject.AutoCreate.AControl">
        <short>The control being dragged.</short>
      </element>

      <element name="TDragObject.HideDragImage">
        <short>Asks the image list to hide the drag image.</short>
        <seealso>
          <link id="TDragObject.ShowDragImage"/>
        </seealso>
      </element>

      <element name="TDragObject.ShowDragImage">
        <short>Asks the image list to show the drag image.</short>
        <descr/>
        <seealso>
          <link id="TDragObject.HideDragImage"/>
        </seealso>
      </element>

      <element name="TDragObject.AlwaysShowDragImages">
        <short>Should the image of dragged objects always be shown?</short>
        <descr>
          This is another chance for enforcing the display of a drag image, even if a drop is acceptable.
        </descr>
        <seealso/>
      </element>

      <element name="TDragObject.AutoCreated">
        <short>Was the drag object created automatically?</short>
        <descr>This property is of little use, more important is the AutoFree property.</descr>
      </element>

      <element name="TDragObject.AutoFree">
        <short>Indicates whether the object shall be destroyed at the end of the dragging operation.</short>
        <descr>
          This is a Lazarus specific property, introduced to get rid of the special Delphi TDrag...Ex classes.
        </descr>
      </element>

      <element name="TDragObject.Control">
        <short>The control that is dragged (source).</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDragObject.DragPos">
        <short>Current mouse position in screen coordinates.</short>
        <seealso>
          <link id="TDragObject.DragTargetPos"/>
        </seealso>
      </element>

      <element name="TDragObject.DragTarget">
        <short>The control over which the object currently is dragged (target).</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDragObject.DragTargetPos">
        <short>Mouse position in client coordinates of the DragTarget.</short>
        <seealso>
          <link id="TDragObject.DragPos"/>
        </seealso>
      </element>

      <element name="TDragObject.Dropped">
        <short>Indicates whether the drag object has been dropped yet.</short>
        <descr>
          Contains False while dragging is in progress, or when dragging has been aborted.
        </descr>
      </element>

      <element name="TDragObjectClass">
        <short>A <link id="TDragObject"/> class type.</short>
      </element>
      <element name="TDragObjectEx">
        <short>A drag object that is automatically destroyed after use.</short>
        <seealso>
          <link id="TDragObject"/>
        </seealso>
      </element>

      <element name="TDragObjectEx">
        <short>Extends TDragObject to automatically free itself in the DragManager.</short>
        <descr>
          <p>
            <var>TDragObjectEx</var> is a <var>TDragObject</var> descendant. It provides an overridden constructor which sets the <var>AutoFree</var> property to <b>True</b>.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TDragObjectEx.Create">
        <short>Constructor for the class instance.</short>
        <descr>
          <p>
            <var>Create</var> is the overridden constructor for the class instance. Create sets the value in <var>AutoFree</var> to <b>True</b>. <var>AutoFree</var> is tested by the <var>DragManager</var> at the end of a dragging operation.
          </p>
        </descr>
        <seealso>
          <link id="TDragObject.AutoFree"/>
        </seealso>
      </element>
      <element name="TDragObjectEx.Create.AControl">
        <short>Control for the class instance.</short>
      </element>

      <element name="TDragControlObject">
        <short>A drag object for dragging a control.</short>
        <descr>
          <p>
            While a <var>TDragObject</var> can be used for dragging controls, this class <b>knows</b> that it drags a control, and asks it for a <var>DragCursor</var> and <var>DragImages</var>.
          </p>
        </descr>
        <seealso>
          <link id="TDragObject"/>
        </seealso>
      </element>

      <element name="TDragControlObject.GetDragCursor">
        <short>Asks the Control to provide a drag cursor.</short>
      </element>
      <element name="TDragControlObject.GetDragCursor.Result">
        <short/>
      </element>
      <element name="TDragControlObject.GetDragCursor.Accepted">
        <short/>
      </element>
      <element name="TDragControlObject.GetDragCursor.X">
        <short/>
      </element>
      <element name="TDragControlObject.GetDragCursor.Y">
        <short/>
      </element>

      <element name="TDragControlObject.GetDragImages">
        <short>Asks the Control to provide an ImageList.</short>
      </element>
      <element name="TDragControlObject.GetDragImages.Result">
        <short>The Image list to be used in dragging this control.</short>
      </element>
      <element name="TDragControlObjectEx" link="#lcl.controls.TDragControlObject"/>
      <element name="TDragControlObjectEx.Create">
        <short>Creates an object to be destroyed after use.</short>
      </element>
      <element name="TDragControlObjectEx.Create.AControl">
        <short>The control to drag.</short>
      </element>

      <element name="TDockOrientation">
        <short>Orientation of DockZones and docked controls, similar to <link id="TAlign"/></short>
        <descr>
          <p>
            This is a Delphi relic, bound to TDockTree and not very useful in application code. All <var>DockZones</var> in a <var>DockTree</var> have an orientation, horizontal or vertical, indicating how controls are arranged in the dock zone. When a control is docked into a zone, it obtains the orientation of that zone.
          </p>
          <remark>
            The orientation for the control can be stored as the opposite for the dock zone, depending on the DockManager used.
          </remark>
        </descr>
        <seealso/>
      </element>
      <element name="TDockOrientation.doNoOrient">
        <short>no orientation applies (like alNone).</short>
      </element>
      <element name="TDockOrientation.doHorizontal">
        <short>siblings are arranged horizontally, children top-to-bottom.</short>
      </element>
      <element name="TDockOrientation.doVertical">
        <short>siblings are arranged vertically, children left-to-right.</short>
      </element>
      <element name="TDockOrientation.doPages">
        <short>children are pages in a tabbed control.</short>
      </element>

      <element name="TDockDropEvent">
        <short>The type of an OnDockDrop handler.</short>
        <descr>
          <p>
            An OnDockDrop event is sent by the drop target (dock site) on the drop of a dragged object.
          </p>
        </descr>
        <seealso>
          <link id="TDragDropEvent"/>
        </seealso>
      </element>
      <element name="TDockDropEvent.Sender">
        <short>The drop target (docksite control).</short>
      </element>
      <element name="TDockDropEvent.Source">
        <short>The DragDock object, containing information about the dragged object.</short>
      </element>
      <element name="TDockDropEvent.X" link="#lcl.controls.TDragOverEvent.X">
        <short/>
      </element>
      <element name="TDockDropEvent.Y" link="#lcl.controls.TDragOverEvent.Y">
        <short/>
      </element>

      <element name="TDockOverEvent">
        <short>The type of an OnDockOver handler.</short>
        <descr>
          <p>
            An OnDockOver event is sent by a dock site, when an object is dragged over it. The handler can specify whether a drop will be accepted or rejected.
          </p>
        </descr>
        <seealso>
          <link id="TDragOverEvent"/>
        </seealso>
      </element>
      <element name="TDockOverEvent.Sender">
        <short>The possible drop target.</short>
      </element>
      <element name="TDockOverEvent.Source" link="#lcl.controls.TDockDropEvent.Source">
        <short/>
      </element>
      <element name="TDockOverEvent.X" link="#lcl.controls.TDragOverEvent.X">
        <short/>
      </element>
      <element name="TDockOverEvent.Y" link="#lcl.controls.TDragOverEvent.Y">
        <short/>
      </element>
      <element name="TDockOverEvent.State" link="#lcl.controls.TDragOverEvent.State">
        <short/>
      </element>
      <element name="TDockOverEvent.Accept" link="#lcl.controls.TDragOverEvent.Accept">
        <short/>
      </element>

      <element name="TUnDockEvent">
        <short>The type used for OnUnDock event handler.</short>
        <descr>
          <p>
            An UnDock event is sent by a dock site, before a control is undocked from it. The handler can reject undocking, by setting Allow to False.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TUnDockEvent.Sender">
        <short>The docksite from which the object is undocked.</short>
      </element>
      <element name="TUnDockEvent.Client">
        <short>The control to be undocked.</short>
      </element>
      <element name="TUnDockEvent.NewTarget">
        <short>The new docksite for Client, <b>Nil</b> when undocked into floating state.</short>
      </element>
      <element name="TUnDockEvent.Allow">
        <short>Set Allow to False to reject undocking.</short>
      </element>

      <element name="TStartDockEvent">
        <short>The type of an OnStartDock handler.</short>
        <descr>
          <p>
            An OnStartDock event is sent by a control when it shall be dragged and its DragKind is dkDock. The handler can provide a specific DragDock object, else a standard TDragDockObjectEx is automatically created by the DragManager.
          </p>
        </descr>
        <seealso>
          <link id="TStartDragEvent"/>
        </seealso>
      </element>
      <element name="TStartDockEvent.Sender">
        <short>The control being dragged.</short>
      </element>

      <element name="TStartDockEvent.DragObject">
        <short>Supply your own TDragDockObject, or leave it <b>Nil</b> to request automatic creation.</short>
      </element>

      <element name="TGetSiteInfoEvent">
        <short>An OnGetSiteInfo handler returns information about a docksite.</short>
        <descr>
          <p>
            An OnGetSiteInfo event is sent by the DragManager to all docksites. The handler can adjust the snapping rectangle (InfluenceRect), and can reject an drop.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TGetSiteInfoEvent.Sender">
        <short>The dock site near the mouse pointer.</short>
      </element>
      <element name="TGetSiteInfoEvent.DockClient">
        <short>The dragged control.</short>
      </element>
      <element name="TGetSiteInfoEvent.InfluenceRect">
        <short>The screen rectangle where a drop or mouse move is directed to this docksite.</short>
      </element>
      <element name="TGetSiteInfoEvent.MousePos">
        <short>The current position of the mouse.</short>
      </element>
      <element name="TGetSiteInfoEvent.CanDock">
        <short>Set CanDock to False to reject docking.</short>
      </element>

      <element name="TDrawDockImageEvent">
        <short>Event handler used to draw the docking image in a drag and dock operation.</short>
        <descr>
          <p>
            <var>TDrawDockImageEvent</var> is an object procedure type which specifies an event handler used to draw the docking image for TDragDockObject instances. <var>TDrawDockImageEvent</var> is the type used to implement the <var>OnDrawDockImage</var> variable in the <file>Controls</file> unit.
          </p>
        </descr>
        <seealso>
          <link id="OnDrawDockImage"/>
        </seealso>
      </element>
      <element name="TDrawDockImageEvent.Sender">
        <short/>
      </element>
      <element name="TDrawDockImageEvent.AOldRect">
        <short/>
      </element>
      <element name="TDrawDockImageEvent.ANewRect">
        <short/>
      </element>
      <element name="TDrawDockImageEvent.AOperation">
        <short/>
      </element>

      <element name="OnDrawDockImage">
        <short>Routine used to draw dock images in drag/dock operations </short>
        <descr>
          <p>
            <var>OnDrawDockImage</var> is a <var>TDrawDockImageEvent</var> variable which contains the default routine used to draw the docking image in a drag/dock operation. It is used in <var>TDragDockObject</var> methods which draw docking images likes <var>HideDockImage</var>, <var>ShowDockImage</var>, and <var>MoveDockInage</var>.
          </p>
        </descr>
        <seealso>
          <link id="TDragDockObject.ShowDockImage"/>
          <link id="TDragDockObject.HideDockImage"/>
          <link id="TDragDockObject.MoveDockImage"/>
        </seealso>
      </element>

      <element name="TDragDockObject">
        <short>A drag object for drag-dock.</short>
        <descr>
          <p>
            This object type serves two main purposes: it allows one to distinguish between drag-drop and drag-dock operations, and it implements docking specific information and behavior.
          </p>
          <p>
            The primary use is for tree docking, as assumed by methods in <var>TControl</var> and <var>TWinControl</var>.
          </p>
        </descr>
        <seealso>
          <link id="TDragObject"/>
        </seealso>
      </element>

      <element name="TDragDockObject.FDockOffset"/>
      <element name="TDragDockObject.FDockRect"/>
      <element name="TDragDockObject.FDropAlign"/>
      <element name="TDragDockObject.FDropOnControl"/>
      <element name="TDragDockObject.FEraseDockRect"/>
      <element name="TDragDockObject.FFloating"/>
      <element name="TDragDockObject.FIncreaseDockArea"/>

      <element name="TDragDockObject.AdjustDockRect">
        <short>Adjust the DockRect relative to the dragging hotspot (DockOffset).</short>
        <descr>
          <remark>
            The parameter type is bad, should be <b>var</b>. Ignore it please.
          </remark>
          <p>
            The default implementation adjusts the stored FDockRect, by DockOffset.
            This adjustment will make the DockRect appear right over the control, when dragging starts, regardless of where the user clicked onto the control.
          </p>
          <p>
            You'll rarely have to override this method, since the DockRect is adjusted by every target site's DockManager later.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TDragDockObject.AdjustDockRect.ARect">
        <short>Not used; please ignore it.</short>
      </element>

      <element name="TDragDockObject.GetDragCursor">
        <short>Gets the drag cursor shape for the class instance.</short>
        <descr/>
        <seealso>
          <link id="TDragObject.GetDragCursor"/>
        </seealso>
      </element>
      <element name="TDragDockObject.GetDragCursor.Result">
        <short/>
      </element>
      <element name="TDragDockObject.GetDragCursor.Accepted">
        <short/>
      </element>
      <element name="TDragDockObject.GetDragCursor.X">
        <short/>
      </element>
      <element name="TDragDockObject.GetDragCursor.Y">
        <short/>
      </element>

      <element name="TDragDockObject.EndDrag">
        <short>Finish docking.</short>
        <descr>Invokes Control.DoEndDock.</descr>
        <seealso>
          <link id="TControl.DoEndDock"/>
        </seealso>
      </element>
      <element name="TDragDockObject.EndDrag.Target">
        <short>The target docksite, or <b>Nil</b> to make the Control float.</short>
      </element>
      <element name="TDragDockObject.EndDrag.X">
        <short/>
      </element>
      <element name="TDragDockObject.EndDrag.Y">
        <short/>
      </element>

      <element name="TDragDockObject.InitDock">
        <short>Initializes the dragging coordinates.</short>
        <descr>
          <p>
            Determines the hotspot offset for adjusting the floating DockRect. Since the undocked extent of the control doesn't change while dragging, we fix the hotspot offset here.
          </p>
          <p>Usage:</p>
          <code>OffsetRect(DockRect, FDockOffset);</code>
        </descr>
      </element>
      <element name="TDragDockObject.InitDock.APosition">
        <short/>
      </element>

      <element name="TDragDockObject.ShowDockImage">
        <short>Shows the DockRect, remembers the coordinates in EraseDockRect.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDragDockObject.HideDockImage">
        <short>Hides the DockRect, invalidates EraseDockRect to prevent further erases.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDragDockObject.MoveDockImage">
        <short>Moves an already visible DockRect.</short>
        <descr>
          <p>Checks the DockRect for changes against EraseDockRect, to prevent flicker.</p>
          <p>Remembers the drawn frame coordinates in EraseDockRect.</p>
        </descr>
      </element>

      <element name="TDragDockObject.HasOnDrawImage">
         <short>Checks for an assigned OnDrawDockImage event handler.</short>
        <descr>
          <p>
            <var>HasOnDrawImage</var> is a <var>Boolean</var> function used to determine if an event handler has been assigned to the <var>OnDrawDockImage</var> property. The return value is <b>True</b> if a routine has been assigned to the property. If an event handler has not been supplied,  the <var>HintDockImage</var> routine is assigned to the event handler, and the return value is set to <b>True</b>.
          </p>
          <p>
            For platforms where the Alpha blending is not enabled for Forms, the return value is always <b>False</b> (determined by calling <var>GetSystemMetrics</var> for the <var>SM_LCLHasFormAlphaBlend</var> metric in the widget set class).
          </p>
          <p>
            <var>HasOnDrawImage</var> is used in methods like <var>ShowDockImage</var>, <var>HideDockImage</var>, and <var>MoveDockImage</var>.
          </p>
        </descr>
        <seealso>
          <link id="TDragDockObject.ShowDockImage"/>
          <link id="TDragDockObject.HideDockImage"/>
          <link id="TDragDockObject.MoveDockImage"/>
        </seealso>
      </element>
      <element name="TDragDockObject.HasOnDrawImage.Result">
         <short>True when an event handler has been assigned to OnDrawDockImage.</short>
      </element>

      <element name="TDragDockObject.DockOffset">
        <short>The hotspot offset of the dragged DockRect.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDragDockObject.DockRect">
        <short>Screen coordinates for a possible drop location.</short>
        <descr>
          <p>
            <var>DockRect</var> gives feedback to the user where the dragged control may be dropped. When no docksite signals acceptance, the DockRect uses the floating state of the dragged control. When a drop will dock the control, the DockRect signifies the approximate position for the docked control.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TDragDockObject.DropAlign">
        <short>How the dragged control will be docked, relative to the target control.</short>
        <descr>
          <p>
            When the target is a DockTree, DropAlign indicates the placement of the control relative to DropOnControl. Other docking methods require a specialized (derived) DragDockObject.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TDragDockObject.DropOnControl">
        <short>
          The already docked control, relative to which the dragged control will be docked. <b>Nil</b> for an empty docksite.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDragDockObject.Floating">
        <short>The final state of the dragged control (after drop).</short>
        <descr>True when the dragged control becomes or stays floating.</descr>
        <seealso/>
      </element>

      <element name="TDragDockObject.IncreaseDockArea">
        <short>Determines whether the dock site shall be enlarged.</short>
        <descr>Not normally used, perhaps a special AnchorDocking property?</descr>
        <seealso/>
      </element>

      <element name="TDragDockObject.EraseDockRect">
         <short>Area to be erased when refreshing the display for the docking rectangle.</short>
        <descr>
          <p>
            <var>EraseDockRect</var> is a <var>TRect</var> property that represents the area to be erased when redrawing the docking rectangle. The value in EraseDockRect is assigned in InitDock, and updated to contain the value from DockRect when the docking rectangle has been altered in methods like ShowDockImage, HideDockImage, and MoveDockImage.
          </p>
          <p>
            EraseDockRect is passed as an argument to OnDrawDockImage, and to the underlying widget set class.
          </p>
        </descr>
        <seealso>
          <link id="TDragDockObject.DockRect"/>
          <link id="TDragDockObject.InitDock"/>
          <link id="TDragDockObject.ShowDockImage"/>
          <link id="TDragDockObject.HideDockImage"/>
          <link id="TDragDockObject.MoveDockImage"/>
        </seealso>
      </element>

      <element name="TDragDockObjectEx">
        <short>A drag object for docking that is automatically destroyed after use.</short>
      </element>

      <element name="TDragDockObjectEx.Create">
        <short>Creates an object to be destroyed after use.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDragDockObjectEx.Create.AControl">
        <short/>
      </element>

      <element name="TDragManager">
        <short>
          The abstract base class used to manage dragging of controls (for drop or dock operations).
        </short>
        <descr>
          <p>
            TDragManager specifies an object-oriented version of the Delphi drag manager. It is implemented by the TDragManagerDefault descendant.
          </p>
          <remark>
            The registered dock sites should be stored in a persistent list, not in a DragManager instance.
          </remark>
        </descr>
        <seealso/>
      </element>

      <element name="TDragManager.FDragImmediate"/>
      <element name="TDragManager.FDragThreshold"/>

      <element name="TDragManager.KeyUp">
        <short>Handler for keyboard key released.</short>
        <descr>When the Ctrl key is released, a drop is enabled again.</descr>
        <seealso/>
      </element>
      <element name="TDragManager.KeyUp.Key">
        <short/>
      </element>
      <element name="TDragManager.KeyUp.Shift">
        <short/>
      </element>

      <element name="TDragManager.KeyDown">
        <short>Handler for keyboard key pressed.</short>
        <descr>
          <p>When (and while) the Ctrl key is pressed, dropping is disabled.</p>
          <p>The Esc key aborts the current dragging operation immediately.</p>
        </descr>
        <seealso/>
      </element>
      <element name="TDragManager.KeyDown.Key">
        <short/>
      </element>
      <element name="TDragManager.KeyDown.Shift">
        <short/>
      </element>

      <element name="TDragManager.CaptureChanged">
        <short>Aborts the dragging operation, when the capturing control has changed.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDragManager.CaptureChanged.OldCaptureControl">
        <short/>
      </element>

      <element name="TDragManager.MouseMove">
        <short>Generates visual feedback for mouse movement in a drag operation.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDragManager.MouseMove.Shift">
        <short/>
      </element>
      <element name="TDragManager.MouseMove.X">
        <short/>
      </element>
      <element name="TDragManager.MouseMove.Y">
        <short/>
      </element>

      <element name="TDragManager.MouseUp">
        <short>Ends dragging.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDragManager.MouseUp.Button">
        <short/>
      </element>
      <element name="TDragManager.MouseUp.Shift">
        <short/>
      </element>
      <element name="TDragManager.MouseUp.X">
        <short/>
      </element>
      <element name="TDragManager.MouseUp.Y">
        <short/>
      </element>

      <element name="TDragManager.MouseDown">
        <short>NOP.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDragManager.MouseDown.Button">
        <short/>
      </element>
      <element name="TDragManager.MouseDown.Shift">
        <short/>
      </element>
      <element name="TDragManager.MouseDown.X">
        <short/>
      </element>
      <element name="TDragManager.MouseDown.Y">
        <short/>
      </element>

      <element name="TDragManager.Create">
        <short>Initializes the Delphi default dragging parameters.</short>
        <descr>
          <p>The Delphi VCL sets DragImmediate=True and DragThreshold=5.</p>
          <remark>A docking operation never should start immediately.</remark>
        </descr>
      </element>
      <element name="TDragManager.Create.TheOwner">
        <short/>
      </element>

      <element name="TDragManager.IsDragging">
        <short>Check if dragging is in progress.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDragManager.IsDragging.Result">
        <short>True if dragging.</short>
      </element>

      <element name="TDragManager.Dragging">
        <short>True if the specified control is being dragged.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDragManager.Dragging.Result">
        <short/>
      </element>
      <element name="TDragManager.Dragging.AControl">
        <short/>
      </element>

      <element name="TDragManager.RegisterDockSite">
        <short>Adds the control to the list of registered docking sites.</short>
        <descr>
          <remark>
            This should become a class method, maintaining the list of registered docking sites outside any DragManager instance.
          </remark>
        </descr>
        <seealso/>
      </element>
      <element name="TDragManager.RegisterDockSite.Site">
        <short>The DockSite to register.</short>
      </element>
      <element name="TDragManager.RegisterDockSite.DoRegister">
        <short>True for adding, False for removing the site.</short>
      </element>

      <element name="TDragManager.DragStart">
        <short>Starts dragging a control.</short>
        <descr>
          <p>
            A DragObject must be created, depending on the Control.DragKind. The mouse has to be captured, and visual feedback must be initialized.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TDragManager.DragStart.AControl">
        <short>The control that initiates the drag operation.</short>
      </element>
      <element name="TDragManager.DragStart.AImmediate">
        <short>False when dragging should start only when the mouse is moved (delayed).</short>
      </element>
      <element name="TDragManager.DragStart.AThreshold">
        <short>How much the mouse must move before delayed dragging starts.</short>
      </element>

      <element name="TDragManager.DragMove">
        <short>Updates the visual dragging feedback.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDragManager.DragMove.APosition">
        <short>Mouse position in <b>screen</b> coordinates.</short>
      </element>

      <element name="TDragManager.DragStop">
        <short>Ends dragging.</short>
        <descr>
          <p>The visual feedback is reset.</p>
          <p>
            All related controls are notified of the outcome of the operation (drop, dock, abort).
          </p>
          <p>Finally all temporary objects are destroyed.</p>
        </descr>
        <seealso/>
      </element>
      <element name="TDragManager.DragStop.ADrop">
        <short>False when dragging was aborted.</short>
      </element>

      <element name="TDragManager.CanStartDragging">
         <short>
           Indicates if the mouse coordinates are within the drag threshold for the specified control.
        </short>
        <descr>
          <p>
            <var>CanStartDragging</var> is an abstract virtual <var>Boolean</var> function used to determine if the mouse has been moved beyond the threshold that initiates a drag operation. The result is <b>True</b> when the mouse coordinates in X and Y are located within the client rectangle and threshold for the specified control in <var>Site</var>.
          </p>
          <p>
            CanStartDragging must be implemented in a descendent class, like <var>TDragManagerDefault</var>.
          </p>
        </descr>
        <seealso>
        </seealso>
      </element>
      <element name="TDragManager.CanStartDragging.Result">
        <short/>
      </element>
      <element name="TDragManager.CanStartDragging.Site">
        <short/>
      </element>
      <element name="TDragManager.CanStartDragging.AThreshold">
        <short/>
      </element>
      <element name="TDragManager.CanStartDragging.X">
        <short/>
      </element>
      <element name="TDragManager.CanStartDragging.Y">
        <short/>
      </element>

      <element name="TDragManager.DragImmediate">
        <short>Start dragging immediately, on MouseDown?</short>
        <descr>This is the default value for e.g. BeginDrag.</descr>
        <seealso/>
      </element>

      <element name="TDragManager.DragThreshold">
        <short>
          The threshold amount for mouse movement before delayed dragging starts (default is 5 pixels).
        </short>
        <seealso/>
      </element>

      <element name="DragManager">
        <short>The current DragManager (always TDragManagerDefault).</short>
        <descr>
          <remark>
            A <var>DragManager</var> must be implemented in the <file>Controls</file> unit; it requires access to private members in the classes declared in the unit.
          </remark>
        </descr>
        <seealso>
          <link id="TDragManager"/>
        </seealso>
      </element>

      <element name="TDockManager">
        <short>The layout manager for a docksite.</short>
        <descr>
          <p>
            <var>TDockManager</var> is an abstract class for managing the controls on a dock site. Every docksite can have a DockManager, which arranges the docked controls. See <link id="TDockTree">TDockTree</link> for more info.
          </p>
        </descr>
        <seealso>
          <link id="TDockTree"/>
        </seealso>
      </element>

      <element name="TDockManager.Create">
        <short>Creates an DockManager for ADockSite.</short>
      </element>
      <element name="TDockManager.Create.ADockSite">
        <short>This is the TWinControl acting as the docksite.</short>
      </element>

      <element name="TDockManager.BeginUpdate">
        <short>Starts updating the DockSite layout.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDockManager.EndUpdate">
        <short>Finishes updating the DockSite layout.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDockManager.GetControlBounds">
        <short>Returns the zone bounds of a docked control.</short>
        <descr>
          <p>
            The TDockTree manager returns the bounds of the dockzone, including the dock header.
          </p>
          <p>
            When the Control is not docked, an empty Rect(0,0,0,0) is returned.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TDockManager.GetControlBounds.Control">
        <short>The docked control.</short>
      </element>
      <element name="TDockManager.GetControlBounds.AControlBounds">
        <short>The enclosing rectangle, in client coordinates of the docksite.</short>
      </element>

      <element name="TDockManager.GetDockEdge">
        <short>Determine the DropAlign.</short>
        <descr>
          <p>
            ADockObject contains valid DragTarget, DragPos and DragTargetPos relative dock site. DockRect is undetermined.
          </p>
          <p>
            DropOnControl may be <b>Nil</b> if nothing has been docked yet, or no target control exists at the mouse coordinates.
          </p>
          <p>
            Returns True if ADockObject.DropAlign has been determined. If False, the DropAlign has to be determined by default procedures.
          </p>
        </descr>
      </element>
      <element name="TDockManager.GetDockEdge.Result">
        <short>True if the DropAlign was determined.</short>
      </element>
      <element name="TDockManager.GetDockEdge.ADockObject">
        <short>The DragDockObject holding all information about the drag-dock operation.</short>
      </element>

      <element name="TDockManager.InsertControl">
        <short>
          Position <var>DropCtl</var> relative <var>Control</var>, using the alignment specified by <var>InsertAt</var>.
        </short>
        <descr>
          <p>
            InsertControl determines the placement of the just docked control, forcing a repaint of the container control if necessary.
          </p>
          <remark>
            When SetReplacingControl has been called with a non-Nil Control before, the dropped control only should replace that control.
          </remark>
          <p>
            An overloaded version passes the DragDockObject to the dockmanager, allowing to pass more information about the drop. It allows one to implement other than tree-style docksites.
          </p>
        </descr>
        <seealso>
          <link id="TDockManager.RemoveControl"/>
        </seealso>
      </element>
      <element name="TDockManager.InsertControl.Control">
        <short>The control relative to which insert.</short>
      </element>
      <element name="TDockManager.InsertControl.InsertAt">
        <short>How to insert relative to Control.</short>
      </element>
      <element name="TDockManager.InsertControl.DropCtl">
        <short>The control to insert.</short>
      </element>
      <element name="TDockManager.InsertControl.ADockObject">
        <short>The DragDockObject holding all information about the drag-dock operation.</short>
      </element>

      <element name="TDockManager.LoadFromStream">
        <short>Restores the layout of the docksite from the specified stream.</short>
        <descr>
          <p>
            The controls to be docked can be retrieved by using <var>ReloadDockedControl</var> in the docksite. This method returns only existing controls of the given name, owned by the owner of the docksite, by default.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.ReloadDockedControl"/>
          <link id="TDockManager.SaveToStream"/>
        </seealso>
      </element>
      <element name="TDockManager.LoadFromStream.Stream">
        <short>The stream with the layout information.</short>
      </element>

      <element name="TDockManager.MessageHandler">
        <short>Handles the messages sent to a docksite.</short>
        <descr>
          <p>
            This handler must handle all mouse messages, related to the client area of the docksite that is not covered by docked controls (dock headers, et. al.).
          </p>
          <p>
            Handling mouse messages while dragging is not required. Painting of the docksite has to be implemented in PaintSite.
          </p>
        </descr>
        <seealso>
          <link id="TDockManager.PaintSite"/>
        </seealso>
      </element>
      <element name="TDockManager.MessageHandler.Sender">
        <short/>
      </element>
      <element name="TDockManager.MessageHandler.Message">
        <short>The message to be processed.</short>
      </element>

      <element name="TDockManager.PaintSite">
        <short>Handles special painting of the docksite.</short>
        <descr>
          <p>
            While the docked controls paint themselves, the eventual dockheaders and other decorations have to be painted by the DockManager.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TDockManager.PaintSite.DC">
        <short>The device context, used to paint.</short>
      </element>

      <element name="TDockManager.PositionDockRect">
        <short>Determines the DockRect while dragging a control over the docksite.</short>
        <descr>
          <p>
            This method updates DockRect to provide visual feedback when a control is dragged over the docksite. The initial DragDockObject.DockRect spans the entire DockSite.
          </p>
          <p>
            The Delphi-compatible version only can use the parameters determined by the default processing in the docksite.
          </p>
          <p>
            The Lazarus version can update the DockObject with better-suited parameters. A DockManager here can implement any algorithm for the placement of a dropped control. The default implementation calls the Delphi compatible version. When you override the Lazarus version, you may have to determine the dock sibling and DropAlign again, when the default determination (in TControl and TWinControl) is inappropriate.
          </p>
        </descr>
        <seealso>
          <link id="TDragDockObject"/>
        </seealso>
      </element>
      <element name="TDockManager.PositionDockRect.Client">
        <short>The dropped control.</short>
      </element>
      <element name="TDockManager.PositionDockRect.DropCtl">
        <short>
          The control relative to which Client shall be docked; <b>Nil</b> for docking into the docksite.
        </short>
      </element>
      <element name="TDockManager.PositionDockRect.DropAlign">
        <short>How to dock, relative to DropCtl.</short>
      </element>
      <element name="TDockManager.PositionDockRect.DockRect">
        <short>The screen rectangle of the docksite, to be adjusted by this method.</short>
      </element>
      <element name="TDockManager.PositionDockRect.ADockObject">
        <short>The DragDockObject holding all information about the drag-dock operation.</short>
      </element>

      <element name="TDockManager.RemoveControl">
        <short>Removes the undocked control from the docksite layout.</short>
        <descr>
          <p>
            When <var>SetReplacingControl</var> has been called with a non-<b>Nil</b> argument before, the layout of the docksite should not be changed. Instead, the next inserted control should take the place and role of this control.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TDockManager.RemoveControl.Control">
        <short>Control to remove.</short>
      </element>

      <element name="TDockManager.ResetBounds">
        <short><var>ResetBounds</var> refreshes the layout of the docksite.</short>
        <descr>
          <p>
            This method typically notifies the DockManager when the DockSite calls its Resize method. When the extent of the docksite has changed, the DockManager should reposition and resize all docked controls accordingly.
          </p>
          <p>
            The layout always should be refreshed when <var>Force</var> is True. This is required when e.g. the visibility of docked controls has changed, but not the size of the docksite.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TDockManager.ResetBounds.Force">
        <short>When True, always update the layout.</short>
      </element>

      <element name="TDockManager.SaveToStream">
        <short>Saves the docksite layout to <var>Stream</var>.</short>
        <descr/>
        <seealso>
          <link id="TDockManager.LoadFromStream"/>
        </seealso>
      </element>
      <element name="TDockManager.SaveToStream.Stream">
        <short>Write the layout information into this stream.</short>
      </element>

      <element name="TDockManager.SetReplacingControl">
        <short>Specifies the control to be replaced subsequently.</short>
        <descr>
          <p>
            This method is called by <var>ReplaceDockedControl</var>, to announce a pending replacement of <var>Control</var> by another control. The next <var>RemoveControl</var> should be ignored, and <var>InsertControl</var> should only exchange the controls, without reorganizing the layout of the docksite. When <var>Control</var> is <b>Nil</b>, this call signals the end of the exchange [obsolete].
          </p>
          <remark>
            The name "SetReplacingControl" is a misnomer, it should read "SetControlToBeReplaced".
          </remark>
          <p>
            The intended purpose of this method is the replacement of a docked control by a Notebook, preserving the DockZone. This operation should be handled by an DockManager internally, and calls to this method should be ignored.
          </p>
        </descr>
        <seealso>
          <link id="TDockManager.InsertControl"/>
          <link id="TDockManager.RemoveControl"/>
        </seealso>
      </element>
      <element name="TDockManager.SetReplacingControl.Control">
        <short>The control to be replaced later.</short>
      </element>

      <element name="TDockManager.AutoFreeByControl">
        <short>Returns True if the DockManager should be destroyed together with the docksite.</short>
        <descr>
          <p>
            This is a Lazarus-specific extension of the Delphi TDockManager. It allows multiple docksites to share the same DockManager instance.
          </p>
        </descr>
      </element>
      <element name="TDockManager.AutoFreeByControl.Result">
        <short>True if the DockManager should be destroyed together with the docksite.</short>
      </element>

      <element name="TDockManager.IsEnabledControl">
        <short>
          Determines whether the specified control is a windowed control using the current dock manager.
        </short>
        <descr>
          When the return value is True, the Control can be docked using the dock manager.
        </descr>
        <seealso/>
      </element>
      <element name="TDockManager.IsEnabledControl.Result">
        <short>True when Control can be docked using the dock manager.</short>
      </element>
      <element name="TDockManager.IsEnabledControl.Control">
        <short>Control examined in the method.</short>
      </element>

      <element name="TDockManagerClass">
        <short>
          The DockManager class type, for use when a DockManager is automatically created.
        </short>
        <seealso>
          <link id="TWinControl.CreateDockManager"/>
          <link id="DefaultDockManagerClass"/>
        </seealso>
      </element>

      <element name="TConstraintSize">
        <short>Range for control size constraints.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TSizeConstraintsOption">
         <short>Enumerated type with options used in TSizeConstraints.</short>
        <descr>
          Not used in the current LCL Implementation.
        </descr>
        <seealso/>
      </element>
      <element name="TSizeConstraintsOption.scoAdviceWidthAsMin">
        <short/>
      </element>
      <element name="TSizeConstraintsOption.scoAdviceWidthAsMax">
        <short/>
      </element>
      <element name="TSizeConstraintsOption.scoAdviceHeightAsMin">
        <short/>
      </element>
      <element name="TSizeConstraintsOption.scoAdviceHeightAsMax">
        <short/>
      </element>

      <element name="TSizeConstraintsOptions">
        <short>Set type used to store values from the TSizeConstraintsOption enumeration.</short>
        <descr/>
        <seealso>
          <link id="TSizeConstraintsOption"/>
        </seealso>
      </element>

      <element name="TSizeConstraints">
        <short>Holds maximum and minimum values that can be used in sizing objects.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TSizeConstraints.FControl"/>
      <element name="TSizeConstraints.FMaxHeight"/>
      <element name="TSizeConstraints.FMaxInterfaceHeight"/>
      <element name="TSizeConstraints.FMaxInterfaceWidth"/>
      <element name="TSizeConstraints.FMaxWidth"/>
      <element name="TSizeConstraints.FMinHeight"/>
      <element name="TSizeConstraints.FMinInterfaceHeight"/>
      <element name="TSizeConstraints.FMinInterfaceWidth"/>
      <element name="TSizeConstraints.FMinWidth"/>
      <element name="TSizeConstraints.FOnChange"/>
      <element name="TSizeConstraints.FOptions"/>

      <element name="TSizeConstraints.SetOptions">
         <short>Sets the value for the Options property.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TSizeConstraints.SetOptions.AValue">
         <short>New value for the property.</short>
      </element>

      <element name="TSizeConstraints.Change">
        <short>Calls an OnChange handler if assigned.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TSizeConstraints.AssignTo">
        <short>Copies property values to the specified persistent object.</short>
        <descr/>
        <seealso>
          <link id="#rtl.classes.TPersistent.Assign">TPersistent.Assign</link>
        </seealso>
      </element>
      <element name="TSizeConstraints.AssignTo.Dest">
        <short>Persistent object where property values are stored.</short>
      </element>

      <element name="TSizeConstraints.SetMaxHeight">
        <short>Sets the value for the MaxHeight property.</short>
        <descr/>
        <seealso>
          <link id="TSizeConstraints.MaxHeight"/>
        </seealso>
      </element>
      <element name="TSizeConstraints.SetMaxHeight.Value">
        <short>New value for the MaxHeight property.</short>
      </element>

      <element name="TSizeConstraints.SetMaxWidth">
        <short>Sets the value for the MaxWidth property.</short>
        <descr/>
        <seealso>
          <link id="TSizeConstraints.MaxWidth"/>
        </seealso>
      </element>
      <element name="TSizeConstraints.SetMaxWidth.Value">
        <short>New value for the MaxWidth property.</short>
      </element>

      <element name="TSizeConstraints.SetMinHeight">
        <short>Sets the value for the MinHeight property.</short>
        <descr/>
        <seealso>
          <link id="TSizeConstraints.MinHeight"/>
        </seealso>
      </element>
      <element name="TSizeConstraints.SetMinHeight.Value">
        <short>New value for the MinHeight property.</short>
      </element>

      <element name="TSizeConstraints.SetMinWidth">
        <short>Sets the value for the MinWidth property.</short>
        <descr/>
        <seealso>
          <link id="TSizeConstraints.MinWidth"/>
        </seealso>
      </element>
      <element name="TSizeConstraints.SetMinWidth.Value">
        <short>New value for the MinWidth property.</short>
      </element>

      <element name="TSizeConstraints.Create">
         <short>Constructor for the class instance.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TSizeConstraints.Create.AControl">
         <short>TControl instance where the size constraints are applied.</short>
      </element>

      <element name="TSizeConstraints.UpdateInterfaceConstraints">
        <short>Asks the interface for size constraints.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TSizeConstraints.SetInterfaceConstraints">
        <short>Used by the interface to set the interface constraints.</short>
        <descr>Should only be used by custom components, not by applications.</descr>
        <seealso/>
      </element>
      <element name="TSizeConstraints.SetInterfaceConstraints.MinW">
        <short/>
      </element>
      <element name="TSizeConstraints.SetInterfaceConstraints.MinH">
        <short/>
      </element>
      <element name="TSizeConstraints.SetInterfaceConstraints.MaxW">
        <short/>
      </element>
      <element name="TSizeConstraints.SetInterfaceConstraints.MaxH">
        <short/>
      </element>

      <element name="TSizeConstraints.EffectiveMinWidth">
        <short>Determines the minimum applicable width, given the local and interface constraints.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TSizeConstraints.EffectiveMinWidth.Result">
        <short>Zero means no constraints.</short>
      </element>

      <element name="TSizeConstraints.EffectiveMinHeight">
        <short>Determines the minimum applicable height, given the local and interface constraints.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TSizeConstraints.EffectiveMinHeight.Result">
        <short>Zero means no constraints.</short>
      </element>

      <element name="TSizeConstraints.EffectiveMaxWidth">
        <short>Determines the maximum applicable width, given the local and interface constraints.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TSizeConstraints.EffectiveMaxWidth.Result">
        <short>Zero means no constraints.</short>
      </element>

      <element name="TSizeConstraints.EffectiveMaxHeight">
        <short>Determines the maximum applicable height, given the local and interface constraints.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TSizeConstraints.EffectiveMaxHeight.Result">
        <short>Zero means no constraints.</short>
      </element>

      <element name="TSizeConstraints.MinMaxWidth">
        <short>Determines the constrained Width, and transfers it to the widget.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TSizeConstraints.MinMaxWidth.Result">
        <short>The constrained width.</short>
      </element>
      <element name="TSizeConstraints.MinMaxWidth.Width">
        <short>The suggested width.</short>
      </element>

      <element name="TSizeConstraints.MinMaxHeight">
        <short>Determines the constrained Height, and transfers it to the widget.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TSizeConstraints.MinMaxHeight.Result">
        <short>The constrained height.</short>
      </element>
      <element name="TSizeConstraints.MinMaxHeight.Height">
        <short>The suggested height.</short>
      </element>

      <element name="TSizeConstraints.AutoAdjustLayout">
        <short>
          Adjusts width and height values in the class using the specified scaling factors.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TSizeConstraints.AutoAdjustLayout.AXProportion">
        <short>Scaling factor applied to width values.</short>
      </element>
      <element name="TSizeConstraints.AutoAdjustLayout.AYProportion">
        <short>Scaling factor applied to height values.</short>
      </element>

      <element name="TSizeConstraints.MaxInterfaceHeight">
        <short>The maximum height allowed by the widget.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TSizeConstraints.MaxInterfaceWidth">
        <short>The maximum width allowed by the widget.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TSizeConstraints.MinInterfaceHeight">
        <short>The minimum height allowed by the widget.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TSizeConstraints.MinInterfaceWidth">
        <short>The minimum width allowed by the widget.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TSizeConstraints.Control">
        <short>The <var>Control</var> to which these constraints apply.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TSizeConstraints.Options">
        <short>Options used to determine the size constraints.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TSizeConstraints.OnChange">
        <short>Event handler for a change in the constraints.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TSizeConstraints.MaxHeight">
        <short>The maximum height.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TSizeConstraints.MaxWidth">
        <short>The maximum width.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TSizeConstraints.MinHeight">
        <short>The minimum height.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TSizeConstraints.MinWidth">
        <short>The minimum width.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TConstrainedResizeEvent">
        <short>Specifies an event handler signalled to resize a control to the specified size constraints.</short>
        <descr>
          <p>
            <var>TConstrainedResizeEvent</var> is an object procedure type that specifies an event handler signalled to resize a control to the specified size constraints. Used to implement the <var>OnConstrainedResize</var> event in <var>TControl</var>.
          </p>
        </descr>
        <seealso>
          <link id="TControl.OnConstrainedResize"/>
        </seealso>
      </element>
      <element name="TConstrainedResizeEvent.Sender">
        <short>TObject for the event notification.</short>
      </element>
      <element name="TConstrainedResizeEvent.MinWidth">
        <short/>
      </element>
      <element name="TConstrainedResizeEvent.MinHeight">
        <short/>
      </element>
      <element name="TConstrainedResizeEvent.MaxWidth">
        <short/>
      </element>
      <element name="TConstrainedResizeEvent.MaxHeight">
        <short/>
      </element>

      <element name="TSpacingSize">
        <short>Alias to the Integer type.</short>
        <descr>
          <p>
            <var>TSpacingSize</var> is an alias to the <var>Integer</var> type. TSpacingSize is used for values that represent spacing around or between controls. TSpacingSize is the type used to implement properties in <var>TControlBorderSpacingDefault</var> and <var>TControlBorderSpacing</var>.
          </p>
        </descr>
        <seealso>
          <link id="TControlBorderSpacingDefault"/>
          <link id="TControlBorderSpacing"/>
          <link id="TControl.AnchorAsAlign"/>
          <link id="TControl.AnchorClient"/>
          <link id="TControl.AnchorParallel"/>
          <link id="TControl.AnchorToCompanion"/>
          <link id="TControl.AnchorToNeighbour"/>
        </seealso>
      </element>

      <element name="TControlCellAlign">
        <short>Modes for aligning a control in a table cell.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlCellAlign.ccaFill">
        <short>Cause the cell to fill the available space for the cell.</short>
      </element>

      <element name="TControlCellAlign.ccaLeftTop">
        <short>Cell is aligned to the Left and Top coordinates.</short>
      </element>

      <element name="TControlCellAlign.ccaRightBottom">
        <short>Cell is aligned to the Right and Bottom coordinates.</short>
      </element>

      <element name="TControlCellAlign.ccaCenter">
        <short>Cell is aligned to the center of the its width and height.</short>
      </element>

      <element name="TControlCellAligns">
        <short>Set type used to store values from the TControlCellAlign enumeration.</short>
        <descr/>
        <seealso>
          <link id="TControlCellAlign"/>
        </seealso>
      </element>

      <element name="TControlBorderSpacingDefault">
        <short>Defines the default values for TControlBorderSpacing.</short>
        <descr>
          <p>
            <var>TControlBorderSpacingDefault</var> is a record type which defines the default values for properties in a <var>TControlBorderSpacing</var> instance. Used to differentiate default values in derived <var>TControl</var> classes.
          </p>
        </descr>
        <seealso>
          <link id="TControl.BorderSpacing"/>
          <link id="TControlBorderSpacing"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacingDefault.Left"/>
      <element name="TControlBorderSpacingDefault.Top"/>
      <element name="TControlBorderSpacingDefault.Right"/>
      <element name="TControlBorderSpacingDefault.Bottom"/>
      <element name="TControlBorderSpacingDefault.Around"/>

      <element name="PControlBorderSpacingDefault">
        <short>Pointer to a TControlBorderSpacingDefault type.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlBorderSpacing">
        <short>Describes the (minimum) spacing around a control.</short>
        <descr>
          <p>
            TControlBorderSpacing defines the spacing around a control. The spacing around its children and between its children is defined in <link id="TWinControl.ChildSizing"/>.
          </p>
          <dl>
            <dt>
              Left, Top, Right, Bottom: Integer;
            </dt>
            <dd>
              Defines the space available to the auto-sized control. For example: Control A lies left of control B. A has borderspacing Right=10 and B has borderspacing Left=5. Then A and B will have a minimum space of 10 between.
            </dd>
            <dt>
              Around: Integer;
            </dt>
            <dd>
              Same as Left, Top, Right and Bottom but specified all at once. This will be added to the effective Left, Top, Right and Bottom. Example: Left=3 and Around=5 results in a minimum spacing to the left of 8.
            </dd>
            <dt>
              InnerBorder: Integer;
            </dt>
            <dd>
              This is added to the preferred size. For example: A buttons widget returns 75x25 on GetPreferredSize. CalculatePreferredSize adds 2 times the InnerBorder to the width and height.
            </dd>
            <dt>
              CellAlignHorizontal, CellAlignVertical: TControlCellAlign;
            </dt>
            <dd>
              Used, for example, when the Parents.ChildSizing.Layout defines a table layout.
            </dd>
          </dl>
        </descr>
        <seealso/>
      </element>

      <element name="TControlBorderSpacing.FAround"/>
      <element name="TControlBorderSpacing.FBottom"/>
      <element name="TControlBorderSpacing.FCellAlignHorizontal"/>
      <element name="TControlBorderSpacing.FCellAlignVertical"/>
      <element name="TControlBorderSpacing.FControl"/>
      <element name="TControlBorderSpacing.FInnerBorder"/>
      <element name="TControlBorderSpacing.FLeft"/>
      <element name="TControlBorderSpacing.FOnChange"/>
      <element name="TControlBorderSpacing.FRight"/>
      <element name="TControlBorderSpacing.FTop"/>
      <element name="TControlBorderSpacing.FDefault"/>

      <element name="TControlBorderSpacing.GetAroundBottom">
        <short>Gets the value for the AroundBottom property.</short>
        <descr/>
        <seealso>
          <link id="TControlBorderSpacing.AroundBottom"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.GetAroundBottom.Result">
        <short>Value for the property.</short>
      </element>

      <element name="TControlBorderSpacing.GetAroundLeft">
        <short>Gets the value for the AroundLeft property.</short>
        <descr/>
        <seealso>
          <link id="TControlBorderSpacing.AroundLeft"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.GetAroundLeft.Result">
        <short>Value for the property.</short>
      </element>

      <element name="TControlBorderSpacing.GetAroundRight">
        <short>Gets the value for the AroundRight property.</short>
        <descr/>
        <seealso>
          <link id="TControlBorderSpacing.AroundRight"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.GetAroundRight.Result">
        <short>Value for the property.</short>
      </element>

      <element name="TControlBorderSpacing.GetAroundTop">
        <short>Gets the value for the AroundTop property.</short>
        <descr/>
        <seealso>
          <link id="TControlBorderSpacing.AroundRight"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.GetAroundTop.Result">
        <short>Value for the property.</short>
      </element>

      <element name="TControlBorderSpacing.GetControlRight">
        <short>Gets the value for the ControlRight property.</short>
        <descr/>
        <seealso>
          <link id="TControlBorderSpacing.ControlRight"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.GetControlRight.Result">
        <short>Value for the property.</short>
      </element>

      <element name="TControlBorderSpacing.GetControlTop">
        <short>Gets the value for the ControlTop property.</short>
        <descr/>
        <seealso>
          <link id="TControlBorderSpacing.ControlTop"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.GetControlTop.Result">
        <short>Value for the property.</short>
      </element>

      <element name="TControlBorderSpacing.GetControlWidth">
        <short>Gets the value for the ControlWidth property.</short>
        <descr/>
        <seealso>
          <link id="TControlBorderSpacing.ControlWidth"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.GetControlWidth.Result">
        <short>Value for the property.</short>
      </element>

      <element name="TControlBorderSpacing.IsAroundStored">
        <short>Implements the storage specifier for the Around property.</short>
        <descr/>
        <seealso>
          <link id="TControlBorderSpacing.Around"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.IsAroundStored.Result">
        <short/>
      </element>

      <element name="TControlBorderSpacing.IsBottomStored">
        <short>Implements the storage specifier for the Bottom property.</short>
        <descr/>
        <seealso>
          <link id="TControlBorderSpacing.Bottom"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.IsBottomStored.Result">
        <short/>
    </element>

    <element name="TControlBorderSpacing.IsInnerBorderStored">
      <short>Implements the storage specifier for the InnerBorder property.</short>
      <descr/>
      <seealso>
        <link id="TControlBorderSpacing.InnerBorder"/>
      </seealso>
    </element>
    <element name="TControlBorderSpacing.IsInnerBorderStored.Result">
      <short/>
    </element>

      <element name="TControlBorderSpacing.IsLeftStored">
        <short>Implements the storage specifier for the Left property.</short>
        <descr/>
        <seealso>
          <link id="TControlBorderSpacing.Left"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.IsLeftStored.Result">
        <short/>
      </element>

      <element name="TControlBorderSpacing.IsRightStored">
        <short>Implements the storage specifier for the Right property.</short>
        <descr/>
        <seealso>
          <link id="TControlBorderSpacing.Right"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.IsRightStored.Result">
        <short/>
      </element>

      <element name="TControlBorderSpacing.IsTopStored">
        <short>Implements the storage specifier for the Top property.</short>
        <descr/>
        <seealso>
          <link id="TControlBorderSpacing.Top"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.IsTopStored.Result">
        <short/>
      </element>

      <element name="TControlBorderSpacing.SetAround">
        <short>Sets the value for the Around property.</short>
        <descr/>
        <seealso>
          <llink id="TControlBorderSpacing.Around"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.SetAround.AValue">
        <short>New value for the property.</short>
      </element>

      <element name="TControlBorderSpacing.SetBottom">
        <short>Sets the value for the Bottom property.</short>
        <descr/>
        <seealso>
          <llink id="TControlBorderSpacing.Bottom"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.SetBottom.AValue">
        <short>New value for the property.</short>
      </element>

      <element name="TControlBorderSpacing.SetCellAlignHorizontal">
        <short>Sets the value for the CellAlignHorizontal property.</short>
        <descr/>
        <seealso>
          <link id="TControlBorderSpacing.CellAlignHorizontal"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.SetCellAlignHorizontal.AValue">
        <short>New value for the CellAlignHorizontal property.</short>
      </element>

      <element name="TControlBorderSpacing.SetCellAlignVertical">
        <short>Sets the value for the SetCellAlignVertical property.</short>
        <descr/>
        <seealso>
          <link id="TControlBorderSpacing.CellAlignVertical"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.SetCellAlignVertical.AValue">
        <short>New value for the SetCellAlignVertical property.</short>
      </element>

      <element name="TControlBorderSpacing.SetInnerBorder">
        <short>Sets the value for the InnerBorder property.</short>
        <descr/>
        <seealso>
          <link id="TControlBorderSpacing.InnerBorder"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.SetInnerBorder.AValue">
        <short>New value for the InnerBorder property.</short>
      </element>

      <element name="TControlBorderSpacing.SetLeft">
        <short>Sets the value for the Left property.</short>
        <descr/>
        <seealso>
          <link id="TControlBorderSpacing.Left"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.SetLeft.AValue">
        <short>New value for the Left property.</short>
      </element>

      <element name="TControlBorderSpacing.SetRight">
        <short>Sets the value for the Right property.</short>
        <descr/>
        <seealso>
          <link id="TControlBorderSpacing.Right"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.SetRight.AValue">
        <short>New value for the Right property.</short>
      </element>

      <element name="TControlBorderSpacing.SetSpace">
        <short>Sets the value for the indexed Space property.</short>
        <descr/>
        <seealso>
          <link id="TControlBorderSpacing.Space"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.SetSpace.Kind">
        <short>Identifies the ordinal position in the indexed property.</short>
      </element>
      <element name="TControlBorderSpacing.SetSpace.AValue">
        <short>New value for the indexed Space property.</short>
      </element>

      <element name="TControlBorderSpacing.SetTop">
        <short>Sets the value for the Top property.</short>
        <descr/>
        <seealso>
          <link id="TControlBorderSpacing.Top"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.SetTop.AValue">
        <short>New value for the Top property.</short>
      </element>

      <element name="TControlBorderSpacing.Change">
        <short>Invalidates the control and signals the OnChange event handler.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlBorderSpacing.Change.InnerSpaceChanged">
        <short>Currently ignored (distinction no longer required).</short>
      </element>

      <element name="TControlBorderSpacing.Create">
        <short>Constructor for the class instance.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlBorderSpacing.Create.OwnerControl">
        <short>The associated control which owns the class instance.</short>
      </element>
      <element name="TControlBorderSpacing.Create.ADefault">
        <short>
          Pointer to an record with default settings; can be <b>Nil</b> for all zero defaults.
        </short>
      </element>

      <element name="TControlBorderSpacing.Assign">
        <short>Copies property values from the specified persistent object.</short>
        <descr/>
        <seealso>
          <link id="#rtl.classes.TPersistent">TPersistent</link>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.Assign.Source">
        <short>Persistent object with the values copied in the method.</short>
      </element>

      <element name="TControlBorderSpacing.AssignTo">
        <short>
          Copies property value from the class instance to the specified persistent object.
        </short>
        <descr/>
        <seealso>
          <link id="#rtl.classes.TPersistent">TPersistent</link>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.AssignTo.Dest">
        <short>Persistent object where property values are stored.</short>
      </element>

      <element name="TControlBorderSpacing.IsEqual">
        <short>True when the specified spacing is the same as the current settings.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlBorderSpacing.IsEqual.Result">
        <short/>
      </element>
      <element name="TControlBorderSpacing.IsEqual.Spacing">
        <short/>
      </element>

      <element name="TControlBorderSpacing.GetSpaceAround">
        <short>Returns the bounds with added Around space.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlBorderSpacing.GetSpaceAround.SpaceAround">
        <short>Out parameter, initial contents are ignored!</short>
      </element>

      <element name="TControlBorderSpacing.GetSideSpace">
        <short>The space on a control side, including Around space.</short>
        <descr/>
        <seealso>
          <link id="TControlBorderSpacing.Space"/>
          <link id="TControlBorderSpacing.GetSideSpace"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.GetSideSpace.Result">
        <short>The space value.</short>
      </element>
      <element name="TControlBorderSpacing.GetSideSpace.Kind">
        <short>The requested edge.</short>
      </element>

      <element name="TControlBorderSpacing.GetSpace">
        <short>Gets the value for the indexed Space property.</short>
        <descr/>
        <seealso>
          <link id="TControlBorderSpacing.Space"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.GetSpace.Result">
        <short>Value for the indexed Space property.</short>
      </element>
      <element name="TControlBorderSpacing.GetSpace.Kind">
        <short>Ordinal position for the value in the indexed property.</short>
      </element>

      <element name="TControlBorderSpacing.AutoAdjustLayout">
        <short>Automatically adjusts the size of the control using the specified proportions.</short>
        <descr>
          <p>
            <var>AutoAdjustLayout</var> is a procedure used to automatically adjust the size of the control using the specified proportions.
          </p>
          <p>
            <var>AXProportion</var> and <var>AYProportion</var> are <var>Double</var> values which contain the scaling factor applied to width and height values in  corresponding properties. For example, 1.25 indicates an increase to 125% of the original value, and 0.5 indicates a 50% decrease in the original value.
          </p>
          <p>
            <var>AutoAdjustLayout</var> scales the value in width and height for properties, including:
          </p>
          <ul>
            <li>Around</li>
            <li>InnerBorder</li>
            <li>Left</li>
            <li>Top</li>
            <li>Right</li>
            <li>Bottom</li>
          </ul>
          <p>
            When property values are altered in the scaling operation, the <var>InvalidatePreferredSize</var> method is called to recalculate the dimensions for the control. The <var>Change</var> method is called when value(s) in <var>InnerBorder</var> have been altered.
          </p>
        </descr>
        <seealso>
          <link id="TControlBorderSpacing.Around"/>
          <link id="TControlBorderSpacing.InnerBorder"/>
          <link id="TControlBorderSpacing.Left"/>
          <link id="TControlBorderSpacing.Top"/>
          <link id="TControlBorderSpacing.Right"/>
          <link id="TControlBorderSpacing.Bottom"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.AutoAdjustLayout.AXPxproportion">
        <short>Scaling factor applied to width values.</short>
      </element>
      <element name="TControlBorderSpacing.AutoAdjustLayout.AYProportion">
        <short>Scaling factor applied to height values.</short>
      </element>

      <element name="TControlBorderSpacing.Control">
        <short>The control to which this border spacing applies.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlBorderSpacing.Space">
        <short>Kind of array access to the space at every side.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlBorderSpacing.Space.Kind">
        <short>The side for which the space is requested.</short>
      </element>

      <element name="TControlBorderSpacing.AroundLeft">
         <short>Spacing used around and on the left-hand side of the control.</short>
        <descr>
          <p>
            <var>AroundLeft</var> is a read-only <var>Integer</var> property which indicates the spacing used around and on the left-hand side of the control.
          </p>
          <p>
            AroundLeft represents the total space reserved on all sides of the control, plus any additional space reserved on it left-hand edge. The value for the property is calculated as the sum of the values from the <var>Around</var> and <var>Left</var> properties. Updates must be performed to the Around and Left properties.
          </p>
        </descr>
        <seealso>
          <link id="TControlBorderSpacing.Around"/>
          <link id="TControlBorderSpacing.Left"/>
        </seealso>
      </element>

      <element name="TControlBorderSpacing.AroundTop">
         <short>Space reserved around and on the top edge of the control.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlBorderSpacing.AroundRight">
         <short>Space reserved around and on the right-hand side of the control.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlBorderSpacing.AroundBottom">
         <short>Space reserved around and on the bottom edge of the control.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlBorderSpacing.ControlLeft">
         <short>
           Space reserved on the left-hand edge of the control relative to the position for the control.
        </short>
        <descr>
          <p>
            <var>ControlLeft</var> is a read-only <var>Integer</var> property that indicates the space reserved on the left-hand edge of the control relative to the position for the control class instance. The value in <var>ControlLeft</var> is calculated as the difference between the <var>Left</var> position for the control and the values in the <var>Around</var> and <var>Left</var> properties. For example:
          </p>
          <code>FControl.Left-Around-Left</code>
          <p>
            If a <var>TControl</var> instance is not available in <var>Control</var>, the value for the property is <b>0</b> (<b>zero</b>).
          </p>
        </descr>
        <seealso>
          <link id="TControlBorderSpacing.Around"/>
          <link id="TControlBorderSpacing.Left"/>
          <link id="TControl.Left"/>
        </seealso>
      </element>

      <element name="TControlBorderSpacing.ControlTop">
         <short>
           Space reserved on the top edge of the control relative to the position for the control.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlBorderSpacing.ControlWidth">
         <short>
           Total width for the control including spacing values in Around, Left, and Right.
        </short>
        <descr>
          <p>
            <var>ControlWidth</var> is a read-only <var>Integer</var> property that contains the total width for the control including spacing values in the <var>Around</var>, <var>Left</var>, and <var>Right</var> properties. The property value is calculated using the following formula:
          </p>
          <code>TControl.Width + (2 * Around) + Left + Right</code>
          <p>
            If a <var>TControl</var> instance is not available in <var>Control</var>, the value for the property is <b>0</b> (<b>zero</b>).
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TControlBorderSpacing.ControlHeight">
         <short>
           Total height for the control including spacing values in Around, Top, and Bottom.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlBorderSpacing.ControlRight">
         <short>
           Space reserved on the right-hand edge of the control relative to the position for the control.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlBorderSpacing.ControlBottom">
         <short>
           Space reserved on the bottom edge of the control relative to the position for the control.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlBorderSpacing.OnChange">
        <short>Event handler for a change in border spacing.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlBorderSpacing.Left">
        <short>The space at the left border.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlBorderSpacing.Top">
        <short>The space at the top border.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlBorderSpacing.Right">
        <short>The space at the right border.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlBorderSpacing.Bottom">
        <short>The space at the bottom border.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlBorderSpacing.Around">
        <short>The space to add on each side of a control.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlBorderSpacing.InnerBorder">
        <short>
          Space added to the widget's <link id="TControl.GetPreferredSize">preferred size</link>
        </short>
        <descr>
          <p>
            When <link id="TControl.GetPreferredSize">calculating the preferred size</link> of control, the LCL asks the widget first.
          </p>
          <p>
            When the widget returns a preferred size, e.g. a TButton widget, then the InnerBorder is added twice to this size - e.g. to the Height for top and bottom space.
          </p>
          <p>
            If the widget does not return a preferred size, the InnerBorder has no effect.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TControlBorderSpacing.CellAlignHorizontal">
        <short>The horizontal alignment inside a table cell.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlBorderSpacing.CellAlignVertical">
        <short>The vertical alignment inside a table cell.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TAnchorSideChangeOperation">
        <short>Operations in <link id="TControl.ForeignAnchorSideChanged"/></short>
        <descr/>
        <seealso/>
      </element>
      <element name="TAnchorSideChangeOperation.ascoAdd">
        <short>AnchorSide added.</short>
      </element>
      <element name="TAnchorSideChangeOperation.ascoRemove">
        <short>AnchorSide removed.</short>
      </element>
      <element name="TAnchorSideChangeOperation.ascoChangeSide">
        <short>AnchorSide changed.</short>
      </element>

      <element name="TAnchorSide">
        <short>Specifies how the side of a control is anchored to other controls.</short>
        <descr>
          <p>
            Class holding the reference sides of the anchors of a TControl. Every TControl has four AnchorSides: AnchorSide[akLeft], AnchorSide[akRight], AnchorSide[akTop] and AnchorSide[akBottom]. Normally if Anchors contain akLeft, and the Parent is resized, the LCL tries to keep the distance between the left side of the control and the right side of its parent client area. With AnchorSide[akLeft] you can define a different reference side. The kept distance is defined by the BorderSpacing. For example:
          </p>
<code>
+-----+  +-----+
|  B  |  |  C  |
|     |  +-----+
+-----+
</code>
          <p>
            If you want to have the top of B the same as the top of C use
          </p>
  <code>
  B.AnchorSide[akTop].Side:=asrTop;
  B.AnchorSide[akTop].Control:=C;
  </code>
          <p>
            If you want to keep a distance of 10 pixels between B and C use
          </p>
  <code>
  B.BorderSpacing.Right:=10;
  B.AnchorSide[akRight].Side:=asrLeft;
  B.AnchorSide[akRight].Control:=C;
  </code>
          <p>
            Do not setup in both directions, because this will create a circle, and circles are not allowed.
          </p>
          <p>
            Another example:
          </p>
<code>
+-------+
|       | +---+
|   B   | | A |
|       | +---+
+-------+
</code>
          <p>
            Centering A relative to B:
          </p>
<code>
  A.AnchorSide[akTop].Side:=asrCenter;
  A.AnchorSide[akTop].Control:=B;
</code>
          <p>
            Or use this equivalent:
          </p>
<code>
  A.AnchorSide[akBottom].Side:=asrCenter;
  A.AnchorSide[akBottom].Control:=B;
</code>
        </descr>
        <seealso/>
      </element>

      <element name="TAnchorSide.FControl"/>
      <element name="TAnchorSide.FKind"/>
      <element name="TAnchorSide.FOwner"/>
      <element name="TAnchorSide.FSide"/>

      <element name="TAnchorSide.IsSideStored">
        <short>Determines if the Control uses an anchor on the side specified in Kind.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TAnchorSide.IsSideStored.Result">
        <short/>
      </element>

      <element name="TAnchorSide.SetControl">
        <short>Sets the value for the Control property.</short>
        <descr/>
        <seealso>
          <link id="TAnchorSide.Control"/>
        </seealso>
      </element>
      <element name="TAnchorSide.SetControl.AValue">
        <short>New value for the property.</short>
      </element>

      <element name="TAnchorSide.SetSide">
        <short>Sets the value for the Side property.</short>
        <descr/>
        <seealso>
          <link id="TAnchorSide.Side"/>
        </seealso>
      </element>
      <element name="TAnchorSide.SetSide.AValue">
        <short>New value for the property.</short>
      </element>

      <element name="TAnchorSide.GetOwner">
        <short>Gets the owner of the persistent object.</short>
        <descr/>
        <seealso>
          <link id="#rtl.classes.TPersistent">TPersistent</link>
        </seealso>
      </element>
      <element name="TAnchorSide.GetOwner.Result">
        <short>Owner of the persistent object.</short>
      </element>

      <element name="TAnchorSide.Create">
        <short>Constructor for the class instance.</short>
        <descr>
          <p>
            <var>Create</var> is the constructor for the class instance.
          </p>
          <p>
            Create calls the inherited constructor, and sets the values in the <var>Owner</var>, <var>Kind</var>, and <var>Side</var> properties. The default value for Side is <var>asrTop</var>.
          </p>
        </descr>
        <seealso></seealso>
      </element>
      <element name="TAnchorSide.Create.TheOwner">
        <short>Owner of the class instance.</short>
      </element>
      <element name="TAnchorSide.Create.TheKind">
        <short>TAnchorKind value for the Kind property.</short>
      </element>

      <element name="TAnchorSide.Destroy">
        <short>Destructor for the class instance.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TAnchorSide.GetSidePosition">
        <short>Get information about the target control, side and side position.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TAnchorSide.GetSidePosition.ReferenceControl">
        <short>The control we are anchored to.</short>
      </element>
      <element name="TAnchorSide.GetSidePosition.ReferenceSide">
        <short>The side we are anchored to.</short>
      </element>
      <element name="TAnchorSide.GetSidePosition.Position">
        <short>Position of the side to anchor to.</short>
      </element>

      <element name="TAnchorSide.CheckSidePosition">
        <short>
          Checks for anchor cycles and invalid targets, and returns information about the target side.
        </short>
        <descr/>
        <errors>
          Can raise an exception with the message: <b>'TAnchorSide.CheckSidePosition invalid Side'.</b>
        </errors>
        <seealso/>
      </element>
      <element name="TAnchorSide.CheckSidePosition.Result">
        <short>False when errors have been found.</short>
      </element>
      <element name="TAnchorSide.CheckSidePosition.NewControl">
        <short/>
      </element>
      <element name="TAnchorSide.CheckSidePosition.NewSide">
        <short/>
      </element>
      <element name="TAnchorSide.CheckSidePosition.ReferenceControl">
        <short>The control we are anchored to.</short>
      </element>
      <element name="TAnchorSide.CheckSidePosition.ReferenceSide">
        <short>The side we are anchored to.</short>
      </element>
      <element name="TAnchorSide.CheckSidePosition.Position">
        <short>Position of the side to anchor to.</short>
      </element>

      <element name="TAnchorSide.Assign">
        <short>
          Copies properties from the specified persistent object into the current class instance.
        </short>
        <descr>
          <p>
            <var>Assign</var> is an overridden method in <var>TAnchorSide</var> used to copy property values from the persistent object in <var>Source</var> into the current class instance. When Source is derived from <var>TAnchorSide</var>, the following properties are copied:
          </p>
          <ul>
            <li>Side</li>
            <li>Control</li>
          </ul>
          <p>
            If Source is not derived from TAnchorSide, the inherited method is called using Source as an argument.
          </p>
        </descr>
        <seealso>
          <link id="#rtl.classes.TPersistent">TPersistent</link>
        </seealso>
      </element>
      <element name="TAnchorSide.Assign.Source">
        <short>Persistent object with the properties copied in the method.</short>
      </element>

      <element name="TAnchorSide.IsAnchoredToParent">
        <short>True when we are anchored to our parent, at least on the ParentSide.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TAnchorSide.IsAnchoredToParent.Result">
        <short/>
      </element>
      <element name="TAnchorSide.IsAnchoredToParent.ParentSide">
        <short/>
      </element>

      <element name="TAnchorSide.FixCenterAnchoring">
        <short>Remove conflicting anchors.</short>
        <descr>
          <p>
            With <var>asrCenter</var>, both sides are controlled by one anchor. Disable opposite anchor and all aligning.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TAnchorSide.Owner">
        <short>The control being anchored.</short>
        <descr>
          <p>
            For example:
          </p>
          <code>AButton1.AnchorSide[akBottom].Owner = AButton1</code>
        </descr>
        <seealso/>
      </element>

      <element name="TAnchorSide.Kind">
        <short>The control side being anchored.</short>
        <descr>
          <p>
            Every control has four AnchorSide elements, one for each side. For example:
          </p>
          <code>AButton1.AnchorSide[akLeft].Kind := akLeft.</code>
        </descr>
        <seealso/>
      </element>

      <element name="TAnchorSide.Control">
        <short>The target control of the anchor.</short>
        <descr>
          <p>
            For example: if the right side of a Button1 is anchored to the left side of Edit1, then:
          </p>
          <code>Button1.AnchorSide[akRight].Control // contains Edit1</code>
          <p>and</p>
          <code>Button1.AnchorSide[akRight].Side // contains asrLeft</code>
        </descr>
        <seealso/>
      </element>

      <element name="TAnchorSide.Side">
        <short>The side of the target Control, to which we anchor.</short>
        <descr>
          <p>
            For example, if the right side of a Button1 is anchored to the left side of Edit1, then:
          </p>
          <code>Button1.AnchorSide[akRight].Control=Edit1</code>
          <p>and</p>
          <code>Button1.AnchorSide[akRight].Side=asrLeft</code>
        </descr>
        <seealso/>
      </element>

      <element name="TControlActionLink">
        <short>Links an Action to a control.</short>
        <descr>
          <p>
            An ActionLink is created when an Action is assigned to the control.
            TControl.Action effectively becomes TControl.ActionLink.Action.
          </p>
          <p>
            An ActionLink propagates changes in Action properties to the client control. It's assumed that properties of the <b>same value</b> (in the Control and Action) are linked to the Action, and follow changes to the Action properties.
          </p>
          <p>
            Linked control properties are (by default):
          </p>
          <ul>
            <li>Caption</li>
            <li>Enabled</li>
            <li>Hint</li>
            <li>
              HelpContext, HelpKeyword, HelpType: these are linked only if all three property values match.
            </li>
            <li>Visible</li>
            <li>OnClick is linked to Action.Execute</li>
          </ul>
          <p>
            The control can update itself, when it receives a Change notification from the ActionLink <link id="TControl.ActionChange"/>.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TControlActionLink.FClient">
        <short>The client control that is linked to the action.</short>
        <descr>It can be assumed that FClient is not Nil.</descr>
      </element>

      <element name="TControlActionLink.AssignClient">
        <short>Called during construction, sets FClient to the given control.</short>
        <seealso>
          <link id="#rtl.classes.TBasicActionLink">TBasicActionLink</link>
        </seealso>
      </element>
      <element name="TControlActionLink.AssignClient.AClient">
        <short>The control linked to the action.</short>
      </element>

      <element name="TControlActionLink.SetCaption">
        <short>Sets the client's Caption, if the old values match.</short>
        <descr/>
        <seealso>
          <link id="#lcl.actnlist.TActionLink.SetCaption">TActionLink.SetCaption</link>
        </seealso>
      </element>
      <element name="TControlActionLink.SetCaption.Value">
        <short/>
      </element>

      <element name="TControlActionLink.SetEnabled">
        <short>Sets the client's Enabled property, if the old values match.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlActionLink.SetEnabled.Value">
        <short/>
      </element>

      <element name="TControlActionLink.SetHint">
        <short>Sets client's Hint, if the old values match.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlActionLink.SetHint.Value">
        <short/>
      </element>

      <element name="TControlActionLink.SetHelpContext">
        <short>Sets the HelpContext, if the old Help properties match (IsHelpLinked).</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlActionLink.SetHelpContext.Value">
        <short/>
      </element>

      <element name="TControlActionLink.SetHelpKeyword">
        <short>Sets the HelpKeyword, if the old Help properties match (IsHelpLinked).</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlActionLink.SetHelpKeyword.Value">
        <short/>
      </element>

      <element name="TControlActionLink.SetHelpType">
        <short>Sets the HelpType, if the old Help properties match (IsHelpLinked).</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlActionLink.SetHelpType.Value">
        <short/>
      </element>

      <element name="TControlActionLink.SetVisible">
        <short>Sets the Visible property in the client, if the old values match.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlActionLink.SetVisible.Value">
        <short/>
      </element>

      <element name="TControlActionLink.SetOnExecute">
        <short>Set OnClick handler for the client, if the old values match.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlActionLink.SetOnExecute.Value">
        <short/>
      </element>

      <element name="TControlActionLink.IsOnExecuteLinked">
        <short>True if the client's OnClick is the action's OnExecute handler.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlActionLink.IsOnExecuteLinked.Result">
        <short/>
      </element>

      <element name="TControlActionLink.DoShowHint">
        <short>Compose the hint string, depending on HintShortCuts.</short>
        <descr/>
        <seealso>
          <link id="#lcl.forms.TApplication.HintShortCuts">TApplication.HintShortCuts</link>
        </seealso>
      </element>
      <element name="TControlActionLink.DoShowHint.Result">
        <short>Always True.</short>
      </element>
      <element name="TControlActionLink.DoShowHint.HintStr">
        <short>The hint to show.</short>
      </element>

      <element link="#lcl.actnlist.TActionLink.IsCaptionLinked" name="TControlActionLink.IsCaptionLinked"/>
      <element name="TControlActionLink.IsCaptionLinked.Result"/>

      <element link="#lcl.actnlist.TActionLink.IsEnabledLinked" name="TControlActionLink.IsEnabledLinked"/>
      <element name="TControlActionLink.IsEnabledLinked.Result"/>

      <element name="TControlActionLink.IsHelpLinked">
        <short>Help properties are assumed linked only when all these properties match.</short>
        <descr>Compares the HelpContext, HelpKeyword and HelpType properties.</descr>
        <seealso>
          <link id="#lcl.actnlist.TActionLink.IsHelpLinked">TActionLink.IsHelpLinked</link>
        </seealso>
      </element>
      <element name="TControlActionLink.IsHelpLinked.Result">
        <short>True only if all three Control properties match the Action properties.</short>
      </element>

      <element link="#lcl.actnlist.TActionLink.IsHintLinked" name="TControlActionLink.IsHintLinked"/>
      <element name="TControlActionLink.IsHintLinked.Result"/>

      <element link="#lcl.actnlist.TActionLink.IsVisibleLinked" name="TControlActionLink.IsVisibleLinked"/>
      <element name="TControlActionLink.IsVisibleLinked.Result"/>

      <element name="TControlActionLinkClass">
        <short>Class of <link id="TControlActionLink"/></short>
        <descr/>
        <seealso>
          <link id="TControlActionLink"/>
        </seealso>
      </element>

      <element name="ELayoutException">
        <short>
          Exception raised when a loop is detected when adjusting the size for controls.
        </short>
        <descr>
          <p>
            <var>ELayoutException</var> is an <var>Exception</var> descendant that implements  the exception raised when a loop is detected when adjusting the size for controls, or when an invalid value is assigned to the control width or height.
          </p>
        </descr>
        <seealso>
          <link id="TControl.AdjustSize"/>
          <link id="TControl.EnableAutoSizing"/>
          <link id="TControl.ChangeBounds"/>
          <link id="TControl.Width"/>
          <link id="TControl.Height"/>
        </seealso>
      </element>

      <element name="TControlAutoSizePhase">
        <short>Represents AutoSizing phases for controls.</short>
        <descr>
          <p>
            <var>TControlAutoSizePhase</var> is an enumerated type with values that represent phases or steps in the auto-sizing process for controls. Values from TControlAutoSizePhase are stored in the <var>TControlAutoSizePhases</var> set type.
          </p>
        </descr>
        <seealso>
          <link id="TControlAutoSizePhases"/>
          <link id="TControl.AutoSizePhases"/>
          <link id="TWinControl.AutoSizePhases"/>
        </seealso>
      </element>
      <element name="TControlAutoSizePhase.caspNone">
        <short/>
      </element>
      <element name="TControlAutoSizePhase.caspChangingProperties">
        <short/>
      </element>
      <element name="TControlAutoSizePhase.caspCreatingHandles">
        <short>Create/Destroy handles.</short>
      </element>
      <element name="TControlAutoSizePhase.caspComputingBounds">
        <short/>
      </element>
      <element name="TControlAutoSizePhase.caspRealizingBounds">
        <short/>
      </element>
      <element name="TControlAutoSizePhase.caspShowing">
        <short>Makes a handle visible.</short>
      </element>

      <element name="TControlAutoSizePhases">
        <short>Set type used to store values from the TControlAutoSizePhase enumeration.</short>
        <descr/>
        <seealso>
          <link id="TControlAutoSizePhase"/>
        </seealso>
      </element>

      <element name="TTabOrder">
        <short>Type used for <link id="TWinControl.TabOrder"/></short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlShowHintEvent">
        <short>Type used to implement an OnShowHint event handler.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlShowHintEvent.Sender">
         <short>TObject for the event notification.</short>
      </element>
      <element name="TControlShowHintEvent.HintInfo">
         <short>Hint information used to derive hint value.</short>
      </element>

      <element name="TContextPopupEvent">
        <short>Handler type for OnContextPopup.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TContextPopupEvent.Sender">
        <short>The clicked control.</short>
      </element>
      <element name="TContextPopupEvent.MousePos">
        <short>
          Mouse position in client coordinates; (-1,-1) if the event was not generated by a mouse click.
        </short>
      </element>
      <element name="TContextPopupEvent.Handled">
        <short>
          Set Handled to True when everything was handled; False shows the associated PopupMenu, by default.
        </short>
      </element>

      <element name="TControlFlag">
        <short>Flags mostly for pending actions.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlFlag.cfLoading">
        <short>
          Set by TControl.ReadState, and unset by TControl.Loaded when all controls for the form have finished loading.
        </short>
      </element>
      <element name="TControlFlag.cfAutoSizeNeeded">
        <short>Set when AutoSize was delayed.</short>
      </element>
      <element name="TControlFlag.cfLeftLoaded">
        <short>Set when Left was set during loading.</short>
      </element>
      <element name="TControlFlag.cfTopLoaded">
        <short>Set when Top was set during loading.</short>
      </element>
      <element name="TControlFlag.cfWidthLoaded">
        <short>Set when Width was set during loading.</short>
      </element>
      <element name="TControlFlag.cfHeightLoaded">
        <short>Set when Height was set during loading.</short>
      </element>
      <element name="TControlFlag.cfClientWidthLoaded">
        <short>Set when ClientWidth was set during loading.</short>
      </element>
      <element name="TControlFlag.cfClientHeightLoaded">
        <short>Set when ClientHeight was set during loading.</short>
      </element>
      <element name="TControlFlag.cfBoundsRectForNewParentValid">
        <short>Set when BoundsRectForNewParent has been initialized.</short>
      </element>
      <element name="TControlFlag.cfBaseBoundsValid">
        <short>Indicates if the rectangle in the base bounds for a control is valid.</short>
      </element>
      <element name="TControlFlag.cfPreferredSizeValid">
        <short>Set when PreferredSize has been calculated (CalculatePreferredSize).</short>
      </element>
      <element name="TControlFlag.cfPreferredMinSizeValid">
        <short/>
      </element>
      <element name="TControlFlag.cfOnChangeBoundsNeeded">
        <short/>
      </element>
      <element name="TControlFlag.cfProcessingWMPaint">
        <short>Set (in WndProc) while processing an LM_PAINT message.</short>
      </element>
      <element name="TControlFlag.cfKillChangeBounds">
        <short/>
      </element>
      <element name="TControlFlag.cfKillInvalidatePreferredSize">
        <short/>
      </element>
      <element name="TControlFlag.cfKillAdjustSize">
        <short/>
      </element>

      <element name="TControlFlags">
        <short>Set type used to store values from the TControlFlag enumeration.</short>
        <descr/>
        <seealso>
          <link id="TControlFlag"/>
        </seealso>
      </element>

      <element name="TControlHandlerType">
        <short>Notification handler types.</short>
        <descr>
          <p>
            Notification handlers only receive a Sender argument, and must know themselves why they have been invoked.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TControlHandlerType.chtOnResize">
        <short>Notification request for OnResize.</short>
      </element>
      <element name="TControlHandlerType.chtOnChangeBounds">
        <short>Notification request for OnChangeBounds.</short>
      </element>
      <element name="TControlHandlerType.chtOnVisibleChanging">
        <short>Notification request for OnVisibleChanging.</short>
      </element>
      <element name="TControlHandlerType.chtOnVisibleChanged">
        <short>Notification request for OnVisibleChanged.</short>
      </element>
      <element name="TControlHandlerType.chtOnEnabledChanging">
        <short>Notification request for OnEnabledChanging.</short>
      </element>
      <element name="TControlHandlerType.chtOnEnabledChanged">
        <short>Notification request for OnEnabledChanged.</short>
      </element>
      <element name="TControlHandlerType.chtOnKeyDown">
        <short>Notification request for OnKeyDown.</short>
      </element>

      <element name="TLayoutAdjustmentPolicy">
        <short>
          Indicates the policy for the LCL to execute automatic adjustments in the form layout.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TLayoutAdjustmentPolicy.lapDefault">
        <short>Widgetset dependent.</short>
      </element>
      <element name="TLayoutAdjustmentPolicy.lapFixedLayout">
        <short>A fixed absolute layout on all platforms.</short>
      </element>
      <element name="TLayoutAdjustmentPolicy.lapAutoAdjustWithoutHorizontalScrolling">
        <short>
          Smartphone platforms use this one, the x axis is stretched to fill the screen and the y axis is scaled to fit the DPI.
        </short>
      </element>
      <element name="TLayoutAdjustmentPolicy.lapAutoAdjustForDPI">
        <short>For desktops using High DPI, scale x and y to fit the DPI.</short>
      </element>

      <element name="TLazAccessibilityRole">
        <short>Indicates the role which a accessible object takes in the user interface.</short>
        <descr/>
        <seealso>
          <link id="TLazAccessibleObject"/>
        </seealso>
      </element>
      <element name="TLazAccessibilityRole.larIgnore">
        <short>Something to be ignored. For example a blank space between other objects.</short>
      </element>
      <element name="TLazAccessibilityRole.larAnimation">
        <short>An object that displays an animation.</short>
      </element>
      <element name="TLazAccessibilityRole.larButton">
        <short>A button.</short>
      </element>
      <element name="TLazAccessibilityRole.larCell">
        <short>A cell in a table.</short>
      </element>
      <element name="TLazAccessibilityRole.larChart">
        <short>An object that displays a graphical representation of data.</short>
      </element>
      <element name="TLazAccessibilityRole.larCheckBox">
        <short>An object that can be checked or unchecked, or sometimes in an intermediary state.</short>
      </element>
      <element name="TLazAccessibilityRole.larClock">
        <short>A clock displaying time.</short>
      </element>
      <element name="TLazAccessibilityRole.larColorPicker">
        <short>A control which allows selecting a color.</short>
      </element>
      <element name="TLazAccessibilityRole.larColumn">
        <short>A generic column in a table.</short>
      </element>
      <element name="TLazAccessibilityRole.larComboBox">
        <short>A list of choices that the user can select from.</short>
      </element>
      <element name="TLazAccessibilityRole.larDateField">
        <short>A controls which displays and possibly allows one to choose a date.</short>
      </element>
      <element name="TLazAccessibilityRole.larGrid">
        <short>A grid control which displays cells.</short>
      </element>
      <element name="TLazAccessibilityRole.larGroup">
        <short>A control which groups others, such as a TGroupBox.</short>
      </element>
      <element name="TLazAccessibilityRole.larImage">
        <short>A graphic or picture or an icon.</short>
      </element>
      <element name="TLazAccessibilityRole.larLabel">
        <short>A text label as usually placed near other widgets.</short>
      </element>
      <element name="TLazAccessibilityRole.larListBox">
        <short>A list of items, from which the user can select one or more items.</short>
      </element>
      <element name="TLazAccessibilityRole.larListItem">
        <short>An item in a list of items.</short>
      </element>
      <element name="TLazAccessibilityRole.larMenuBar">
        <short>A main menu bar.</short>
      </element>
      <element name="TLazAccessibilityRole.larMenuItem">
        <short>A item in a menu.</short>
      </element>
      <element name="TLazAccessibilityRole.larProgressIndicator">
        <short>A control which shows a progress indication.</short>
      </element>
      <element name="TLazAccessibilityRole.larRadioButton">
        <short>A radio button, see for example TRadioButton.</short>
      </element>
      <element name="TLazAccessibilityRole.larResizeGrip">
        <short>A grip that the user can drag to change the size of widgets.</short>
      </element>
      <element name="TLazAccessibilityRole.larRow">
        <short>A generic row in a table.</short>
      </element>
      <element name="TLazAccessibilityRole.larScrollBar">
        <short>A control to scroll another one.</short>
      </element>
      <element name="TLazAccessibilityRole.larSpinner">
        <short>A control which allows one to increment / decrement a value.</short>
      </element>
      <element name="TLazAccessibilityRole.larTabControl">
        <short>A control with tabs, like TPageControl.</short>
      </element>
      <element name="TLazAccessibilityRole.larText">
        <short>Text inside of a control, like text in a row cell.</short>
      </element>
      <element name="TLazAccessibilityRole.larTextEditorMultiline">
        <short>A multi-line text editor (for example: TMemo, SynEdit).</short>
      </element>
      <element name="TLazAccessibilityRole.larTextEditorSingleline">
        <short>A single-line text editor (for example: TEdit).</short>
      </element>
      <element name="TLazAccessibilityRole.larToolBar">
        <short>A control that holds ToolButtons.</short>
      </element>
      <element name="TLazAccessibilityRole.larToolBarButton">
        <short>A button on a ToolBar.</short>
      </element>
      <element name="TLazAccessibilityRole.larTrackBar">
        <short>A control which allows one to drag a slider.</short>
      </element>
      <element name="TLazAccessibilityRole.larTreeView">
        <short>A list of items in a tree structure.</short>
      </element>
      <element name="TLazAccessibilityRole.larTreeItem">
        <short>An item in a tree structure.</short>
      </element>
      <element name="TLazAccessibilityRole.larUnknown">
        <short>An item that doesn't fit any of the other categories.</short>
      </element>
      <element name="TLazAccessibilityRole.larWindow">
        <short>A top level window.</short>
      </element>

      <element name="TLazAccessibleObjectEnumerator">
        <short>Implements an enumerator for a list of TLazAccessibleObject instances.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TLazAccessibleObjectEnumerator.GetCurrent">
         <short>Gets the value for the Current property.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TLazAccessibleObjectEnumerator.GetCurrent.Result">
         <short>Value for the property.</short>
      </element>

      <element name="TLazAccessibleObjectEnumerator.Current">
         <short>Current value for the enumerator.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TLazAccessibleObject">
        <short>
          Represents an accessibility object for user or accessibility tool interactions.
        </short>
        <descr>
          <p>
            Every <var>TControl</var> has a <var>TLazAccessibleObject</var> instance associated with it, which means that every <var>TControl</var> is potentially accessible. But to actually be usable, the accessible object needs to have its properties set, the most important of which are the role, description and value. Native windowed classes should already receive accessibility properties from the underlying widgetset, while <var>TCustomControl</var> descendants will use the accessibility properties provided by LCL itself.
          </p>
          <p>
            User applications should add accessibility for their own <var>TCustomControl</var> descendant classes, and possibly customize the descriptions of some elements. It is also possible to make an accessible object invisible to the user, which is done by setting its AccessibleRole property to <var>larIgnored</var>.
          </p>
          <p>
             Accessibility support in Lazarus is also documented on the Wiki at:
             <url href="http://wiki.lazarus.freepascal.org/LCL_Accessibility"/>.
           </p>
        </descr>
        <seealso>
          <link id="TControl"/>
          <link id="TControl.AccessibleRole"/>
          <link id="TControl.AccessibleDescription"/>
          <link id="TControl.AccessibleValue"/>
          <link id="TLazAccessibilityRole"/>
        </seealso>
      </element>

      <element name="TLazAccessibleObject.FPosition"/>
      <element name="TLazAccessibleObject.FSize"/>
      <element name="TLazAccessibleObject.FLastSearchNode"/>
      <element name="TLazAccessibleObject.FLastSearchIndex"/>
      <element name="TLazAccessibleObject.FLastSearchInSubcontrols"/>

      <element name="TLazAccessibleObject.GetPosition">
        <short>Gets the value for the Position property.</short>
      </element>
      <element name="TLazAccessibleObject.GetPosition.Result">
         <short>Value for the property.</short>
      </element>

      <element name="TLazAccessibleObject.GetSize">
        <short>Gets the value for the Size property.</short>
        <seealso>
          <link id="TLazAccessibleObject.Size"/>
        </seealso>
      </element>
      <element name="TLazAccessibleObject.GetSize.Result">
         <short>Value for the property.</short>
     </element>

      <element name="TLazAccessibleObject.SetHandle">
        <short>Sets the value for the Handle property.</short>
        <seealso>
          <link id="TLazAccessibleObject.Handle"/>
        </seealso>
      </element>
      <element name="TLazAccessibleObject.SetHandle.AValue">
         <short>New value for the property.</short>
      </element>

      <element name="TLazAccessibleObject.SetPosition">
        <short>Sets the value for the Position property.</short>
        <seealso>
          <link id="TLazAccessibleObject.Position"/>
        </seealso>
      </element>
      <element name="TLazAccessibleObject.SetPosition.AValue">
        <short>New value for the Position property.</short>
      </element>

      <element name="TLazAccessibleObject.SetSize">
        <short>Sets the value for the Size property.</short>
        <descr></descr>
        <seealso>
          <link id="TLazAccessibleObject.Size"/>
        </seealso>
      </element>
      <element name="TLazAccessibleObject.SetSize.AValue">
         <short>New value for the property.</short>
      </element>

      <element name="TLazAccessibleObject.FHandle">
        <short>Member with the Handle for the accessibility object.</short>
      </element>
      <element name="TLazAccessibleObject.FChildrenSortedForDataObject">
        <short>Member with the AVL tree for the sorted child objects.</short>
      </element>
      <element name="TLazAccessibleObject.FAccessibleName">
        <short>Member with the value for AccessibleName.</short>
      </element>
      <element name="TLazAccessibleObject.FAccessibleDescription">
        <short>Member with the value for AccessibleDescription.</short>
      </element>
      <element name="TLazAccessibleObject.FAccessibleValue">
        <short>Member with the value for AccessibleValue.</short>
      </element>
      <element name="TLazAccessibleObject.FAccessibleRole">
        <short>Member with the value for AccessibleRole.</short>
      </element>

      <element name="TLazAccessibleObject.WSRegisterClass"  link="#lcl.lclclasses.TLCLComponent.WSRegisterClass"/>

      <element name="TLazAccessibleObject.GetAccessibleValue">
         <short>Gets the value for the AccessibleValue property.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TLazAccessibleObject.GetAccessibleValue.Result">
         <short>Value for the property.</short>
      </element>

      <element name="TLazAccessibleObject.GetHandle">
        <short>Gets the value for the Handle property.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TLazAccessibleObject.GetHandle.Result">
         <short>Value for the property.</short>
      </element>

      <element name="TLazAccessibleObject.OwnerControl">
        <short>
          The control that this accessible object is attached to. It might be the main accessible object of this control or it might represent a sub-part of a control.
        </short>
        <descr>
          <p>
            The control that this accessible object is attached to. It might be the main accessible object of this control, or it might represent a sub-part of a control which does not have a corresponding TControl, like an item of TTreeView. One can verify if this is the main accessible object of the control by checking if (lAccessibleObject.OwnerControl = lAccessibleObject.OwnerControl.GetAccessibleObject())
          </p>
        </descr>
        <seealso>
          <link id="TControl.GetAccessibleObject"/>
        </seealso>
      </element>

      <element name="TLazAccessibleObject.Parent">
        <short>The parent TLazAccessibleObject of this accessible object.</short>
      </element>

      <element name="TLazAccessibleObject.DataObject">
        <short>Available to be used to connect to an object.</short>
      </element>

      <element name="TLazAccessibleObject.SecondaryHandle">
        <short>Available for Widgetsets to use.</short>
      </element>

      <element name="TLazAccessibleObject.Create">
         <short>Constructor for the class instance.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TLazAccessibleObject.Destroy">
         <short>Destructor for the class instance.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TLazAccessibleObject.HandleAllocated">
        <short>Returns if the handle of this object was already allocated or not.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TLazAccessibleObject.InitializeHandle">
        <short>
          Utilized to set all properties of this property via widgetset routines when creating the handle.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TLazAccessibleObject.SetAccessibleName">
        <short>Sets the value for AccessibleName.</short>
        <descr/>
        <seealso>
          <link id="TLazAccessibleObject.AccessibleName"/>
        </seealso>
      </element>
      <element name="TLazAccessibleObject.SetAccessibleName.AName">
        <short>New value for the AccessibleName property.</short>
      </element>

      <element name="TLazAccessibleObject.SetAccessibleDescription">
        <short>Setter for the property AccessibleDescription.</short>
      </element>

      <element name="TLazAccessibleObject.SetAccessibleValue">
        <short>Setter for the property AccessibleValue.</short>
      </element>

      <element name="TLazAccessibleObject.SetAccessibleRole">
        <short>Setter for the property AccessibleRole.</short>
      </element>

      <element name="TLazAccessibleObject.FindOwnerWinControl">
        <short>Inspect the tree of accessible objects upwards until it finds a parent which is attached directly to a windowed control, a TWinControl.</short>
      </element>

      <element name="TLazAccessibleObject.AddChildAccessibleObject">
        <short>Creates and returns a new child accessiblity object.</short>
      </element>
      <element name="TLazAccessibleObject.AddChildAccessibleObject.Result">
        <short>Child accessibility object created in the method.</short>
      </element>
      <element name="TLazAccessibleObject.AddChildAccessibleObject.ADataObject">
        <short/>
      </element>

      <element name="TLazAccessibleObject.InsertChildAccessibleObject">
        <short>Inserts an already created child accessible object as a child of this one.</short>
      </element>

      <element name="TLazAccessibleObject.ClearChildAccessibleObjects">
        <short>
          Removes all children of this control; freed if they are not attached to a TControl instance.
        </short>
      </element>

      <element name="TLazAccessibleObject.RemoveChildAccessibleObject">
        <short>Removes a child accessible object.</short>
      </element>

      <element name="TLazAccessibleObject.GetChildAccessibleObject">
        <short>Obtains a child accessible object by its index.</short>
      </element>

      <element name="TLazAccessibleObject.GetChildAccessibleObjectWithDataObject">
        <short>Obtains a child accessible object by its DataObject property.</short>
      </element>

      <element name="TLazAccessibleObject.GetChildAccessibleObjectsCount">
        <short>Returns the number of direct children that this accessible object has.</short>
      </element>

       <element name="TLazAccessibleObject.GetFirstChildAccessibleObject">
         <short>Searches in sub-controls for the first child accessibility object.</short>
         <descr/>
         <seealso/>
       </element>
       <element name="TLazAccessibleObject.GetFirstChildAccessibleObject.Result">
         <short/>
       </element>

       <element name="TLazAccessibleObject.GetNextChildAccessibleObject">
         <short>Searches in sub-controls for the next child accessibility object.</short>
         <descr/>
         <seealso/>
       </element>
       <element name="TLazAccessibleObject.GetNextChildAccessibleObject.Result">
         <short/>
       </element>

      <element name="TLazAccessibleObject.GetSelectedChildAccessibleObject">
        <short>
          Returns the currently selected child accessible object or <b>Nil</b> if none are selected;  Override this method in your sub class.
        </short>
        <seealso>
          <link id="TControl.GetSelectedChildAccessibleObject"/>
        </seealso>
      </element>

      <element name="TLazAccessibleObject.GetChildAccessibleObjectAtPos">
        <short>
          Returns the child of this control located at a particular position given as a client position for the control.
        </short>
        <seealso>
          <link id="TControl.GetChildAccessibleObjectAtPos"/>
        </seealso>
      </element>

      <element name="TLazAccessibleObject.AccessibleName">
        <short>The name for this accessible object.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TLazAccessibleObject.AccessibleDescription">
        <short>The description of this accessible object.</short>
        <seealso>
          <link id="TControl.AccessibleDescription"/>
        </seealso>
      </element>

      <element name="TLazAccessibleObject.AccessibleValue">
        <short>The value of this accessible object.</short>
        <seealso>
          <link id="TControl.AccessibleValue"/>
        </seealso>
      </element>

      <element name="TLazAccessibleObject.AccessibleRole">
        <short>The role of this accessible object.</short>
        <seealso>
          <link id="TControl.AccessibleRole"/>
        </seealso>
      </element>

      <element name="TLazAccessibleObject.Position">
        <short>The position of this accessible object.</short>
      </element>

      <element name="TLazAccessibleObject.Size">
        <short>The size of this accessible object.</short>
      </element>

      <element name="TLazAccessibleObject.Handle">
        <short>The widgetset handle of this accessible object.</short>
      </element>

      <element name="TLazAccessibleObject.GetEnumerator">
        <short>Default enumerator for the children.</short>
      </element>

      <element name="TControl">
        <short>The base class for visible controls.</short>
      </element>

      <element name="TControl.FActionLink"/>
      <element name="TControl.FAlign"/>
      <element name="TControl.FAnchors"/>
      <element name="TControl.FAnchorSides"/>
      <element name="TControl.fAnchoredControls"/>
      <element name="TControl.FAutoSizingLockCount"/>
      <element name="TControl.FAutoSizingLockReasons"/>
      <element name="TControl.FBaseBounds"/>
      <element name="TControl.FBaseBoundsLock"/>
      <element name="TControl.FBaseParentClientSize"/>
      <element name="TControl.FBiDiMode"/>
      <element name="TControl.FBorderSpacing"/>
      <element name="TControl.FBoundsRectForNewParent"/>
      <element name="TControl.FCaption"/>
      <element name="TControl.FCaptureMouseButtons"/>
      <element name="TControl.FColor"/>
      <element name="TControl.FConstraints"/>
      <element name="TControl.FControlFlags"/>

      <element name="TControl.FControlHandlers">
        <short>Array of the installable notification handlers.</short>
      </element>

      <element name="TControl.FControlStyle"/>
      <element name="TControl.FDockOrientation"/>
      <element name="TControl.FDragCursor"/>
      <element name="TControl.FDragKind"/>
      <element name="TControl.FDragMode"/>
      <element name="TControl.FFloatingDockSiteClass"/>
      <element name="TControl.FFont"/>
      <element name="TControl.FHeight"/>
      <element name="TControl.FHelpContext"/>
      <element name="TControl.FHelpKeyword"/>
      <element name="TControl.FHelpType"/>
      <element name="TControl.FHint"/>
      <element name="TControl.FHostDockSite"/>
      <element name="TControl.FLastDoChangeBounds"/>
      <element name="TControl.FLastDoChangeClientSize"/>
      <element name="TControl.FLastResizeClientHeight"/>
      <element name="TControl.FLastResizeClientWidth"/>
      <element name="TControl.FLastResizeHeight"/>
      <element name="TControl.FLastResizeWidth"/>
      <element name="TControl.FLeft"/>

      <element name="TControl.FLoadedClientSize">
        <short>Intended ClientSize, initialized during loading.</short>
      </element>

      <element name="TControl.FLRDockWidth"/>
      <element name="TControl.FOnChangeBounds"/>
      <element name="TControl.FOnClick"/>
      <element name="TControl.FOnConstrainedResize"/>
      <element name="TControl.FOnContextPopup"/>
      <element name="TControl.FOnDblClick"/>
      <element name="TControl.FOnDragDrop"/>
      <element name="TControl.FOnDragOver"/>
      <element name="TControl.FOnEditingDone"/>
      <element name="TControl.FOnEndDock"/>
      <element name="TControl.FOnEndDrag"/>
      <element name="TControl.FOnMouseDown"/>
      <element name="TControl.FOnMouseEnter"/>
      <element name="TControl.FOnMouseLeave"/>
      <element name="TControl.FOnMouseMove"/>
      <element name="TControl.FOnMouseUp"/>
      <element name="TControl.FOnMouseWheel"/>
      <element name="TControl.FOnMouseWheelDown"/>
      <element name="TControl.FOnMouseWheelUp"/>
      <element name="TControl.FOnMouseWheelHorz"/>
      <element name="TControl.FOnMouseWheelLeft"/>
      <element name="TControl.FOnMouseWheelUpRight"/>
      <element name="TControl.FOnQuadClick"/>
      <element name="TControl.FOnResize"/>
      <element name="TControl.FOnShowHint"/>
      <element name="TControl.FOnStartDock"/>
      <element name="TControl.FOnStartDrag"/>
      <element name="TControl.FOnTripleClick"/>
      <element name="TControl.FParent"/>
      <element name="TControl.FPopupMenu"/>
      <element name="TControl.FPreferredMinHeight"/>
      <element name="TControl.FPreferredMinWidth"/>
      <element name="TControl.FPreferredWidth"/>
      <element name="TControl.FPreferredHeight"/>
      <element name="TControl.FReadBounds"/>
      <element name="TControl.FSessionProperties"/>
      <element name="TControl.FSizeLock"/>
      <element name="TControl.FTBDockHeight"/>
      <element name="TControl.FTop"/>
      <element name="TControl.FUndockHeight"/>
      <element name="TControl.FUndockWidth"/>
      <element name="TControl.FWidth"/>
      <element name="TControl.FWindowProc"/>
      <element name="TControl.FDesktopFont"/>
      <element name="TControl.FParentBiDiMode"/>
      <element name="TControl.FIsControl"/>
      <element name="TControl.FShowHint"/>
      <element name="TControl.FParentColor"/>
      <element name="TControl.FParentFont"/>
      <element name="TControl.FParentShowHint"/>
      <element name="TControl.FAutoSize"/>
      <element name="TControl.FAutoSizingAll"/>
      <element name="TControl.FAutoSizingSelf"/>
      <element name="TControl.FEnabled"/>
      <element name="TControl.FMouseInClient"/>
      <element name="TControl.FVisible"/>

      <element name="TControl.CaptureMouseButtonsIsStored">
        <short>Implements the storage specifier for the CaptureMouseButtons property.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.CaptureMouseButtonsIsStored.Result">
        <short/>
      </element>

      <element name="TControl.DoActionChange">
        <short>Implements the  OnChange handler routine assigned to the ActionLink.</short>
        <descr>
          <p>
            When an Action is assigned to the control, related properties are updated using <link id="TControl.ActionChange">ActionChange</link>.
          </p>
        </descr>
      </element>
      <element name="TControl.DoActionChange.Sender">
        <short>The changed Action.</short>
      </element>

      <element name="TControl.GetAccessibleDescription">
         <short>Gets the value for the AccessibleDescription property.</short>
        <descr/>
        <seealso>
          <link id="TControl.AccessibleDescription"/>
        </seealso>
      </element>
      <element name="TControl.GetAccessibleDescription.Result">
         <short>Value for the property.</short>
      </element>

      <element name="TControl.GetAccessibleValue">
         <short>Gets the value for the AccessibleValue property.</short>
        <descr/>
        <seealso>
          <link id="TControl.AccessibleValue"/>
        </seealso>
      </element>
      <element name="TControl.GetAccessibleValue.Result">
         <short>Value for the property.</short>
      </element>

      <element name="TControl.GetAccessibleRole">
         <short>Gets the value for the AccessibleRole property.</short>
        <descr/>
        <seealso>
          <link id="TControl.AccessibleRole"/>
        </seealso>
      </element>
      <element name="TControl.GetAccessibleRole.Result">
         <short>Value for the property.</short>
      </element>

      <element name="TControl.GetAutoSizingAll">
        <short>Gets the value for the AutoSizingAll property.</short>
        <descr>
          <p>
            Returns the value from the AutoSizingAll property in the Parent when Parent has been assigned. Otherwise, the existing property value is used.
          </p>
        </descr>
        <seealso>
          <link id="TControl.AutoSizingAll"/>
          <link id="TControl.Parent"/>
        </seealso>
      </element>
      <element name="TControl.GetAutoSizingAll.Result">
        <short>Value for the AutoSizingAll property.</short>
      </element>

      <element name="TControl.GetAnchorSide">
        <short>Gets the value for the indexed AnchorSide property.</short>
        <descr/>
        <seealso>
          <link id="TControl.AnchorSide"/>
          <link id="TAnchorKind"/>
        </seealso>
      </element>
      <element name="TControl.GetAnchorSide.Result">
        <short>Value for the indexed AnchorSide property.</short>
      </element>
      <element name="TControl.GetAnchorSide.Kind">
        <short>TAnchorKind value with the array element accessed for the property value.</short>
      </element>

      <element name="TControl.GetAnchoredControls">
        <short>Gets the value for the indexed AnchoredControls property.</short>
        <descr/>
        <seealso>
          <link id="TControl.AnchoredControls"/>
        </seealso>
      </element>
      <element name="TControl.GetAnchoredControls.Result">
        <short>Value for the indexed AnchoredControls property.</short>
      </element>
      <element name="TControl.GetAnchoredControls.Index">
        <short>Ordinal position in the list of anchored controls for the property value.</short>
      </element>

      <element name="TControl.GetBoundsRect">
        <short>Gets the value for the BoundsRect property.</short>
        <descr/>
        <seealso>
          <link id="TControl.BoundsRect"/>
        </seealso>
      </element>
      <element name="TControl.GetBoundsRect.Result">
        <short>Value for the BoundsRect property.</short>
      </element>

      <element name="TControl.GetClientHeight">
        <short>Gets the value for the ClientHeight property.</short>
        <descr/>
        <seealso>
          <link id="TControl.ClientHeight"/>
        </seealso>
      </element>
      <element name="TControl.GetClientHeight.Result">
        <short>Value for the ClientHeight property.</short>
      </element>

      <element name="TControl.GetClientWidth">
        <short>Gets the value for the ClientWidth property.</short>
        <descr/>
        <seealso>
          <link id="TControl.ClientWidth"/>
        </seealso>
      </element>
      <element name="TControl.GetClientWidth.Result">
        <short>Value for the ClientWidth property.</short>
      </element>

      <element name="TControl.GetLRDockWidth">
        <short>Gets the value for the LRDockWidth property.</short>
        <descr/>
        <seealso>
          <link id="TControl.LRDockWidth"/>
        </seealso>
      </element>
      <element name="TControl.GetLRDockWidth.Result">
        <short>Value for the LRDockWidth property.</short>
      </element>

      <element name="TControl.GetTBDockHeight">
        <short>Gets the value for the TBDockHeight property.</short>
        <descr/>
        <seealso>
          <link id="TControl.TBDockHeight"/>
        </seealso>
      </element>
      <element name="TControl.GetTBDockHeight.Result">
        <short>Value for the TBDockHeight property.</short>
      </element>

      <element name="TControl.GetText">
        <short>Gets the value for the Text property.</short>
        <descr>
          <p>
            Uses RealGetText (which reads the Caption member), instead of GetTextBuf (which calls WM_GETTEXT), when possible.
          </p>
        </descr>
        <seealso>
          <link id="TControl.RealGetText"/>
          <link id="TControl.GetTextBuf"/>
        </seealso>
      </element>
      <element name="TControl.GetText.Result">
        <short>The value for the Text property.</short>
      </element>

      <element name="TControl.GetUndockHeight">
        <short>Gets the value for the UndockHeight property.</short>
        <descr/>
        <seealso>
          <link id="TControl.UndockHeight"/>
        </seealso>
      </element>
      <element name="TControl.GetUndockHeight.Result">
        <short>Value for the UndockHeight property.</short>
      </element>

      <element name="TControl.GetUndockWidth">
        <short>Gets the value for the UndockWidth property.</short>
        <descr/>
        <seealso>
          <link id="TControl.UndockWidth"/>
        </seealso>
      </element>
      <element name="TControl.GetUndockWidth.Result">
        <short>Value for the UndockWidth property.</short>
      </element>

      <element name="TControl.IsAnchorsStored">
        <short>Implements the storage specifier for the Anchors property.</short>
        <descr/>
        <seealso>
          <link id="TControl.Anchors"/>
        </seealso>
      </element>
      <element name="TControl.IsAnchorsStored.Result">
        <short/>
      </element>

      <element name="TControl.IsBiDiModeStored">
        <short>Implements the storage specifier for the BiDiMode property.</short>
        <descr/>
        <seealso>
          <link id="TControl.BiDiMode"/>
        </seealso>
      </element>
      <element name="TControl.IsBiDiModeStored.Result">
        <short/>
      </element>

      <element name="TControl.IsEnabledStored">
        <short>Implements the storage specifier for the Enabled property.</short>
        <descr/>
        <seealso>
          <link id="TControl.Enabled"/>
        </seealso>
      </element>
      <element name="TControl.IsEnabledStored.Result">
        <short/>
      </element>

      <element name="TControl.IsFontStored">
        <short>Implements the storage specifier for the Font property.</short>
        <descr/>
        <seealso>
          <link id="TControl.Font"/>
        </seealso>
      </element>
      <element name="TControl.IsFontStored.Result">
        <short/>
      </element>

      <element name="TControl.IsHintStored">
        <short>Implements the storage specifier for the Hint property.</short>
        <descr>
          <p>
            The return value is True when the property value is not supplied by an Action linked to the control. This occurs when an ActionLink has not been assigned for the control, or when the IsHintLinked property in the ActionLink is set to False.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Hint"/>
        </seealso>
      </element>
      <element name="TControl.IsHintStored.Result">
        <short>True when the property value is stored using LCL component streaming.</short>
      </element>

      <element name="TControl.IsHelpContextStored"/>
      <element name="TControl.IsHelpContextStored.Result"/>

      <element name="TControl.IsHelpKeyWordStored"/>
      <element name="TControl.IsHelpKeyWordStored.Result"/>

      <element name="TControl.IsShowHintStored"/>
      <element name="TControl.IsShowHintStored.Result"/>

      <element name="TControl.IsVisibleStored"/>
      <element name="TControl.IsVisibleStored.Result"/>

      <element name="TControl.DoBeforeMouseMessage">
        <short>Generate MouseEnter and MouseLeave events.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.DoConstrainedResize">
        <short>Adjust the intended (given) Bounds, according to Constraints.</short>
        <descr/>
        <seealso>
          <link id="TControl.Constraints"/>
          <link id="TControl.ConstrainedResize"/>
        </seealso>
      </element>
      <element name="TControl.DoConstrainedResize.NewLeft">
        <short/>
      </element>
      <element name="TControl.DoConstrainedResize.NewTop">
        <short/>
      </element>
      <element name="TControl.DoConstrainedResize.NewWidth">
        <short/>
      </element>
      <element name="TControl.DoConstrainedResize.NewHeight">
        <short/>
      </element>

      <element name="TControl.DoMouseDown">
        <short>
          Performs the message handler for mouse button down messages; calls the MouseDown handler.
        </short>
        <descr/>
        <seealso>
          <link id="TControl.DoMouseUp"/>
          <link id="TControl.MouseDown"/>
          <link id="TControl.OnMouseDown"/>
        </seealso>
      </element>
      <element name="TControl.DoMouseDown.Message">
        <short/>
      </element>
      <element name="TControl.DoMouseDown.Button">
        <short/>
      </element>
      <element name="TControl.DoMouseDown.Shift">
        <short/>
      </element>

      <element name="TControl.DoMouseUp">
        <short>
          Performs the message handler for mouse button up messages; calls the MouseUp handler.
        </short>
        <descr/>
        <seealso>
          <link id="TControl.DoMouseDown"/>
          <link id="TControl.MouseUp"/>
          <link id="TControl.OnMouseUp"/>
        </seealso>
      </element>
      <element name="TControl.DoMouseUp.Message">
        <short/>
      </element>
      <element name="TControl.DoMouseUp.Button">
        <short/>
      </element>

      <element name="TControl.SetAccessibleDescription">
         <short>Sets the value for the AccessibleDescription property.</short>
        <descr/>
        <seealso>
          <link id="TControl.AccessibleDescription"/>
        </seealso>
      </element>
      <element name="TControl.SetAccessibleDescription.AValue">
        <short>New value for the property.</short>
      </element>

      <element name="TControl.SetAccessibleValue">
        <short>Sets the value for the AccessibleValue property.</short>
        <descr/>
        <seealso>
          <link id="TControl.AccessibleValue"/>
        </seealso>
      </element>
      <element name="TControl.SetAccessibleValue.AValue">
        <short>New value for the property.</short>
      </element>

      <element name="TControl. SetAccessibleRole">
        <short>Sets the value for the AccessibleRole property.</short>
        <descr/>
        <seealso>
          <link id="TControl.AccessibleRole"/>
        </seealso>
      </element>
      <element name="TControl. SetAccessibleRole.AValue">
        <short>New value for the property.</short>
      </element>

      <element name="TControl.SetAnchorSide">
        <short>Sets the value for the indexed AnchorSide property.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.SetAnchorSide.Kind">
       <short>Index for the element updated in the method.</short>
      </element>
      <element name="TControl.SetAnchorSide.AValue">
       <short>New value for the AnchorSize property.</short>
      </element>

      <element name="TControl.SetBorderSpacing">
        <short>Sets the value for the BorderSpacing property.</short>
        <descr/>
        <seealso>
          <link id="TControl.BorderSpacing"/>
        </seealso>
      </element>
      <element name="TControl.SetBorderSpacing.AValue">
       <short>New value for the BorderSpacing property.</short>
      </element>

      <element link="#lcl.controls.TControl.BoundsRect" name="TControl.SetBoundsRect"/>
      <element name="TControl.SetBoundsRect.ARect">
        <short/>
      </element>

      <element link="#lcl.controls.TControl.BoundsRectForNewParent" name="TControl.SetBoundsRectForNewParent"/>
      <element name="TControl.SetBoundsRectForNewParent.AValue">
       <short/>
      </element>

      <element link="#lcl.controls.TControl.ClientHeight" name="TControl.SetClientHeight"/>
      <element name="TControl.SetClientHeight.Value">
       <short/>
      </element>

      <element link="#lcl.controls.TControl.ClientRect" name="TControl.SetClientSize"/>
      <element name="TControl.SetClientSize.Value">
       <short/>
      </element>

      <element link="#lcl.controls.TControl.ClientWidth" name="TControl.SetClientWidth"/>
      <element name="TControl.SetClientWidth.Value">
       <short/>
      </element>

      <element name="TControl.SetConstraints">
        <short>Sets the value for the Constraints property.</short>
        <descr/>
        <seealso>
          <link id="TControl.Constraints"/>
        </seealso>
      </element>
      <element name="TControl.SetConstraints.Value">
       <short>New value for the Constraints property.</short>
      </element>

      <element link="#lcl.controls.TControl.DesktopFont" name="TControl.SetDesktopFont"/>
      <element name="TControl.SetDesktopFont.AValue">
       <short/>
      </element>

      <element link="#lcl.controls.TControl.DragCursor" name="TControl.SetDragCursor"/>
      <element name="TControl.SetDragCursor.AValue">
       <short/>
      </element>

      <element link="#lcl.controls.TControl.Font" name="TControl.SetFont"/>
      <element name="TControl.SetFont.Value">
       <short/>
      </element>

      <element link="#lcl.controls.TControl.Height" name="TControl.SetHeight"/>
      <element name="TControl.SetHeight.Value">
       <short/>
      </element>

      <element link="#lcl.controls.TControl.HelpContext" name="TControl.SetHelpContext"/>
      <element name="TControl.SetHelpContext.AValue">
       <short/>
      </element>

      <element link="#lcl.controls.TControl.HelpKeyword" name="TControl.SetHelpKeyword"/>
      <element name="TControl.SetHelpKeyword.AValue">
       <short/>
      </element>

      <element link="#lcl.controls.TControl.HostDockSite" name="TControl.SetHostDockSite"/>
      <element name="TControl.SetHostDockSite.AValue">
       <short/>
      </element>

      <element link="#lcl.controls.TControl.Left" name="TControl.SetLeft"/>
      <element name="TControl.SetLeft.Value">
       <short/>
      </element>

      <element link="#lcl.controls.TControl.MouseCapture" name="TControl.SetMouseCapture"/>
      <element name="TControl.SetMouseCapture.Value">
       <short/>
      </element>

      <element link="#lcl.controls.TControl.ParentShowHint" name="TControl.SetParentShowHint"/>
      <element name="TControl.SetParentShowHint.Value">
       <short/>
      </element>

      <element link="#lcl.controls.TControl.ParentColor" name="TControl.SetParentColor"/>
      <element name="TControl.SetParentColor.Value">
       <short/>
      </element>

      <element link="#lcl.controls.TControl.ParentFont" name="TControl.SetParentFont"/>
      <element name="TControl.SetParentFont.Value">
        <short/>
      </element>

      <element link="#lcl.controls.TControl.PopupMenu" name="TControl.SetPopupMenu"/>
      <element name="TControl.SetPopupMenu.Value">
        <short/>
      </element>

      <element link="#lcl.controls.TControl.ShowHint" name="TControl.SetShowHint"/>
      <element name="TControl.SetShowHint.Value">
        <short/>
      </element>

      <element name="TControl.SetText">
        <short>Sets the value for the Text property.</short>
        <descr>
          Uses the RealSetText method instead of SetTextBuf, when possible.
        </descr>
        <seealso>
          <link id="TControl.Text"/>
          <link id="TControl.RealSetText"/>
          <link id="TControl.SetTextBuf"/>
        </seealso>
      </element>
      <element name="TControl.SetText.Value">
        <short>The new value for the Text property.</short>
      </element>

      <element link="#lcl.controls.TControl.Top" name="TControl.SetTop"/>
      <element name="TControl.SetTop.Value">
        <short/>
      </element>

      <element link="#lcl.controls.TControl.Width" name="TControl.SetWidth"/>
      <element name="TControl.SetWidth.Value">
        <short/>
      </element>

      <element name="TControl.FAccessibleObject">
        <short>Member with the accessibility object for the control.</short>
      </element>
      <element name="TControl.FControlState">
        <short>Member with the value for the ControlState property.</short>
      </element>
      <element name="TControl.FCursor">
        <short>Member with the value for the Cursor property.</short>
      </element>

      <element name="TControl.WSRegisterClass" link="#lcl.lclclasses.TLCLComponent.WSRegisterClass"/>

      <element name="TControl.GetCursor">
        <short>Gets the value for the Cursor property.</short>
        <descr/>
        <seealso>
          <link id="TControl.Cursor"/>
        </seealso>
      </element>
      <element name="TControl.GetCursor.Result">
        <short>Value for the Cursor property.</short>
      </element>

      <element name="TControl.SetCursor">
        <short>Sets the value for the Cursor property.</short>
        <descr>
          <p>
            Calls Perform to send a CM_CURSORCHANGED control message to the processing loop when the member for the property is updated.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Cursor"/>
          <link id="TControl.Perform"/>
          <link id="TControl.CMCursorChanged"/>
        </seealso>
      </element>
      <element name="TControl.SetCursor.Value">
        <short>New value for the Cursor property.</short>
      </element>

      <element name="TControl.SetVisible">
        <short>Sets the value for the Visible property.</short>
        <descr>
          <p>
            Changing the value for the property causes additional actions to be performed.
          </p>
          <p>
            VisibleChanging is called to notify event handler routines for the control. The Perform method is used to send a CM_VISIBLECHANGED control message to the processing loop for the control.
          </p>
          <p>
            Preferred width and  height values in the control, and its children (when derived from TWinControl), are invalidated. To minimize the overhead from the DoAutoSize method, auto-sizing is temporarily disabled when the control is updated. The AdjustSize method is called to perform the equivalent of DoAutoSize without the extra overhead of getting the preferred sizes from the widgetset class. If the control is not Visible but has a Parent control, the AdjustSize method in Parent is called.
          </p>
          <p>
            VisibleChanged is called to notify event handler routines for the control.
          </p>
          <p>
            SetVisible ensures that ControlState is updated to include the value csVisibleSetInLoading when csLoading is included in the ComponentState property.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Visible"/>
        </seealso>
      </element>
      <element name="TControl.SetVisible.Value">
        <short>New value for the Visible property.</short>
      </element>

      <element name="TControl.DoOnParentHandleDestruction">
        <short>Performs actions needed when the handle for the parent control is freed.</short>
        <descr>
          <p>
            Has an empty implementation in TControl, and must be implement in descendent classes.
          </p>
        </descr>
        <seealso>
          <link id="TGraphicControl.DoOnParentHandleDestruction"/>
        </seealso>
      </element>

      <element name="TControl.DoAutoSize">
        <short>For internal use only; call AdjustSize instead.</short>
        <descr>
          <remark>
            IMPORTANT: Many Delphi controls override this method and many call this method directly after setting some properties.
          </remark>
          <p>
            During handle creation not all interfaces can create complete Device Contexts which are needed to calculate things like text size. That's why you should always call <link id="#lcl.controls.TControl.AdjustSize">AdjustSize</link> instead of <var>DoAutoSize</var>.
          </p>
        </descr>
        <seealso>
          <link id="TControl.AutoSize"/>
          <link id="TControl.AdjustSize"/>
        </seealso>
      </element>

      <element name="TControl.DoAllAutoSize">
        <short>Resizes and aligns the control and all of it children.</short>
        <descr>
          <p>
            No actions are performed in the method when AutoSizingAll is True, or when the control is not derived from TWinControl.
          </p>
          <p>
            Calls DoAutoSize while the control includes cfAutoSizeNeeded in its ControlFlags property.
            Called from the AdjustSize and EnableAutoSizing methods.
          </p>
        </descr>
        <errors>
          Raises an EInvalidOperation exception if Parent has not been assigned for the control.
        </errors>
        <seealso>
          <link id="TControl.Parent"/>
          <link id="TControl.AutoSizingAll"/>
          <link id="TControl.AutoSizeDelayed"/>
          <link id="TWinControl.Controls"/>
        </seealso>
      </element>

      <element name="TControl.BeginAutoSizing">
        <short>Sets AutoSizing to True; used to prevent loops.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.EndAutoSizing">
        <short>End of the auto-sizing process, resets AutoSizing to False.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.AnchorSideChanged">
        <short>Request further processing after an anchor side was changed.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.AnchorSideChanged.TheAnchorSide">
        <short>Ignored.</short>
      </element>

      <element name="TControl.ForeignAnchorSideChanged">
        <short>
          Requests further processing after an anchor side has changed, that anchors another control to this one.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.ForeignAnchorSideChanged.TheAnchorSide">
        <short/>
      </element>
      <element name="TControl.ForeignAnchorSideChanged.Operation">
        <short/>
      </element>

      <element name="TControl.SetAlign">
        <short>Sets the value for the Align property.</short>
        <descr>
          <p>
            Changing the value for the property causes additional actions to be performed.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Align"/>
        </seealso>
      </element>
      <element name="TControl.SetAlign.Value">
        <short>New value for the Align property.</short>
      </element>

      <element name="TControl.SetAnchors">
        <short>Sets the value for the Anchors property.</short>
        <descr>
          <!-- TODO:
            Calls FixCenterAnchoring for each of the new anchor side values.
            Calls UpdateAnchorRules.
            Calls AdjustSize.
          -->
        </descr>
        <seealso>
          <link id="TControl.Anchors"/>
        </seealso>
      </element>
      <element name="TControl.SetAnchors.AValue">
        <short>New value for the Anchors property.</short>
      </element>

      <element name="TControl.SetAutoSize">
        <short>Sets the value for the AutoSize property.</short>
        <descr>
          <p>
            Calls AdjustSize when the property is enabled.
          </p>
        </descr>
        <seealso>
          <link id="TControl.AdjustSize"/>
          <link id="TControl.AutoSize"/>
        </seealso>
      </element>
      <element name="TControl.SetAutoSize.Value">
        <short>New value for the AutoSize property.</short>
      </element>

      <element name="TControl.BoundsChanged">
        <short>
          Called when the Bounds of the control have been changed; override as required.
        </short>
        <descr>
          Notifications can be performed in this method.
        </descr>
      </element>

      <element name="TControl.CreateControlBorderSpacing">
        <short>
          Creates the default BorderSpacing object instance for the class.
        </short>
        <descr>
          <p>
            Allocates the class instance used for the BorderSpacing property. Can be overridden in descendent controls to use the type or default values needed for the class instance.
          </p>
        </descr>
        <seealso>
          <link id="TControlBorderSpacing"/>
          <link id="TControl.BorderSpacing"/>
        </seealso>
      </element>
      <element name="TControl.CreateControlBorderSpacing.Result">
        <short>The class instance created in the method.</short>
      </element>

      <element name="TControl.DoConstraintsChange">
        <short>Performs actions needed when value(s) in Constraints have been changed.</short>
        <descr>
          <p>
            DoConstraintsChange calls AdjustSize to ensure that the control and any children are sized and positioned to  the new Constraints for the control. The method is overridden in descendent classes, like TWinControl, to perform actions needed for the class instance.
          </p>
          <p>
            Called from the TSizeConstraints.Change method before it signals the OnChange event handler in the constraints class instance.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.DoConstraintsChange"/>
        </seealso>
      </element>
      <element name="TControl.DoConstraintsChange.Sender">
        <short>Not used in the method.</short>
      </element>

      <element name="TControl.DoBorderSpacingChange">
        <short>Reacts on a change in the control's border spacing.</short>
      </element>
      <element name="TControl.DoBorderSpacingChange.Sender">
        <short/>
      </element>
      <element name="TControl.DoBorderSpacingChange.InnerSpaceChanged">
        <short/>
      </element>

      <element name="TControl.IsBorderSpacingInnerBorderStored">
        <short>Checks for a defined (non-zero) value in BorderSpacing.InnerBorder.</short>
      </element>
      <element name="TControl.IsBorderSpacingInnerBorderStored.Result">
        <short>True when InnerBorder has been assigned and must be applied to the control.</short>
      </element>

       <element name="TControl.IsCaptionStored">
         <short>Implements the storage specifier for the Caption property.</short>
         <descr>
           <p>
             Returns True if ActionLink has not been assigned, or its IsCaptionLinked property is set to False.
           </p>
         </descr>
         <seealso/>
       </element>
       <element name="TControl.IsCaptionStored.Result">
         <short>
           Returns True if ActionLink has not been assigned, or its IsCaptionLinked property is set to False.
         </short>
       </element>

      <element name="TControl.SendMoveSizeMessages">
        <short>
          Sends Move and Size messages through the LCL message paths.
        </short>
        <descr>
          <p>
            Overridden in TWinControl; in TControl it's a NOP. This method simulates the VCL behavior and has no real effect.
          </p>
        </descr>
      </element>
      <element name="TControl.SendMoveSizeMessages.SizeChanged">
        <short/>
      </element>
      <element name="TControl.SendMoveSizeMessages.PosChanged">
        <short/>
      </element>

      <element name="TControl.ConstrainedResize">
        <short>Signals  the OnConstrainedResize handler.</short>
        <seealso>
          <link id="TControl.OnConstrainedResize"/>
        </seealso>
      </element>
      <element name="TControl.ConstrainedResize.MinWidth">
        <short/>
      </element>
      <element name="TControl.ConstrainedResize.MinHeight">
        <short/>
      </element>
      <element name="TControl.ConstrainedResize.MaxWidth">
        <short/>
      </element>
      <element name="TControl.ConstrainedResize.MaxHeight">
        <short/>
      </element>

      <element name="TControl.CalculatePreferredSize">
        <short>
          Override this method to return the preferred height and width for the control.
        </short>
        <descr>
          <p>
            Calculates the preferred width and height for a control, which is used by the LCL auto-sizing algorithms as the default size. Negative or zero (0) values are treated as undefined and the LCL uses other sizes instead.
          </p>
          <p>
            <var>TWinControl</var> overrides this and asks the interface for theme dependent values. See <link id="TWinControl.CalculatePreferredSize"/> for more information.
          </p>
          <p>
            When WithThemeSpace contains True, space is added for stacking.
          </p>
          <p>
            For example: <var>TRadioButton</var> has a minimum size. But for stacking multiple TRadioButtons there should be some space around the controls. This space is theme-dependent, so the parameter is passed to the widgetset.
          </p>
        </descr>
      </element>
      <element name="TControl.CalculatePreferredSize.PreferredWidth">
        <short>Set this argument to the preferred width.</short>
      </element>
      <element name="TControl.CalculatePreferredSize.PreferredHeight">
        <short>Set this argument to the preferred height.</short>
      </element>
      <element name="TControl.CalculatePreferredSize.WithThemeSpace">
        <short>True when space around stacked controls should be added.</short>
      </element>

      <element name="TControl.DoOnResize">
        <short>Signals OnResize event handlers for the control.</short>
        <descr/>
        <seealso>
          <link id="TControl.OnResize"/>
          <link id="TControl.DoCallNotifyHandler"/>
          <link id="TControlHandlerType"/>
        </seealso>
      </element>

      <element name="TControl.DoOnChangeBounds">
        <short>
          Signals OnChangeBounds event handlers for the control.
        </short>
        <descr/>
        <seealso>
          <link id="TControl.OnChangeBounds"/>
          <link id="TControl.DoCallNotifyHandler"/>
          <link id="TControlHandlerType"/>
        </seealso>
      </element>

      <element name="TControl.CheckOnChangeBounds">
        <short>
          Checks for changes and calls <link id="#lcl.Controls.TControl.DoOnChangeBounds">DoOnChangeBounds</link> if needed.
        </short>
        <descr>
          <p>
            Maintains internal members used to track the last bounds rectangle and client size before DoOnChangeBounds is called. Called from the LoadedAll and ChangeBounds methods.
          </p>
        </descr>
        <seealso>
          <link id="TControl.LoadedAll"/>
          <link id="TControl.ChangeBounds"/>
          <link id="TControl.DoOnChangeBounds"/>
        </seealso>
      </element>

      <element name="TControl.Resize">
        <short>Checks for changes and calls DoOnResize if needed.</short>
        <descr>
          <p>
            No actions are performed in the method at design-time, during LCL component streaming, or when AutoSizeDelayed is set to True.
          </p>
          <p>
            Resize updates internal members used to track the current values in the Width, Height, ClientWidth, and ClientHeight properties. It calls DoOnResize to signal OnResize event handler(s) (when assigned) for the control.
          </p>
        </descr>
        <seealso>
          <link id="TControl.DoOnResize"/>
          <link id="TControl.OnResize"/>
          <link id="TControl.DoCallNotifyHandler"/>
          <link id="TControlHandlerType"/>
        </seealso>
      </element>

      <element name="TControl.RequestAlign">
        <short>
          Smart calling of <var>Parent.AlignControls</var> (very indirectly).
        </short>
        <seealso>
          <link id="TWinControl.AlignControls"/>
        </seealso>
      </element>

      <element name="TControl.UpdateAnchorRules">
        <short>Update the rules for anchoring the control.</short>
      </element>

      <element name="TControl.ChangeBounds">
        <short>
          Sets the bounds (left, top, height, width) optionally the BaseBounds of the control.
        </short>
        <descr>
          <p>
            ChangeBounds is called whenever the position or size of the control is set, either via the properties or by the layout engine in the LCL.
          </p>
          <p>
            SetBounds calls ChangeBounds internally with KeepBase set to False, while the LCL layout engine calls it with KeepBase set to True.
          </p>
          <p>
            Override this for code that might change the preferred size or resizes other controls.
          </p>
          <p>
            You can call this function in your custom controls. Keep in mind that the given aLeft, aTop, aWidth, aHeight might not be valid and will be changed by the LCL before applied.
          </p>
        </descr>
      </element>
      <element name="TControl.ChangeBounds.ALeft">
        <short/>
      </element>
      <element name="TControl.ChangeBounds.ATop">
        <short/>
      </element>
      <element name="TControl.ChangeBounds.AWidth">
        <short/>
      </element>
      <element name="TControl.ChangeBounds.AHeight">
        <short/>
      </element>
      <element name="TControl.ChangeBounds.KeepBase">
        <short>True when the BaseBounds should not be modified.</short>
      </element>

      <element name="TControl.DoSetBounds">
        <short>Internal function to set the control's bounds (Left, Top, Height, Width).</short>
        <descr>
          <p>
            DoSetBounds is a low level function to set the private variables FLeft, FTop, FWidth, FHeight. Do not call this function, only the LCL calls it.
          </p>
          <p>
            It also updates FClientWidth and FClientHeight accordingly.
          </p>
          <p>
            Override this to update the content layout of the control, for example scroll bars. As always: do not paint here, but call Invalidate and paint in OnPaint or override Paint.
          </p>
        </descr>
      </element>
      <element name="TControl.DoSetBounds.ALeft">
        <short/>
      </element>
      <element name="TControl.DoSetBounds.ATop">
        <short/>
      </element>
      <element name="TControl.DoSetBounds.AWidth">
        <short/>
      </element>
      <element name="TControl.DoSetBounds.AHeight">
        <short/>
      </element>

      <element name="TControl.ScaleConstraints">
        <short>Scales the minimum and maximum Width and Height.</short>
        <descr>
          <p>
            ScaleConstraints is called from the ChangeScale method;  never call it directly. Multiplier and Divider contain the values passed as arguments to the ChangeScale method.
          </p>
        </descr>
        <seealso>
          <link id="TControl.ChangeScale"/>
          <link id="TWinControl.ScaleBy"/>
        </seealso>
      </element>
      <element name="TControl.ScaleConstraints.Multiplier">
        <short>Multiplier used to derive the scaling factor for the control constraints.</short>
      </element>
      <element name="TControl.ScaleConstraints.Divider">
        <short>Divisor used to derive the scaling factor for the control constraints.</short>
      </element>

      <element name="TControl.ChangeScale">
        <short>
          Applies scaling (multiplier and divider) to the bounds coordinates, constraints, and Font in a control.
        </short>
        <descr>
          <p>
            ChangeScale is amethod used to apply scaling, expressed by the Multiplier and Divider arguments, to size values in the control. These values include:
          </p>
          <ul>
            <li>
              The minimum and maximum heights and widths in Constraints (by calling ScaleContraints).
            </li>
            <li>
              The Font height (when ParentFont is not enabled).
            </li>
            <li>
              The bounds rectangle for the control (Left, Top, Bottom, and Right). If the control is the top-most form in a component hierarchy, the Top and Left values are not changed.
            </li>
          </ul>
          <p>
            ChangeScale calls the MulDiv routine in the <file>LCLType</file> unit to calculate the scaled numeric values. The results from the calculations are rounded and returned as an Integer type.
          </p>
          <p>
            No actions are performed in the method when Multiplier and Divider have the same value.
          </p>
          <p>
            ChangeScale can be overridden in descendent classes to perform any additional action needed for the class type.
          </p>
          <p>
            ChangeScale is called from the ScaleControls and ScaleBy methods in the TWinControl descendant.
          </p>
        </descr>
        <seealso>
          <link id="TControl.BaseBounds"/>
          <link id="TControl.BoundsRect"/>
          <link id="TControl.Font"/>
          <link id="TControl.ParentFont"/>
          <link id="TControl.ScaleConstraints"/>
          <link id="TWinControl.ScaleBy"/>
          <link id="TWinControl.ScaleControls"/>
          <link id="#lcl.lcltype.MulDiv">MulDiv</link>
        </seealso>
      </element>
      <element name="TControl.ChangeScale.Multiplier">
        <short>Multiplicand used to calculate the scaled numeric values.</short>
      </element>
      <element name="TControl.ChangeScale.Divider">
        <short>Divisor used to calculate the scaled numeric values.</short>
      </element>

      <element name="TControl.CanAutoSize">
        <short>
          Determines if auto-sizing is possible, and if so, gets the new width and height when enabled.
        </short>
        <descr>
          <p>
            Always returns True in TControl. The values in NewWidth and NewHeight are not updated in TControl. Override the method in descendent classes to return values as needed for the class type.
          </p>
        </descr>
      </element>
      <element name="TControl.CanAutoSize.Result">
        <short>TControl returns True.</short>
      </element>
      <element name="TControl.CanAutoSize.NewWidth">
        <short>Suggested width, can be adjusted in an overridden version.</short>
      </element>
      <element name="TControl.CanAutoSize.NewHeight">
        <short>Suggested height, can be adjusted in an overridden version.</short>
      </element>

      <element name="TControl.SetBiDiMode">
        <short>Sets the value for the BiDiMode property.</short>
        <descr>
        </descr>
        <seealso>
          <link id="TControl.BiDiMode"/>
        </seealso>
      </element>
      <element name="TControl.SetBiDiMode.AValue">
        <short>New value for the BiDiMode property.</short>
      </element>

      <element name="TControl.SetParentBiDiMode">
        <short>Sets the value for the ParentBiDiMode property.</short>
        <descr/>
        <seealso>
          <link id="TControl.ParentBiDiMode"/>
        </seealso>
      </element>
      <element name="TControl.SetParentBiDiMode.AValue">
        <short>New value for the ParentBiDiMode property.</short>
      </element>

      <element name="TControl.IsAParentAligning">
        <short>Determine if a parent control is involved in the alignment process.</short>
      </element>
      <element name="TControl.IsAParentAligning.Result">
        <short/>
      </element>

      <element name="TControl.GetClientOrigin">
        <short>Gets the value for the ClientOrigin property.</short>
        <descr/>
        <seealso>
          <link id="TControl.ClientOrigin"/>
        </seealso>
      </element>
      <element name="TControl.GetClientOrigin.Result">
        <short>Value for the ClientOrigin property.</short>
      </element>

      <element name="TControl.GetClientRect">
        <short>Gets the value for the ClientRect property.</short>
        <descr>
          <p>
            Returns the size for the visual client area in the control. For example, the inner size of a TGroupBox. For a TScrollBox it is the visual size, and not the logical size.
          </p>
          <p>
            The return value is a TRect instance with the Top and Left members set to 0, and the Height and Width members set to the corresponding property values for the control.
          </p>
        </descr>
        <seealso>
          <link id="#lcl.controls.TControl.ClientRect">TControl.ClientRect</link>
        </seealso>
      </element>
      <element name="TControl.GetClientRect.Result">
        <short>Value for the ClientRect property.</short>
      </element>

      <element name="TControl.GetLogicalClientRect">
        <short>Logical client area, can be bigger than the visible client area.</short>
        <descr>
          A <link id="Forms.TScrollingWinControl"/> has a logical client area, of which only a portion can be visible. The origin always is (0,0), regardless of an ScrollOffset.
        </descr>
        <seealso>
          <link id="TControl.BoundsRect"/>
          <link id="TControl.ClientRect"/>
          <link id="TControl.GetScrolledClientRect"/>
        </seealso>
      </element>
      <element name="TControl.GetLogicalClientRect.Result">
        <short>TControl returns the ClientRect.</short>
      </element>

      <element name="TControl.GetScrolledClientRect">
        <short>Get the visible part of the logical client area.</short>
        <descr>
          <p>
            Includes the ScrollOffset in a TScrollingWinControl Parent.
          </p>
          <p>
            For TControl: When the Parent is a TScrollingWinControl, the ClientRect is offset by its ScrollOffset. This Rect can be intersected with the visible ClientArea of the Parent, to get the actual visible part of the control.
          </p>
          <p>
            For TWinControl: The visible ClientRect is offset by ScrollOffset, to reflect the visible part of the logical ClientRect.
          </p>
        </descr>
        <seealso>
          <link id="TControl.ClientRect"/>
          <link id="TControl.GetScrolledClientRect"/>
        </seealso>
      </element>
      <element name="TControl.GetScrolledClientRect.Result">
        <short>The scrolled ClientRect (TopLeft, BottomRight).
        </short>
      </element>

      <element name="TControl.GetClientScrollOffset">
        <short>
          Returns the offset of the scrolled client area (in a scrolling TWinControl).
        </short>
        <descr>
          The overridden method may fail when the TScrollingWinControl has only one scrollbar.
        </descr>
        <seealso>
          <link id="TControl.GetScrolledClientRect"/>
          <link id="#lcl.forms.TScrollingWinControl.GetClientScrollOffset">
            TScrollingWinControl.GetClientScrollOffset</link>
        </seealso>
      </element>
      <element name="TControl.GetClientScrollOffset.Result">
        <short>
          The X and Y offsets of the visible client area, equal to the scrollbar positions.
        </short>
      </element>

      <element name="TControl.GetControlOrigin">
        <short>
          Gets the value for the ControlOrigin property.
        </short>
        <descr>
          Returns the origin (top left pixel) of the control, in screen coordinates.
        </descr>
        <seealso>
          <link id="TControl.ControlOrigin"/>
        </seealso>
      </element>
      <element name="TControl.GetControlOrigin.Result">
        <short>Value for the ControlOrigin property.</short>
      </element>

      <element name="TControl.IsClientHeightStored">
        <short>Implements the storage specifier for the ClientHeight property.</short>
        <descr/>
        <seealso>
          <link id="TControl.ClientHeight"/>
        </seealso>
      </element>
      <element name="TControl.IsClientHeightStored.Result">
        <short>True if the value for ClientHeight is stored using LCL component streaming.</short>
      </element>

      <element name="TControl.IsClientWidthStored">
        <short>Implements the storage specifier for the ClientWidth property.</short>
        <descr/>
        <seealso>
          <link id="TControl.ClientWidth"/>
        </seealso>
      </element>
      <element name="TControl.IsClientWidthStored.Result">
        <short>True if the property is stored using LCL component streaming.</short>
      </element>

      <element name="TControl.WidthIsAnchored">
        <short>True when both the control's left and right side are anchored.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.WidthIsAnchored.Result">
        <short>True if the Width varies with the Parent.Width.</short>
      </element>

      <element name="TControl.HeightIsAnchored">
        <short>True when both the control's top and bottom side are anchored.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.HeightIsAnchored.Result">
        <short>True if the Height varies with the Parent.Height.</short>
      </element>

      <element name="TControl.AutoSizing">
        <short>True while auto-sizing is in progress.</short>
      </element>

      <element name="TControl.AutoSizingAll">
        <short>Flag to prevent recursive AutoSizing (in DoAllAutoSize).</short>
        <descr>
          By default Parent.AutoSizingAll is read, because a mere TControl cannot have child controls.
        </descr>
        <seealso/>
      </element>

      <element name="TControl.AutoSizingLockCount">
        <short>Internal counter, increased/decreased by DisableAutoSizing/EnableAutoSizing.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.WMCancelMode">
        <short>
          Handles a LM_CANCELMODE message for the control.
        </short>
        <descr>
          <p>
            Calls the SetCaptureControl routine to clear the value in the CaptureControl variable.
          </p>
        </descr>
      </element>
      <element name="TControl.WMCancelMode.Message">
        <short>Message handled in the method.</short>
      </element>

      <element name="TControl.WMContextMenu">
        <short>
          Handles a LM_CONTEXTMENU message for the control.
        </short>
        <descr>
          <p>
            No actions are performed in the method at design-time, or when the result code in Message has non-zero value.
          </p>
          <p>
            Calls DoContextPopup to signal the OnContextPopup event handler (when assigned). No additional actions are performed in the method if the context menu was displayed and executed in the OnContextPopup event handler.
          </p>
          <p>
            Otherwise, the TPopupMenu instance in the PopupMenu property is displayed and executed by calling its Popup method.
          </p>
          <p>
            The result code in Message is set to 1 if the context menu was displayed and executed in the method.
          </p>
        </descr>
        <seealso>
          <link id="TControl.PopupMenu"/>
          <link id="TControl.DoContextPopup"/>
          <link id="TControl.OnContextPopup"/>
          <link id="#lcl.menus.TPopupMenu">TPopupMenu</link>
        </seealso>
      </element>
      <element name="TControl.WMContextMenu.Message">
        <short>Message examined and optionally handled in the method.</short>
      </element>

      <element name="TControl.WMLButtonDown">
        <short>
          Handles a LM_LBUTTONDOWN (left mouse button down) message for the control.
        </short>
        <descr>
          <p>
            Sets MouseCapture to True when enabled in the ControlStyle property and the left mouse button is included in CaptureMouseButtons. Includes csClicked in ControlState when click events have been enabled in the ControlStyle property.
          </p>
          <p>
            Calls the private DoMouseDown method to perform the mouse button event for the control, and to signal its OnMouseDown event handler (when assigned). No mouse down actions are performed when standard events are ignored by including csNoStdEvents in the ControlStyle property.
          </p>
        </descr>
        <seealso>
          <link id="TControl.ControlStyle"/>
          <link id="TControl.MouseCapture"/>
          <link id="TControl.CaptureMouseButtons"/>
          <link id="TControl.MouseDown"/>
          <link id="TControl.OnMouseDown"/>
          <link id="TMouseButton"/>
        </seealso>
      </element>
      <element name="TControl.WMLButtonDown.Message">
        <short>Message handled in the method.</short>
      </element>

      <element name="TControl.WMRButtonDown">
        <short>
          Handles a LM_RBUTTONDOWN (right mouse button down) message for the control.
        </short>
        <descr>
          <p>
            Sets MouseCapture to True when enabled in the ControlStyle property and the right mouse button is included in CaptureMouseButtons.
          </p>
          <p>
            Calls the private DoMouseDown method to perform the mouse button event for the control, and to signal its OnMouseDown event handler (when assigned). No mouse down actions are performed when standard events are ignored by including csNoStdEvents in the ControlStyle property.
          </p>
        </descr>
        <seealso>
          <link id="TControl.ControlStyle"/>
          <link id="TControl.MouseCapture"/>
          <link id="TControl.CaptureMouseButtons"/>
          <link id="TControl.MouseDown"/>
          <link id="TControl.OnMouseDown"/>
          <link id="TMouseButton"/>
        </seealso>
      </element>
      <element name="TControl.WMRButtonDown.Message">
        <short>Message handled in the method.</short>
      </element>

      <element name="TControl.WMMButtonDown">
        <short>
          Handles a LM_MBUTTONDOWN (middle mouse button down) message for the control.
        </short>
        <descr>
          <p>
            Sets MouseCapture to True when enabled in the ControlStyle property and the middle mouse button is included in CaptureMouseButtons.
          </p>
          <p>
            Calls the private DoMouseDown method to perform the mouse button event for the control, and to signal its OnMouseDown event handler (when assigned). No mouse down actions are performed when standard events are ignored by including csNoStdEvents in the ControlStyle property.
          </p>
        </descr>
        <seealso>
          <link id="TControl.ControlStyle"/>
          <link id="TControl.MouseCapture"/>
          <link id="TControl.CaptureMouseButtons"/>
          <link id="TControl.MouseDown"/>
          <link id="TControl.OnMouseDown"/>
          <link id="TMouseButton"/>
        </seealso>
      </element>
      <element name="TControl.WMMButtonDown.Message">
        <short>Message handled in the method.</short>
      </element>

      <element name="TControl.WMXButtonDown">
        <short>
          Handles a LM_XBUTTONDOWN (extra mouse button down) message for the control.
        </short>
        <descr>
          <p>
            Checks the Keys member in Message to determine whether the first or second extra mouse button is represented in the structure. No actions are performed in the method if Keys does not represent the mbExtra1 or mbExtra2 mouse button.
          </p>
          <p>
            Sets MouseCapture to True when enabled in the ControlStyle property and the mouse button is included in CaptureMouseButtons.
          </p>
          <p>
            Calls the private DoMouseDown method to perform the mouse button event for the control, and to signal its OnMouseDown event handler (when assigned). No mouse down actions are performed when standard events are ignored by including csNoStdEvents in the ControlStyle property.
          </p>
        </descr>
        <seealso>
          <link id="TControl.ControlStyle"/>
          <link id="TControl.MouseCapture"/>
          <link id="TControl.CaptureMouseButtons"/>
          <link id="TControl.MouseDown"/>
          <link id="TControl.OnMouseDown"/>
          <link id="TMouseButton"/>
        </seealso>
      </element>
      <element name="TControl.WMXButtonDown.Message">
        <short>Message examined and optionally handled in the method.</short>
      </element>

      <element name="TControl.WMLButtonDblClk">
        <short>
          Message handler for left mouse button double click.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.WMLButtonDblClk.Message">
        <short/>
      </element>

      <element name="TControl.WMRButtonDblClk">
        <short>
          Message handler for right mouse button double click.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.WMRButtonDblClk.Message">
        <short/>
      </element>

      <element name="TControl.WMMButtonDblClk">
        <short>
          Message handler for middle mouse button double click.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.WMMButtonDblClk.Message">
        <short/>
      </element>

      <element name="TControl.WMXButtonDblClk">
        <short>
          Message handler for extra mouse button double click.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.WMXButtonDblClk.Message">
        <short/>
      </element>

      <element name="TControl.WMLButtonTripleClk">
        <short>
          Message handler for left mouse button triple click.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.WMLButtonTripleClk.Message">
        <short/>
      </element>

      <element name="TControl.WMRButtonTripleClk">
        <short>
          Message handler for right mouse button triple click.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.WMRButtonTripleClk.Message">
        <short/>
      </element>

      <element name="TControl.WMMButtonTripleClk">
        <short>
          Message handler for middle mouse button triple click.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.WMMButtonTripleClk.Message">
        <short/>
      </element>

      <element name="TControl.WMXButtonTripleClk">
        <short>
          Message handler for extra mouse button triple click.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.WMXButtonTripleClk.Message">
        <short/>
      </element>

      <element name="TControl.WMLButtonQuadClk">
        <short>
          Message handler for left mouse button quadruple click.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.WMLButtonQuadClk.Message">
        <short/>
      </element>

      <element name="TControl.WMRButtonQuadClk">
        <short>
          Message handler for right mouse button quadruple click.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.WMRButtonQuadClk.Message">
        <short/>
      </element>

      <element name="TControl.WMMButtonQuadClk">
        <short>
          Message handler for middle mouse button quadruple click.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.WMMButtonQuadClk.Message">
        <short/>
      </element>

      <element name="TControl.WMXButtonQuadClk">
        <short>
          Message handler for extra mouse button quadruple click.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.WMXButtonQuadClk.Message">
        <short/>
      </element>

      <element name="TControl.WMXButtonup">
        <short>
          Message handler for extra mouse button going up.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.WMXButtonup.Message">
        <short/>
      </element>

      <element name="TControl.WMMouseMove">
        <short>
          Message handler for mouse moved.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.WMMouseMove.Message">
        <short/>
      </element>

      <element name="TControl.WMLButtonUp">
        <short>
          Message handler for left mouse button going up.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.WMLButtonUp.Message">
        <short/>
      </element>

      <element name="TControl.WMRButtonUp">
        <short>
          Message handler for right mouse button going up.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.WMRButtonUp.Message">
        <short/>
      </element>

      <element name="TControl.WMMButtonUp">
        <short>
          Message handler for middle mouse button going up.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.WMMButtonUp.Message">
        <short/>
      </element>
      <element name="TControl.WMMouseWheel">
        <short>Handles mouse wheel messages for the control.</short>
      </element>
      <element name="TControl.WMMouseWheel.Message">
        <short>Mouse wheel message handled in the method.</short>
      </element>
      <element name="TControl.WMMouseHWheel">
        <short>Handles horizontal mouse wheel messages for the control.</short>
      </element>
      <element name="TControl.WMMouseHWheel.Message">
        <short>Mouse wheel message handled in the method.</short>
      </element>
      <element name="TControl.WMMove">
        <short>
          Message handler for control moved.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.WMMove.Message">
        <short/>
      </element>

      <element name="TControl.WMSize">
        <short>
          Message handler for changed control size.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.WMSize.Message">
        <short/>
      </element>

      <element name="TControl.WMWindowPosChanged">
        <short>
          Message handler for changed control position.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.WMWindowPosChanged.Message">
        <short/>
      </element>

      <element name="TControl.CMChanged">
        <short>Handles CM_CHANGED control messages for the control.</short>
        <descr>
          <p>
            Calls the WindowProc method in the Parent control (when assigned) to handle the control message in Message.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TControl.CMChanged.Message">
        <short>Control message handled  in the method.</short>
      </element>

      <element name="TControl.LMCaptureChanged">
        <short>
          Message handler signalled when the mouse capture has been  changed.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.LMCaptureChanged.Message">
        <short/>
      </element>

      <element name="TControl.CMBiDiModeChanged">
        <short>
          Message handler for BiDi mode changed.
        </short>
      </element>
      <element name="TControl.CMBiDiModeChanged.Message">
        <short/>
      </element>

      <element name="TControl.CMSysFontChanged">
        <short>
          Message handler for changed system Font.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.CMSysFontChanged.Message">
        <short/>
      </element>

      <element name="TControl.CMEnabledChanged">
        <short>
          Message handler for changed Enabled state.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.CMEnabledChanged.Message">
        <short/>
      </element>

      <element name="TControl.CMHitTest">
        <short>
          Message handler for hit test.
        </short>
        <descr>
          The hit test handler determines the specific part of a control (caption, border...) at the given mouse position.
        </descr>
        <seealso/>
      </element>
      <element name="TControl.CMHitTest.Message">
        <short/>
      </element>

      <element name="TControl.CMMouseEnter">
        <short>
          Message handler for mouse entering the control.
        </short>
        <seealso/>
      </element>
      <element name="TControl.CMMouseEnter.Message">
        <short/>
      </element>

      <element name="TControl.CMMouseLeave">
        <short>
          Message handler for mouse leaving the control.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.CMMouseLeave.Message">
        <short/>
      </element>

      <element name="TControl.CMHintShow">
        <short>
          Message handler for hint display.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.CMHintShow.Message">
        <short/>
      </element>

      <element name="TControl.CMParentBiDiModeChanged">
        <short>Message handler for parent control's BiDi mode changed.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.CMParentBiDiModeChanged.Message">
        <short/>
      </element>

      <element name="TControl.CMParentFontChanged">
        <short>
          Message handler for changed parent Font.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.CMParentFontChanged.Message">
        <short/>
      </element>

      <element name="TControl.CMParentColorChanged">
        <short>
          Message handler for changed parent Color.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.CMParentColorChanged.Message">
        <short/>
      </element>

      <element name="TControl.CMParentShowHintChanged">
        <short>
          Message handler for changed parent ShowHint.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.CMParentShowHintChanged.Message">
        <short/>
      </element>

      <element name="TControl.CMVisibleChanged">
        <short>
          Message handler for changed visibility.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.CMVisibleChanged.Message">
        <short/>
      </element>

      <element name="TControl.CMTextChanged">
        <short>Message handler for control's Text changed.</short>
      </element>
      <element name="TControl.CMTextChanged.Message">
        <short/>
      </element>
      <element name="TControl.CMWantSpecialKey">
        <short>
          Message handler for special character (TAB...).
        </short>
      </element>
      <element name="TControl.CMWantSpecialKey.Message">
        <short/>
      </element>

      <element name="TControl.CMCursorChanged">
        <short>Handles the CM_CURSORCHANGED message for the control.</short>
        <descr>
          <p>
            At run-time, the SetTempCursor method is called to apply the temporary cursor shape in the Cursor property. No actions are performed in the method at design-time.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TControl.CMCursorChanged.Message">
        <short>Control message handled in the method.</short>
      </element>

      <element name="TControl.CalculateDockSizes">
        <short>Saves the docked and undocked extent of the control.</short>
        <descr>
          <p>
            In the floating state, it sets UndockWidth/Height to the current Width/Height. In docked state, it sets LRDockWidth/TBDockHeight to the current Width/Height.
          </p>
          <remark>
            Please note: Should save both in any case, independent from DockOrientation or host Align. Rationale: a DockManager will either ignore these values, or use them according to the <b><i>new</i></b> alignment. Without a DockManager both extents are required, because no (valid) alignment information applies.
          </remark>
        </descr>
      </element>

      <element name="TControl.CreateFloatingDockSite">
        <short>
          Create a floating dock site with a client area equal to the given screen coordinates.
        </short>
        <descr>
          The new dock site is owned by the control.
        </descr>
      </element>
      <element name="TControl.CreateFloatingDockSite.Result">
        <short>The dock site, can be <b>Nil</b> for a TWinControl that can float by itself.</short>
      </element>
      <element name="TControl.CreateFloatingDockSite.Bounds">
        <short>The bounds of the client area of the floating window.</short>
      </element>

      <element name="TControl.GetDockEdge">
        <short>Determine the side to which the dragged control shall be docked.</short>
      </element>
      <element name="TControl.GetDockEdge.Result">
        <short/>
      </element>
      <element name="TControl.GetDockEdge.MousePos">
        <short>Mouse position in client coordinates.</short>
      </element>

      <element name="TControl.GetDragImages">
        <short>Get the list of images usable during dragging.</short>
      </element>
      <element name="TControl.GetDragImages.Result">
        <short/>
      </element>

      <element name="TControl.GetFloating">
        <short>Determines whether the control is floating.</short>
        <descr>
          <p>
            Floating state is assumed when the control has a HostDockSite of FloatingDockSiteClass, and is the only docked client.
          </p>
        </descr>
      </element>
      <element name="TControl.GetFloating.Result">
        <short/>
      </element>

      <element name="TControl.GetFloatingDockSiteClass">
        <short>Returns the class for a floating host dock site.</short>
        <descr>
          <p>
            An instance of this class is created whenever a control shall float,
            but can not (or shall not) float by itself.
          </p>
          <p>
            Only TWinControls can float on the screen (with Parent=Nil), but not ordinary TControls.
          </p>
          <p>
            Since dockable forms are not supported by every platform, a dockable TWinControl may need a floating host which presents a docking handle to the user (e.g. a dock caption).
          </p>
        </descr>
        <seealso>
          <link id="TControl.CreateFloatingDockSite"/>
        </seealso>
      </element>
      <element name="TControl.GetFloatingDockSiteClass.Result">
        <short>The class of a floating host dock site for this control.</short>
      </element>

      <element name="TControl.BeforeDragStart">
        <short>Not implemented in TControl.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.BeginAutoDrag">
        <short>For internal use: user has started dragging the control.</short>
      </element>

      <element name="TControl.DoFloatMsg">
        <short>Handler called when the control starts floating.</short>
        <descr>
          <p>
            Since TControls cannot float for themselves, a FloatHost site is created and the control is docked into it.
          </p>
          <p>
            When the control already has a Parent (FloatHost site), the Parent's position and extent is adjusted to fit the DockRect as its ClientRect.
          </p>
        </descr>
      </element>
      <element name="TControl.DoFloatMsg.ADockSource">
        <short>The DockObject of the current drag-dock operation.</short>
      </element>

      <element name="TControl.DockTrackNoTarget">
        <short>Adjust the DockRect for floating state (no drop target under the mouse).</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.DockTrackNoTarget.Source">
        <short>The dragged DockObject, containing the DockRect to adjust.</short>
      </element>
      <element name="TControl.DockTrackNoTarget.X">
        <short>The mouse position, in screen coordinates.</short>
      </element>
      <element name="TControl.DockTrackNoTarget.Y">
        <short/>
      </element>

      <element name="TControl.DoDock">
        <short>
          Adjusts the control's position and extent for the new docksite.
        </short>
        <descr>
          <p>
            DoDock is an Internal method, called by Dock, to performs actions needed when a control is docked to a docksite.
          </p>
          <p>
            If NewDockSite=Nil, Parent is set to <b>Nil</b> (in preparation of floating the control).
            Otherwise ARect is ignored, and recomputed to fit approximately into the ClientRect of the NewDockSite.
          </p>
          <p>
            Finally the computed coordinates are stored, in BoundsRectForNewParent when the NewDockSite differs from Parent, else in BoundsRect.
          </p>
        </descr>
        <errors>
          A correct implementation should allow for computations in a derived class, and accept and handle the changed bounds without any further adjustments.
        </errors>
        <seealso/>
      </element>
      <element name="TControl.DoDock.NewDockSite">
        <short>The site where the control will be docked, or <b>Nil</b> when it becomes floating.</short>
      </element>
      <element name="TControl.DoDock.ARect">
        <short>The control's new Bounds, in screen coordinates when NewDockSite is Nil, else in client coordinates of NewDockSite.
        </short>
      </element>

      <element name="TControl.DoDragMsg">
        <short>
          Handler for a drag message, sent by the DragManager to the current target control.
        </short>
        <descr>
          <p>These messages can be sent while dragging:
          </p>
          <dl>
            <dt>dmFindTarget</dt>
            <dd>
              Request to determine the possible target control for an drop. A TControl returns itself, a TWinControl finds the child control closest to the mouse position.
            </dd>
            <dt>dmDragEnter, dmDragLeave, dmDragMove</dt>
            <dd>
              Notification of mouse moves. Invokes DragOver, or DockOver if docking. Result indicates acceptance of a drop.
            </dd>
            <dt>dmDragDrop</dt>
            <dd>
              The dragged object has been dropped onto this control. Invokes DragDrop, or DockDrop if docking.
            </dd>
          </dl>
          <p>
            The <var>Source</var> argument of the invoked methods is the DragDockObject when docking. If the DragObject has been AutoCreated, the dragged control is passed as the Source. Otherwise, the DragObject itself is passed as Source.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TControl.DoDragMsg.Result">
        <short>
          Contains the result for the Drag message.
        </short>
        <descr>
          <p>
            The Result member is polymorphic:
          </p>
          <p>
            For dmFindTarget, the result is a reference to the the target control. For dmDragDropm the result is zero (0). For other drag messages, the result indicates acceptance of the drop message.
          </p>
        </descr>
      </element>
      <element name="TControl.DoDragMsg.ADragMessage">
        <short>The task to perform.</short>
      </element>
      <element name="TControl.DoDragMsg.APosition">
        <short>The mouse position in <b>screen</b> coordinates.</short>
      </element>
      <element name="TControl.DoDragMsg.ADragObject">
        <short>The drag object.</short>
      </element>
      <element name="TControl.DoDragMsg.ATarget">
        <short>The drop target, <b>Nil</b> if none.</short>
      </element>
      <element name="TControl.DoDragMsg.ADocking">
        <short>Distinguishes between a drag-drop and drag-dock operation.</short>
      </element>

      <element name="TControl.DoEndDock">
        <short>
          Invokes the <link id="#lcl.Controls.TControl.OnEndDock">OnEndDock</link> handler.
        </short>
      </element>
      <element name="TControl.DoEndDock.Target">
        <short/>
      </element>
      <element name="TControl.DoEndDock.X">
        <short/>
      </element>
      <element name="TControl.DoEndDock.Y">
        <short/>
      </element>

      <element name="TControl.DoEndDrag">
        <short>
          Invokes the <link id="#lcl.Controls.TControl.OnEndDrag">OnEndDrag</link> handler.
        </short>
      </element>
      <element name="TControl.DoEndDrag.Target">
        <short/>
      </element>
      <element name="TControl.DoEndDrag.X">
        <short/>
      </element>
      <element name="TControl.DoEndDrag.Y">
        <short/>
      </element>

      <element name="TControl.DoStartDock">
        <short>
          Invokes the <link id="#lcl.Controls.TControl.OnStartDock">OnStartDock</link> handler.
        </short>
      </element>
      <element name="TControl.DoStartDock.DragObject">
        <short/>
      </element>

      <element name="TControl.DoStartDrag">
        <short>
          Invokes the <link id="#lcl.Controls.TControl.OnStartDrag">OnStartDrag</link> handler.
        </short>
      </element>
      <element name="TControl.DoStartDrag.DragObject">
        <short/>
      </element>

      <element name="TControl.DragCanceled">
        <short>Notifies the control of a cancelled drag.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.DragOver">
        <short>
          Called when an object is dragged over this control; Determines whether a drop is acceptable, using the OnDragOver handler.
        </short>
        <descr>
          <p>
            An OnDragOver handler is required, or any drop will be rejected (Accept becomes False).
          </p>
          <p>
            When an OnDragOver handler is installed, Accept is set to True and can be changed by the handler.
          </p>
          <remark>
            Please note: Source can be either a TDragObject, or the dragged control.
          </remark>
        </descr>
        <seealso>
          <link id="TControl.OnDragOver"/>
          <link id="TWinControl.DockOver"/>
        </seealso>
      </element>
      <element name="TControl.DragOver.Source">
        <short>The dragged object, a control or a DragObject.</short>
      </element>
      <element name="TControl.DragOver.X">
        <short>The mouse position in client coordinates.</short>
      </element>
      <element name="TControl.DragOver.Y">
        <short/>
      </element>
      <element name="TControl.DragOver.State">
        <short>State change flag (dsDragEnter, dsDragMove, dsDragLeave).</short>
      </element>
      <element name="TControl.DragOver.Accept">
        <short>Set to True when a drop is allowed.</short>
      </element>

      <element name="TControl.PositionDockRect">
        <short>Get the DockRect for an possible drop.</short>
        <descr>
          <p>
            Calls the <var>DockManager.PositionDockRect</var> in the target site, or <var>DragDockObject.AdjustDockRect</var> after moving the undocked control rectangle to the <var>DragPos</var>. AdjustDockRect takes the hotspot of the DockRect into account.
          </p>
        </descr>
        <seealso>
          <link id="TDragDockObject.AdjustDockRect"/>
        </seealso>
      </element>
      <element name="TControl.PositionDockRect.DragDockObject">
        <short/>
      </element>

      <element name="TControl.SetDragMode">
        <short>Sets the value for the DragMode property.</short>
        <descr/>
        <seealso>
          <link id="TControl.DragMode"/>
        </seealso>
      </element>
      <element name="TControl.SetDragMode.Value">
        <short>New value for the DragMode property.</short>
      </element>

      <element name="TControl.GetDefaultDockCaption">
        <short>Returns the string for the dock caption, by default the control's Name.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.GetDefaultDockCaption.Result">
        <short/>
      </element>

      <element name="TControl.Click">
        <short>
          Signals OnClick and/or executes the ActionLink when the control has been clicked.
        </short>
        <descr>
          <p>
            Performs actions needed when the control has been clicked using the mouse or its keyboard equivalent.
          </p>
          <p>
            Click uses the value in ActionLink (when assigned) to determine whether OnClick and / or Action are executed for the control.
          </p>
          <p>
            When ActionLink has been assigned, it is compared to the routine in the OnClick event handler (when assigned). When the routines differ, the OnCLick event handler is signalled. If an ActionLink exists, the Execute method in ActionLink is called as well.
          </p>
          <p>
            Neither OnClick nor the ActionLink are executed at design-time.
          </p>
        </descr>
        <seealso>
          <link id="TControl.OnClick"/>
          <link id="TControl.ActionLink"/>
          <link id="#rtl.classes.TBasicActionLink.Execute">TBasicActionLink.Execute</link>
        </seealso>
      </element>

      <element name="TControl.DblClick">
        <short>
          Signals the OnDblClick event handler (when assigned).
        </short>
        <descr/>
        <seealso>
          <link id="TControl.OnDblClick"/>
        </seealso>
      </element>

      <element name="TControl.TripleClick">
        <short>
          Signals the OnTripleClick event handler (when assigned).
        </short>
        <descr/>
        <seealso>
          <link id="TControl.OnTripleClick"/>
        </seealso>
      </element>

      <element name="TControl.QuadClick">
        <short>
          Signals the OnQuadClick event handler (when assigned).
        </short>
        <descr/>
        <seealso>
          <link id="TControl.OnQuadClick"/>
        </seealso>
      </element>

      <element name="TControl.GetMousePosFromMessage">
        <short>
          Converts the coordinates in the specified mouse message from SmallInt to LongInt values.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.GetMousePosFromMessage.Result">
        <short>TPoint instance with the LongInt values for the mouse cursor position.</short>
      </element>
      <element name="TControl.GetMousePosFromMessage.MessageMousePos">
        <short>TSmallPoint instance with the values converted in the method.</short>
      </element>

      <element name="TControl.MouseDown">
        <short>Handler for MouseDown events.</short>
        <descr>
          <p>
            Called by the <var>MouseDown</var> message handler. Handles Focus changes, and notifies the DragManager while dragging. Finally, it calls the <link id="TControl.OnMouseDown"/> handler.
          </p>
        </descr>
      </element>
      <element name="TControl.MouseDown.Button">
        <short>Which buttons are down.</short>
      </element>
      <element name="TControl.MouseDown.Shift">
        <short>Which of Ctrl, Shift or Alt keys are also pressed.</short>
      </element>
      <element name="TControl.MouseDown.X">
        <short>Horizontal Mouse position in <b>client</b> coordinates.</short>
      </element>
      <element name="TControl.MouseDown.Y">
        <short>Vertical Mouse position in <b>client</b> coordinates.</short>
      </element>

      <element name="TControl.MouseMove">
        <short>Handler for MouseMove events.</short>
        <descr>
          <p>
            Called by the <var>MouseMove</var> message handler. The DragManager is notified while the control is being dragged. Finally the <link id="#lcl.Controls.TControl.OnMouseMove">OnMouseMove</link> handler is invoked.
          </p>
        </descr>
      </element>
      <element name="TControl.MouseMove.Shift">
        <short>
          The currently pressed mouse buttons and modifier keys.
        </short>
      </element>
      <element name="TControl.MouseMove.X">
        <short>Horizontal Mouse position in <b>client</b> coordinates.</short>
      </element>
      <element name="TControl.MouseMove.Y">
        <short>Vertical Mouse position in <b>client</b> coordinates.</short>
      </element>

      <element name="TControl.MouseUp">
        <short>
          Invokes the <link id="#lcl.Controls.TControl.OnMouseUp">OnMouseUp</link> handler.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.MouseUp.Button">
        <short>The currently pressed modifier keys.</short>
      </element>
      <element name="TControl.MouseUp.Shift">
        <short>The currently pressed mouse buttons.</short>
      </element>
      <element name="TControl.MouseUp.X">
        <short>Horizontal Mouse position in <b>client</b> coordinates.</short>
      </element>
      <element name="TControl.MouseUp.Y">
        <short>Vertical Mouse position in <b>client</b> coordinates.</short>
      </element>

      <element name="TControl.MouseEnter">
        <short>
          Invokes the <link id="#lcl.Controls.TControl.OnMouseEnter">OnMouseEnter</link> handler.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.MouseLeave">
        <short>
          Invokes the <link id="#lcl.Controls.TControl.OnMouseLeave">OnMouseLeave</link> handler.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.DialogChar">
        <short>Performs actions needed to handle an accelerator key for the control.</short>
        <descr>
          <p>
            Always return False in TControl. The method is overridden in descendent classes to perform actions needed to handle an accelerator character in the Message argument.
          </p>
          <p>
            This method is called even if the control is disabled or hidden. Provided for Delphi VCL compatibility.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.DialogChar"/>
          <link id="TWinControl.SendDialogChar"/>
        </seealso>
      </element>
      <element name="TControl.DialogChar.Result">
        <short>True if the accelerator key in Message is handled by the control.</short>
      </element>
      <element name="TControl.DialogChar.Message">
        <short>TLMKey instance with the character code examined in the method.</short>
      </element>

      <element name="TControl.UpdateMouseCursor">
        <short>Changes the cursor shape to the value in the Cursor property.</short>
        <descr>
          <p>
            UpdateMouseCursor is a method used to change the cursor shape displayed when the mouse is hovered over the control. No actions are performed in the method at design-time, or when the screen cursor already has a shape other than crDefault.
          </p>
          <p>
            UpdateMouseCursor calls SetTempCursor to apply the value in the Cursor property to the Parent control.
          </p>
          <p>
            UpdateMouseCursor is called from WMMouseMove after the mouse position has been captured, and before the OnMouseMove event handler is signalled.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TControl.UpdateMouseCursor.X">
        <short>Not used in the method.</short>
      </element>
      <element name="TControl.UpdateMouseCursor.Y">
        <short>Not used in the method.</short>
      </element>

      <element name="TControl.Changed">
        <short>
          Performs actions needed when the value for the control has been changed.
        </short>
        <descr>
          <p>
            In TControl, Changed posts a CM_CHANGED control message to the message processing loop.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TControl.GetPalette">
        <short>
          Override <var>GetPalette</var> to return the handle of a color palette.
        </short>
        <descr>
          <p>
            Always returns 0 (zero) in TControl.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TControl.GetPalette.Result">
        <short>The Palette handle, zero (no Palette) by default.</short>
      </element>

      <element name="TControl.ChildClassAllowed">
        <short>
          Returns True if the specified class is allowed for children of this control.
        </short>
        <descr>
          <p>
            Always returns False in TControl. It is overridden in descendent classes to check whether the class reference in ChildClass is allowed for the control.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.ChildClassAllowed"/>
        </seealso>
      </element>
      <element name="TControl.ChildClassAllowed.Result">
        <short>True when the class is allowed as a child control.</short>
      </element>
      <element name="TControl.ChildClassAllowed.ChildClass">
        <short>The class type for the child control.</short>
      </element>

      <element name="TControl.ReadState">
        <short>Updates control flags and reads the data for the component.</short>
        <descr/>
        <seealso>
          <link id="#rtl.classes.TComponent">TComponent</link>
        </seealso>
      </element>
      <element name="TControl.ReadState.Reader">
        <short>TReader instance used to read the component data. </short>
      </element>

      <element name="TControl.Loaded">
        <short>Performs actions needed when LCL component streaming has been completed.</short>
        <descr>
          <p>
            Calls the inherited method on entry.
          </p>
          <p>
            Ensures that values for Width and Height are available in the Bounds rectangle for the control. Explicit values for Width and Height are not always available in the values loaded using LCL component streaming. When this condition is indicated in the control flags, the ClientWidth and ClientHeight loaded from the resource stream are used in the Bounds for the control.
          </p>
          <p>
            Ensures that values for Color, Font, BiDiMode, and ShowHint are set to values in the Parent control when enabled in the ParentColor, ParentFont, ParentBiDiMode, and ParentShowHint properties. The values from Parent are omitted when Parent has not been assigned.
          </p>
          <p>
            Calls UpdateBaseBounds to store the bounds rectangle and client size using the loaded values.
          </p>
          <p>
            If an Action has been assigned in the control, the ActionChange method is called to ensure that default values from the Action are applied to the control.
          </p>
         <p>
            If an ancestor control is still loading its child controls, resize and align operations are deferred for the control. Otherwise, the LoadedAll method is called to adjust the sizes and layouts for the control.
          </p>
        </descr>
        <seealso>
          <link id="#rtl.classes.TComponent">TComponent</link>
        </seealso>
      </element>

      <element name="TControl.LoadedAll">
        <short>
          Called when the control and its child controls have been loaded, and their control state is changed.
        </short>
        <descr>
          <p>
            <var>LoadedAll</var> is a procedure called when the control (and its child controls) have been loaded using the LCL component streaming mechanism, and csLoading is removed from their control state. LoadedAll is called from the Loaded method.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Loaded"/>
        </seealso>
      </element>

      <element name="TControl.DefineProperties">
        <short>
          Defines which non-published properties should be streamed (none here).
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.DefineProperties.Filer">
        <short/>
      </element>

      <element name="TControl.AssignTo">
        <short>
          Implements assignment of the control to an Action object, or  calls the inherited method.
        </short>
        <descr>
          <p>
            Properties copied in the method include:
          </p>
          <ul>
            <li>Enabled</li>
            <li>Hint</li>
            <li>Caption</li>
            <li>Visible</li>
            <li>OnExecute (copied to OnClick in the destination object)</li>
            <li>HelpContext</li>
            <li>HelpKeyword</li>
            <li>HelpType</li>
          </ul>
        </descr>
        <seealso>
          <link id="#rtl.classes.TPersistent.Assign">TPersistent.Assign</link>
        </seealso>
      </element>
      <element name="TControl.AssignTo.Dest">
        <short>Destination object which receives values copied in the method.</short>
      </element>

      <element name="TControl.FormEndUpdated">
        <short>Called for each control on a form where the update count has reached 0 (zero).</short>
        <descr>
          <p>
            FormEndUpdated is overridden in descendent classes, like TWinControl, which provides a container for its child controls.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.GetChildren"/>
        </seealso>
      </element>

      <element name="TControl.InvalidateControl">
        <short>Requests a repaint of the control.</short>
        <descr>
          <p>
            <var>InvalidateControl</var> is an overloaded method used to redraw the bounds rectangle for control. No actions are performed in the method if the Parent control or its Handle are not assigned, during LCL component streaming, or when the control is being freed.
          </p>
          <p>
            When CtrlIsVisible is set to <b>True</b> or the control has a visible design surface, the InvalidateRect routine is called. The BoundsRect for the control is erased and redrawn when the control uses an opaque drawing style, or when it occludes a sibling control in its Parent.
          </p>
          <p>
            InvalidateControl is called from methods like Invalidate and ChangeBounds, and when a new value is assigned to the Visible property.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Invalidate"/>
          <link id="TControl.ChangeBounds"/>
          <link id="TControl.Visible"/>
          <link id="TControl.VisibleChanged"/>
          <link id="TControl.CMVisibleChanged"/>
        </seealso>
      </element>
      <element name="TControl.InvalidateControl.CtrlIsVisible">
        <short>True if the control is visible.</short>
      </element>
      <element name="TControl.InvalidateControl.CtrlIsOpaque">
        <short>True if the control use an opaque drawing style.</short>
      </element>
      <element name="TControl.InvalidateControl.IgnoreWinControls">
        <short>True if TWinControl descendants are ignored in  the method.</short>
      </element>

      <element name="TControl.FontChanged">
        <short>
          Handles changes to the Font property.
        </short>
        <descr>
          <p>
            <var>FontChanged</var> is a procedure used to perform actions needed when the value in the <var>Font</var> property has been changed for the control. FontChanged ensures that values in <var>ParentFont</var> and <var>DesktopFont</var> are set to <b>False</b> to reflect the font assignment.
          </p>
          <p>
            FontChanged calls the <var>Invalidate</var> method to force the control to be redrawn when it is Visible. The CM_FONTCHANGED control change message is performed to reflect the change in the control state. When <var>AutoSize</var> contains <b>True</b>, the <var>InvalidatePreferredSize</var> and <var>AdjustSize</var> methods are called to update the control dimensions using the new font.
          </p>
          <p>
            FontChanged is assigned to the <var>OnChange</var> event handler for the <var>Font</var> property in the constructor for the class instance.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Font"/>
          <link id="TControl.ParentFont"/>
          <link id="TControl.DesktopFont"/>
          <link id="TControl.Invalidate"/>
          <link id="TControl.InvalidatePreferredSize"/>
          <link id="TControl.AdjustSize"/>
          <link id="TControl.IsVisible"/>
          <link id="TControl.AutoSize"/>
          <link id="TControl.Perform"/>
        </seealso>
      </element>
      <element name="TControl.FontChanged.Sender">
        <short>Class instance generating the change notification.</short>
      </element>

      <element name="TControl.ParentFontChanged">
        <short>
          [Delphi compatible] Does nothing here, all work is done in CMParentFontChanged.
        </short>
        <descr/>
        <seealso>
          <link id="TControl.CMParentFontChanged"/>
        </seealso>
      </element>

      <element name="TControl.GetAction">
        <short>Gets the value for the Action property.</short>
        <descr>
          <p>
            The property value is retrieved from ActionLink (when assigned). Otherwise, the property value is Nil.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Action"/>
        </seealso>
      </element>
      <element name="TControl.GetAction.Result">
        <short>Value for the Action property.</short>
      </element>

      <element name="TControl.RealGetText">
        <short>Returns the Caption property.</short>
        <descr>
          <p>
            This method is called by <var>GetText</var>, when GetTextBuf has not been overridden.
          </p>
        </descr>
        <seealso>
          <link id="TControl.GetTextBuf"/>
          <link id="TControl.RealSetText"/>
          <link id="TControl.SetTextBuf"/>
        </seealso>
      </element>
      <element name="TControl.RealGetText.Result">
        <short>Value for the Caption property.</short>
      </element>

      <element name="TControl.RealSetText">
        <short>Sets the value for the Caption property.</short>
        <descr>
          <p>
            RealSetText is a method used to apply the TCaption value in AValue to the text or caption for the control. RealSetText is called by the private <var>SetText</var> method, when <var>SetTextBuf</var> has not been overridden.
          </p>
          <p>
            <b>Notes on TControl.Caption, TControl.Text, et. al.</b>
          </p>
          <p>
            The Delphi VCL implementation relies on the virtual GetTextBuf and SetTextBuf methods to exchange text for controls.. This requires a lot of (unnecessary) copies to move values between Text and Caption.
          </p>
          <p>
            The LCL uses strings to exchange text values because it is more efficient. To maintain VCL compatibility, the virtual RealGetText and RealSetText methods were  introduced. These functions use the LCLInterface. The default GetTextBuf and SetTextBuf implementations calls the RealGetText and RealSetText methods as needed. As long as the GetTextBuf and/or SetTextBuf aren't overridden, GetText and SetText call RealGetText and RealSetText to avoid copying PChar values.
          </p>
          <p>
            To keep things optimal, LCL implementations should always override RealGetText and RealSetText. GetTextBuf and SetTextBuf are only kept for compatibility with Delphi code.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Caption"/>
          <link id="TControl.Text"/>
          <link id="TControl.RealGetText"/>
          <link id="TControl.SetTextBuf"/>
          <link id="TControl.GetTextBuf"/>
        </seealso>
      </element>
      <element name="TControl.RealSetText.Value">
        <short>The string value to store in the Text / Caption properties.</short>
      </element>

      <element name="TControl.TextChanged">
        <short>Performs actions needed when the value for the Text property has been changed.</short>
        <descr>
          <p>
            TextChanged has an empty implementation in TControl, and is overridden in descendent classes to perform any actions needed for the control type. Called from the CMTextChanged message handler.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TControl.GetCachedText">
        <short>Returns the cached Text property (FCaption).</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.GetCachedText.Result">
        <short>True if successful.</short>
      </element>
      <element name="TControl.GetCachedText.CachedText">
        <short>Here: FCaption (can be overridden).</short>
      </element>

      <element name="TControl.SetAction">
        <short>Sets the value for the Action property.</short>
        <descr>
          <p>
            Ensures that ActionLink is updated when the value for the property is updated. When Value is unassigned (Nil), ActionLink is freed and set to Nil. The control style flags are also updated to remove the value csActionClient. Otherwise, a new ActionLink class instance is created for ActionLink and Value is assigned to its  Action property. Its OnChange handler is assigned, and the ActionChange method is called to apply values from the action to the control.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Action"/>
        </seealso>
      </element>
      <element name="TControl.SetAction.Value">
        <short>New value for the Action property.</short>
      </element>

      <element name="TControl.SetColor">
        <short>Sets the value for the Color property.</short>
        <descr>
          <p>
            SetColor is a method used to set the value for the Color property to the specified TColor value. Assigning a value to Color causes the ParentColor property to be set to False.
          </p>
          <p>
            SetColor calls Perform to send a CM_COLORCHANGED control message to the widgetset class. Invalidate is called to force the control to be redrawn.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Color"/>
        </seealso>
      </element>
      <element name="TControl.SetColor.Value">
        <short>New value for the Color property.</short>
      </element>

      <element name="TControl.SetEnabled">
        <short>Sets the value for the Enabled property.</short>
        <descr>
          <p>
            Calls EnabledChanging to notify handlers for the chtOnEnabledChanged type. Stores the new value for the property, and performs a CM_ENABLEDCHANGED control message. Calls EnabledChanged to notify handlers for the chtOnEnabledChanged type.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Enabled"/>
        </seealso>
      </element>
      <element name="TControl.SetEnabled.Value">
        <short>New value for the Enabled property.</short>
      </element>

      <element name="TControl.SetHint">
        <short>Sets the value for the Hint property.</short>
        <descr>
          <p>
            Value is a TTranslateString type which allows it be recognized and processed in the LCL translation facilities.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Hint"/>
        </seealso>
      </element>
      <element name="TControl.SetHint.Value">
        <short>New value for the Hint property.</short>
      </element>

      <element name="TControl.SetName">
        <short>Sets the value for the Name property.</short>
        <descr/>
        <seealso>
          <link id="#rtl.classes.TComponent.Name">TComponent.Name</link>
        </seealso>
      </element>
      <element name="TControl.SetName.Value">
        <short>New value for the Name property.</short>
      </element>

      <element name="TControl.SetParent">
        <short>Sets the value for the Parent property.</short>
        <descr/>
        <seealso>
          <link id="TControl.Parent"/>
        </seealso>
      </element>
      <element name="TControl.SetParent.NewParent">
        <short>New value for the the Parent property.</short>
      </element>

      <element name="TControl.SetParentComponent">
        <short>
          Sets the value in the Parent property when the new parent component is a TWinControl instance.
        </short>
        <descr>
          <p>
            Implements the dynamic method inherited from TComponent. When NewParentComponent is derived from TWinControl, the SetParent method is called to re-parent, position, and resize the control.
          </p>
        </descr>
        <seealso>
          <link id="TControl.SetParent"/>
          <link id="TControl.Parent"/>
          <link id="#rtl.classes.TComponent.GetParentComponent">TComponent.GetParentComponent</link>
        </seealso>
      </element>
      <element name="TControl.SetParentComponent.NewParentComponent">
        <short>New TWinControl instance used as the Parent for the control.</short>
      </element>

      <element name="TControl.ParentFormHandleInitialized">
        <short>Internal handler for activities after a form widget has been created.
        </short>
        <descr>
          <p>
            Called by <var>ChildHandlesCreated</var> of parent form.
          </p>
          <p>
            Functions like GetTextWidth require a valid widget and a device context.
            That is why AutoSizing is delayed until the handle in a parent Form is allocated.
          </p>
        </descr>
      </element>

      <element name="TControl.GetMouseCapture">
        <short>Gets the value for the MouseCapture property.</short>
        <descr>
          <p>
            Indicates if the class instance is the current CaptureControl for the LCL framework.
            The property value is True when the following condition are satisfied:
          </p>
          <ul>
            <li>
              Parent is assigned (not Nil).
            </li>
            <li>
              Parent has an allocated window handle.
            </li>
            <li>
              The value in the LCL CaptureContol variable is the current class instance.
            </li>
          </ul>
        </descr>
        <seealso>
          <link id="TControl.MouseCapture"/>
          <link id="GetCaptureControl"/>
        </seealso>
      </element>
      <element name="TControl.GetMouseCapture.Result">
        <short>True when the current class instance is the LCL CaptureControl.</short>
      </element>

      <element name="TControl.CaptureChanged">
        <short>Handler for mouse capture moved to a different control.</short>
        <descr>
          <p>
            Notifies the DragManager of a change to the capture control, and to stop dragging this control. A very dangerous implementation; it can cause an immediate abort of dragging before dragging really starts.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TControl.Notification">
        <short>Notification handler for insertion or deletion of components.</short>
        <descr>
          <p>
            First, the inherited <var>TComponent.Notification</var> is called to notify all attached notification handlers.
          </p>
          <p>
            If <var>Operation</var> is <var>opRemove</var>, additional actions are performed, depending on <var>AComponent</var>: the PopupMenu, Action, or anchors for the removed control are detached.
          </p>
        </descr>
        <seealso>
          <link id="#rtl.classes.TComponent.Notification">TComponent.Notification</link>
        </seealso>
      </element>
      <element name="TControl.Notification.AComponent">
        <short>The component being inserted or removed.</short>
      </element>
      <element name="TControl.Notification.Operation">
        <short>The action (opInsert or opRemove).</short>
      </element>

      <element name="TControl.CanTab">
        <short>Determined whether the Tab key can be used for navigation in the control.</short>
        <descr>
          <p>
            Always returns <b>False</b> in TControl. Overridden in TWinControl.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.CanTab"/>
        </seealso>
      </element>
      <element name="TControl.CanTab.Result">
        <short/>
      </element>

      <element name="TControl.GetDeviceContext">
        <short>Returns a device context handle for the control, from Parent.
        </short>
        <descr>
          <p>
            Initializes the device context position to the control origin, and shrinks its clipping rectangle to the bounds for the control.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TControl.GetDeviceContext.Result">
        <short>The device context.</short>
      </element>
      <element name="TControl.GetDeviceContext.WindowHandle">
        <short>Returns the window handle of the device context.</short>
      </element>

      <element name="TControl.GetEnabled">
        <short>Gets the value for the Enabled property.</short>
        <descr/>
        <seealso>
          <link id="TControl.Enabled"/>
        </seealso>
      </element>
      <element name="TControl.GetEnabled.Result">
        <short>Value for the Enabled property.</short>
      </element>

      <element name="TControl.GetPopupMenu">
        <short>Gets the value for the PopupMenu property.</short>
        <descr/>
        <seealso>
          <link id="TControl.PopupMenu"/>
        </seealso>
      </element>
      <element name="TControl.GetPopupMenu.Result">
        <short>Value for the PopupMenu property.</short>
      </element>

      <element name="TControl.DoOnShowHint">
        <short>Invokes the <var>OnShowHint</var> event handler.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.DoOnShowHint.HintInfo">
        <short/>
      </element>

      <element name="TControl.DoMouseWheel">
        <short>
          Invokes the OnMouseWheel handlers, when the wheel has been turned.
        </short>
        <descr>
          <p>
            Multiple wheel handlers can be implemented. First the general OnMouseWheel handler is tried, and if it doesn't report the event handled, then OnMouseWheelUp or OnMouseWheelDown are tried.
          </p>
          <p>
            The actual WheelDelta is available <b>only</b> to the OnMouseWheel handler, not to the up and down handlers [Delphi compatible].
          </p>
        </descr>
        <seealso>
          <link id="TMouseWheelEvent"/>
          <link id="TMouseWheelUpDownEvent"/>
        </seealso>
      </element>
      <element name="TControl.DoMouseWheel.Result">
        <short>Set Result to True if handled.</short>
      </element>
      <element name="TControl.DoMouseWheel.Shift">
        <short>State of the modifier keys and mouse buttons.</short>
      </element>
      <element name="TControl.DoMouseWheel.WheelDelta">
        <short>How many notches the wheel has been turned.</short>
      </element>
      <element name="TControl.DoMouseWheel.MousePos">
        <short>The mouse coordinates.</short>
      </element>

      <element name="TControl.DoMouseWheelDown">
        <short>Invokes the OnMouseWheelDown handler.</short>
      </element>
      <element name="TControl.DoMouseWheelDown.Result">
        <short>True if handled.</short>
      </element>
      <element link="#lcl.controls.TMouseWheelEvent.Shift" name="TControl.DoMouseWheelDown.Shift">
        <short/>
      </element>
      <element link="#lcl.controls.TMouseWheelEvent.MousePos" name="TControl.DoMouseWheelDown.MousePos">
        <short/>
      </element>

      <element name="TControl.DoMouseWheelUp">
        <short>Invokes the OnMouseWheelUp handler.</short>
      </element>
      <element name="TControl.DoMouseWheelUp.Result">
        <short>True if handled.</short>
      </element>
      <element link="#lcl.controls.TMouseWheelEvent.Shift" name="TControl.DoMouseWheelUp.Shift">
        <short/>
      </element>
      <element link="#lcl.controls.TMouseWheelEvent.MousePos" name="TControl.DoMouseWheelUp.MousePos">
        <short/>
      </element>

      <element name="TControl.DoMouseWheelHorz">
        <short>Performs actions needed to handle horizontal mouse wheel events.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.DoMouseWheelHorz.Result">
        <short>True when the mouse wheel event has been handled for the control.</short>
      </element>
      <element name="TControl.DoMouseWheelHorz.Shift">
        <short>Shift state for the mouse wheel event.</short>
      </element>
      <element name="TControl.DoMouseWheelHorz.WheelDelta">
        <short>Number of units (or clicks) the mouse wheel was moved.</short>
      </element>
      <element name="TControl.DoMouseWheelHorz.MousePos">
        <short>TPoint with the mouse coordinates for the event.</short>
      </element>

      <element name="TControl.DoMouseWheelLeft">
        <short>Performs the OnMouseWheelLeft event handler.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.DoMouseWheelLeft.Result">
        <short/>
      </element>
      <element name="TControl.DoMouseWheelLeft.Shift">
        <short/>
      </element>
      <element name="TControl.DoMouseWheelLeft.MousePos">
        <short/>
      </element>

      <element name="TControl.DoMouseWheelRight">
        <short>Performs the OnMouseWheelRight event handler.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.DoMouseWheelRight.Result">
        <short/>
      </element>
      <element name="TControl.DoMouseWheelRight.Shift">
        <short/>
      </element>
      <element name="TControl.DoMouseWheelRight.MousePos">
        <short/>
      </element>

      <element name="TControl.VisibleChanging">
        <short>Notifies all <var>OnVisibleChanging</var> handlers.</short>
      </element>

      <element name="TControl.VisibleChanged">
        <short>Notifies all OnVisibleChanged handlers.</short>
      </element>

      <element name="TControl.EnabledChanging">
        <short>Notifies all OnEnabledChanging handlers.</short>
      </element>

      <element name="TControl.EnabledChanged">
        <short>Notifies all OnEnabledChanged handlers.</short>
      </element>

      <element name="TControl.AddHandler">
        <short>Adds an notification handler.</short>
        <descr>
          Notification handlers allow to notify other components of certain events. When the registered event occurs, all installed (added) handlers are invoked.
        </descr>
      </element>
      <element name="TControl.AddHandler.HandlerType">
        <short>Type of the event.</short>
      </element>
      <element name="TControl.AddHandler.AMethod">
        <short>The handler to be added.</short>
      </element>
      <element name="TControl.AddHandler.AsFirst">
        <short>Unused.</short>
      </element>

      <element name="TControl.RemoveHandler">
        <short>Removes the given notification handler.</short>
        <seealso>
          <link id="TControl.AddHandler"/>
        </seealso>
      </element>
      <element name="TControl.RemoveHandler.HandlerType">
        <short>Type of the notification.</short>
      </element>
      <element name="TControl.RemoveHandler.AMethod">
        <short>The handler to be removed.</short>
      </element>

      <element name="TControl.DoCallNotifyHandler">
        <short>Invokes all notification handlers of the specified type.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.DoCallNotifyHandler.HandlerType">
        <short>The event that has occurred.</short>
      </element>

      <element name="TControl.DoCallKeyEventHandler">
        <short>
          Passes key events for the specified type to the handlers added to the control.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.DoCallKeyEventHandler.HandlerType">
        <short/>
      </element>
      <element name="TControl.DoCallKeyEventHandler.Key">
        <short/>
      </element>
      <element name="TControl.DoCallKeyEventHandler.Shift">
        <short/>
      </element>

      <element name="TControl.DoCallMouseWheelEventHandler">
        <short>Passes mouse wheel events to the handlers added to the control.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.DoCallMouseWheelEventHandler.HandlerType">
        <short/>
      </element>
      <element name="TControl.DoCallMouseWheelEventHandler.Shift">
        <short/>
      </element>
      <element name="TControl.DoCallMouseWheelEventHandler.WheelDelta">
        <short/>
      </element>
      <element name="TControl.DoCallMouseWheelEventHandler.MousePos">
        <short/>
      </element>
      <element name="TControl.DoCallMouseWheelEventHandler.Handled">
        <short/>
      </element>

      <element name="TControl.DoContextPopup">
        <short>Invokes the OnContextPopup handler.</short>
        <seealso/>
      </element>
      <element name="TControl.DoContextPopup.MousePos">
        <short>Mouse position, used to place the menu.</short>
      </element>
      <element name="TControl.DoContextPopup.Handled">
        <short>To be set by the handler, when it has handled the menu display and selection.</short>
      </element>

      <element name="TControl.SetZOrder">
        <short>Moves the control in front or back of all sibling controls.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.SetZOrder.TopMost">
        <short/>
      </element>

      <element name="TControl.GetControlClassDefaultSize">
        <short>Returns the default size for this class of controls (when added to a form).</short>
      </element>
      <element name="TControl.GetControlClassDefaultSize.Result">
        <short/>
      </element>

      <element name="TControl.ColorIsStored">
        <short>Implements the storage specifier for the Color property.</short>
        <descr/>
        <seealso>
          <link id="TControl.Color"/>
        </seealso>
      </element>
      <element name="TControl.ColorIsStored.Result">
        <short/>
      </element>

      <element name="TControl.DoAutoAdjustLayout">
        <short>
          Applies layout changes using the specified policy and scaling proportions to the control.
        </short>
        <descr>
          <p>
            DoAutoAdjustLayout is a method which implements changes to control sizes for the AutoAdjustLayout method. These methods are called when High-DPI and scaling have been enabled in the project options for an application.
          </p>
          <p>
            AMode indicates the automatic layout policy applied in the method. It is a value from the TLayoutAdjustmentPolicy enumeration, and determines whether horizontal / vertical / or both sizes are adjusted in the method. It generally reflects the constraints for the device type where the application is running.
          </p>
          <p>
            AXProportion and AYProportion contain the scaling factors applied to the horizontal and/or vertical sizes.
          </p>
          <p>
            DoAutoAdjustLayout ensures that new values for Height and Width in the control are calculated (when allowed and needed) using the scaling factors, Constraints, BorderSpacing and Anchors for the control. The SetBoundsKeepBase method is called to apply the newly calculated values to the control.
          </p>
          <p>
            Font scaling is performed in AutoAdjustLayout (when needed) and occurs prior to calling DoAutoAdjustLayout.
          </p>
          <p>
            DoAutoAdjustLayout, ScaleFontsPPI, and FixDesignFontsPPI are often overridden in descendent classes to perform additional actions needed for a control or its children.
          </p>
        </descr>
        <seealso>
          <link id="TControl.AutoAdjustLayout"/>
          <link id="TControl.ShouldAutoAdjust"/>
          <link id="TControl.Anchors"/>
          <link id="TControl.BorderSpacing"/>
          <link id="TControl.Constraints"/>
          <link id="TControl.SetBoundsKeepBase"/>
        </seealso>
      </element>
      <element name="TControl.DoAutoAdjustLayout.AMode">
        <short>Identifies the auto-layout policy applied in the method.</short>
      </element>
      <element name="TControl.DoAutoAdjustLayout.AXProportion">
        <short>Scaling factor for horizontal dimensions.</short>
      </element>
      <element name="TControl.DoAutoAdjustLayout.AYProportion">
        <short>Scaling factor for vertical dimensions.</short>
      </element>

      <element name="TControl.DoFixDesignFontPPI">
        <short>Applies the design-time PPI and resizes the specified control font.</short>
        <descr>
          <p>
            Implements the FixDesignFontsPPI method for the control.
          </p>
          <p>
            Performs actions needed to restore the design-time PPI (Pixels Per Inch) for controls when they are loaded using the LCL component streaming mechanism. The design-time PPI for fonts is not stored in .LFM files, and could result in invalid scaling operations when loaded on a machine with a different display density. DoFixDesignFontPPI ensures that the font is resized to the specified design-time PPI.
          </p>
        </descr>
        <seealso>
          <link id="TControl.FixDesignFontsPPI"/>
        </seealso>
      </element>
      <element name="TControl.DoFixDesignFontPPI.AFont">
        <short/>
      </element>
      <element name="TControl.DoFixDesignFontPPI.ADesignTimePPI">
        <short/>
      </element>

      <element name="TControl.DoScaleFontPPI">
        <short>
          Adjusts the height for a given Font to the specified pixels per inch (PPI).
        </short>
        <descr>
          <p>
            Implements the ScaleFontsPPI method for the control.
          </p>
        </descr>
        <seealso>
          <link id="TControl.ScaleFontsPPI"/>
        </seealso>
      </element>
      <element name="TControl.DoScaleFontPPI.AFont">
        <short>Font examined and updated in the method.</short>
      </element>
      <element name="TControl.DoScaleFontPPI.AToPPI">
        <short>Pixels per inch setting adjusted in the method.</short>
      </element>
      <element name="TControl.DoScaleFontPPI.AProportion">
        <short>Scaling factor a applied to the font.</short>
      </element>

      <element name="TControl.GetActionLinkClass">
        <short>The default ActionLink class (TControlActionLink).</short>
        <descr>Used when the control is linked to an Action.</descr>
        <seealso/>
      </element>
      <element name="TControl.GetActionLinkClass.Result">
        <short/>
      </element>

      <element name="TControl.ActionChange">
        <short>Handler for a changed Action.</short>
        <descr>Several properties are copied from the new Action.</descr>
      </element>
      <element name="TControl.ActionChange.Sender">
        <short>The changed Action.</short>
      </element>
      <element name="TControl.ActionChange.CheckDefaults">
        <short>When True, forces update of all properties. Otherwise only properties in default state are overwritten.</short>
      </element>

      <element name="TControl.ActionLink">
        <short>Link to the default Action associated with this control.</short>
      </element>

      <element name="TControl.DesktopFont">
        <short>Allows to use the desktop font for text display in this control.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.DragCursor">
        <short>The cursor shape shown while the control is dragged.</short>
        <descr>Default is crDrag. When no drop is allowed, the cursor changes temporarily to crNoDrop.</descr>
      </element>

      <element name="TControl.DragKind">
        <short>The operation when the control is dragged - Drag or Dock.</short>
        <descr>Set to dkDrag for drag-drop, or to dkDock for drag-dock operation.</descr>
        <seealso/>
      </element>

      <element name="TControl.DragMode">
        <short>Allows the user to drag the control.</short>
        <descr>
          <p>Default is dmManual, meaning that dragging must be started in code.</p>
          <p>
            Set to dmAutomatic to allow the user to drag this control. In this mode dragging can start immediately (on left mouse button press) or delayed, after the mouse has been moved away by a number of pixels (Threshold).
          </p>
        </descr>
        <seealso>
          <link id="TControl.DragKind"/>
          <link id="TDragManager.DragImmediate"/>
        </seealso>
      </element>

      <element name="TControl.MouseCapture">
        <short>True when mouse messages are currently captured by this control.</short>
        <descr>
          <p>
            In normal operation, all mouse messages are sent to the control under the mouse pointer. Mouse messages also can be sent to a capturing control, e.g. when a control is dragged.
          </p>
          <p>
            Applications should capture mouse events only for special purposes, and release the capture as soon as a the target position has been determined. Limited user feedback is possible while the mouse is captured, not all application controls will work properly so long.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TControl.ParentColor">
        <short>
          Use the Color from the Parent control, when enabled.
        </short>
        <descr>
          <p>
            <var>ParentColor</var> determines if the control should use the <var>Color</var> from the Parent control, when enabled. The default value is <b>True</b>.
          </p>
          <p>
            When this property is <b>True</b>, all changes to the <var>Color</var> of the parent will also be applied to the Color of the control, ensuring that they both contain same value. If the Color of the control is changed by the application, then <var>ParentColor</var> will be automatically set to <b>False</b>.
           </p>
           <p>
             Using <var>ParentColor</var> when the <var>Color</var> value is <var>clDefault</var> can cause problems in resolving the actual color value. To obtain the Color property of a control while taking into account clDefault and ParentColor, use the <var>GetColorResolvingParent</var> method. This method might return a non-RGB color, but will never return clDefault. To obtain a purely RGB result use the <var>GetRGBColorResolvingParent</var> method.
           </p>
        </descr>
        <seealso>
          <link id="TControl.Color"/>
          <link id="TControl.GetColorResolvingParent"/>
          <link id="TControl.GetRGBColorResolvingParent"/>
        </seealso>
      </element>

      <element name="TControl.ParentFont">
        <short>
          If true, the Font of the control will be the same as the one from the Parent. Default is true.
        </short>
        <descr>
          <p>
            While <var>ParentFont</var> is <b>True</b>, all changes to the font of the parent will also be applied to the font for the control. This synchronizes them, keeping them set to the same value. If the <var>Font</var> for the control is changed by the application, then <var>ParentFont</var> will automatically be set to <b>False</b>.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Font"/>
        </seealso>
      </element>

      <element name="TControl.ParentShowHint">
        <short>
          If true, the value of ShowHint for the control will be the same as the one from the Parent. Default is true.
        </short>
        <descr>
          <p>
            While <var>ParentShowHint</var> is <b>True</b>, all changes to the <var>ShowHint</var> property of the parent will also be applied to the <var>ShowHint</var> property for the control. This synchronizes them, keeping them with the same value. If the <var>ShowHint</var> property for the control is changed by the application, then <var>ParentShowHint</var> will automatically be set to <b>False</b>.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Hint"/>
          <link id="TControl.ShowHint"/>
        </seealso>
      </element>

      <element name="TControl.SessionProperties">
        <short>
          The stored (saved) properties of the current session, expressed as a string.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.Text">
        <short>The character string associated with the control.</short>
        <descr>
          <p>
            This is the character string, shown in controls with visible text content (<link id="#lcl.StdCtrls.TEdit">TEdit</link>...).
          </p>
          <remark>
            BEWARE: In other controls it can be the Name or Caption of the control, quite tricky to use.
          </remark>
          <p>
            The Delphi VCL implementation stores Text mostly in the widgets, using the virtual <var>Get/SetTextBuf</var> methods to exchange text between widgets and VCL. This means a lot of text copies and message handling in WM_GETTEXT and WM_SETTEXT.
          </p>
          <p>
            The LCL instead (typically) stores Text in a field of the control, and transfers it from/to the widgets only when required.
          </p>
          <p>
            To maintain VCL compatibility, the virtual <var>RealGet/SetText</var> methods have been introduced, which read or write the Caption string directly.
          </p>
          <p>
            The default <var>Get/SetTextBuf</var> implementation calls the <var>RealGet/SetText</var> methods, resulting in a string-to-PCHAR and another PCHAR-to-string conversion. But as long as <var>Get/SetTextBuf</var> is not overridden, <var>Get/SetText</var> can (and does) safely call <var>RealGet/SetText</var> immediately, to avoid the mentioned conversions.
          </p>
          <p>
            To keep things optimal, LCL components should always override RealGet/SetText; Get/SetTextBuf is only kept for compatibility.
          </p>
        </descr>
      </element>

      <element name="TControl.OnConstrainedResize">
        <short>This handler can supply specific Constraints (size limits), when the control is resized.</short>
        <descr/>
        <seealso>
          <link id="TConstrainedResizeEvent"/>
          <link id="TControl.Constraints"/>
        </seealso>
      </element>

      <element name="TControl.OnContextPopup">
        <short>Invoked when a context-sensitive pop-up menu is requested.</short>
        <descr>
          <p>
            The handler can show and handle the menu selection itself. If so, it should set Handled to True. Otherwise the installed PopupMenu is shown.
          </p>
        </descr>
        <seealso>
          <link id="TContextPopupEvent"/>
          <link id="TControl.PopupMenu"/>
        </seealso>
      </element>

      <element name="TControl.OnDblClick">
        <short>Event Handler for double mouse clicks.</short>
        <descr>
          <p>
            Double-clicking is much more common in a Windows environment than in Unix or Linux, where single-clicking is the default method for selecting an object. However, in all environments there could be valid use for a double-click, and a method should be supplied if appropriate.
          </p>
        </descr>
      </element>

      <element name="TControl.OnTripleClick">
        <short>Event handler for triple mouse clicks.</short>
      </element>

      <element name="TControl.OnQuadClick">
        <short>Event handler for quadruple mouse clicks.</short>
      </element>

      <element name="TControl.OnDragDrop">
        <short>This handler determines the action on an drop onto this control, in a drag-drop operation.
        </short>
        <descr>
          <p>
            Unlike for a drag-dock operation, no default action is associated with an drag-drop; the OnDragDrop handler is the only way to do something meaningful on an drag-drop.
          </p>
        </descr>
        <seealso>
          <link id="TDragDropEvent"/>
          <link id="TControl.DragDrop"/>
        </seealso>
      </element>

      <element name="TControl.OnDragOver">
        <short>Event handler for a control being dragged over this control.</short>
        <descr>
          The handler can reject an drop, by setting Accept to False.
        </descr>
        <seealso>
          <link id="TDragOverEvent"/>
        </seealso>
      </element>

      <element name="TControl.OnEndDock">
        <short>Notification handler for the end of a docking operation.</short>
        <descr/>
        <seealso>
          <link id="TEndDragEvent"/>
        </seealso>
      </element>

      <element name="TControl.OnEndDrag">
        <short>Notification handler for the end of a dragging operation.</short>
        <descr/>
        <seealso>
          <link id="TEndDragEvent"/>
        </seealso>
      </element>

      <element name="TControl.OnMouseDown">
        <short>Event handler for mouse button going down.</short>
        <seealso>
          <link id="TControl.OnClick"/>
        </seealso>
      </element>

      <element name="TControl.OnMouseMove">
        <short>Event handler for mouse movement within the control.</short>
      </element>

      <element name="TControl.OnMouseUp">
        <short>Event handler for mouse button going up.</short>
        <seealso>
          <link id="TControl.OnClick"/>
        </seealso>
      </element>

      <element name="TControl.OnMouseEnter">
        <short>Event handler for mouse entering the area of the control.</short>
      </element>

      <element name="TControl.OnMouseLeave">
        <short>Event handler for mouse leaving the area of the control.</short>
      </element>

      <element name="TControl.OnMouseWheel">
        <short>Event handler for mouse wheel turned.</short>
        <descr>
          <p>
            By default all mouse wheel actions are translated into scroll events. Write an OnMouseWheel handler to react on turns of the mouse wheel.
          </p>
          <p>
            The OnMouseWheelUp and OnMouseWheelDown handlers are notified only, they are not suited for customization of mouse wheel events.
          </p>
        </descr>
        <seealso>
          <link id="TMouseWheelEvent"/>
        </seealso>
      </element>

      <element name="TControl.OnMouseWheelDown">
        <short>Event handler for downward movement of mouse wheel.</short>
        <seealso>
          <link id="TControl.OnMouseWheel"/>
          <link id="TMouseWheelUpDownEvent"/>
        </seealso>
      </element>

      <element name="TControl.OnMouseWheelUp">
        <short>Event handler for upward movement of the mouse wheel.</short>
        <seealso>
          <link id="TControl.OnMouseWheel"/>
          <link id="TMouseWheelUpDownEvent"/>
        </seealso>
      </element>

      <element name="TControl.OnMouseWheelHorz">
        <short>Event handler for horizontal movements of the mouse wheel.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.OnMouseWheelLeft">
        <short>Event handler for left movements of the mouse wheel.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.OnMouseWheelRight">
        <short>Event handler for right movements of the mouse wheel.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.OnStartDock">
        <short>Event handler for the start of a docking operation.</short>
        <descr>
          <p>The handler can provide a special DragDock object, otherwise a default object is created.</p>
        </descr>
        <seealso>
          <link id="TControl.OnStartDrag"/>
          <link id="TDragDockObject"/>
        </seealso>
      </element>

      <element name="TControl.OnStartDrag">
        <short>Event handler for the start of a dragging operation.</short>
        <descr>
          <p>
            The handler can provide a special DragControl object, otherwise a default object is created.
          </p>
        </descr>
        <seealso>
          <link id="TControl.OnStartDock"/>
          <link id="TDragObject"/>
        </seealso>
      </element>

      <element name="TControl.OnEditingDone">
        <short>Event handler signalled when editing is done.</short>
        <descr>
          <p>
            The user has finished editing the value for the control, and the resulting text can be validated. It is called (when assigned) from the <var>EditingDone</var> method, which occurs when focus changes to another control.
          </p>
        </descr>
        <seealso>
          <link id="TControl.EditingDone"/>
        </seealso>
      </element>

      <element name="TControl.FCompStyle">
        <short>Deprecated.</short>
        <descr>
          <remark>
            DEPRECATED. Enables valid use of the <b>'IN'</b> operator (this is a hack for speed). It will be replaced by the use of the widgetset classes. So, don't use it anymore.
          </remark>
        </descr>
        <seealso/>
      </element>

      <element name="TControl.DragDrop">
        <short>Invokes the OnDragDrop handler, when a dragged object is dropped onto this control.</short>
        <seealso>
          <link id="TControl.OnDragDrop"/>
        </seealso>
      </element>
      <element name="TControl.DragDrop.Source">
        <short>The dropped object (control or DragDrop object).</short>
      </element>
      <element name="TControl.DragDrop.X">
        <short>The drop position in client coordinates.</short>
      </element>
      <element name="TControl.DragDrop.Y">
        <short>The drop position in client coordinates.</short>
      </element>

      <element name="TControl.Dock">
        <short>Moves the control into a new docksite.</short>
        <descr>
          <p>
            Calls <link id="TControl.DoDock">DoDock</link> to prepare for the new position of the control, when docked into an unmanaged or floating docksite.
          </p>
          <p>
            When the old and new docksites are different, the control is removed from the DockClients of the old docksite, and added to the DockClients of the new docksite; afterwards the docksites are notified by calling their DoAddDockClient and DoRemoveDockClient methods, to adjust the control's Parent.
          </p>
        </descr>
        <errors>
          An exception is raised if there is already a docking process in progress for this control.
        </errors>
      </element>
      <element name="TControl.Dock.NewDockSite">
        <short>The host site into which which the control is to be docked, <b>Nil</b> for floating.</short>
      </element>
      <element name="TControl.Dock.ARect">
        <short>
          The new Bounds for the control. Expressed in screen coordinates when NewDockSite is Nil. Otherwise, client coordinates for NewDockSite.
        </short>
      </element>

      <element name="TControl.ManualDock">
        <short>Docks a control programmatically.</short>
        <descr>
          <p>
            Docks this control into NewDockSite, relative to DropControl. When NewDockSite is Nil, the control becomes floating.
          </p>
          <p>
            When the new docksite uses an DockManager, and DropControl is not Nil, the control will be docked relative to DropControl, as specified by ControlSide.
          </p>
          <p>
            The interpretation of ControlSide depends on the DockManager of NewDockSite,
            or on the OnDockDrop handler in an unmanaged  docksite.
          </p>
          <p>
            A tree docking manager (TDockTree) should interpret alCustom as NoteBook docking, i.e. a tabbed notebook is created in place of DropControl, and both DropControl and this control are docked into pages of this notebook.
          </p>
        </descr>
      </element>
      <element name="TControl.ManualDock.Result">
        <short>True if successfully docked.</short>
      </element>
      <element name="TControl.ManualDock.NewDockSite">
        <short>The site into which the control is docked; <b>Nil</b> to make it float.</short>
      </element>
      <element name="TControl.ManualDock.DropControl">
        <short>The sibling relative to which the control is inserted; can be Nil.
        </short>
      </element>
      <element name="TControl.ManualDock.ControlSide">
        <short>The side of DropControl on which the control is to be docked.
        </short>
      </element>
      <element name="TControl.ManualDock.KeepDockSiteSize">
        <short/>
      </element>

      <element name="TControl.ManualFloat">
        <short>Undocks the control into floating state.</short>
        <descr>
          TWinControls float for themselves, for TControls a floating host dock site is created, and the control is docked into it.
        </descr>
      </element>
      <element name="TControl.ManualFloat.Result">
        <short>True if successfully floated.</short>
      </element>
      <element name="TControl.ManualFloat.TheScreenRect">
        <short>
          The screen area where the floating control is moved; or the client area for a floating host site.
        </short>
      </element>
      <element name="TControl.ManualFloat.KeepDockSiteSize">
        <short/>
      </element>

      <element name="TControl.ReplaceDockedControl">
        <short>Replaces a previously docked control.</short>
        <descr>
          <p>
            This method exists for use by the DockManager for NoteBook docking. It should not be used in application code.
          </p>
          <p>
            Delphi introduced a different method, DockReplaceDockClient, which is used when the replaced Control is in an unmanaged docksite.
          </p>
        </descr>
        <seealso>
          <link id="TControl.ManualDock"/>
        </seealso>
      </element>
      <element name="TControl.ReplaceDockedControl.Result">
        <short>True if the docked control has been successfully replaced.</short>
      </element>
      <element name="TControl.ReplaceDockedControl.Control">
        <short>The control to be replaced, will be docked into NewDockSite.</short>
      </element>
      <element name="TControl.ReplaceDockedControl.NewDockSite">
        <short>The new dock site for Control, typically a docking Notebook.
        </short>
      </element>
      <element name="TControl.ReplaceDockedControl.DropControl">
        <short>The control to which Control is docked.</short>
      </element>
      <element name="TControl.ReplaceDockedControl.ControlSide">
        <short>The side of DropControl, to which Control is docked.</short>
      </element>

      <element name="TControl.Docked">
        <short>Indicates if the control has a host dock site.</short>
        <descr>
          <p>
            Docked is a Boolean function which indicates if the control instance is docked to a host  docking site. The return value is True when all of the following conditions are met:
          </p>
          <ul>
            <li>Parent is assigned (not Nil).</li>
            <li>Parent has the same value as the HostDockSite property.</li>
            <li>Parent has a parent form with a different value than Parent itsself.</li>
          </ul>
        </descr>
        <seealso>
          <link id="TControl.HostDockSite"/>
          <link id="TControl.Parent"/>
          <link id="#lcl.forms.GetParentForm">GetParentForm</link>
        </seealso>
      </element>
      <element name="TControl.Docked.Result">
        <short/>
      </element>

      <element name="TControl.Dragging">
        <short>Returns True if the control is being dragged.</short>
      </element>
      <element name="TControl.Dragging.Result">
        <short>Returns True if the control is being dragged.</short>
      </element>

      <element name="TControl.GetAccessibleObject">
        <short>Returns True if the control is being dragged.</short>
      </element>

      <element name="TControl.CreateAccessibleObject">
        <short>
          Creates a TLazAccessibleObject instance for this control.
        </short>
        <descr>
          <p>
            CreateAccessibleObject should just create and return the object instance. It is useful for classes derived from a descendant of TLazAccessibleObject (instead of the base class).
          </p>
        </descr>
        <seealso>
          <link id="TLazAccessibleObject"/>
          <link id="TControl.GetAccessibleObject"/>
        </seealso>
      </element>

      <element name="TControl.GetSelectedChildAccessibleObject">
        <short>
          Returns the currently selected child accessible object.
        </short>
        <descr>
          <p>
          GetSelectedChildAccessibleObject is provided for controls which wish to override this behavior without sub-classing TLazAccessibleObject.
          </p>
        </descr>
        <seealso>
          <link id="TLazAccessibleObject"/>
          <link id="TLazAccessibleObject.GetSelectedChildAccessibleObject"/>
          <link id="TControl.CreateAccessibleObject"/>
          <link id="TControl.GetAccessibleObject"/>
        </seealso>
      </element>

      <element name="TControl.GetChildAccessibleObjectAtPos">
        <short>
          Returns the child accessibility object at the given position for the control.
        </short>
        <descr>
          <p>
            GetChildAccessibleObjectAtPos returns the accesibility object at the position expressed in client coordinates. This method is provided for controls which wish to override this behavior without sub-classing TLazAccessibleObject.
          </p>
        </descr>
        <seealso>
          <link id="TLazAccessibleObject"/>
          <link id="TLazAccessibleObject.GetChildAccessibleObjectAtPos"/>
          <link id="TControl.CreateAccessibleObject"/>
          <link id="TControl.GetAccessibleObject"/>
        </seealso>
      </element>

      <element name="TControl.ScaleDesignToForm">
        <short>
          Scales a size value from the design-time PPI to the run-time PPI for the parent form.
        </short>
        <descr>
        </descr>
        <seealso/>
      </element>
      <element name="TControl.ScaleDesignToForm.Result">
        <short>Scaled sized value.</short>
      </element>
      <element name="TControl.ScaleDesignToForm.ASize">
        <short>Original size value scaled in the method.</short>
      </element>

      <element name="TControl.ScaleFormToDesign">
        <short>
          Scales a size value from the run-time PPI for the parent form to the design-time PPI.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.ScaleFormToDesign.Result">
        <short>Scaled sized value.</short>
      </element>
      <element name="TControl.ScaleFormToDesign.ASize">
        <short>Original size value scaled in the method.</short>
      </element>

      <element name="TControl.Scale96ToForm">
        <short>
          Scales a size value from 96 PPI to the run-time PPI for the Screen.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.Scale96ToForm.Result">
        <short>
          Scaled size value.
        </short>
      </element>
      <element name="TControl.Scale96ToForm.ASize">
        <short>
          Original size value scaled in the method.
        </short>
      </element>

      <element name="TControl.ScaleFormTo96">
        <short>
          Scales a size value from the PPI for the Parent form (or designer control) to 96 PPI.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.ScaleFormTo96.Result">
        <short>
          Scaled size value.
        </short>
      </element>
      <element name="TControl.ScaleFormTo96.ASize">
        <short>
          Original size value scaled in the method.
        </short>
      </element>

      <element name="TControl.Scale96ToFont">
        <short>
          Scales a size value from 96 PPI to the PPI setting for the Font in the control.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.Scale96ToFont.Result">
        <short>
          Scaled sized value.
        </short>
      </element>
      <element name="TControl.Scale96ToFont.ASize">
        <short>
          Original size value scaled in the method.
        </short>
      </element>

      <element name="TControl.ScaleFontTo96">
        <short>
          Scales a size value from the PPI setting in the Font for the control to 96 PPI.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.ScaleFontTo96.Result">
        <short>
          Scaled size value.
        </short>
      </element>
      <element name="TControl.ScaleFontTo96.ASize">
        <short>
          Original size value scaled in the method.
        </short>
      </element>

      <element name="TControl.ScaleScreenToFont">
        <short>
          Scales a size value from the PPI setting for the Screen to the PPI setting for the Font in the control.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.ScaleScreenToFont.Result">
        <short>
          Scaled size value.
        </short>
      </element>
      <element name="TControl.ScaleScreenToFont.ASize">
        <short>
          Original size value scaled in the method.
        </short>
      </element>

      <element name="TControl.ScaleFontToScreen">
        <short>
          Scales a size value from the PPI setting for the Font to the PPI setting for the Screen.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.ScaleFontToScreen.Result">
        <short>
          Scaled size value.
        </short>
      </element>
      <element name="TControl.ScaleFontToScreen.ASize">
        <short>
          Size value scaled in the method.
        </short>
      </element>

      <element name="TControl.Scale96ToScreen">
        <short>
          Scales a size value from 96 PPI to the PPI setting for the Screen.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.Scale96ToScreen.Result">
        <short>
          Scaled size value.
        </short>
      </element>
      <element name="TControl.Scale96ToScreen.ASize">
        <short>
          Size value scaled in the method.
        </short>
      </element>

      <element name="TControl.ScaleScreenTo96">
        <short>
          Scales a size value from the PPI setting for the Screen to 96 PPI.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.ScaleScreenTo96.Result">
        <short>
          Scaled size value.
        </short>
      </element>
      <element name="TControl.ScaleScreenTo96.ASize">
        <short>
          Size value scaled in the method.
        </short>
      </element>

      <element name="TControl.AdjustSize">
        <short>Smart way to <var>DoAutoSize</var>.
        </short>
        <descr>
          <p>
            <var>AdjustSize</var> is the same as Delphi the <var>TWinControl.DoAutoSize</var> method. But since <var>DoAutoSize</var> is commonly overridden in descendent components, it is not useful to perform all tests, which can result in too much overhead. To reduce this the LCL calls <var>AdjustSize</var> instead.
          </p>
          <p>
            During loading and handle creation the calls are delayed.
          </p>
        </descr>
        <seealso>
          <link id="TControl.AutoSize"/>
        </seealso>
      </element>

      <element name="TControl.AutoSizePhases">
        <short>Auto-sizing phases enabled for the control.</short>
        <descr>
          <p>
            <var>AutoSizePhases</var> is a <var>TControlAutoSizePhases</var> function used to get the <var>Autosizing</var> phases enabled for the control. In general, the values in AutoSizePhases depend on the <var>TWinControlFlag</var> values enabled for the control.
          </p>
          <p>
            For <var>TControl</var>, the values from the Parent control are used. If the Parent control is unassigned, the value is an empty set (<b>[]</b>).
          </p>
          <p>
            For <var>TWinControl</var>, the value from the Parent control are used (when a Parent has been assigned). Otherwise, the windows control flags are used to get the return value. For example:
          </p>
          <dl>
            <dt>wcfCreatingHandle,wcfCreatingChildHandles</dt>
            <dd>Includes caspCreatingHandles in the set</dd>
            <dt>wcfRealizingBounds</dt>
            <dd>Includes caspRealizingBounds in the set</dd>
            <dt>wcfUpdateShowing</dt>
            <dd>Includes caspShowing in the set</dd>
          </dl>
          <p>
            In addition, <var>AutoSizingAll</var> forces <var>caspComputingBounds</var> to be included in the set. <var>caspChangingProperties</var> is included when the internal auto-sizing lock count has a value greater than zero (<b>0</b>).
          </p>
        </descr>
        <seealso>
          <link id="TWinControlFlags"/>
          <link id="TControlAutoSizePhase"/>
        </seealso>
      </element>
      <element name="TControl.AutoSizePhases.Result">
        <short>Set with the TControlAutoSizePhase values.</short>
      </element>

      <element name="TControl.AutoSizeDelayed">
        <short>
          Returns true if auto-sizing must be has been delayed, until some other process is complete.
        </short>
      </element>
      <element name="TControl.AutoSizeDelayed.Result">
        <short>True if auto-sizing has been delayed.</short>
      </element>

      <element name="TControl.AutoSizeDelayedReport">
        <short>Returns a string with a debugging message for delayed auto-size requests.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.AutoSizeDelayedReport.Result">
        <short/>
      </element>

      <element name="TControl.AutoSizeDelayedHandle">
        <short>
          Returns true if AutoSize should be skipped or delayed because of its handle.
        </short>
        <descr>
          <p>
            A TControl instance does not have a handle, so it needs a parent control.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TControl.AutoSizeDelayedHandle.Result">
        <short/>
      </element>

      <element name="TControl.AnchorToNeighbour">
        <short>Anchor to Sibling at Side.</short>
        <descr>
          <p>
            Setup <var>AnchorSide</var> to anchor a side to a neighboring sibling control. For example: Right side to Left side, or Top side to Bottom.
          </p>
        </descr>
      </element>
      <element name="TControl.AnchorToNeighbour.Side">
        <short>The side to be anchored to Sibling.</short>
      </element>
      <element name="TControl.AnchorToNeighbour.Space">
        <short>The minimum space to Sibling.</short>
      </element>
      <element name="TControl.AnchorToNeighbour.Sibling">
        <short>The sibling control to which we should anchor.</short>
      </element>

      <element name="TControl.AnchorParallel">
        <short>Anchor parallel to Sibling, at Side.</short>
        <descr/>
      </element>
      <element name="TControl.AnchorParallel.Side">
        <short>The side to anchor to the sibling.</short>
      </element>
      <element name="TControl.AnchorParallel.Space">
        <short>The minimum space to Sibling.</short>
      </element>
      <element name="TControl.AnchorParallel.Sibling">
        <short>The sibling control to which we should anchor.</short>
      </element>

      <element name="TControl.AnchorHorizontalCenterTo">
        <short>Setup AnchorSide to center the control horizontally relative to a sibling.
        </short>
      </element>
      <element name="TControl.AnchorHorizontalCenterTo.Sibling">
        <short>The sibling control to which we should anchor.</short>
      </element>

      <element name="TControl.AnchorVerticalCenterTo">
        <short>Setup AnchorSide to center the control vertically relative to Sibling.
        </short>
      </element>
      <element name="TControl.AnchorVerticalCenterTo.Sibling">
        <short>The sibling control to which we should anchor.</short>
      </element>

      <element name="TControl.AnchorToCompanion">
        <short>Anchor to Sibling at Side, with the same extent.
        </short>
        <descr>
          <p>
            Table or tree style anchoring, into a neighbor cell of Sibling. Obtain the row height (or column width) from <var>Sibling</var>.
          </p>
        </descr>
      </element>
      <element name="TControl.AnchorToCompanion.Side">
        <short>The side to anchor to the sibling.</short>
      </element>
      <element name="TControl.AnchorToCompanion.Space">
        <short>The minimum space to Sibling.</short>
      </element>
      <element name="TControl.AnchorToCompanion.Sibling">
        <short>The sibling control to which we should anchor.</short>
      </element>
      <element name="TControl.AnchorToCompanion.FreeCompositeSide">
        <short/>
      </element>

      <element name="TControl.AnchorSame">
        <short>Copy Sibling's anchoring for Side.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.AnchorSame.Side">
        <short>The side to anchor like the sibling does.</short>
      </element>
      <element name="TControl.AnchorSame.Sibling">
        <short>The sibling control from which to inherit anchoring.</short>
      </element>

      <element name="TControl.AnchorAsAlign">
        <short>Anchor to Parent, following same rules as for Align.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.AnchorAsAlign.TheAlign">
        <short/>
      </element>
      <element name="TControl.AnchorAsAlign.Space">
        <short/>
      </element>

      <element name="TControl.AnchorClient">
        <short>Anchor to Parent's full client area.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.AnchorClient.Space">
        <short>The around space.</short>
      </element>

      <element name="TControl.AnchoredControlCount">
        <short>The number of controls anchored to this one.</short>
      </element>
      <element name="TControl.AnchoredControlCount.Result">
        <short/>
      </element>

      <element name="TControl.AnchoredControls">
        <short>The list of controls anchored to this one.</short>
      </element>
      <element name="TControl.AnchoredControls.Index">
        <short/>
      </element>

      <element name="TControl.SetBounds">
        <short>Sets the bounds (Left, Top, Width, Height) of the control.</short>
        <descr>
          <p>
            <var>SetBounds</var> can be used to change the <var>Left</var>, <var>Top</var>, <var>Width</var>, and <var>Height</var> properties as a single action. This reduces the overhead required for the common operation. Use <var>DisableAutoSize</var> and <var>EnableAutoSize</var> to reduce the overhead for recomputing/moving/resizing even further.
          </p>
          <p>
            <var>SetBounds</var> is also called when any one of these properties, or the BoundsRect property is set.
            SetBounds updates BaseBounds and BaseParentClientSize, which are used by the anchoring mechanism to keep the spacing between controls. For example loading a Form with TMemo and the .lfm contains TMemo's Left and Width, then SetBounds is called two times for the memo.
          </p>
          <p>
            When the user maximizes a window, SetBounds is called for the form, but not for the Memo, keeping the BaseBounds of the Memo. If the Memo is anchored to the right, the Width of the Memo is changed based on the BaseBounds and BaseParentClientSize.
          </p>
          <p>
            Keep in mind that the given aLeft, aTop, aWidth, aHeight might not be valid and will be changed by the LCL before applied.
          </p>
          <p>
            Delphi calls SetBounds more often. SetBounds calls ChangeBounds with the KeepBase argument set to False.
          </p>
        </descr>
      </element>
      <element name="TControl.SetBounds.aLeft">
        <short>The X coordinate of the left side of the control.</short>
      </element>
      <element name="TControl.SetBounds.aTop">
        <short>The Y coordinate of the top of the control.</short>
      </element>
      <element name="TControl.SetBounds.aWidth">
        <short>The width of the control.</short>
      </element>
      <element name="TControl.SetBounds.aHeight">
        <short>The height of the control.</short>
      </element>

      <element name="TControl.SetInitialBounds">
        <short>Sets the bounds of the control initially, when it is created.</short>
        <descr>Does nothing while the control is loaded.</descr>
        <seealso>
          <link id="TControl.SetBounds"/>
        </seealso>
      </element>
      <element name="TControl.SetInitialBounds.aLeft">
        <short>X coordinate for the top, left pixel.</short>
      </element>
      <element name="TControl.SetInitialBounds.aTop">
        <short>Y coordinate for the top, left pixel.</short>
      </element>
      <element name="TControl.SetInitialBounds.aWidth">
        <short>Width of control.</short>
      </element>
      <element name="TControl.SetInitialBounds.aHeight">
        <short>Height of control.</short>
      </element>

      <element name="TControl.SetBoundsKeepBase">
        <short>Set the bounds, keeping the base values.</short>
        <descr>
          <p>
            SetBoundsKeepBase is a procedure used to set the bounds for a Control to the specified values without affecting the bounds in a Parent control.
          </p>
          <p>
            SetBoundsKeepBase calls the ChangeBounds method to update the sized and position for the control to the specified values. If you use this in a custom control, disable LCL auto-sizing for this control prior to calling the method.
          </p>
          <p>
            SetBoundsKeepBase is used in the implementation for several methods, including:
          </p>
          <ul>
            <li>WMSize</li>
            <li>WMMove</li>
            <li>WMWindowPosChanged</li>
            <li>DoAutoSize</li>
            <li>DoAutoAdjustLayout</li>
            <li>DoUndock</li>
            <li>Loaded</li>
          </ul>
        </descr>
        <seealso>
          <link id="TControl.WMSize"/>
          <link id="TControl.WMMove"/>
          <link id="TControl.DoAutoSize"/>
          <link id="TControl.DoAutoAdjustLayout"/>
          <link id="TWinControl.WMWindowPosChanged"/>
          <link id="TWinControl.DoUndock"/>
          <link id="TControl.Loaded"/>
        </seealso>
      </element>
      <element name="TControl.SetBoundsKeepBase.aLeft">
        <short>New Left coordinate for the control.</short>
      </element>
      <element name="TControl.SetBoundsKeepBase.aTop">
        <short>New Right coordinate for the control.</short>
      </element>
      <element name="TControl.SetBoundsKeepBase.aWidth">
        <short>New Width for the control.</short>
      </element>
      <element name="TControl.SetBoundsKeepBase.aHeight">
        <short>New Height for the control.</short>
      </element>

      <element name="TControl.GetPreferredSize">
        <short>Returns default/preferred height and width, for use in auto-sizing.</short>
        <descr>
          <p>
            Called during AutoSize calculations. Only positive values are valid. Negative or 0 are treated as undefined and the LCL uses other sizes instead.
          </p>
          <p>
            WithThemeSpace: If true, adds space for stacking.
          </p>
          <p>
            For example: <var>TRadioButton</var> has a minimum size. But for stacking multiple TRadioButtons there should be some space around. This space is theme dependent, so the parameter is passed to the widgetset
          </p>
          <p>
            <var>TWinControl</var> overrides this and asks the interface for theme dependent values. See <link id="TWinControl.CalculatePreferredSize"/> for more information.
          </p>
        </descr>
      </element>
      <element name="TControl.GetPreferredSize.PreferredWidth">
        <short/>
      </element>
      <element name="TControl.GetPreferredSize.PreferredHeight">
        <short/>
      </element>
      <element name="TControl.GetPreferredSize.Raw">
        <short>
          When False, the values will be adjusted by the constraints, and undefined values will be replaced by GetDefaultWidth/GetDefaultHeight.
        </short>
      </element>
      <element name="TControl.GetPreferredSize.WithThemeSpace">
        <short>If true, adds space for stacking.</short>
      </element>

      <element name="TControl.GetCanvasScaleFactor">
        <short>Gets the scaling factor for the canvas used to render the control.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.GetCanvasScaleFactor.Result">
        <short/>
      </element>

      <element name="TControl.GetDefaultWidth">
        <short>
          The default width for this control, independent of any calculated values like Width and GetPreferredSize.
        </short>
      </element>
      <element name="TControl.GetDefaultWidth.Result">
        <short/>
      </element>

      <element name="TControl.GetDefaultHeight">
        <short>
          The default height for this control, independent of any calculated values like Height and GetPreferredSize.
        </short>
      </element>
      <element name="TControl.GetDefaultHeight.Result">
        <short/>
      </element>

      <element name="TControl.GetDefaultColor">
        <short>Get the default color for this widget, from Parent or color type.</short>
        <descr/>
        <seealso>
          <link id="TControl.Color"/>
          <link id="TControl.ParentColor"/>
          <link id="TControl.GetColorResolvingParent"/>
          <link id="TControl.GetRGBColorResolvingParent"/>
        </seealso>
      </element>
      <element name="TControl.GetDefaultColor.Result">
        <short/>
      </element>
      <element name="TControl.GetDefaultColor.DefaultColorType">
        <short>The color type to use, as the last resort.</short>
      </element>

      <element name="TControl.GetColorResolvingParent">
        <short>
          Returns the color of the control while resolving clDefault and ParentColor.
        </short>
        <descr>
          GetColorResolvingParent is a convenience routine used to obtain the Color for the control while resolving clDefault. It will never return clDefault, but it might return a non-RGB color. To obtain a purely RGB result use GetRGBColorResolvingParent.
        </descr>
        <seealso>
          <link id="TControl.Color"/>
          <link id="TControl.GetDefaultColor"/>
          <link id="TControl.ParentColor"/>
          <link id="TControl.GetRGBColorResolvingParent"/>
        </seealso>
      </element>

      <element name="TControl.GetRGBColorResolvingParent">
        <short>Returns a RGB value for the color of the control.</short>
        <descr>
          This convenience routine will allow to obtain the Color of the control while resolving clDefault, ParentColor and system color indexes and returns a TColor value.
        </descr>
        <seealso>
          <link id="TControl.Color"/>
          <link id="TControl.GetDefaultColor"/>
          <link id="TControl.ParentColor"/>
          <link id="TControl.GetColorResolvingParent"/>
        </seealso>
      </element>

      <element name="TControl.GetSidePosition">
        <short>The client coordinate of the given side.</short>
      </element>
      <element name="TControl.GetSidePosition.Result">
        <short/>
      </element>
      <element name="TControl.GetSidePosition.Side">
        <short/>
      </element>

      <element name="TControl.CNPreferredSizeChanged">
        <short>Message handler for preferred size changed.</short>
      </element>

      <element name="TControl.InvalidatePreferredSize">
        <short>
          Marks the preferred size as invalid for this control and all parents (implies that we will look for another).
        </short>
      </element>

      <element name="TControl.GetAnchorsDependingOnParent">
        <short>Returns the sides which are anchored to the Parent.</short>
      </element>
      <element name="TControl.GetAnchorsDependingOnParent.Result">
        <short/>
      </element>
      <element name="TControl.GetAnchorsDependingOnParent.WithNormalAnchors">
        <short/>
      </element>

      <element name="TControl.DisableAutoSizing">
        <short>
          Disables automatic sizing; implies that the default size is accepted, or sizing is done manually.
        </short>
      </element>

      <element name="TControl.EnableAutoSizing">
        <short>Turns on (enables) automatic sizing.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.UpdateBaseBounds">
        <short>Update the basic boundaries of the control - essential if there has been a lot of re-sizing.</short>
      </element>
      <element name="TControl.UpdateBaseBounds.StoreBounds">
        <short/>
      </element>
      <element name="TControl.UpdateBaseBounds.StoreParentClientSize">
        <short/>
      </element>
      <element name="TControl.UpdateBaseBounds.UseLoadedValues">
        <short/>
      </element>

      <element name="TControl.BaseBounds">
        <short>The rectangle of the designed bounds.</short>
        <descr>The current Bounds can change, due to scaling, anchoring or auto-sizing.
        </descr>
        <seealso>
          <link id="TControl.Anchors"/>
          <link id="TControl.AnchorSide"/>
          <link id="TControl.AutoSize"/>
          <link id="TControl.SetBoundsKeepBase"/>
        </seealso>
      </element>

      <element name="TControl.ReadBounds">
        <short>
          Reflects the Bounds for the Control read during LCL component streaming.
        </short>
        <descr>
          <p>
            <var>ReadBounds</var> is a read-only <var>TRect</var> property used when the values for the Top, Left, Height and Width properties are set during LCL component streaming. When ComponentState contains <var>csLoading</var>, changes to these properties cause the new values to be applied to ReadBounds prior to calling the SetBounds method. The internal ControlFlags are also updated to indicate that the property value has been loaded using LCL component  streaming.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Left"/>
          <link id="TControl.Top"/>
          <link id="TControl.Width"/>
          <link id="TControl.Height"/>
          <link id="TControl.SetBounds"/>
          <link id="TControl.BaseBounds"/>
          <link id="TControlFlag"/>
        </seealso>
      </element>

      <element name="TControl.BaseParentClientSize">
        <short>The Parent's client size, for which the BaseBounds are valid.</short>
        <descr>
          <p>
            BaseBounds and BaseParentClientSize determine the distance to keep from Parent's sides, when a side is anchored to the Parent (akLeft...), and the Parent is resized.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TControl.WriteLayoutDebugReport">
        <short>Used for debugging.</short>
      </element>
      <element name="TControl.WriteLayoutDebugReport.Prefix">
        <short/>
      </element>

      <element name="TControl.AutoAdjustLayout">
        <short>Applies an automatic adjustment layout policy to the control.</short>
        <descr>
          <p>
            AutoAdjustLayout can be used to alter PPI settings, scale the control, or apply changes to height or width without scaling.
          </p>
          <p>
            AMode indicates the layout policy applied in the method, and the actions performed to achieve the task.
          </p>
          <p>
            Scaling factors are calculated (when needed) for both horizontal (X-axis) and vertical (Y-axis ) adjustments. The factors may represent changes to the PPI settings, or changes in the width for the control.
          </p>
          <p>
            AutoAdjustLayout temporarily disables auto-sizing, and calls DoAutoAdjustLayout to apply the scaling factors or size changes.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TControl.AutoAdjustLayout.AMode">
        <short/>
      </element>
      <element name="TControl.AutoAdjustLayout.AFromPPI">
        <short/>
      </element>
      <element name="TControl.AutoAdjustLayout.AToPPI">
        <short/>
      </element>
      <element name="TControl.AutoAdjustLayout.AOldFormWidth">
        <short/>
      </element>
      <element name="TControl.AutoAdjustLayout.ANewFormWidth">
        <short/>
      </element>

      <element name="TControl.ShouldAutoAdjust">
        <short>
          Indicates whether the height and/or width for a control can be automatically adjusted.
        </short>
        <descr>
          <p>
            In TControl, both AWidth and AHeight are set to True when the AutoSize property has not been enabled.
          </p>
        </descr>
        <seealso>
          <link id="TControl.AutoSize"/>
        </seealso>
      </element>
      <element name="TControl.ShouldAutoAdjust.AWidth">
        <short>True if the width can be auto-adjusted.</short>
      </element>
      <element name="TControl.ShouldAutoAdjust.AHeight">
        <short>True if the height can be auto-adjusted.</short>
      </element>

      <element name="TControl.FixDesignFontsPPI">
        <short>Corrects the font size for High-DPI-aware applications.</short>
        <descr>
          <p>
            FixDesignFontsPPI is a method used to adjust the font size when the design-time PPI (Pixels per Inch) setting differs from the run-time PPI setting for the font in the control.  It calls DoFixDesignFontPPI to restore the value in ADesignTimePPI to the Font reference passed as an argument to to the method. The font height is scaled using the factor represented by TFont.PixelsPerInch/ADesignTimePPI.
          </p>
          <p>
            This method does not trigger a CM_PARENTFONTCHANGED message in the Parent control.
          </p>
          <p>
            In TControl, this action is performed for the Font property. In descendent class, additional properties with a font reference may also be adjusted using the method.
          </p>
          <p>
            FixDesignFontsPPI is called when scaling is enabled, and the Form which hosts the control calls its Loaded method when LCL streaming is completed.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TControl.FixDesignFontsPPI.ADesignTimePPI">
        <short>Design-time PPI setting applied for the font size adjustment.</short>
      </element>

      <element name="TControl.ScaleFontsPPI">
        <short>Resizes a font to the specified Pixels per Inch setting.</short>
        <descr>
        <p>
            ScaleFontsPPI is a method used to resize a font in the control to the specified display density (Pixels per Inch) using the scaling factor in AProportion (when needed).
        </p>
          <p>
            A font may need to be scaled when the run-time PPI setting for the screen differs from the design-time value applied to the font. If the font height is not assigned at run-time, its height is set to the value in TFont.PixelsPerInch / Screen.PixelsPerInch.
          </p>
          <p>
            When AToPPI has a positive non-zero value, it is stored in the TFont.PixelsPerInch property for the font. Otherwise, the existing TFont.PixelsPerInch value is adjusted using the scaling factor in AProportion.
          </p>
          <p>
            ScaleFontsPPI may be overridden in descendent controls to call the method for its child controls.
          </p>
          <p>
            ScaleFontsPPI is called form the AutoAdjustLayout method.
          </p>
        </descr>
        <seealso>
          <link id="TControl.AutoAdjustLayout"/>
          <link id="TControl.ShouldAutoAdjust"/>
        </seealso>
      </element>
      <element name="TControl.ScaleFontsPPI.AToPPI">
        <short>PPI setting to apply to the font.</short>
      </element>
      <element name="TControl.ScaleFontsPPI.AProportion">
        <short>Scaling factor applied to the font height.</short>
      </element>

      <element name="TControl.Create">
        <short>Constructor for the class instance.</short>
        <descr>
          <p>
            Create is the overridden constructor for the class instance. Create calls the inherited constructor using TheOwner as the owner for the class instance. Resources are allocated in the method for members in the class instance, and the default values are set for the following properties:
          </p>
          <ul>
            <li>Align</li>
            <li>Anchors</li>
            <li>BaseBounds</li>
            <li>CaptureMouseButtons</li>
            <li>Color</li>
            <li>ControlStyle</li>
            <li>Cursor</li>
            <li>DesktopFont</li>
            <li>DragCursor</li>
            <li>Enabled</li>
            <li>FloatingDockSiteClass</li>
            <li>Font</li>
            <li>HelpType</li>
            <li>IsControl</li>
            <li>ParentBidiMode</li>
            <li>ParentColor</li>
            <li>ParentFont</li>
            <li>ParentShowHint</li>
            <li>Visible</li>
            <li>WindowProc</li>
          </ul>
          <remark>
            Create ensures that auto-sizing is disabled until the class instance is fully realized. Auto-sizing is re-enabled on exit from the method.
          </remark>
        </descr>
        <seealso>
          <link id="TControl.Destroy"/>
        </seealso>
      </element>
      <element name="TControl.Create.TheOwner">
        <short>The owning component.</short>
      </element>

      <element name="TControl.Destroy">
        <short>Removes the control from its Parent.</short>
        <descr>
          <p>Detaches the control from Parent, removes graphics, frees memory and Operating System handles, pointers etc.</p>
        </descr>
        <seealso>
          <link id="#lcl.lclclasses.TLCLComponent.Destroy">TLCLComponent.Destroy</link>
          <link id="#rtl.classes.TComponent.Destroy">TComponent.Destroy</link>
        </seealso>
      </element>

      <element name="TControl.BeforeDestruction">
        <short>
          Performs notifications to before destruction handlers added to the control.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.EditingDone">
        <short>Invokes the <var>OnEditingDone</var> event handler.</short>
        <descr>
          <p>
            Called when user has finished editing. This procedure can be used by data links to commit the changes.
          </p>
          <p>For example:</p>
          <ul>
            <li>When focus switches to another control (default).</li>
            <li>When user selected another item.</li>
          </ul>
          <p>It's totally up to the control, what events will commit.</p>
        </descr>
      </element>

      <element name="TControl.ExecuteDefaultAction">
        <short>Called when the RETURN button is pressed, signifying default action.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.ExecuteCancelAction">
        <short>Called when ESCAPE is hit or the CANCEL button is clicked - signifying CANCEL.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.BeginDrag">
        <short>Starts dragging the control (programmatically).</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.BeginDrag.Immediate">
        <short>If False, start dragging only after the mouse has moved.</short>
      </element>
      <element name="TControl.BeginDrag.Threshold">
        <short>Minimum mouse movement before delayed dragging starts (in pixels); -1 means DragManager default; ignored if Immediate=True.</short>
      </element>

      <element name="TControl.EndDrag">
        <short>Ends a drag operation by notifying the drag manager.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.EndDrag.Drop">
        <short/>
      </element>

      <element name="TControl.BringToFront">
        <short>Bring the control in front of all sibling controls.</short>
      </element>

      <element name="TControl.HasParent">
        <short>Returns True if there is a parent component responsible for streaming.</short>
        <descr>
          <p>
            This function will be called during streaming to decide if a component has to be streamed by its owner or parent.
          </p>
        </descr>
        <seealso>
          <link id="#rtl.classes.TComponent.HasParent">TComponent.HasParent</link>
        </seealso>
      </element>
      <element name="TControl.HasParent.Result">
        <short>True if there is a Parent.</short>
      </element>

      <element name="TControl.GetParentComponent">
        <short>Returns Parent (implements TComponent.GetParentComponent).</short>
      </element>
      <element name="TControl.GetParentComponent.Result">
        <short>The Parent property.</short>
      </element>

      <element name="TControl.IsParentOf">
        <short>Determines whether this control is a parent of AControl.</short>
        <descr>
          <p>
            The recursive search in all Parents of AControl finds not only immediate parent/child controls.
          </p>
        </descr>
      </element>
      <element name="TControl.IsParentOf.Result">
        <short>True if this control is a parent of AControl.</short>
      </element>
      <element name="TControl.IsParentOf.AControl">
        <short>The control of which this control may be a parent.</short>
      </element>

      <element name="TControl.GetTopParent">
        <short>Find the control that is the top-most parent.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.GetTopParent.Result">
        <short/>
      </element>

      <element name="TControl.FindSubComponent">
        <short>
          Finds the sub-component with the specified name in the components property.
        </short>
        <descr>
          <p>
            FindSubComponent is a TComponent function used to get the sub-component with the name specified in AName. FindSubComponent is similar to TComponent.FindComponent, but accepts a prefixed component name in AName. For example: 'LabeledEdit1.EditLabel'.
          </p>
          <p>
            FindSubComponent separates the value in AName into the owner and sub-component names. When a prefix is used, the FindComponent method is called to locate the TComponent instance with the owner name. Its FindComponent method is called to get the component with the sub-component name that is used in the return value. If a prefix is not used, the initial component is used as the return value.
          </p>
          <p>
            The return value is Nil if a component is not found with the specified name.
          </p>
        </descr>
        <seealso>
          <link id="#rtl.classes.TComponent.FindComponent">TComponent.FindComponent</link>
          <link id="#rtl.classes.TComponent.Components">TComponent.Components</link>
        </seealso>
      </element>
      <element name="TControl.FindSubComponent.Result">
        <short>The component with the specified name, or Nil when not found.</short>
      </element>
      <element name="TControl.FindSubComponent.AName">
        <short>Parentage/path for the sub-component to retrieve in the method.</short>
      </element>

      <element name="TControl.IsVisible">
        <short>Returns True if the control is visible, including all of its Parents.</short>
        <seealso>
          <link id="TControl.Visible"/>
        </seealso>
      </element>
      <element name="TControl.IsVisible.Result">
        <short>True only if all Parents also are visible.</short>
      </element>

      <element name="TControl.IsControlVisible">
        <short>True if the control is Visible, or is in design mode.</short>
        <descr>
          <p>Does not check for invisible parents.</p>
        </descr>
        <seealso>
          <link id="TControl.Visible"/>
        </seealso>
      </element>
      <element name="TControl.IsControlVisible.Result">
        <short/>
      </element>

      <element name="TControl.IsEnabled">
        <short>Returns True if the control is Enabled, including all of its Parents.</short>
      </element>
      <element name="TControl.IsEnabled.Result">
        <short>True only if all Parents also are enabled.</short>
      </element>

      <element name="TControl.IsParentColor">
        <short>Provides access to the value in the protected ParentColor property.</short>
        <descr>
          <p>
            Checks the value in the member for the protected ParentColor property. Used in places where we need to check ParentColor property from TControl. Needed for widgetset classes.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TControl.IsParentColor.Result">
        <short>True when ParentColor is set to True.</short>
      </element>

      <element name="TControl.IsParentFont">
        <short>Provides access to the value in the protected ParentFont property.</short>
        <descr>
          <p>
            Checks the value in the member for the protected ParentFont property. Used in places where we need to check ParentFont from TControl.
            Needed for widgetset classes.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TControl.IsParentFont.Result">
        <short>True when ParentFont is set to True.</short>
      </element>

      <element name="TControl.FormIsUpdating">
        <short>True if the form is being updated.</short>
        <descr>
          <p>
            The return value is True a value has been assigned to Parent, and its FormIsUpdating method returns True.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TControl.FormIsUpdating.Result">
        <short>True if the form is being updated.</short>
      </element>

      <element name="TControl.IsProcessingPaintMsg">
        <short>True while painting the control.</short>
        <descr>
          <p>
            As the name implies, the cfProcessingWMPaint flag in FControlFlags is set while a LM_PAINT message is processed, and IsProcessingPaintMsg checks this flag.
          </p>
        </descr>
      </element>
      <element name="TControl.IsProcessingPaintMsg.Result">
        <short>True when the control flags contain a value for paint methods.</short>
      </element>

      <element name="TControl.Hide">
        <short>Hides this control, by setting Visible to False.</short>
        <seealso>
          <link id="TControl.Visible"/>
          <link id="TControl.Show"/>
        </seealso>
      </element>

      <element name="TControl.Refresh">
        <short>Causes the control to be redrawn.</short>
        <descr>
          <p>
            Calls the Repaint method.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Repaint"/>
        </seealso>
      </element>

      <element name="TControl.Repaint">
        <short>Immediately redraws the control when visible, bypassing the message queue.</short>
        <descr/>
        <seealso>
          <link id="TControl.Parent"/>
          <link id="TControl.IsVisible"/>
          <link id="TControl.ControlStyle"/>
          <link id="TControl.Invalidate"/>
          <link id="TControl.Update"/>
          <link id="TWinControl.PaintControls"/>
          <link id="#rtl.classes.TComponent.ComponentState">TComponent.ComponentState</link>
        </seealso>
      </element>

      <element name="TControl.Invalidate">
        <short>
          Force a delayed Repaint of the control, by marking its visible area of the control as invalid.
        </short>
      </element>

      <element name="TControl.CheckChildClassAllowed">
        <short>Returns True if the class is allowed for child controls.</short>
        <descr>
          Only few controls restrict the class of acceptable child controls. E.g. a PageControl only accepts TTabSheet descendants as children
        </descr>
        <errors>
          An EInvalidOperation can be generated (see ExceptionOnInvalid).
        </errors>
      </element>
      <element name="TControl.CheckChildClassAllowed.Result">
        <short>True if the class is allowed for child controls.</short>
      </element>
      <element name="TControl.CheckChildClassAllowed.ChildClass">
        <short>The class of the intended child control.</short>
      </element>
      <element name="TControl.CheckChildClassAllowed.ExceptionOnInvalid">
        <short>When True, raise an exception when the class is not allowed.</short>
      </element>

      <element name="TControl.CheckNewParent">
        <short>Checks if this control can become a child of AParent.</short>
        <descr>
          This check is performed during SetParent. It calls CheckChildClassAllowed and whether AParent is the current class instance (Self).
        </descr>
        <errors>
          An EInvalidOperation occurs when any test fails.
        </errors>
      </element>
      <element name="TControl.CheckNewParent.AParent">
        <short>The new Parent for this control.</short>
      </element>

      <element name="TControl.SendToBack">
        <short>Moves all sibling controls in front of this control.</short>
        <descr>
          <p>
            Use SendToBack to supply an specific background (image) for the Parent control. Only those portions of the control not covered by other controls will be visible.
          </p>
        </descr>
      </element>

      <element name="TControl.SetTempCursor">
        <short>
          Changes the cursor shape temporarily, preserving the original <link id="TControl.Cursor"/>
        </short>
      </element>
      <element name="TControl.SetTempCursor.Value">
        <short>The temporary cursor shape for the control.</short>
      </element>

      <element name="TControl.UpdateRolesForForm">
        <short>
          Internal method called by a Form when its DefaultControl or CancelControl has changed.
        </short>
        <descr>
          This method is overridden in TCustomButton, where it updates the Cancel and Default properties for the control.
        </descr>
        <seealso>
          <link id="TControl.ActiveDefaultControlChanged"/>
        </seealso>
      </element>

      <element name="TControl.ActiveDefaultControlChanged">
        <short>
          Notification of a changed active DefaultControl of a form.
        </short>
        <descr>
          When the user pressed ENTER in a form, its DefaultControl will receive a Click event.
        </descr>
        <errors>
          Currently NewControl can be Nil, even if it should not be.
        </errors>
      </element>
      <element name="TControl.ActiveDefaultControlChanged.NewControl">
        <short>The new DefaultControl.</short>
      </element>

      <element name="TControl.GetTextBuf">
        <short>Copy the <link id="TControl.Text">Text</link> property into Buffer.</short>
        <descr>
          <p>This method only exists for Delphi compatibility.
          </p>
          <p>Don't use or override it, unless really necessary.
          </p>
        </descr>
        <seealso>
          <link id="TControl.RealGetText"/>
        </seealso>
      </element>
      <element name="TControl.GetTextBuf.Result">
        <short>Length of the copied text.</short>
      </element>
      <element name="TControl.GetTextBuf.Buffer">
        <short>Pointer to the buffer receiving the string.</short>
      </element>
      <element name="TControl.GetTextBuf.BufSize">
        <short>Length of the buffer.</short>
      </element>

      <element name="TControl.GetTextLen">
        <short>The length of Text, here: of Caption.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.GetTextLen.Result">
        <short/>
      </element>

      <element name="TControl.SetTextBuf">
        <short>
          Updates the <link id="TControl.Text">Text</link> property from a PChar buffer.
        </short>
        <descr>
          <p>This method only exists for Delphi compatibility.</p>
          <p>Don't use or override it, unless really necessary.</p>
        </descr>
        <seealso>
          <link id="TControl.RealSetText"/>
        </seealso>
      </element>
      <element name="TControl.SetTextBuf.Buffer">
        <short>Pointer to the buffer containing the zero-terminated text.</short>
      </element>

      <element name="TControl.Perform">
        <short>Direct call of an message handler, bypassing the message queue.</short>
        <descr>
          The parameters and result depend on the concrete message.
        </descr>
        <seealso/>
      </element>
      <element name="TControl.Perform.Result">
        <short/>
      </element>
      <element name="TControl.Perform.Msg">
        <short/>
      </element>
      <element name="TControl.Perform.WParam">
        <short/>
      </element>
      <element name="TControl.Perform.LParam">
        <short/>
      </element>

      <element name="TControl.ScreenToClient">
        <short>Convert absolute screen coordinates into client-relative coordinates.</short>
        <seealso>
          <link id="TControl.ClientToScreen"/>
        </seealso>
      </element>
      <element name="TControl.ScreenToClient.Result">
        <short/>
      </element>
      <element name="TControl.ScreenToClient.APoint">
        <short/>
      </element>

      <element name="TControl.ClientToScreen">
        <short>Convert client-relative coordinates into absolute screen coordinates.</short>
        <seealso>
          <link id="TControl.ScreenToClient"/>
        </seealso>
      </element>
      <element name="TControl.ClientToScreen.Result">
        <short/>
      </element>
      <element name="TControl.ClientToScreen.APoint">
        <short/>
      </element>

      <element name="TControl.ScreenToControl">
        <short>Convert absolute screen coordinates into control-relative coordinates.</short>
        <seealso>
          <link id="TControl.ControlToScreen"/>
          <link id="TControl.ScreenToClient"/>
          <link id="TControl.ClientToScreen"/>
        </seealso>
      </element>
      <element name="TControl.ScreenToControl.Result">
        <short/>
      </element>
      <element name="TControl.ScreenToControl.APoint">
        <short/>
      </element>

      <element name="TControl.ControlToScreen">
        <short>Converts control-relative coordinates to absolute screen coordinates.</short>
        <seealso>
          <link id="TControl.ScreenToControl"/>
          <link id="TControl.ScreenToClient"/>
          <link id="TControl.ClientToScreen"/>
        </seealso>
      </element>
      <element name="TControl.ControlToScreen.Result">
        <short/>
      </element>
      <element name="TControl.ControlToScreen.APoint">
        <short/>
      </element>

      <element name="TControl.ClientToParent">
        <short>
          Converts the screen coordinates for the control to the screen coordinates for the specified parent control.
        </short>
        <descr>
          <p>
            ClientToParent is a TPoint function used to convert the screen coordinates for the control to the screen coordinates for the specified parent control. If Aparent is unassigned, the Parent property for the control is used in the method.
          </p>
          <p>
            ClientToParent calls the IsParentOf method in AParent to determine if control is in its control hierarchy. An EInvalidOperation exception is raised if the return value from IsParentOf is False.
          </p>
          <p>
            The return value is determined by converting the client coordinates for the control to screen coordinates, and asking the parent control to convert them back to the client coordinates for the parent control.
          </p>
          <p>
            ClientToParent is used, for instance, in the TScrollingWinControl.ScrollInView method.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TControl.ClientToParent.Result">
        <short>
          TPoint instance with the client coordinates adjusted to the parent control.
        </short>
      </element>
      <element name="TControl.ClientToParent.Point">
        <short>TPoint instance with the client coordinates for the control.</short>
      </element>
      <element name="TControl.ClientToParent.AParent">
        <short>Parent control with the bounds for the adjusted coordinates.</short>
      </element>

      <element name="TControl.ParentToClient">
        <short>
          Converts the screen coordinates for the parent control to the screen coordinates for the control.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.ParentToClient.Result">
        <short/>
      </element>
      <element name="TControl.ParentToClient.Point">
        <short/>
      </element>
      <element name="TControl.ParentToClient.AParent">
        <short/>
      </element>

      <element name="TControl.GetChildrenRect">
        <short>Get the visible part of a possibly scrolled client area.</short>
        <descr>
          <p>
            If <var>Scrolled</var> is False, the ScrollOffset is ignored, so that the ClientRect is returned. Returns the Client rectangle relative to the left and top for the control. If Scrolled is true, the rectangle is moved by the current scrolling values (for an example see TScrollingWincontrol).
          </p>
        </descr>
      </element>
      <element name="TControl.GetChildrenRect.Result">
        <short>The visible part of the client area.</short>
      </element>
      <element name="TControl.GetChildrenRect.Scrolled">
        <short>True forces scrolling taken into account.</short>
      </element>

      <element name="TControl.Show">
        <short>Makes the control visible, by setting Visible to True.</short>
        <descr/>
        <seealso>
          <link id="TControl.Visible"/>
          <link id="TControl.Hide"/>
          <link id="TWinControl.ShowControl"/>
        </seealso>
      </element>

      <element name="TControl.Update">
        <short>Redraw invalidated parts of the control immediately.</short>
      </element>

      <element name="TControl.HandleObjectShouldBeVisible">
        <short>True if the control shall be visible, unless it's being destroyed.</short>
        <descr/>
        <seealso>
          <link id="TControl.IsVisible"/>
        </seealso>
      </element>
      <element name="TControl.HandleObjectShouldBeVisible.Result">
        <short/>
      </element>

      <element name="TControl.ParentDestroyingHandle">
        <short>Returns True if any parent is destroying its Handle (and its children').</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.ParentDestroyingHandle.Result">
        <short/>
      </element>

      <element name="TControl.ParentHandlesAllocated">
        <short>Returns True if all Parents have handles allocated, and are not being destroyed.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.ParentHandlesAllocated.Result">
        <short/>
      </element>

      <element name="TControl.InitiateAction">
        <short>Update the action associated with this control.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.ShowHelp">
        <short>Show the Help associated with this control.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.HasHelp">
        <short>True when a HelpKeyword or HelpContext ID is assigned.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.HasHelp.Result">
        <short/>
      </element>

      <element link="#lcl.lclclasses.TLCLComponent.RemoveAllHandlersOfObject" name="TControl.RemoveAllHandlersOfObject"/>
      <element name="TControl.RemoveAllHandlersOfObject.AnObject">
        <short/>
      </element>

      <element name="TControl.AddHandlerOnResize">
        <short>Adds an handler for the <var>OnResize</var> event.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.AddHandlerOnResize.OnResizeEvent">
        <short/>
      </element>
      <element name="TControl.AddHandlerOnResize.AsFirst">
        <short/>
      </element>

      <element name="TControl.RemoveHandlerOnResize">
        <short>Removes an handler for the <var>OnResize</var> event.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.RemoveHandlerOnResize.OnResizeEvent">
        <short/>
      </element>

      <element name="TControl.AddHandlerOnChangeBounds">
        <short>Adds an handler for the <var>OnChangeBounds</var> event.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.AddHandlerOnChangeBounds.OnChangeBoundsEvent">
        <short/>
      </element>
      <element name="TControl.AddHandlerOnChangeBounds.AsFirst">
        <short/>
      </element>

      <element name="TControl.RemoveHandlerOnChangeBounds">
        <short>Removes an handler for the <var>OnChangeBounds</var> event.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.RemoveHandlerOnChangeBounds.OnChangeBoundsEvent">
        <short/>
      </element>

      <element name="TControl.AddHandlerOnVisibleChanging">
        <short>Adds an <var>OnVisibleChanging</var> handler.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.AddHandlerOnVisibleChanging.OnVisibleChangingEvent">
        <short/>
      </element>
      <element name="TControl.AddHandlerOnVisibleChanging.AsFirst">
        <short/>
      </element>

      <element name="TControl.RemoveHandlerOnVisibleChanging">
        <short>Removes an <var>OnVisibleChanging</var> handler.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.RemoveHandlerOnVisibleChanging.OnVisibleChangingEvent">
        <short/>
      </element>

      <element name="TControl.AddHandlerOnVisibleChanged">
        <short>Adds an <var>OnVisibleChanged</var> handler.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.AddHandlerOnVisibleChanged.OnVisibleChangedEvent">
        <short/>
      </element>
      <element name="TControl.AddHandlerOnVisibleChanged.AsFirst">
        <short/>
      </element>

      <element name="TControl.RemoveHandlerOnVisibleChanged">
        <short>Removes an <var>OnVisibleChanged</var> handler.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.RemoveHandlerOnVisibleChanged.OnVisibleChangedEvent">
        <short/>
      </element>

      <element name="TControl.AddHandlerOnEnabledChanged">
        <short>Adds an <var>OnEnabledChanged</var> handler.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.AddHandlerOnEnabledChanged.OnEnabledChangedEvent">
        <short/>
      </element>
      <element name="TControl.AddHandlerOnEnabledChanged.AsFirst">
        <short/>
      </element>

      <element name="TControl.RemoveHandlerOnEnableChanging">
        <short>Removes an <var>OnEnabledChanged</var> handler.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.RemoveHandlerOnEnableChanging.OnEnableChangingEvent">
        <short/>
      </element>

      <element name="TControl.AddHandlerOnKeyDown">
        <short>Adds an handler for the <var>OnKeyDown</var> event.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.AddHandlerOnKeyDown.OnKeyDownEvent">
        <short/>
      </element>
      <element name="TControl.AddHandlerOnKeyDown.AsFirst">
        <short/>
      </element>

      <element name="TControl.RemoveHandlerOnKeyDown">
        <short>Removes an handler for the <var>OnKeyDown</var> event.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.RemoveHandlerOnKeyDown.OnKeyDownEvent">
        <short/>
      </element>

      <element name="TControl.AddHandlerOnBeforeDestruction">
        <short>Adds a handler for OnBeforeDestruction events.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.AddHandlerOnBeforeDestruction.OnBeforeDestructionEvent">
        <short/>
      </element>
      <element name="TControl.AddHandlerOnBeforeDestruction.AsFirst">
        <short/>
      </element>

      <element name="TControl.RemoveHandlerOnBeforeDestruction">
        <short>Removes a handler for OnBeforeDestruction events.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.RemoveHandlerOnBeforeDestruction.OnBeforeDestructionEvent">
        <short/>
      </element>

      <element name="TControl.AddHandlerOnMouseWheel">
        <short>Adds a handler for OnMouseWheel events.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.AddHandlerOnMouseWheel.OnMouseWheelEvent">
        <short/>
      </element>
      <element name="TControl.AddHandlerOnMouseWheel.AsFirst">
        <short/>
      </element>

      <element name="TControl.RemoveHandlerOnMouseWheel">
        <short>Removes a handler for OnMouseWheel events.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.RemoveHandlerOnMouseWheel.OnMouseWheelEvent">
        <short/>
      </element>

      <element name="TControl.AccessibleName">
        <short>Contains the accessible name for the control.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.AccessibleDescription">
        <short>
          The accessible description of the control.This should describe the role of the control, for example for TLabel it could be "a text caption"
        </short>
        <descr>
          The accessible description of the control. This should describe the role of the control, for example for TLabel it could be "a text caption". This property is connected and synchronized with the accessibility description in TControl.
        </descr>
        <seealso>
          <link id="TLazAccessibleObject.AccessibleDescription"/>
        </seealso>
      </element>

      <element name="TControl.AccessibleValue">
        <short>
          The accessible value of the control.
        </short>
        <descr>
          <p>
            The accessible value of the control. For example, for <var>TLabel</var> it would be the same as the <var>Caption</var> property. This property is connected and synchronized with <var>TControl.GetAccessibleObject().AccessibleValue</var>.
          </p>
        </descr>
        <seealso>
          <link id="TLazAccessibleObject.AccessibleValue"/>
        </seealso>
      </element>

      <element name="TControl.AccessibleRole">
        <short>
          The accessible role of the control which classifies what kind of object this is. See TLazAccessibilityRole for a list of possible values.
        </short>
        <seealso>
          <link id="TLazAccessibilityRole"/>
          <link id="TLazAccessibleObject.AccessibleRole"/>
        </seealso>
      </element>

      <element name="TControl.Action">
        <short>The Action associated with the control.</short>
        <descr>
          <p>
            <var>Action</var> is a <var>TBasicAction</var> property with the action assigned to the control. The value for the property is read from the Action property in ActionLink (when assigned). If ActionLink has not been assigned, the property value is <b>Nil</b>.
          </p>
          <p>
            Assigning an action to the property causes ActionLink to be updated. If the new property value is <b>Nil</b>, the TControlActionLink instance in ActionLink is freed and control style flags are updated to remove the value csActionClient.
          </p>
          <p>
            Conversely, a TControlActionLink instance is created for a non-empty action assignment. Its OnChange event handler is set to the private DoActionChange method in the class instance. Control style flags are updated to include the value csActionClient.
          </p>
          <p>
            Action is used in the Click method to signal its OnExecute event handler when assigned and enabled. Preference is given to the OnClick in the control (when  assigned).
          </p>
          <p>
            Values in the Caption, Enabled, HelpType, and Hint properties can be linked to the Action through the property values in the ActionLink.
          </p>
          <p>
            Use AssignTo to copy property values in the control to a TCustomAction instance.
          </p>
        </descr>
        <seealso>
          <link id="TControl.ActionLink"/>
          <link id="TControl.Enabled"/>
          <link id="TControl.Hint"/>
          <link id="TControl.Click"/>
          <link id="TControl.OnClick"/>
          <link id="TControlActionLink"/>
          <link id="#rtl.classes.TBasicAction">TBasicAction</link>
        </seealso>
      </element>

      <element name="TControl.Align">
        <short>
          Specifies the placement of the control inside its Parent.
        </short>
        <descr>
          <p>
            <var>Align</var> is a <var>TAlign</var> property which specifies how the control is aligned to its parent control. The default value for the property is <var>alNone</var>.
          </p>
          <dl>
            <dt>alNone</dt>
            <dd>
              The control is not aligned. It uses it Top, Left, Height, and Width to place the control in the parent.
            </dd>
            <dt>alTop</dt>
            <dd>
              Aligns the control to the top of the parent control, and adjusts it Width to fill the parent control.
            </dd>
            <dt>alBottom</dt>
            <dd>
              Aligns the control to the bottom of the parent control, and adjusts its Width  to fill the parent control.
            </dd>
            <dt>alLeft</dt>
            <dd>
              Aligns the control to the left edge of the parent control, and adjusts its Height to fill the parent control.
            </dd>
            <dt>alRight</dt>
            <dd>
              Aligns the control to the right edge of the parent control, and adjusts its Height to fill the parent control.
            </dd>
            <dt>alClient</dt>
            <dd>
              Aligns the control to fill the unused Height and Width for the parent control.
            </dd>
            <dt>alCustom</dt>
            <dd>
              Aligns the control by calling the OnAlignInsertBefore or OnAlignPosition event handlers in the parent control.
            </dd>
          </dl>
        </descr>
        <seealso>
          <link id="TAlign"/>
        </seealso>
      </element>

      <element name="TControl.Anchors">
        <short>The set of anchor definitions for this control.</short>
        <descr>
          <p>
            Anchors is a TAnchors property which contains the edges used to align the position of the control relative to its Parent. Anchors allow the control to be repositioned and/or resized when the parent control is resized. Coordinate values in the control - like Left, Top, Bottom, and Right properties -  are updated when the corresponding edge is anchored to its Parent.
          </p>
          <p>
            The default value for the property is [akLeft, akTop], and indicates that only the Top and Left coordinates are anchored in the parent control.
          </p>
          <p>
            For example:
          </p>
          <dl>
            <dt>
              [akLeft, akRight]
            </dt>
            <dd>
              Causes the relative width for the control to be adjusted when the width of the parent control is changed.
            </dd>
            <dt>
              [akTop, akBottom]
            </dt>
            <dd>
              Causes the relative height for the control to be adjusted when the height of the parent control is changed.
            </dd>
            <dt>
              [akTop, akLeft, akRight]
            </dt>
            <dd>
              Causes the relative width (but not the height) for the control to be adjusted when the parent is resized. Like using the Align property.
            </dd>
            <dt>
              [akTop, akLeft, akBottom, akRight]
            </dt>
            <dd>
              Causes both the height and width to be adjusted when the parent control is resized. Like using alCustom in Align.
            </dd>
          </dl>
          <p>
            Setting a new value for the property causes the UpdateAnchorRules and AdjustSize methods to be called.
          </p>
          <p>
            Values in Anchors are used (along with Align) in the DoAutoAdjustLayout method. They control whether values in Left, Top, Bottom, and Right are calculated using the ClientWidth and ClientHeight for the Parent control. The values in Anchors also used in the HeightIsAnchored and WidthIsAnchored methods.
          </p>
          <p>
            Values in Anchors may be updated when a new value is assigned to the Align property which conflicts with the existing values in the property. They may also be updated when values are assigned to  AnchorSide which cause vertical or horizontal centering to a sibling control (AnchorVerticalCenterTo, AnchorHorizontalCenterTo) or alignment to a companion control (AnchorToCompanion).
          </p>
        </descr>
        <seealso>
          <link id="TAnchors"/>
          <link id="TAnchorKind"/>
          <link id="TControl.Align"/>
          <link id="TControl.AnchorSide"/>
          <link id="TControl.AdjustSize"/>
          <link id="TControl.DoAutoAdjustLayout"/>
          <link id="TControl.ClientHeight"/>
          <link id="TControl.ClientWidth"/>
          <link id="TControl.Parent"/>
        </seealso>
      </element>

      <element name="TControl.AnchorSide">
        <short>Array of anchor definitions, indexed by the control sides.</short>
        <descr>
          <p>
            Valid anchor definitions are flagged in <link id="TControl.Anchors">Anchors</link>.
          </p>
          <p>
            AnchorSide specifies how a side is anchored to other controls (siblings or Parent).
          </p>
          <p>
            Various AnchorAs and AnchorTo methods simplify the establishment of anchors.
          </p>
        </descr>
        <seealso>
          <link id="TAnchorSide"/>
          <link id="TControl.AnchorAsAlign"/>
          <link id="TControl.AnchorToNeighbour"/>
        </seealso>
      </element>
      <element name="TControl.AnchorSide.Kind">
        <short>The anchored side of the control.</short>
      </element>

      <element name="TControl.AutoSize">
        <short>
          Allows automatic adjustment of the size for the control, according to its content.
        </short>
        <descr>
          <p>
            The action performed depends on the concrete control type. For example, a label or button can become bigger or smaller to accommodate a longer or shorter caption.
          </p>
          <p>
            Default value for the property is <b>False</b>, and disables auto-sizing for the control instance.
          </p>
        </descr>
        <seealso>
          <link id="#lcl.controls.Autosize">Using AutoSize</link>
        </seealso>
      </element>

      <element name="TControl.BorderSpacing">
        <short>Determines the inner and outer border spacing for this control.</short>
        <descr>
          <p>
            The outer border determines the minimum distance to sibling controls. The inner border is the space between the BoundsRect and ClientRect for the control.
          </p>
          <p>
            When a control sits in a cell of a table (Grid) control, its horizontal and vertical alignment inside the cell can be specified, too.
          </p>
        </descr>
      </element>

      <element name="TControl.BoundsRect">
        <short>The TopLeft and BottomRight of the control, in client coordinates.</short>
        <descr>
          <p>
            The BoundsRect rectangle describes the Top, Left and Bottom, Right coordinates for the control, relative to its parent.
          </p>
          <p>
            The values are based on the Top, Left, Width and Height properties of the control.
          </p>
          <p>
            Set BoundsRect to move and/or resize the control. This can reduce flicker, occurring otherwise when Top, Width etc. are set individually.
          </p>
        </descr>
      </element>

      <element name="TControl.BoundsRectForNewParent">
        <short>
          Temporary BoundsRect, used when the control e.g. is docked into a different Parent.
        </short>
        <descr>
          <p>
            The rectangle describes the placement of the control when its Parent is changed later.
          </p>
          <p>
            Setting the rectangle also sets a flag, that indicates the values are available.
          </p>
        </descr>
      </element>

      <element name="TControl.Caption">
        <short>The text describing the control to the user.</short>
        <descr>
          <p>
            By default, the <var>Caption</var> is the same as the control's <var>Name</var> in the Object Inspector, and the developer must set it explicitly to some different text.
          </p>
        </descr>
        <seealso>
          <link id="TControl.RealGetText"/>
          <link id="TControl.RealSetText"/>
        </seealso>
      </element>

      <element name="TControl.CaptureMouseButtons">
        <short>Which mouse button(s) to be used for capture? Default is the left button.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.ClientHeight">
        <short>The height of the client area of the control.</short>
        <descr/>
      </element>

      <element name="TControl.ClientOrigin">
        <short>
          Screen coordinates of the Top, Left pixel (in the client area) of the control.
        </short>
        <descr>
          <p>
            Only <var>TWinControl</var> has a client area. For other controls, ClientOrigin is the same as <var>ControlOrigin</var>. Uses the corresponding property in the <var>Parent</var> control to get the property value, and includes the values in <var>Left</var> and <var>Top</var> to get the effective  origin for the control.
          </p>
          <p>
            An <var>EInvalidOperation</var> exception is raised if Parent has not been assigned when reading the value for the property.
          </p>
          <p>
            Note that this value is the position as stored in the object, not always in sync with the widget.
          </p>
        </descr>
        <errors>
          Raises an EInvalidOperation exception with the message in sParentRequired if Parent has not been assigned when reading the value for the property.
        </errors>
        <seealso>
          <link id="TControl.Parent"/>
          <link id="TControl.Left"/>
          <link id="TControl.Top"/>
          <link id="TControl.ControlOrigin"/>
          <link id="TControl.GetClientOrigin"/>
        </seealso>
      </element>

      <element name="TControl.ClientRect">
        <short>Size of the client area for the control.</short>
        <descr>
          <p>
            Contains  the size for the visual client area in the control. For example, the inner size of a TGroupBox. For a TScrollBox it is the visual size, and not the logical size.
          </p>
          <p>
            The property value is a TRect instance with the Top and Left members set to 0, and the Height and Width members set to the corresponding property values for the control.
          </p>
        </descr>
        <seealso>
          <link id="TControl.GetClientRect"/>
          <link id="TControl.GetLogicalClientRect"/>
          <link id="#rtl.classes.TRect">TRect</link>
        </seealso>
      </element>

      <element name="TControl.ClientWidth">
        <short>The width of the client area of the control.</short>
        <descr/>
      </element>

      <element name="TControl.Color">
        <short>The background color of the control.</short>
        <descr>
          <p>
            The default value in <var>Color</var> is the same as the value in the parent window <var>Color</var>. If the color is <var>clDefault</var>,  the result will need to be passed through <var>GetDefaultColor</var> to resolve <var>clDefault</var>. Convenience routines which obtain the color by resolving <var>clDefault</var> and <var>ParentColor</var> are also provided as <var>TControl.GetColorResolvingParent</var> and <var>TControl.GetRGBColorResolvingParent</var>.
          </p>
        </descr>
        <seealso>
          <link id="TControl.ParentColor"/>
          <link id="TControl.GetDefaultColor"/>
          <link id="TControl.GetColorResolvingParent"/>
          <link id="TControl.GetRGBColorResolvingParent"/>
          <link id="#lcl.graphics.TColor">TColor</link>
        </seealso>
      </element>

      <element name="TControl.Constraints">
        <short>The minimum and maximum Width and Height for the control.</short>
        <descr/>
        <seealso>
          <link id="TSizeConstraints"/>
        </seealso>
      </element>

      <element name="TControl.ControlOrigin">
        <short>The top, left pixel of the control in screen coordinates.</short>
        <descr/>
        <seealso>
          <link id="TControl.ClientOrigin"/>
          <link id="TControl.BoundsRect"/>
        </seealso>
      </element>

      <element name="TControl.ControlState">
        <short>
          State flags, telling whether the control has been clicked, data being read, control being re-drawn, etc.
        </short>
        <descr/>
        <seealso>
          <link id="TControlState"/>
        </seealso>
      </element>

      <element name="TControl.ControlStyle">
        <short>
          Style flags, specifying whether the control responds to mouse clicks, can be re-sized, has particular actions, etc.
        </short>
        <descr/>
        <seealso>
          <link id="TControlStyle"/>
        </seealso>
      </element>

      <element name="TControl.Enabled">
        <short>Determines whether the control reacts on mouse or keyboard input.</short>
        <descr>Disabled controls usually appear 'greyed-out'</descr>
      </element>

      <element name="TControl.Font">
        <short>The <link id="#lcl.graphics.TFont">font</link> to be used for text display in this control.</short>
        <seealso>
          <link id="#lcl.graphics.TFont">TFont</link>
        </seealso>
      </element>

      <element name="TControl.IsControl">
        <short>Determines whether this object shall be streamed as a control.</short>
        <descr>
          Delphi compatible property, affecting only the streaming of <var>Form</var> properties.
        </descr>
      </element>

      <element name="TControl.MouseEntered">
        <short>True when the mouse has entered the control.</short>
        <descr/>
      </element>

      <element name="TControl.MouseInClient">
        <short>True when the mouse is in the client area for the control.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.OnChangeBounds">
        <short>Event handler for a change of the Bounds of the control.</short>
        <descr/>
        <seealso>
          <link id="#rtl.classes.TNotifyEvent">TNotifyEvent</link>
        </seealso>
      </element>

      <element name="TControl.OnClick">
        <short>Notification handler for mouse clicks.</short>
        <descr>
          <p>
            A mouse click is associated with the default action for controls, and is often the ONLY event handled in user code.
          </p>
          <p>
            The reaction on an click can be specified by a user supplied method, and/or by selecting an action from a supplied <var>ActionList</var>.
          </p>
        </descr>
        <seealso>
          <link id="#rtl.classes.TNotifyEvent">TNotifyEvent</link>
        </seealso>
      </element>

      <element name="TControl.OnResize">
        <short>Notification handler for a resize of the control.</short>
        <descr>
          <p>
            This event is triggered after the Width, Height, ClientWidth or ClientHeight of the control has changed, and before the LCL sends the new size to the widgetset. The size of the underlying widget (e.g. unit LCLIntf function GetWindowSize and GetClientRect) may differ from the control's Width/Height/ClientRect during OnResize. During auto-size the size can change multiple times, but only the last change triggers the OnResize.
          </p>
          <p>
            Use OnResize to react on size changes. To also react on moves, use the OnChangeBounds event.
          </p>
          <p>
            If you want to customize the resize behavior, use OnConstrainedResize instead.
          </p>
          <p>
            Common mistake: Keep in mind that ClientWidth and ClientHeight can change even when Width and Height stay the same. For example when the theme changes, the Width and Height remain the same, but the changed frame reduces the ClientWidth and ClientHeight. This does not happen that often under Windows, but it happens quite often on other platforms.
          </p>
          <p>
            Especially it is not sufficient to write only a TForm.OnResize handler to resize all controls on the form. This is a common bug in Delphi applications.
          </p>
        </descr>
        <seealso>
          <link id="TControl.OnConstrainedResize"/>
          <link id="#rtl.classes.TNotifyEvent">TNotifyEvent</link>
        </seealso>
      </element>

      <element name="TControl.OnShowHint">
        <short>Event handler signalled when a hint window is displayed for the control.</short>
        <descr>
          <p>
            OnShowHint is a TControlShowHintEvent property with the event handler signalled when a hint window is displayed for the control. Arguments to the event handler include the control instance for the event notification, and a pointer to the structure with the Hint details for the control.
          </p>
          <p>
            OnShowHint has public visibility in TControl, but may be redeclared in descendent classes to make it visible in the object inspector. An application must implement and assign a handler routine to respond to the event notification.
          </p>
          <p>
            OnShowHint is signalled from the DoOnShowHint method (when assigned), and occurs when the CM_HINTSHOW control message is handled for the control.
          </p>
          <p>
            Set ShowHint to True to enable hint window display using the value(s) in the Hint property.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Hint"/>
          <link id="TControl.ShowHint"/>
          <link id="TControl.DoOnShowHint"/>
          <link id="TControlShowHintEvent"/>
          <link id="THintInfo"/>
          <link id="PHintInfo"/>
        </seealso>
      </element>

      <element name="TControl.Parent">
        <short>The control within which the control is shown.</short>
        <descr>
          <p>When the Parent moves or hides, all its children move or hide together with it.</p>
          <p>Every TControl must have a Parent, else it is never shown.</p>
          <p>The Parent of a floating form is Nil.</p>
          <p>Set the parent last to reduce updates. For example: </p>
<code>
  Button1 := TButton.Create(Self);
  Button1.Name := 'Button1';
  Button1.Caption := 'Click me'; // parent is not set, so it does not update the whole form
  Button1.Parent := Form1; // set parent as last, the LCL now applies all properties
</code>
          <p>Delphi/VCL: Parent must be set first under Delphi, because many properties work differently if they are set before or after Handle creation. The LCL applies the properties when the Handle is created.</p>
        </descr>
      </element>

      <element name="TControl.PopupMenu">
        <short>
          A context-sensitive menu that pops up when the right mouse button is clicked over this control.
        </short>
        <descr/>
        <seealso>
          <link id="TControl.OnContextPopup"/>
          <link id="TContextPopupEvent"/>
          <link id="#lcl.menus.TPopupMenu">TPopupMenu</link>
        </seealso>
      </element>

      <element name="TControl.ShowHint">
        <short>Enables the <link id="#lcl.controls.TControl.Hint">Hint</link> display.</short>
        <descr>
          <p>
            When True, the Hint text is shown when the mouse hovers over the control.
          </p>
          <p>
            Display of the actual hint is controlled by the OnShowHint event handler.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Hint"/>
          <link id="TControl.OnShowHint"/>
          <link id="TControl.ParentShowHint"/>
        </seealso>
      </element>

      <element name="TControl.Visible">
        <short>Allows the control, and all of its children, to be displayed or hidden.</short>
        <descr>
          <p>
            Visible is set to True by <var>Show</var>, or to False by <var>Hide</var>. Calling these methods is equivalent to setting the Visible property.
          </p>
          <remark>
            Reading the Visible property does not take into account control's parent visibility. Use the IsVisible method to get the real visibility.
          </remark>
        </descr>
        <seealso>
          <link id="TControl.IsVisible"/>
          <link id="TControl.Show"/>
          <link id="TControl.Hide"/>
        </seealso>
      </element>

      <element name="TControl.WndProc">
        <short>The general message handler for this control.</short>
        <descr>
          Preprocesses several messages, then calls Dispatch to invoke the applicable message handler.
        </descr>
        <seealso/>
      </element>
      <element name="TControl.WndProc.TheMessage">
        <short>The message to handle.</short>
      </element>

      <element name="TControl.WindowProc">
        <short>The handler for all messages.</short>
        <descr>
          <p>
            WindowProc is set to <link id="TControl.WndProc"/> by default.
          </p>
          <p>
            When you ever change WindowProc, then remember the previous setting and delegate all unhandled messages to that method.
          </p>
        </descr>
        <seealso>
          <link id="TWndMethod"/>
          <link id="#lcl.lmessages.TLMessage">TLMessage</link>
          <link id="TControl.Perform"/>
        </seealso>
      </element>

      <element name="TControl.DockOrientation">
        <short>
          How the control is currently docked. (horizontally, vertically, in a notebook, or not at all).
        </short>
        <descr>
          <p>
            The property value is assigned when the control is inserted into a docking tree during a drag and dock operation. Its value is used when CalculateDockSizes is called to adjust the height or width for the host dock site.
          </p>
        </descr>
        <seealso>
          <link id="TControl.CalculateDockSizes"/>
          <link id="#lcl.ldocktree.TLazDockTree.InsertControl"/>
        </seealso>
      </element>

      <element name="TControl.Floating">
        <short>Determines whether the control is floating (not part of a form).</short>
        <descr/>
        <seealso>
          <link id="TControl.FloatingDockSiteClass"/>
        </seealso>
      </element>

      <element name="TControl.FloatingDockSiteClass">
        <short>The class for a floating host dock site for this control.</short>
        <descr/>
        <seealso>
          <link id="TControl.Floating"/>
        </seealso>
      </element>

      <element name="TControl.HostDockSite">
        <short>
          The host site (TWinControl) into which this control is docked. <b>Nil</b> if not docked.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.LRDockWidth">
        <short>The Width when last docked, with siblings to the left or right.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.TBDockHeight">
        <short>The Height when last docked, with siblings above or below.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.UndockHeight">
        <short>Height for the control when undocked.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.UndockWidth">
        <short>Width for the control when undocked.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.UseRightToLeftAlignment">
        <short>True when BiDiMode is bdRightToLeft.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.UseRightToLeftAlignment.Result">
        <short/>
      </element>

      <element name="TControl.UseRightToLeftReading">
        <short>True when BiDiMode is not bdLeftToRight.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.UseRightToLeftReading.Result">
        <short/>
      </element>

      <element name="TControl.UseRightToLeftScrollBar">
        <short>True when scrollbars appear at the left side of the control.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.UseRightToLeftScrollBar.Result">
        <short/>
      </element>

      <element name="TControl.IsRightToLeft">
        <short>True when BiDiMode is not bdLeftToRight.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.IsRightToLeft.Result">
        <short/>
      </element>

      <element name="TControl.BiDiMode">
        <short>Customization (of text controls) in bidirectional reading environments.
        </short>
        <descr>
          <p>
            In "normal" reading mode (left-to-right, LTR) text entry starts at the left, text is almost left justified, and vertical scrollbars sit at the right side of the control.
          </p>
          <p>
            In right-to-left mode text entry starts at the right, text is almost right justified, and vertical scrollbars sit at the left side of the control.
          </p>
          <p>
            In a bidirectional environment these different placements and adjustments can be configured (swapped) in various (but not all) ways.
          </p>
          <p>
            (Allows RTL languages such as Arabic and Hebrew to be used)
          </p>
          <p>
            Wild guess: The default mode is established by the platform, RTL reading is not supported on all (Windows) platforms.
          </p>
        </descr>
        <seealso>
          <link id="TControl.UseRightToLeftAlignment"/>
          <link id="TControl.UseRightToLeftReading"/>
          <link id="TControl.UseRightToLeftScrollBar"/>
          <link id="TControl.IsRightToLeft"/>
        </seealso>
      </element>

      <element name="TControl.ParentBiDiMode">
        <short>
          Allows to use the BiDiMode settings in the Parent control. Default is true.
        </short>
        <seealso>
          <link id="TControl.BiDiMode"/>
        </seealso>
      </element>

      <element name="TControl.AnchorSideLeft">
        <short>
          Contains anchor aligment information used to position the control with its left edge  anchored to another control.
        </short>
        <descr>
          <p>
            AnchorSideLeft is a TAnchorSide property with information about the side, type, alignment, and control used to anchor align the class instance. AnchorSideLeft provides access to the array element in AnchorSide stored at the position in akLeft.
          </p>
        </descr>
        <seealso>
          <link id="TControl.AnchorSide"/>
          <link id="TControl.AnchorSideRight"/>
          <link id="TControl.AnchorSideTop"/>
          <link id="TControl.AnchorSideBottom"/>
          <link id="TAnchorKind"/>
        </seealso>
      </element>

      <element name="TControl.AnchorSideTop">
        <short>
          Contains anchor aligment information used to position the control with its top edge  anchored to another control.
        </short>
        <descr>
          <p>
            AnchorSideTop is a TAnchorSide property with information about the side, type, alignment, and control used to anchor align the class instance. AnchorSideTop  provides access to the array element in AnchorSide stored at the position in akTop.
          </p>
        </descr>
        <seealso>
          <link id="TControl.AnchorSide"/>
          <link id="TControl.AnchorSideLeft"/>
          <link id="TControl.AnchorSideRight"/>
          <link id="TControl.AnchorSideBottom"/>
          <link id="TAnchorKind"/>
        </seealso>
      </element>

      <element name="TControl.AnchorSideRight">
        <short>
          Contains anchor aligment information used to position the control with its right  edge anchored to another control.
        </short>
        <descr>
          <p>
            AnchorSideRight is a TAnchorSide property with information about the side, type, alignment, and control used to anchor align the class instance. AnchorSideRight  provides access to the array element in AnchorSide stored at the position in akRight.
          </p>
        </descr>
        <seealso>
          <link id="TControl.AnchorSide"/>
          <link id="TControl.AnchorSideLeft"/>
          <link id="TControl.AnchorSideTop"/>
          <link id="TControl.AnchorSideBottom"/>
          <link id="TAnchorKind"/>
        </seealso>
      </element>

      <element name="TControl.AnchorSideBottom">
        <short>
          Contains anchor aligment information used to position the control with its bottom  edge anchored to another control.
        </short>
        <descr>
          <p>
            AnchorSideTop is a TAnchorSide property with information about the side, type, alignment, and control used to anchor align the class instance. AnchorSideTop  provides access to the array element in AnchorSide stored at the position in akTop.
          </p>
        </descr>
        <seealso>
          <link id="TControl.AnchorSide"/>
          <link id="TControl.AnchorSideLeft"/>
          <link id="TControl.AnchorSideRight"/>
          <link id="TControl.AnchorSideTop"/>
          <link id="TAnchorKind"/>
        </seealso>
      </element>

      <element name="TControl.Cursor">
        <short>The shape of the mouse pointer, when the mouse is over this control.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.Left">
        <short>The client coordinate of the left edge of the control.</short>
      </element>

      <element name="TControl.Height">
        <short>The vertical size of the control.</short>
      </element>

      <element name="TControl.Hint">
        <short>The text to show in the Hint window for the control.</short>
        <descr>
          <p>
            Hint is a TTranslateString property with hint text displayed in a pop-up window when the mouse is hovered over the control. The pop-up window is displayed when the  ShowHint property is set to <b>True</b>.
          </p>
          <p>
            Assign a value to Hint to describe the usage or formatting conventions used for the value entered in the control. For example:
          </p>
          <code>Edit1.Hint := 'Start Date in MM/DD/YYYY format';</code>
          <p>
            Hint can be given a value that includes both short and long variants of the hint text. The values are separated by a '|' (Vertical Bar) character in the property. For example:
          </p>
          <code>Edit1.Hint := 'Start Date | Start Date in MM/DD/YYYY format';</code>
          <p>
            The short variant is used in the pop-up hint window for the control. The long variant is assigned to the Application.Hint property, or displayed on a form status bar when its AutoHint property is set to <b>True</b>.
          </p>
          <p>
            As a TTranslateString type, Hint can be localized using the translation facilities built into the LCL and the Lazarus IDE. The property value is written using LCL component streaming when the hint text for the control is not linked to an assigned Action.
          </p>
          <remark>
            Hint is not the same value as the placeholder introduced as the TextHint property in descendent controls.
          </remark>
        </descr>
        <seealso>
          <link id="TControl.ShowHint"/>
          <link id="TControl.ParentShowHint"/>
          <link id="TControl.ActionLink"/>
          <link id="TControlActionLink.IsHintLinked"/>
        </seealso>
      </element>

      <element name="TControl.Top">
        <short>The client coordinate of the top edge of the control.</short>
      </element>

      <element name="TControl.Width">
        <short>The horizontal extent of the control.</short>
      </element>

      <element name="TControl.HelpType">
        <short>Determines whether context-sensitive Help is selected by numeric ID or keyword.</short>
        <descr/>
        <seealso>
          <link id="TControl.HelpContext"/>
          <link id="TControl.HelpKeyword"/>
        </seealso>
      </element>

      <element name="TControl.HelpKeyword">
        <short>The keyword for context-sensitive Help on this control.</short>
        <descr/>
        <seealso>
          <link id="TControl.HelpContext"/>
        </seealso>
      </element>

      <element name="TControl.HelpContext">
        <short>The ID for context-sensitive Help on this control.</short>
        <descr/>
        <seealso>
          <link id="TControl.HelpKeyword"/>
        </seealso>
      </element>

      <element name="TBorderWidth">
        <short>Integer type for <link id="TWinControl.BorderWidth"/></short>
      </element>

      <element name="TGetChildProc">
        <short>Type of a callback method, to be called for all children of a control.</short>
        <descr/>
        <seealso>
          <link id="TWinControl.GetChildren"/>
        </seealso>
      </element>
      <element name="TGetChildProc.Child">
        <short>The child control.</short>
      </element>

      <element name="TChildControlResizeStyle">
        <short>Modes for resizing child controls.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TChildControlResizeStyle.crsAnchorAligning">
        <short>Using <link id="TControl.Anchors"/> (Delphi compatible).</short>
      </element>
      <element name="TChildControlResizeStyle.crsScaleChilds">
        <short>Scale children, keep space between children fixed.</short>
      </element>
      <element name="TChildControlResizeStyle.crsHomogenousChildResize">
        <short>Enlarge children equally, i.e. by the same amount of pixels.</short>
      </element>
      <element name="TChildControlResizeStyle.crsHomogenousSpaceResize">
        <short>Enlarge space between children equally.</short>
      </element>

      <element name="TControlChildrenLayout">
        <short>Defines the logic used to wrap child controls.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlChildrenLayout.cclNone">
        <short>No wrapping.</short>
      </element>
      <element name="TControlChildrenLayout.cclLeftToRightThenTopToBottom">
        <short>
          Arranges controls in a row filled from left to right, and then top to bottom. Uses the value in BiDiMode; when it contains bdRightToLeft the horizontal direction is reversed (Right to Left).
        </short>
      </element>
      <element name="TControlChildrenLayout.cclTopToBottomThenLeftToRight">
        <short>Arranges controls in columns, from top to bottom and then left to right.</short>
      </element>

      <element name="TControlChildSizing">
        <short>How child controls are sized relative to their parent.</short>
        <descr>
          <p>
            <var>TControlChildSizing</var> is a <var>TPersistent</var> descendant which provides properties and methods used to layout, align, and resize child controls relative to their parent. Properties are provide which define the horizontal and vertical spacing between controls, the preferred direction controls are aligned, and whether controls are scaled to fit in the parent control.
          </p>
          <p>
            See <link id="TChildControlResizeStyle"/> and <link id="TControlChildrenLayout"/> for details about the enumeration values used in the properties.
          </p>
        </descr>
        <seealso>
          <link id="TChildControlResizeStyle"/>
          <link id="TControlChildrenLayout"/>
        </seealso>
      </element>

      <element name="TControlChildSizing.FControl"/>
      <element name="TControlChildSizing.FControlsPerLine"/>
      <element name="TControlChildSizing.FEnlargeHorizontal"/>
      <element name="TControlChildSizing.FEnlargeVertical"/>
      <element name="TControlChildSizing.FHorizontalSpacing"/>
      <element name="TControlChildSizing.FLayout"/>
      <element name="TControlChildSizing.FLeftRightSpacing"/>
      <element name="TControlChildSizing.FOnChange"/>
      <element name="TControlChildSizing.FShrinkHorizontal"/>
      <element name="TControlChildSizing.FShrinkVertical"/>
      <element name="TControlChildSizing.FTopBottomSpacing"/>
      <element name="TControlChildSizing.FVerticalSpacing"/>

      <element link="#lcl.controls.TControlChildSizing.ControlsPerLine" name="TControlChildSizing.SetControlsPerLine"/>
      <element name="TControlChildSizing.SetControlsPerLine.AValue">
        <short/>
      </element>

      <element link="#lcl.controls.TControlChildSizing.EnlargeHorizontal" name="TControlChildSizing.SetEnlargeHorizontal"/>
      <element name="TControlChildSizing.SetEnlargeHorizontal.AValue">
        <short/>
      </element>

      <element link="#lcl.controls.TControlChildSizing.EnlargeVertical" name="TControlChildSizing.SetEnlargeVertical"/>
      <element name="TControlChildSizing.SetEnlargeVertical.AValue">
        <short/>
      </element>

      <element link="#lcl.controls.TControlChildSizing.HorizontalSpacing" name="TControlChildSizing.SetHorizontalSpacing"/>
      <element name="TControlChildSizing.SetHorizontalSpacing.AValue">
        <short/>
      </element>

      <element link="#lcl.controls.TControlChildSizing.Layout" name="TControlChildSizing.SetLayout"/>
      <element name="TControlChildSizing.SetLayout.AValue">
        <short/>
      </element>

      <element link="#lcl.controls.TControlChildSizing.LeftRightSpacing" name="TControlChildSizing.SetLeftRightSpacing"/>
      <element name="TControlChildSizing.SetLeftRightSpacing.AValue">
        <short/>
      </element>

      <element link="#lcl.controls.TControlChildSizing.ShrinkHorizontal" name="TControlChildSizing.SetShrinkHorizontal"/>
      <element name="TControlChildSizing.SetShrinkHorizontal.AValue">
        <short/>
      </element>

      <element link="#lcl.controls.TControlChildSizing.ShrinkVertical" name="TControlChildSizing.SetShrinkVertical"/>
      <element name="TControlChildSizing.SetShrinkVertical.AValue">
        <short/>
      </element>

      <element link="#lcl.controls.TControlChildSizing.TopBottomSpacing" name="TControlChildSizing.SetTopBottomSpacing"/>
      <element name="TControlChildSizing.SetTopBottomSpacing.AValue">
        <short/>
      </element>

      <element link="#lcl.controls.TControlChildSizing.VerticalSpacing" name="TControlChildSizing.SetVerticalSpacing"/>
      <element name="TControlChildSizing.SetVerticalSpacing.AValue">
        <short/>
      </element>

      <element name="TControlChildSizing.Change">
        <short>
          Notifies the Control and invokes the <var>OnChange</var> handler.
        </short>
        <descr/>
        <seealso>
          <link id="TWinControl.DoChildSizingChange"/>
        </seealso>
      </element>

      <element name="TControlChildSizing.Create">
        <short>Constructor for the class instance.</short>
        <descr>
          <p>
            <var>Create</var> is the constructor for the class instance. Create calls the inherited constructor, and sets the default values for properties including:
          </p>
          <dl>
            <dt>Control</dt>
            <dd>Set to the value in the OwnerControl argument</dd>
            <dt>Layout</dt>
            <dd>Set to cclNone</dd>
            <dt>EnlargeHorizontal, EnlargeVertical, ShrinkHorizontal, ShrinkVertical</dt>
            <dd>Set to crsAnchorAligning</dd>
          </dl>
        </descr>
      </element>
      <element name="TControlChildSizing.Create.OwnerControl">
        <short>Control which owns the class instance.</short>
      </element>

      <element name="TControlChildSizing.Assign">
        <short>
          Copies property values from the specified persistent object into the current class instance.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlChildSizing.Assign.Source">
        <short>Persistent object with the property values copied in the method.</short>
      </element>

      <element name="TControlChildSizing.AssignTo">
        <short>
          Copies property values from the current class instance to the specified persistent object.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlChildSizing.AssignTo.Dest">
        <short>Persistent object where the property values are stored.</short>
      </element>

      <element name="TControlChildSizing.IsEqual">
        <short>
          Determines whether the specified sizing contains the same values as the current class instance.
        </short>
        <descr>
          <p>
            <var>IsEqual</var> is a <var>Boolean</var> function used to determine whether the <var>TControlChildSizing</var> instance in <var>Sizing</var> contains the same values as the current class instance. <var>IsEqual</var> compares the following properties to determine the return value:
          </p>
          <ul>
            <li>EnlargeHorizontal</li>
            <li>EnlargeVertical</li>
            <li>ShrinkHorizontal</li>
            <li>EnlargeHorizontal</li>
            <li>ShrinkVertica</li>
            <li>EnlargeVertical</li>
            <li>ShrinkHorizontal</li>
            <li>ShrinkVertical</li>
            <li>ControlsPerLine</li>
            <li>Layout</li>
            <li>LeftRightSpacing</li>
            <li>TopBottomSpacing</li>
            <li>HorizontalSpacing</li>
            <li>VerticalSpacing</li>
          </ul>
          <p>
            The return value is <b>True</b> when the properties contain equivalent values in both class instances.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TControlChildSizing.IsEqual.Result">
        <short>
          True when the specified sizing contains the same values as the current class instance.
        </short>
      </element>
      <element name="TControlChildSizing.IsEqual.Sizing">
        <short>TControlChildSizing class instance compared in the method.</short>
      </element>

      <element name="TControlChildSizing.SetGridSpacing">
        <short>Set all spacing to the same value.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlChildSizing.SetGridSpacing.Spacing">
        <short/>

      </element>
      <element name="TControlChildSizing.Control">
        <short>The <var>Control</var> to which childsizing applies.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlChildSizing.ControlsPerLine">
        <short>Number of controls per line.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlChildSizing.EnlargeHorizontal">
        <short>Various ways to fit controls into the available Width.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlChildSizing.EnlargeVertical">
        <short>Various ways to fit controls into the available Height.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlChildSizing.HorizontalSpacing">
        <short>Minimum space between children.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlChildSizing.Layout">
        <short>Allows to also arrange the child controls in rows or columns.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlChildSizing.LeftRightSpacing">
        <short>Minimum distance between children and client border.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlChildSizing.OnChange">
        <short>Event handler for any change in the data.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlChildSizing.ShrinkHorizontal">
        <short>Various ways to fit controls into the available Width.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlChildSizing.ShrinkVertical">
        <short>Various ways to fit controls into the available Height.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlChildSizing.TopBottomSpacing">
        <short>Minimum distance between children and client border.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlChildSizing.VerticalSpacing">
        <short>Minimum space between children.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControlActionLink">
        <short>Alias for the TControlActionLink type.</short>
        <descr>
          <p>
            Since HelpContext and HelpKeyword are properties of TControl, this class is obsolete. In order not to break existing code, its declaration is aliased to TControlActionLink.
          </p>
        </descr>
        <seealso>
          <link id="TControlActionLink"/>
        </seealso>
      </element>

      <element name="TWinControlActionLinkClass">
        <short>
          Class type used to create new instances of TWinControlActionLink.
        </short>
        <descr/>
        <seealso>
          <link id="TWinControlActionLink"/>
        </seealso>
      </element>

      <element name="TWinControlFlag">
        <short>State flags of TWinControl.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControlFlag.wcfClientRectNeedsUpdate">
        <short/>
      </element>
      <element name="TWinControlFlag.wcfColorChanged">
        <short/>
      </element>
      <element name="TWinControlFlag.wcfFontChanged">
        <short>Set when the font was changed before handle creation.</short>
      </element>
      <element name="TWinControlFlag.wcfAllAutoSizing">
        <short>Set during DoAllAutosize.</short>
      </element>
      <element name="TWinControlFlag.wcfAligningControls">
        <short>Set during <link id="TWinControl.AlignControls"/></short>
      </element>
      <element name="TWinControlFlag.wcfEraseBackground">
        <short/>
      </element>
      <element name="TWinControlFlag.wcfCreatingHandle">
        <short>Set while constructing the handle of this control.</short>
      </element>
      <element name="TWinControlFlag.wcfInitializing">
        <short>Set while initializing during handle creation.</short>
      </element>
      <element name="TWinControlFlag.wcfCreatingChildHandles">
        <short>Set while constructing the handles of the children.</short>
      </element>
      <element name="TWinControlFlag.wcfRealizingBounds">
        <short>Set inside RealizeBoundsRecursive.</short>
      </element>
      <element name="TWinControlFlag.wcfBoundsRealized">
        <short>
          Set before bounds are sent to the widget; used to suppress subsequent size messages sent by the widget.
        </short>
      </element>
      <element name="TWinControlFlag.wcfUpdateShowing">
        <short/>
      </element>
      <element name="TWinControlFlag.wcfHandleVisible">
        <short/>
      </element>
      <element name="TWinControlFlag.wcfAdjustedLogicalClientRectValid">
        <short>Set when the adjusted ClientRect is valid.</short>
        <seealso>
          <link id="TWinControl.GetAdjustedLogicalClientRect"/>
        </seealso>
      </element>
      <element name="TWinControlFlag.wcfKillIntfSetBounds">
        <short/>
      </element>
      <element name="TWinControlFlag.wcfDesignerDeleting">
        <short>Only used for TCustomPairSplitter / TPairSplitter.</short>
      </element>
      <element name="TWinControlFlag.wcfSpecialSubContro">
        <short>Only used for TCustomPairSplitter / TPairSplitter.</short>
      </element>

      <element name="TWinControlFlags">
        <short>Set of TWinControlFlag enumeration values.</short>
        <descr/>
        <seealso>
          <link id="TWinControlFlag"/>
        </seealso>
      </element>

      <element name="TControlAtPosFlag">
        <short>
          Flags for finding a control at a given (client) position.
        </short>
        <descr>
          <p>
            TControlAtPosFlag is an enumeration type with values that indicate the mechanism used to locate a control at a given client position.
          </p>
          <dl>
            <dt>capfAllowDisabled</dt>
            <dd>Include disabled controls</dd>
            <dt>capfAllowWinControls</dt>
            <dd>Do not find WinControls if False</dd>
            <dt>capfOnlyClientAreas</dt>
            <dd>Hit client areas only</dd>
            <dt>capfRecursive</dt>
            <dd>Search in child controls</dd>
            <dt>capfHasScrollOffset</dt>
            <dd>Scroll offset is already included in the coordinates</dd>
            <dt>capfOnlyWinControls</dt>
            <dd>Include only TWinControls (ignore TControls)</dd>
          </dl>
          <p>
            Values from the enumeration are stored in the TControlAtPosFlags type.
          </p>
          <p>
            TControlAtPosFlag enumeration values are used in the implementation of the ControlAtPos method in TWinControl, and in the FindControlAtPosition function.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.ControlAtPos"/>
        </seealso>
      </element>
      <element name="TControlAtPosFlag.capfAllowDisabled">
        <short>If set: include disabled controls.</short>
      </element>
      <element name="TControlAtPosFlag.capfAllowWinControls">
        <short>If set: include TWinControls, in addition to TControls.</short>
      </element>
      <element name="TControlAtPosFlag.capfOnlyClientAreas">
        <short>If set: hit client areas only.</short>
      </element>
      <element name="TControlAtPosFlag.capfRecursive">
        <short>If set: recurse into grand children.</short>
      </element>
      <element name="TControlAtPosFlag.capfHasScrollOffset">
        <short>If set: scroll offset is already included in the coordinates.</short>
      </element>
      <element name="TControlAtPosFlag.capfOnlyWinControls">
        <short>Include only TWinControls (and ignore TControls) when set.</short>
      </element>

      <element name="TControlAtPosFlags">
        <short>Set type used to store values from the TControlAtPosFlag enumeration.</short>
        <descr/>
        <seealso>
          <link id="TControlAtPosFlag"/>
        </seealso>
      </element>

      <element name="TAlignInfo">
        <short>Used in custom alignment (alCustom).</short>
        <descr>
          This record was added for compatibility with Delphi releases after Version 7. It is used in CustomInsertBefore and CustomAlignPosition methods and handlers.
        </descr>
        <seealso>
          <link id="TWinControl.CustomAlignPosition"/>
          <link id="TWinControl.CustomAlignInsertBefore"/>
        </seealso>
      </element>

      <element name="TAlignInfo.AlignList">
        <short>The list of controls currently being aligned.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TAlignInfo.ControlIndex">
        <short>Index of current control.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TAlignInfo.Align">
        <short>The kind of alignment currently processed (always alCustom).</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TAlignInfo.Scratch">
        <short>For internal use.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TAlignInsertBeforeEvent">
        <short>Type of an OnAlignInsertBefore handler.</short>
        <descr>
          The handler determines the order used to align both controls.
        </descr>
        <seealso>
          <link id="TWinControl.CustomAlignInsertBefore"/>
        </seealso>
      </element>
      <element name="TAlignInsertBeforeEvent.Result">
        <short>True if Control2 shall be placed before Control1 is placed.</short>
      </element>
      <element name="TAlignInsertBeforeEvent.Sender">
        <short>The Parent control.</short>
      </element>
      <element name="TAlignInsertBeforeEvent.Control1">
        <short/>
      </element>
      <element name="TAlignInsertBeforeEvent.Control2">
        <short/>
      </element>

      <element name="TAlignPositionEvent">
        <short>Type of an OnAlignPosition handler.</short>
        <descr>
          Handler which positions the Control using the specified coordinates.
        </descr>
        <seealso>
          <link id="TWinControl.CustomAlignPosition"/>
        </seealso>
      </element>
      <element name="TAlignPositionEvent.Sender">
        <short>TWinControl generating the event notification.</short>
      </element>
      <element name="TAlignPositionEvent.Control">
        <short>The control to position.</short>
      </element>
      <element name="TAlignPositionEvent.NewLeft">
        <short>New Left coordinate for the control.</short>
      </element>
      <element name="TAlignPositionEvent.NewTop">
        <short>New Top coordinate for the control.</short>
      </element>
      <element name="TAlignPositionEvent.NewWidth">
        <short>New Width for the control.</short>
      </element>
      <element name="TAlignPositionEvent.NewHeight">
        <short>New Height for the control.</short>
      </element>
      <element name="TAlignPositionEvent.AlignRect">
        <short>The remaining ClientRect.</short>
      </element>
      <element name="TAlignPositionEvent.AlignInfo">
        <short>Information about the current align process.</short>
      </element>

      <element name="TWinControlEnumerator">
        <short>Implements an enumerator for TWinControl instances.</short>
        <descr>
          <p>
            <var>TWinControlEnumerator</var> is a class used to implement an enumerator for <var>TWinControl</var> class instances. TWinControlEnumerator provides support the enumerator interface through its <var>GetCurrent</var> and <var>MoveNext</var> methods.
          </p>
          <p>
            <var>TWinControlEnumerator</var> is the type returned by the <var>GetEnumeratorControls</var> and <var>GetEnumeratorControlsReverse</var> functions in <var>TWinControl</var>.
          </p>
        </descr>
        <seealso>
          <link id="TWinControlEnumerator.Current"/>
          <link id="TWinControlEnumerator.MoveNext"/>
          <link id="TWinControl.GetEnumeratorControls"/>
          <link id="TWinControl.GetEnumeratorControlsReverse"/>
        </seealso>
      </element>

      <element name="TWinControlEnumerator.FIndex">
        <short>Member with the current position for the enumerator.</short>
      </element>
      <element name="TWinControlEnumerator.FLowToHigh">
        <short>Member which indicates the order for the enumerator.</short>
      </element>
      <element name="TWinControlEnumerator.FParent">
        <short>Member with the Parent for the enumerated values.</short>
      </element>

      <element name="TWinControlEnumerator.GetCurrent">
        <short>Gets the current enumerator value.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControlEnumerator.GetCurrent.Result">
        <short>The enumerator instance.</short>
      </element>

      <element name="TWinControlEnumerator.Create">
        <short>Constructor for the class instance.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControlEnumerator.Create.Parent">
        <short>Control which is the Parent for the enumerator.</short>
      </element>
      <element name="TWinControlEnumerator.Create.aLowToHigh">
        <short>The enumerator uses ascending order when True (default).</short>
      </element>

      <element name="TWinControlEnumerator.GetEnumerator">
        <short>Gets the enumerator for the class.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControlEnumerator.GetEnumerator.Result">
        <short/>
      </element>

      <element name="TWinControlEnumerator.MoveNext">
        <short>
          Moves to the next value using the ordering in effect for the enumerator.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControlEnumerator.MoveNext.Result">
        <short>Next value for the enumerator.</short>
      </element>

      <element name="TWinControlEnumerator.Current">
        <short>Gets the current value for the enumerator.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl">
        <short>
          The base class for controls which can contain other (child) controls.
        </short>
        <descr>
          <p>
            <var>TWinControl</var> is a <var>TControl</var> descendant which implements a base class for controls that can contain child controls. The name reflects the fact that (on Windows platforms) the controls are based on OS-provided widgets, which have window Handles.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TWinControl.FAlignOrder"/>
      <element name="TWinControl.FBorderWidth"/>
      <element name="TWinControl.FBoundsLockCount"/>

      <element name="TWinControl.FBoundsRealized">
        <short>
          The bounds as sent to the widget. Used to suppress feedback messages from the widget.
        </short>
      </element>

      <element name="TWinControl.FBorderStyle"/>
      <element name="TWinControl.FBrush"/>
      <element name="TWinControl.FAdjustClientRectRealized"/>
      <element name="TWinControl.FAdjustClientRect"/>
      <element name="TWinControl.FChildSizing"/>
      <element name="TWinControl.FControls"/>
      <element name="TWinControl.FOnGetDockCaption"/>
      <element name="TWinControl.FDefWndProc"/>
      <element name="TWinControl.FDockClients"/>
      <element name="TWinControl.FClientWidth"/>
      <element name="TWinControl.FClientHeight"/>
      <element name="TWinControl.FDockManager"/>
      <element name="TWinControl.FFlipped"/>
      <element name="TWinControl.FOnAlignInsertBefore"/>
      <element link="#lcl.controls.TWinControl.OnAlignPosition" name="TWinControl.FOnAlignPosition"/>
      <element link="#lcl.controls.TWinControl.OnDockDrop" name="TWinControl.FOnDockDrop"/>
      <element link="#lcl.controls.TWinControl.OnDockOver" name="TWinControl.FOnDockOver"/>
      <element link="#lcl.controls.TWinControl.OnGetSiteInfo" name="TWinControl.FOnGetSiteInfo"/>
      <element link="#lcl.controls.TWinControl.OnKeyDown" name="TWinControl.FOnKeyDown"/>
      <element link="#lcl.controls.TWinControl.OnKeyPress" name="TWinControl.FOnKeyPress"/>
      <element link="#lcl.controls.TWinControl.OnKeyUp" name="TWinControl.FOnKeyUp"/>
      <element link="#lcl.controls.TWinControl.OnEnter" name="TWinControl.FOnEnter"/>
      <element link="#lcl.controls.TWinControl.OnExit" name="TWinControl.FOnExit"/>
      <element link="#lcl.controls.TWinControl.OnUnDock" name="TWinControl.FOnUnDock"/>
      <element link="#lcl.controls.TWinControl.OnUTF8KeyPress" name="TWinControl.FOnUTF8KeyPress"/>
      <element name="TWinControl.FParentDoubleBuffered"/>
      <element link="#lcl.controls.TWinControl.ParentWindow" name="TWinControl.FParentWindow"/>
      <element name="TWinControl.FRealizeBoundsLockCount"/>
      <element link="#lcl.controls.TWinControl.Handle" name="TWinControl.FHandle"/>
      <element link="#lcl.controls.TWinControl.TabOrder" name="TWinControl.FTabOrder"/>
      <element name="TWinControl.FTabList"/>
      <element link="#lcl.controls.TWinControl.TabStop" name="TWinControl.FTabStop"/>
      <element link="#lcl.controls.TWinControl.Showing" name="TWinControl.FShowing"/>
      <element link="#lcl.controls.TWinControl.DockSite" name="TWinControl.FDockSite"/>
      <element link="#lcl.controls.TWinControl.UseDockManager" name="TWinControl.FUseDockManager"/>

      <element name="TWinControl.AlignControl">
        <short>Aligns the control and its child controls.</short>
        <descr>
          <p>
            <var>AlignControl</var> is a procedure used to align the control (and its child controls) relative to the control specified in <var>AControl</var>. AControl can contain the value <b>Nil</b> to indicate a containing control is not used to align the control instance.
          </p>
          <p>
            AlignControl calls <var>DisableAlign</var> on entry, and <var>EnableAlign</var> prior to exiting from the method.
          </p>
          <remark>
            No actions are performed in the method when the control is being freed (the value csDestroying is in ComponentState).
          </remark>
          <p>
            AlignControl gets the client rectangle used to display the control, and calls <var>AdjustClientRect</var> to allocate border spacing when needed. <var>AlignControls</var> is called to align child controls relative to the control in AControl using the calculated client rectangle. Some widget sets update their client rectangle when the first child is positioned; a second call to AlignControls is made if the client rectangle is altered in the initial call to the method.
          </p>
          <p>
            AlignControl is used in the implementation of the <var>DoAllAutoSize</var> method in <var>TControl</var>.
          </p>
        </descr>
        <seealso>
          <link id="TControl.DoAllAutoSize"/>
        </seealso>
      </element>
      <element name="TWinControl.AlignControl.AControl">
        <short>
          Control which provides the relative position for the control and its children.
        </short>
      </element>

      <element name="TWinControl.DoubleBufferedIsStored">
        <short>Implements the storage specifier for the DoubleBuffered property.</short>
        <descr>
          <p>Contains True when a parent control has not enabled its DoubleBuffered property.</p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.DoubleBufferedIsStored.Result">
        <short/>
      </element>

      <element link="#lcl.controls.TWinControl.Brush" name="TWinControl.GetBrush"/>
      <element name="TWinControl.GetBrush.Result">
        <short/>
      </element>

      <element link="#lcl.controls.TWinControl.Controls" name="TWinControl.GetControl"/>
      <element name="TWinControl.GetControl.Result">
        <short/>
      </element>
      <element name="TWinControl.GetControl.Index">
        <short/>
      </element>

      <element link="#lcl.controls.TWinControl.ControlCount" name="TWinControl.GetControlCount"/>
      <element name="TWinControl.GetControlCount.Result">
        <short/>
      </element>

      <element link="#lcl.controls.TWinControl.DockClientCount" name="TWinControl.GetDockClientCount"/>
      <element name="TWinControl.GetDockClientCount.Result">
        <short/>
      </element>

      <element link="#lcl.controls.TWinControl.DockClients" name="TWinControl.GetDockClients"/>
      <element name="TWinControl.GetDockClients.Result">
        <short/>
      </element>
      <element name="TWinControl.GetDockClients.Index">
        <short/>
      </element>

      <element link="#lcl.controls.TWinControl.Handle" name="TWinControl.GetHandle"/>
      <element name="TWinControl.GetHandle.Result">
        <short/>
      </element>

      <element link="#lcl.controls.TWinControl.IsResizing" name="TWinControl.GetIsResizing"/>
      <element name="TWinControl.GetIsResizing.Result">
        <short/>
      </element>

      <element name="TWinControl.GetIsSpecialSubControl">
        <short>Gets the value for the IsSpecialSubControl property.</short>
        <descr/>
        <seealso>
          <link id="TWinControl.IsSpecialSubControl"/>
        </seealso>
      </element>
      <element name="TWinControl.GetIsSpecialSubControl.Result">
        <short>Value for the property.</short>
      </element>

      <element link="#lcl.controls.TWinControl.TabOrder" name="TWinControl.GetTabOrder"/>
      <element name="TWinControl.GetTabOrder.Result">
        <short/>
      </element>

      <element name="TWinControl.GetVisibleDockClientCount">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.GetVisibleDockClientCount.Result">
        <short/>
      </element>

      <element link="#lcl.controls.TWinControl.ChildSizing" name="TWinControl.SetChildSizing"/>
      <element name="TWinControl.SetChildSizing.AValue">
        <short/>
      </element>

      <element name="TWinControl.SetDesignerDeleting">
        <short>Sets the value for the DesignerDeleting property.</short>
        <descr/>
        <seealso>
          <link id="TWinControl.DesignerDeleting"/>
        </seealso>
      </element>
      <element name="TWinControl.SetDesignerDeleting.AValue">
        <short>New value for the property.</short>
      </element>

      <element link="#lcl.controls.TWinControl.DockSite" name="TWinControl.SetDockSite"/>
      <element name="TWinControl.SetDockSite.NewDockSite">
        <short/>
      </element>

      <element link="#lcl.controls.TWinControl.Handle" name="TWinControl.SetHandle"/>
      <element name="TWinControl.SetHandle.NewHandle">
        <short>New value for the Handle property.</short>
      </element>

      <element link="#lcl.controls.TWinControl.BorderWidth" name="TWinControl.SetBorderWidth"/>
      <element name="TWinControl.SetBorderWidth.Value">
        <short>New value for the BorderWidth property.</short>
      </element>

      <element name="TWinControl.SetParentDoubleBuffered">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.SetParentDoubleBuffered.Value">
        <short/>
      </element>

      <element link="#lcl.controls.TWinControl.ParentWindow" name="TWinControl.SetParentWindow"/>
      <element name="TWinControl.SetParentWindow.AValue">
        <short>New value for the ParentWindow property.</short>
      </element>

      <element link="#lcl.controls.TWinControl.TabOrder" name="TWinControl.SetTabOrder"/>
      <element name="TWinControl.SetTabOrder.NewTabOrder">
        <short>New value for the TabOrder property.</short>
      </element>

      <element link="#lcl.controls.TWinControl.TabStop" name="TWinControl.SetTabStop"/>
      <element name="TWinControl.SetTabStop.NewTabStop">
        <short/>
      </element>

      <element link="#lcl.controls.TWinControl.UseDockManager" name="TWinControl.SetUseDockManager"/>
      <element name="TWinControl.SetUseDockManager.AValue">
        <short>New value for the TabStop property.</short>
      </element>

      <element name="TWinControl.UpdateTabOrder">
        <short>
          Places a control at the specified position in the tab order for Controls.
        </short>
        <descr>
          <p>
            UpdateTabOrder is a procedure used to place the current control at the position in NewTabOrder in its Parent control. Causes the TabOrder for child controls in Parent to be re-sequenced as needed.
          </p>
          <p>
            No actions are performed in the method when Parent is unassigned (contains Nil).
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.UpdateTabOrder.NewTabOrder">
        <short>New tab order for the current control.</short>
      </element>

      <element name="TWinControl.Insert">
        <short>
          Inserts or appends the specified control to the list of child controls.
        </short>
        <descr>
          <p>
            Insert is an overloaded procedure used to insert or append the control specified in AControl to the list of child controls in the class instance. An overloaded variant has an Index argument which specifies the position in the list.
         </p>
         <p>
           No actions are performed in the method when AControl has not been assigned (contains <b>Nil</b>).
         </p>
         <p>
           Insert raises an exception if AControl already has an assigned Parent, or when AControl is the same as the current class instance.
         </p>
         <p>
           The ListInsert routine is called to store AControl in the Controls property at the position contained in Index. If AControl is a TWinControl instance, it is added to the internal list which maintains the tab order for child controls. At design-time, the TabStop property in AControl is automatically set to True when its CanTab property is enabled.
         </p>
         <p>
           Insert sets the Parent property in AControl to the current control instance.
         </p>
         <p>
           Inserts checks to see whether auto-sizing has been disabled in the AControl argument. When disabled in the child control, it is also disabled in the current class instance.
         </p>
         <p>
           Insert is used in the implementation for the InsertControl method.
         </p>
        </descr>
        <errors>
          <p>
            Raises an EInvalidOperation exception when the inserted control already has a Parent.
          </p>
          <p>
            Raises an EInvalidOperation exception when the inserted control is the same as the current class instance. Uses the exception message in rsAControlCanNotHaveItselfAsParent.
          </p>
        </errors>
        <seealso>
          <link id="TControl.Parent"/>
          <link id="TWinControl.Controls"/>
          <link id="TWinControl.InsertControl"/>
          <link id="TControl.DisableAutoSizing"/>
          <link id="ListInsert"/>
        </seealso>
      </element>
      <element name="TWinControl.Insert.AControl">
        <short>Control to insert or append as a child control.</short>
      </element>
      <element name="TWinControl.Insert.Index">
        <short>Position where the new control is stored in the Controls property.</short>
      </element>

      <element name="TWinControl.Remove">
        <short>
          Removes the specified control from the list of child Controls for the class instance.
        </short>
        <descr>
          <p>
            Remove is a procedure used to remove the control in AControl from the list of child Controls for the class instance. No actions are performed in the method when AControl has not been assigned (contains <b>Nil</b>).
          </p>
          <p>
            Remove ensures that the value in AControl is removed from the Controls property, and the internal list used to determine alignment order of the child controls. When AControl is a TWinControl instance, it is removed from the internal tab order list for child controls.
          </p>
          <p>
            Remove sets the Parent property in AControl to Nil.
          </p>
          <p>
            Remove checks to see whether auto-sizing has been disabled in the AControl argument. When disabled in the child control, it is re-enabled for the current class instance.
          </p>
          <p>
            Remove is used in the implementation of the RemoveControl method.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.Controls"/>
          <link id="TControl.Parent"/>
          <link id="TWinControl.RemoveControl"/>
          <link id="TControl.EnableAutoSizing"/>
        </seealso>
      </element>
      <element name="TWinControl.Remove.AControl">
        <short>Control removed from the list of child Controls in the class instance.</short>
      </element>

      <element name="TWinControl.AlignNonAlignedControls">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.AlignNonAlignedControls.ListOfControls">
        <short/>
      </element>
      <element name="TWinControl.AlignNonAlignedControls.BoundsModified">
        <short/>
      </element>

      <element name="TWinControl.CreateControlAlignList">
        <short>
          Fills the list with the child controls which must be realigned.
        </short>
        <descr>
          <p>
            The list is initialized with all child controls which have the given alignment and are visible.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.AlignControls"/>
        </seealso>
      </element>
      <element name="TWinControl.CreateControlAlignList.TheAlign">
        <short>List all controls with this alignment.</short>
      </element>
      <element name="TWinControl.CreateControlAlignList.AlignList">
        <short/>
      </element>
      <element name="TWinControl.CreateControlAlignList.StartControl">
        <short/>
      </element>

      <element name="TWinControl.UpdateAlignIndex">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.UpdateAlignIndex.aChild">
        <short/>
      </element>

      <element link="#lcl.controls.TWinControl.DoubleBuffered" name="TWinControl.FDoubleBuffered"/>

      <element name="TWinControl.FWinControlFlags">
        <short>Various window control state flags.</short>
        <descr/>
        <seealso/>
      </element>

      <element link="#lcl.lclclasses.TLCLComponent.WSRegisterClass" name="TWinControl.WSRegisterClass"/>

      <element name="TWinControl.AdjustClientRect">
        <short>
          Override this method when the ClientRect for a control differs from the default value.
        </short>
        <descr>
          It is called often, so don't use expensive code here, or cache the resulting client rectangle.
        </descr>
        <seealso>
          <link id="TWinControl.GetAdjustedLogicalClientRect"/>
        </seealso>
      </element>
      <element name="TWinControl.AdjustClientRect.ARect">
        <short/>
      </element>

      <element name="TWinControl.GetAdjustedLogicalClientRect">
        <short>
          Returns the adjusted ClientRect, using the cached value if available.
        </short>
        <descr/>
        <seealso>
          <link id="TControl.ClientRect"/>
          <link id="TWinControl.AdjustClientRect"/>
          <link id="TWinControlFlag"/>
        </seealso>
      </element>
      <element name="TWinControl.GetAdjustedLogicalClientRect.ARect">
        <short/>
      </element>

      <element name="TWinControl.AlignControls">
        <short>Aligns all child controls.</short>
        <descr/>
        <seealso>
          <link id="TWinControlFlag"/>
        </seealso>
      </element>
      <element name="TWinControl.AlignControls.AControl">
        <short/>
      </element>
      <element name="TWinControl.AlignControls.RemainingClientRect">
        <short>The available space, becomes remaining space on exit.</short>
      </element>

      <element name="TWinControl.CustomAlignInsertBefore">
        <short>
          Returns the placement order of custom-aligned child controls, using the <var>OnAlignInsertBefore</var> handler.
        </short>
        <seealso>
          <link id="TAlignInsertBeforeEvent"/>
        </seealso>
      </element>
      <element name="TWinControl.CustomAlignInsertBefore.Result">
        <short>True if Control2 shall be placed before Control1 is placed.</short>
      </element>
      <element name="TWinControl.CustomAlignInsertBefore.AControl1">
        <short/>
      </element>
      <element name="TWinControl.CustomAlignInsertBefore.AControl2">
        <short/>
      </element>

      <element name="TWinControl.CustomAlignPosition">
        <short>
          Returns the aligned position for a custom-aligned child control, using the <var>OnAlignPosition</var> handler.
        </short>
        <descr>
          <p>
            The derived coordinates take into account the anchoring for <var>AControl</var>.
          </p>
          <p>
            The <var>OnAlignPosition</var> handler can update the coordinates as required.
          </p>
        </descr>
        <seealso>
          <link id="TAlignInsertBeforeEvent"/>
        </seealso>
      </element>
      <element name="TWinControl.CustomAlignPosition.AControl">
        <short>The control to be placed.</short>
      </element>
      <element name="TWinControl.CustomAlignPosition.ANewLeft">
        <short/>
      </element>
      <element name="TWinControl.CustomAlignPosition.ANewTop">
        <short/>
      </element>
      <element name="TWinControl.CustomAlignPosition.ANewWidth">
        <short/>
      </element>
      <element name="TWinControl.CustomAlignPosition.ANewHeight">
        <short/>
      </element>
      <element name="TWinControl.CustomAlignPosition.AlignRect">
        <short>
          The remaining client area, within which the control can be placed.
        </short>
      </element>
      <element name="TWinControl.CustomAlignPosition.AlignInfo">
        <short>Information about the current align process.</short>
      </element>

      <element name="TWinControl.DoAlignChildControls">
        <short>
          Override this method to position/align all given controls.
        </short>
        <descr/>
        <seealso>
          <link id="TWinControl.AlignControls"/>
        </seealso>
      </element>
      <element name="TWinControl.DoAlignChildControls.Result">
        <short>True when all controls have been placed.</short>
      </element>
      <element name="TWinControl.DoAlignChildControls.TheAlign">
        <short>The alignment of all given controls.</short>
      </element>
      <element name="TWinControl.DoAlignChildControls.AControl">
        <short/>
      </element>
      <element name="TWinControl.DoAlignChildControls.AControlList">
        <short>The controls to be placed.</short>
      </element>
      <element name="TWinControl.DoAlignChildControls.ARect">
        <short/>
      </element>

      <element name="TWinControl.DoChildSizingChange">
        <short>
          Called after a change in ChildSizing information to trigger further processing.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.DoChildSizingChange.Sender">
        <short/>
      </element>

      <element name="TWinControl.InvalidatePreferredChildSizes">
        <short>Flags the preferred sizes of all child controls as invalid (recursively).</short>
        <seealso>
          <link id="TWinControlFlag"/>
          <link id="TControlFlag"/>
        </seealso>
      </element>

      <element name="TWinControl.CanTab">
          <short>Indicates whether the Tab key can be used for keyboard navigation in the control.</short>
          <descr>
            <p>
              CanTab is an overridden method in TWinControl. The return value is True if the control is eligible to receive input focus. It must have a parent form and be both visible and enabled.
            </p>
            <p>
              Set TabStop to indicate the control is omitted in the tab order for the parent form.
            </p>
          </descr>
          <seealso>
            <link id="TWinControl.CanFocus"/>
            <link id="TWinControl.SelectNext"/>
            <link id="TWinControl.Focused"/>
            <link id="TControl.CanTab"/>
          </seealso>
        </element>
      <element name="TWinControl.CanTab.Result">
        <short/>
      </element>

      <element name="TWinControl.IsClientHeightStored">
        <short>Implements the storage specifier for the ClientHeight property.</short>
        <descr>
          <p>
            Re-implements the method inherited from TControl.
          </p>
        </descr>
        <seealso>
          <link id="#lcl.controls.TControl.ClientHeight">TControl.ClientHeight</link>
        </seealso>
      </element>
      <element name="TWinControl.IsClientHeightStored.Result">
        <short>True if ControlCount has a non-zero value.</short>
      </element>

      <element name="TWinControl.IsClientWidthStored">
        <short>Implements the storage specifier for the ClientWidth property.</short>
        <descr>
          <p>
            Re-implements the method inherited from TControl.
          </p>
        </descr>
        <seealso>
          <link id="#lcl.controls.TControl.ClientWidth">TControl.ClientWidth</link>
        </seealso>
      </element>
      <element name="TWinControl.IsClientWidthStored.Result">
        <short>True if ControlCount has a non-zero value.</short>
      </element>

      <element name="TWinControl.DoSendShowHideToInterface">
        <short>Sends the new Visible state to the widgetset.</short>
        <descr>
          <p>
            Called by the CMShowingChanged method.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.CMShowingChanged"/>
        </seealso>
      </element>

      <element name="TWinControl.ControlsAligned">
        <short>Called by AlignControls after aligning controls.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.DoSendBoundsToInterface">
        <short>Sends the control's new bounds to the widget.</short>
        <descr>Called by RealizeBounds.</descr>
        <seealso>
          <link id="TWinControlFlag"/>
        </seealso>
      </element>

      <element name="TWinControl.RealizeBounds">
        <short>
          Checks for changes in BoundsRect, and sends the new bounds to the widget using DoSendBoundsToInterface.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.RealizeBoundsRecursive">
        <short>
          Sends changed BoundsRects to the widget, for this and all child controls.
        </short>
        <descr/>
        <seealso>
          <link id="TWinControl.RealizeBounds"/>
          <link id="TWinControlFlag"/>
        </seealso>
      </element>

      <element name="TWinControl.InvalidateBoundsRealized">
        <short>Resets the bounds rectangle for the control.</short>
        <descr>
          <p>
            Creates a new, empty TRect instance for the internal member passed to the widgetset class. Used in widgetset methods which apply changes to the Font for the control.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TWinControl.CreateSubClass">
        <short>An empty implementation in the current LCL version.</short>
        <descr>
          <p>
            An empty implementation in the current LCL version.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.CreateSubClass.Params">
        <short>Creation parameters for the subclass.</short>
      </element>
      <element name="TWinControl.CreateSubClass.ControlClassName">
        <short>Class name for the control added as a subclass.</short>
      </element>

      <element link="#lcl.controls.TControl.DoConstraintsChange" name="TWinControl.DoConstraintsChange"/>
      <element name="TWinControl.DoConstraintsChange.Sender">
        <short/>
      </element>

      <element name="TWinControl.DoSetBounds">
        <short>
          Updates the size and extent of the control and its ClientRect.
        </short>
        <descr>
          <p>
            Changing the ClientRect here, to the most probable size, reduces unnecessary resize messages.
          </p>
          <p>
            Normally, the ClientWidth / ClientHeight are adjusted automatically by the widget. But it is up to the widget when this will be done. GTK, for example, just puts resize requests in a queue. The LCL would resize the child components immediately after the GTK procedure to adjust the ClientRect. On complex forms with lots of nested controls, this would result in thousands of resize messages.
          </p>
        </descr>
        <seealso>
          <link id="TControl.DoSetBounds"/>
        </seealso>
      </element>
      <element name="TWinControl.DoSetBounds.ALeft">
        <short/>
      </element>
      <element name="TWinControl.DoSetBounds.ATop">
        <short/>
      </element>
      <element name="TWinControl.DoSetBounds.AWidth">
        <short/>
      </element>
      <element name="TWinControl.DoSetBounds.AHeight">
        <short/>
      </element>

      <element name="TWinControl.DoAutoSize">
        <short>
          Shrinks or enlarges the control to accommodate its children.
        </short>
        <descr>
          <p>
            Because this method is frequently overridden, the LCL calls the <link id="TControl.AdjustSize"/> method instead; it checks whether DoAutoSize really should be called right now.
          </p>
          <p>
            DoAutoSize does roughly this:
          </p>
          <ul>
            <li>Checks whether Autosize is in fact permitted</li>
            <li>Checks for unaligned child components and fits them in as best it can</li>
            <li>Moves the constrained (aligned) child components to the correct position</li>
            <li>Adjusts the size of the client rectangle</li>
            <li>Adjusts the bounds of the whole control</li>
          </ul>
        </descr>
        <seealso>
          <link id="TControl.DoAutoSize"/>
        </seealso>
      </element>

      <element link="#lcl.controls.TControl.DoAllAutoSize" name="TWinControl.DoAllAutoSize"/>

      <element name="TWinControl.AllAutoSized">
        <short>Called by DoAllAutoSize after all bounds are computed.</short>
        <descr/>
        <seealso>
          <link id="#lcl.forms.TCustomForm.AllAutoSized">TCustomForm.AllAutoSized</link>
        </seealso>
      </element>

      <element name="TWinControl.CalculatePreferredSize">
        <short>
          Override this method to return a different preferred height and/or width for auto-sizing.
        </short>
        <descr>
          <p>
            Calls the inherited method to calculate the default / preferred width and height for a <var>TWinControl</var> instance. It is used by the LCL auto-sizing algorithms as the default size. Only positive values are valid. Negative or 0 (Zero) values are treated as undefined, and the LCL uses other values to perform auto-sizing.
          </p>
          <p>
            <var>TWinControl</var> overrides this:
          </p>
          <ul>
            <li>If there are child components, their total preferred size is calculated</li>
            <li>If this value can not be computed (e.g. the children depend too much on their
              parent clientrect), then the interface is asked for the preferred size</li>
          </ul>
          <p>
            For example the preferred size of a <var>TButton</var> is the size, where the label fits exactly. This relies on the current theme and widgetset.
          </p>
          <p>
            This value is independent of constraints and siblings, only the inner parts are relevant for the calculates values.
          </p>
          <p>
            <var>WithThemeSpace</var> adds space for stacking when set to <b>True</b>. For example: <var>TRadioButton</var> has a minimum size. But for stacking multiple TRadioButtons there should be space around each control. This space is theme- dependent, so it is passed as a parameter to the widget set.
          </p>
        </descr>
        <seealso>
          <link id="TControl.CalculatePreferredSize"/>
        </seealso>
      </element>
      <element name="TWinControl.CalculatePreferredSize.PreferredWidth">
        <short/>
      </element>
      <element name="TWinControl.CalculatePreferredSize.PreferredHeight">
        <short/>
      </element>
      <element name="TWinControl.CalculatePreferredSize.WithThemeSpace">
        <short>Indicates if additional space is reserved for theme services.</short>
      </element>

      <element name="TWinControl.GetPreferredSizeClientFrame">
        <short>Calculates the width and height for the frame area around the control.</short>
        <descr>
          <p>
            Calculated as follows:
          </p>
          <ul>
            <li>
              AWidth is the difference between Width and ClientWidth.
            </li>
            <li>
              AHeight is the difference between Height and ClientHeight.
            </li>
          </ul>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.GetPreferredSizeClientFrame.AWidth">
        <short>Width used for the frame around the control.</short>
      </element>
      <element name="TWinControl.GetPreferredSizeClientFrame.AHeight">
        <short>Height used for the frame around the control.</short>
      </element>

      <element name="TWinControl.GetChildren">
        <short>
          Calls the specified procedure for each child control owned by the control in Root.
        </short>
        <descr/>
        <seealso>
        </seealso>
      </element>
      <element name="TWinControl.GetChildren.Proc">
        <short>The callback procedure.</short>
      </element>
      <element name="TWinControl.GetChildren.Root">
        <short>Owner of the affected controls.</short>
      </element>

      <element name="TWinControl.ChildClassAllowed">
        <short>Returns True if the specified  class is allowed in child controls.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.ChildClassAllowed.Result">
        <short>True when allowed.</short>
      </element>
      <element name="TWinControl.ChildClassAllowed.ChildClass">
        <short>Class type examined in the method.</short>
      </element>

      <element name="TWinControl.PaintControls">
        <short>Paints all child controls which do not have a Handle.</short>
        <descr>
          <p>
            Controls which do <b>not</b> descend from <var>TWinControl</var> have no handle of their own; they are repainted when the parent control is redrawn.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.PaintControls.DC">
        <short>The device context usable for painting child controls.</short>
      </element>
      <element name="TWinControl.PaintControls.First">
        <short>First of the controls in Controls[], which remain to paint.</short>
      </element>

      <element name="TWinControl.PaintHandler">
        <short>Handler for TLMPaint, manages the painting of child controls.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.PaintHandler.TheMessage">
        <short/>
      </element>

      <element name="TWinControl.PaintWindow">
        <short>Paints a clipped portion (child control) on the specified device context.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.PaintWindow.DC">
        <short/>
      </element>

      <element name="TWinControl.CreateBrush">
        <short>
          Creates the <link id="TWinControl.Brush">Brush</link>, if not already created.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.ScaleControls">
        <short>Scales (resizes) all child controls.</short>
        <descr/>
        <seealso>
          <link id="TControl.ChangeScale"/>
        </seealso>
      </element>
      <element name="TWinControl.ScaleControls.Multiplier">
        <short/>
      </element>
      <element name="TWinControl.ScaleControls.Divider">
        <short/>
      </element>

      <element name="TWinControl.ChangeScale">
        <short>
          Scales (resizes) the control and all of its child controls.
        </short>
        <descr/>
        <seealso>
          <link id="TControl.ChangeScale"/>
        </seealso>
      </element>
      <element name="TWinControl.ChangeScale.Multiplier">
        <short/>
      </element>
      <element name="TWinControl.ChangeScale.Divider">
        <short/>
      </element>

      <element name="TWinControl.CMBiDiModeChanged">
        <short>
          Handler for a changed <link id="#lcl.Controls.TControl.BiDiMode">BiDiMode</link> message; notifies the widget and all child controls.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.CMBiDiModeChanged.Message">
        <short/>
      </element>

      <element name="TWinControl.CMBorderChanged">
        <short>
          Handler for changed Border property messages; adjusts and invalidates the control.
        </short>
      </element>
      <element name="TWinControl.CMBorderChanged.Message">
        <short>Message examined in the method.</short>
      </element>

      <element name="TWinControl.CMDoubleBufferedChanged">
        <short>Handler for changes to the DoubleBuffered property.</short>
        <descr>
          <p>
            <var>CMDoubleBufferedChanged</var> is the handler used to process <b>CM_PARENTDOUBLEBUFFEREDCHANGED</b> messages when the value in <var>DoubleBuffered</var> has been been changed.
          </p>
          <p>
            CMDoubleBufferedChanged calls <var>NotifyControls</var> to apply the message in the widget set class; the value in the Message argument is ignored.
          </p>
          <p>
            CMDoubleBufferedChanged calls <var>Invalidate</var> to cause the control to be redrawn.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.DoubleBuffered"/>
          <link id="TWinControl.NotifyControls"/>
          <link id="TWinControl.Invalidate"/>
        </seealso>
      </element>
      <element name="TWinControl.CMDoubleBufferedChanged.Message">
        <short>Message examined in the method.</short>
      </element>

      <element name="TWinControl.CMEnabledChanged">
        <short>
          Handler for changed <link id="#lcl.Controls.TControl.Enabled">Enabled</link> message; notifies the widgetset.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.CMEnabledChanged.Message">
        <short/>
      </element>

      <element name="TWinControl.CMParentDoubleBufferedChanged">
        <short>
          Handles the CM_PARENTDOUBLEBUFFEREDCHANGED control message for the control (when enabled).
        </short>
        <descr>
          <p>
            Sets the value in ParentDoubleBuffered to True. When Parent is assigned, the value in DoubleBufferred is set to the corresponding value from the Parent control.
          </p>
          <p>
            No actions are performed in the method if ParentDoubleBuffered is already set to False.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.CMParentDoubleBufferedChanged.Message">
        <short>Message handled in the method.</short>
      </element>

      <element name="TWinControl.CMShowingChanged">
        <short>
          Handler for changed <link id="TWinControl.Showing">Showing</link> message; notifies the widgetset.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.CMShowingChanged.Message">
        <short/>
      </element>

      <element name="TWinControl.CMShowHintChanged">
        <short>
          Handler for changed <link id="TControl.ShowHint">ShowHint</link> message; notifies all child controls.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.CMShowHintChanged.Message">
        <short/>
      </element>

      <element name="TWinControl.CMVisibleChanged">
        <short>
          Handles Focus changes, and forces UpdateControlState.
        </short>
        <descr>
          Handler for changed <link id="TControl.Visible">Visible</link> message.
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.CMVisibleChanged.Message">
        <short/>
      </element>

      <element name="TWinControl.CMEnter">
        <short>Handles the CM_ENTER control message for the control.</short>
        <descr>
          <p>
            CM_ENTER and CM_EXIT messages occur when the active control is changed on a form.
          </p>
          <p>
            Calls DoEnter to signal the OnEnter event handler (when assigned).
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.DoEnter"/>
          <link id="TWinControl.OnEnter"/>
        </seealso>
      </element>
      <element name="TWinControl.CMEnter.Message">
        <short>Message handled in the method.</short>
      </element>

      <element name="TWinControl.CMExit">
        <short>Handles the CM_EXIT control message for the control.</short>
        <descr>
          <p>
            CM_ENTER and CM_EXIT messages occur when the active control is changed on a form.
          </p>
          <p>
            Calls DoExit to signal the OnExit event handler (when assigned).
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.DoExit"/>
          <link id="TWinControl.OnExit"/>
        </seealso>
      </element>
      <element name="TWinControl.CMExit.Message">
        <short/>
      </element>

      <element name="TWinControl.WMContextMenu">
        <short>
          Handler for an <link id="TControl.PopupMenu">ContextMenu</link> event; eventually delegates handling to the affected child control.
        </short>
        <descr>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.WMContextMenu.Message">
        <short/>
      </element>

      <element name="TWinControl.WMEraseBkgnd">
        <short>
          Erases the background, when required.
        </short>
        <descr/>
        <seealso>
          <link id="TWinControlFlag"/>
        </seealso>
      </element>
      <element name="TWinControl.WMEraseBkgnd.Message">
        <short/>
      </element>

      <element name="TWinControl.WMNotify">
        <short>Handles (dispatches) notification messages.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.WMNotify.Message">
        <short/>
      </element>

      <element name="TWinControl.WMSetFocus">
        <short>Handler for receiving Focus event.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.WMSetFocus.Message">
        <short/>
      </element>

      <element name="TWinControl.WMKillFocus">
        <short>Handles the LM_KILLFOCUS  message for the control.</short>
        <descr>
          <p>
            <var>WMKillFocus</var> is a method used to handle the LM_KILLFOCUS  control message  received when a control loses focus. WMKillFocus ensures that the <var>EditingDone</var> method is called for the control when the parent form has been assigned and is Active.
          </p>
          <p>
            No actions are performed in the method at design-time, or when the control is being freed.
          </p>
        </descr>
        <seealso>
          <link id="TControl.EditingDone"/>
          <link id="#lcl.forms.GetParentForm">GetParentForm</link>
        </seealso>
      </element>
      <element name="TWinControl.WMKillFocus.Message">
        <short>Message examined in the method.</short>
      </element>

      <element name="TWinControl.WMShowWindow">
        <short>Handler for changed visibility notification.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.WMShowWindow.Message">
        <short/>
      </element>

      <element name="TWinControl.WMEnter">
        <short>Handles the LM_ENTER message for the control.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.WMEnter.Message">
        <short>Message handled in the method.</short>
      </element>

      <element name="TWinControl.WMExit">
        <short>Handles the LM_EXIT message for the control.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.WMExit.Message">
        <short>Message handled in the method.</short>
      </element>

      <element name="TWinControl.WMKeyDown">
        <short>
          Event handler for a key press not handled by the widget; Tries <link id="TWinControl.DoRemainingKeyDown"/>
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.WMKeyDown.Message">
        <short/>
      </element>

      <element name="TWinControl.WMSysKeyDown">
        <short>
          Event handler for system key presses not handled by the widget; tries <link id="TWinControl.DoRemainingKeyDown"/>
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.WMSysKeyDown.Message">
        <short/>
      </element>

      <element name="TWinControl.WMKeyUp">
        <short>
          Event handler for key released, not handled by the widget. Tries <link id="TWinControl.DoRemainingKeyUp"/>.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.WMKeyUp.Message">
        <short/>
      </element>

      <element name="TWinControl.WMSysKeyUp">
        <short>
          Event handler for system key releases not handled by the widget; tries <link id="TWinControl.DoRemainingKeyUp"/>
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.WMSysKeyUp.Message">
        <short/>
      </element>

      <element name="TWinControl.WMChar">
        <short>
          Handler for messages sent by the widget, after it has handled the key press itself.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.WMChar.Message">
        <short/>
      </element>

      <element name="TWinControl.WMSysChar">
        <short>
          Handler for messages sent by the widget, after it has handled the key press itself.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.WMSysChar.Message">
        <short/>
      </element>

      <element name="TWinControl.WMPaint">
        <short>
          Manages paint requests, and handles double buffering.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.WMPaint.Msg">
        <short/>
      </element>

      <element name="TWinControl.WMDestroy">
        <short>
          Handler for widget destroyed message; clears the Handle.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.WMDestroy.Message">
        <short/>
      </element>

      <element name="TWinControl.WMMove">
        <short>
          Handler for widget moved message; updates the Bounds.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.WMMove.Message">
        <short/>
      </element>

      <element name="TWinControl.WMSize">
        <short>
          Event handler for size messages.
        </short>
        <descr>
          <p>
            This method is called whenever <var>Width</var>, <var>Height</var>, <var>ClientWidth</var> or <var>ClientHeight</var> have changed. If the source of the message is the interface, the new size is stored in the internal BoundsRealized member to avoid sending a size message back to the interface.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.WMSize.Message">
        <short/>
      </element>

      <element name="TWinControl.WMWindowPosChanged">
        <short>
          Event handler for size/move messages.
        </short>
        <descr>
          <p>
            This method is called whenever left, top, width, height, clientwidth or clientheight have changed.
          </p>
          <p>
            If the source of the message is the interface, the new size is stored in the internal BoundsRealized member. Avoids sending a size message back to the interface.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.WMWindowPosChanged.Message">
        <short/>
      </element>

      <element name="TWinControl.CNKeyDown">
        <short>
          Handler for a key pushed notification; the message is handled by DoKeyDownBeforeInterface by default.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.CNKeyDown.Message">
        <short/>
      </element>

      <element name="TWinControl.CNSysKeyDown">
        <short>
          Handler for a system key pushed notification; the message is handled by DoKeyDownBeforeInterface by default.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.CNSysKeyDown.Message">
        <short/>
      </element>

      <element name="TWinControl.CNKeyUp">
        <short>
          Handler for a key released notification; the message is handled by DoKeyUpBeforeInterface by default.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.CNKeyUp.Message">
        <short/>
      </element>

      <element name="TWinControl.CNSysKeyUp">
        <short>
          Handler for a system key released notification; the message is handled by DoKeyUpBeforeInterface by default.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.CNSysKeyUp.Message">
        <short/>
      </element>

      <element name="TWinControl.CNChar">
        <short>
          Handler for a key pressed notification; CNChar is sent by the widget before it has handled the key press itself.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.CNChar.Message">
        <short/>
      </element>

      <element name="TWinControl.DoDragMsg">
        <short>Dispatches a drag message, sent by the DragManager.</short>
        <descr>
          <p>
            On dmFindTarget, a TWinControl returns the child control under the mouse, or Self if none is found.
          </p>
          <p>
            All other messages are handled by the inherited <link id="TControl.DoDragMsg"/> method.
          </p>
        </descr>
        <seealso>
          <link id="TControl.DoDragMsg"/>
        </seealso>
      </element>
      <element name="TWinControl.DoDragMsg.Result">
        <short/>
      </element>
      <element name="TWinControl.DoDragMsg.ADragMessage">
        <short/>
      </element>
      <element name="TWinControl.DoDragMsg.APosition">
        <short/>
      </element>
      <element name="TWinControl.DoDragMsg.ADragObject">
        <short/>
      </element>
      <element name="TWinControl.DoDragMsg.ATarget">
        <short/>
      </element>
      <element name="TWinControl.DoDragMsg.ADocking">
        <short/>
      </element>

      <element name="TWinControl.DoDockClientMsg">
        <short>
          Handles a dmDragDock message, when a control has been docked to this site.
        </short>
        <descr>
          <p>
            Called when a control is dropped for docking. Asks the dropped control to Dock itself into this control (adjust HostDockSite etc.). Calls an installed DockManager to adjust the coordinates of the docked control. The Result is always True (unless overridden).
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.DoDockClientMsg.Result">
        <short/>
      </element>
      <element name="TWinControl.DoDockClientMsg.DragDockObject">
        <short/>
      </element>
      <element name="TWinControl.DoDockClientMsg.aPosition">
        <short/>
      </element>

      <element name="TWinControl.DoUndockClientMsg">
        <short>
          Notifies the DockManager of the undock of a client control.
        </short>
        <descr/>
        <seealso>
          <link id="TDockManager.RemoveControl"/>
        </seealso>
      </element>
      <element name="TWinControl.DoUndockClientMsg.Result">
        <short>Always True.</short>
      </element>
      <element name="TWinControl.DoUndockClientMsg.NewTarget">
        <short/>
      </element>
      <element name="TWinControl.DoUndockClientMsg.Client">
        <short/>
      </element>

      <element name="TWinControl.DoAddDockClient">
        <short>Adjust the Parent of a newly docked Client.</short>
        <descr>
          The default action is to set the Parent to the new docksite (this control), so that the client is displayed within the new site.
        </descr>
      </element>
      <element name="TWinControl.DoAddDockClient.Client">
        <short/>
      </element>
      <element name="TWinControl.DoAddDockClient.ARect">
        <short/>
      </element>

      <element name="TWinControl.DockOver">
        <short>Called to check whether this control allows docking and where.
        </short>
        <descr>
          <p>
            Called for messages from the DragManager including: dmEnter, dmLeave, and dmMove. Gets the DockRect to show.
          </p>
          <p>
            Positions the DockRect, and invokes OnDockOver (via DoDockOver).
          </p>
          <p>
            Everything can be overridden using the OnDockOver handler, when assigned.
          </p>
        </descr>
        <seealso>
          <link id="TControl.PositionDockRect"/>
          <link id="TWinControl.OnDockOver"/>
        </seealso>
      </element>
      <element name="TWinControl.DockOver.Source">
        <short/>
      </element>
      <element name="TWinControl.DockOver.X">
        <short/>
      </element>
      <element name="TWinControl.DockOver.Y">
        <short/>
      </element>
      <element name="TWinControl.DockOver.State">
        <short/>
      </element>
      <element name="TWinControl.DockOver.Accept">
        <short>Initially True, set to False to reject an drop.</short>
      </element>

      <element name="TWinControl.DoDockOver">
        <short>Invoke the <link id="TWinControl.OnDockOver">OnDockOver</link> handler.</short>
      </element>
      <element name="TWinControl.DoDockOver.Source">
        <short/>
      </element>
      <element name="TWinControl.DoDockOver.X">
        <short/>
      </element>
      <element name="TWinControl.DoDockOver.Y">
        <short/>
      </element>
      <element name="TWinControl.DoDockOver.State">
        <short/>
      </element>
      <element name="TWinControl.DoDockOver.Accept">
        <short/>
      </element>

      <element name="TWinControl.DoRemoveDockClient">
        <short>
          Override this method to take special actions on removal of an docked client.
        </short>
        <descr>The default implementation does nothing.</descr>
      </element>
      <element name="TWinControl.DoRemoveDockClient.Client">
        <short/>
      </element>

      <element name="TWinControl.DoUnDock">
        <short>
          Notifies an <var>OnUnDock</var> handler and the <var>DockManager</var> of an undocked client control.
        </short>
        <descr>
          <p>
            The <var>OnUnDock</var> handler can deny the undocking request for the control. This can cause problems; instead, the control better should not be draggable.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.DoUndockClientMsg"/>
          <link id="TWinControl.OnUnDock"/>
        </seealso>
      </element>
      <element name="TWinControl.DoUnDock.Result">
        <short>Set to False to deny undocking.</short>
      </element>
      <element name="TWinControl.DoUnDock.NewTarget">
        <short>The new docksite, <b>Nil</b> for floating.</short>
      </element>
      <element name="TWinControl.DoUnDock.Client">
        <short>The control being undocked.</short>
      </element>
      <element name="TWinControl.DoUnDock.KeepDockSiteSize">
        <short/>
      </element>

      <element name="TWinControl.GetSiteInfo">
        <short>Return information about this dock site (InfluenceRect).</short>
        <descr>
          <p>
            The <var>InfluenceRect</var> determines the screen coordinates, within which a drop is accepted. The <var>InfluenceRect</var> is the slightly inflated <var>WindowRect</var> for the dock site, and can be adjusted in the  <var>OnGetSiteInfo</var> event handler.
          </p>
        </descr>
      </element>
      <element name="TWinControl.GetSiteInfo.Client">
        <short>The dragged control.</short>
      </element>
      <element name="TWinControl.GetSiteInfo.InfluenceRect">
        <short>The screen rectangle within which a drop is allowed.</short>
      </element>
      <element name="TWinControl.GetSiteInfo.MousePos">
        <short>The current mouse position.</short>
      </element>
      <element name="TWinControl.GetSiteInfo.CanDock">
        <short>Can be set to False to reject an drop.</short>
      </element>

      <element name="TWinControl.GetParentHandle">
        <short>Gets the handle for the Parent control.</short>
        <descr>
          <p>
            <var>GetParentHandle</var> is a <var>HWND</var> function used to get the handle for the Parent in the current control. The return value contains the handle for the TWinControl instance in Parent (when assigned). When unassigned, the handle in ParentWindow is used as the return value.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Parent"/>
          <link id="TWinControl.ParentWindow"/>
        </seealso>
      </element>
      <element name="TWinControl.GetParentHandle.Result">
        <short>Control or window handle that is the parent for the current control.</short>
      </element>

      <element name="TWinControl.GetTopParentHandle">
        <short>
          Gets the window handle for the parent control at the top of the control hierarchy.
        </short>
        <descr>
          <p>
            GetTopParentHandle is a HWND function used to get the window handle for the first control in the parent control hierarchy. The value in Parent is recusrively searched until Parent is not assigned.
          </p>
          <p>
            The return value is the ParentWindow property in the top-most control. If ParentWindow is 0 (the unassigned value), the value in its Handle property is used.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.GetTopParentHandle.Result">
        <short>Window handle for the top-most parent control in the hierarchy.</short>
      </element>

      <element name="TWinControl.ReloadDockedControl">
        <short>Returns the docked control of the specified name.</short>
        <descr>
          <p>This method is used during the restore of the layout of a docksite.</p>
          <p>The control is searched in the controls owned by the owner of the docksite.</p>
          <p>Override to search other places, or to create a control of the requested name.</p>
        </descr>
      </element>
      <element name="TWinControl.ReloadDockedControl.AControlName">
        <short>The name of the control to be docked.</short>
      </element>
      <element name="TWinControl.ReloadDockedControl.AControl">
        <short>The matching control.</short>
      </element>

      <element name="TWinControl.CreateDockManager">
        <short>Returns the DockManager for this control.</short>
        <descr>
          <p>
            If DockManager is <b>Nil</b>, and <var>UseDockManager</var> is <b>True</b>, a new default DockManager is created.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.CreateDockManager.Result">
        <short>The dockmanager for this site, can be <b>Nil</b> for an unmanaged site.</short>
      </element>

      <element name="TWinControl.SetDockManager">
        <short>Sets the value for the DockManager property.</short>
        <descr/>
        <seealso>
          <link id="TWinControl.DockManager"/>
        </seealso>
      </element>
      <element name="TWinControl.SetDockManager.AMgr">
        <short>New value for the DockManager property.</short>
      </element>

      <element name="TWinControl.DoFloatMsg">
        <short>Handler called when the control starts floating.</short>
        <descr>
          TWinControls can float for themselves, unless they request a special FloatingDockSiteClass.
        </descr>
        <seealso>
          <link id="TControl.DoFloatMsg"/>
        </seealso>
      </element>
      <element name="TWinControl.DoFloatMsg.ADockSource">
        <short/>
      </element>

      <element name="TWinControl.DoGetDockCaption">
        <short>Returns the dock caption in AControl.</short>
        <descr>
          <p>
            Asks the control for its default dock caption, then allows the OnGetDockCaption handler to adjust the string value.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.GetDockCaption"/>
          <link id="TWinControl.OnGetDockCaption"/>
        </seealso>
      </element>
      <element name="TWinControl.DoGetDockCaption.AControl">
        <short>The control whose dock caption string is requested.</short>
      </element>
      <element name="TWinControl.DoGetDockCaption.ACaption">
        <short>The dock caption to use.</short>
      </element>

      <element name="TWinControl.DoEnter">
        <short>Invokes the <link id="#lcl.Controls.TWinControl.OnEnter">OnEnter</link> event handler.</short>
      </element>

      <element name="TWinControl.DoExit">
        <short>Invoke the <link id="#lcl.Controls.TWinControl.OnExit">OnExit</link> event handler.</short>
      </element>

      <element name="TWinControl.DoKeyDownBeforeInterface">
        <short>Handles a KeyDown event before the widget processes the key.
        </short>
        <descr>
          <p>
            Key event handlers are invoked in sequence, until a handler is located which responds to the key.
          </p>
          <p>
            First, all application wide handlers are invoked (<var>TApplication.NotifyKeyDownBeforeHandler</var>).
          </p>
          <p>
            Second, the form handler is invoked when KeyPreview is requested.
          </p>
          <p>
            Third, the DragManager is used to determine the dragging status for the control. It interprets the <b>ESC</b> key as a cancel dragging request, and the <b>CTRL</b> key as a request to ignore drag targets.
          </p>
          <p>
            Finally, the <link id="TWinControl.OnKeyDown"/> user handler is invoked.
          </p>
          <p>
            If none of the  handlers accept / respond to the key, the widget set class is used to process  the key.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.OnKeyDown"/>
          <link id="#lcl.Forms.TApplication.NotifyKeyDownBeforeHandler">
            TApplication.NotifyKeyDownBeforeHandler</link>
        </seealso>
      </element>
      <element name="TWinControl.DoKeyDownBeforeInterface.Result">
        <short>Set to True when the key was handled.</short>
      </element>
      <element name="TWinControl.DoKeyDownBeforeInterface.Message">
        <short>Message examined in the method.</short>
      </element>
      <element name="TWinControl.DoKeyDownBeforeInterface.IsRecurseCall">
        <short/>
      </element>

      <element name="TWinControl.DoRemainingKeyDown">
        <short>
          Handles key down messages which are not handled by the widget.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.DoRemainingKeyDown.Result">
        <short>True if the key was handled.</short>
      </element>
      <element name="TWinControl.DoRemainingKeyDown.Message">
        <short/>
      </element>

      <element name="TWinControl.DoRemainingKeyUp">
        <short>
          Handles key up messages which are not handled by the widget.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.DoRemainingKeyUp.Result">
        <short>True if the key was handled.</short>
      </element>
      <element name="TWinControl.DoRemainingKeyUp.Message">
        <short/>
      </element>

      <element name="TWinControl.DoKeyPress">
        <short>
          Tries all <link id="#lcl.Controls.TWinControl.OnKeyPress">OnKeyPress</link> handlers;  the Parent OnKeyPress handler is tried first.
        </short>
        <descr/>
        <seealso>
          <link id="TWinControl.OnUTF8KeyPress"/>
        </seealso>
      </element>
      <element name="TWinControl.DoKeyPress.Result">
        <short>True if the key was handled.</short>
      </element>
      <element name="TWinControl.DoKeyPress.Message">
        <short/>
      </element>

      <element name="TWinControl.DoUTF8KeyPress">
        <short>
          Tries all <link id="#lcl.Controls.TWinControl.OnUTF8KeyPress">OnUTF8KeyPress</link> handlers;  the Parent OnUTF8KeyPress handler is tried first.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.DoUTF8KeyPress.Result">
        <short>True if the key was handled.</short>
      </element>
      <element name="TWinControl.DoUTF8KeyPress.UTF8Key">
        <short>UTF-8-encoded character examined in the method.</short>
      </element>

      <element name="TWinControl.DoKeyUpBeforeInterface">
        <short>
          Handles a KeyUp event before the widget processes the key.
        </short>
        <descr>
          <p>
            For details, see the <link id="TWinControl.DoKeyDownBeforeInterface"/> method.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.DoKeyUpBeforeInterface.Result">
        <short>True if the key was handled.</short>
      </element>
      <element name="TWinControl.DoKeyUpBeforeInterface.Message">
        <short>Message examined in the method.</short>
      </element>

      <element name="TWinControl.ChildKey">
        <short>Applies the key message using ChildKey in the parent control.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.ChildKey.Result">
        <short>True if the key was handled.</short>
      </element>
      <element name="TWinControl.ChildKey.Message">
        <short/>
      </element>

      <element name="TWinControl.SendDialogChar">
        <short>
          Forwards the key message to the parent form to be handled as an accelerator (shortcut) key.
        </short>
        <descr>
          <p>
            No actions are performed in the method when accelerator keys are not enabled for the LCL interface, or when ParentForm is unassigned for the control.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.SendDialogChar.Result">
        <short>True if the key was handled.</short>
      </element>
      <element name="TWinControl.SendDialogChar.Message">
        <short/>
      </element>

      <element link="#lcl.controls.TControl.DialogChar" name="TWinControl.DialogChar"/>
      <element name="TWinControl.DialogChar.Result">
        <short>True if the key was handled.</short>
      </element>
      <element name="TWinControl.DialogChar.Message">
        <short/>
      </element>

      <element name="TWinControl.ControlKeyDown">
        <short>Lets the Application handle an navigation key.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.ControlKeyDown.Key">
        <short/>
      </element>
      <element name="TWinControl.ControlKeyDown.Shift">
        <short/>
      </element>

      <element name="TWinControl.ControlKeyUp">
        <short>Lets the Application handle an navigation key.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.ControlKeyUp.Key">
        <short/>
      </element>
      <element name="TWinControl.ControlKeyUp.Shift">
        <short/>
      </element>

      <element name="TWinControl.KeyDown">
        <short>
          Invokes the <link id="#lcl.Controls.TWinControl.OnKeyDown">OnKeyDown</link> handler.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.KeyDown.Key">
        <short/>
      </element>
      <element name="TWinControl.KeyDown.Shift">
        <short/>
      </element>

      <element name="TWinControl.KeyDownBeforeInterface">
        <short>
          Invokes the <link id="#lcl.Controls.TWinControl.OnKeyDown">OnKeyDown</link> handler.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.KeyDownBeforeInterface.Key">
        <short/>
      </element>
      <element name="TWinControl.KeyDownBeforeInterface.Shift">
        <short/>
      </element>

      <element name="TWinControl.KeyDownAfterInterface">
        <short>An empty implementation in the current LCL version.</short>
        <descr>
          <p>
            An empty implementation in the current LCL version.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.KeyDownAfterInterface.Key">
        <short/>
      </element>
      <element name="TWinControl.KeyDownAfterInterface.Shift">
        <short/>
      </element>

      <element name="TWinControl.KeyPress">
        <short>
          Invokes the <link id="#lcl.Controls.TWinControl.OnKeyPress">OnKeyPress</link> handler.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.KeyPress.Key">
        <short/>
      </element>

      <element name="TWinControl.KeyUp">
        <short>
          Invokes the <link id="#lcl.Controls.TWinControl.OnKeyUp">OnKeyUp</link> handler.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.KeyUp.Key">
        <short/>
      </element>
      <element name="TWinControl.KeyUp.Shift">
        <short/>
      </element>

      <element name="TWinControl.KeyUpBeforeInterface">
        <short>
          Invokes the <link id="#lcl.Controls.TWinControl.OnKeyUp">OnKeyUp</link> handler.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.KeyUpBeforeInterface.Key">
        <short/>
      </element>
      <element name="TWinControl.KeyUpBeforeInterface.Shift">
        <short/>
      </element>

      <element name="TWinControl.KeyUpAfterInterface">
        <short>An empty implementation in the current LCL version.</short>
        <descr>
          <p>
            An empty implementation in the current LCL version.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.KeyUpAfterInterface.Key">
        <short/>
      </element>
      <element name="TWinControl.KeyUpAfterInterface.Shift">
        <short/>
      </element>

      <element name="TWinControl.UTF8KeyPress">
        <short>
          Invokes the <link id="TWinControl.OnUTF8KeyPress">OnUTF8KeyPress</link> handler.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.UTF8KeyPress.UTF8Key">
        <short/>
      </element>

      <element name="TWinControl.FindNextControl">
        <short>Returns the preceding or next control in the tab order.</short>
        <descr>
          <p>
            When <var>CurrentControl</var> is <b>Nil</b>, the first control (forward) or last control (backward) in the TabOrder is returned; direction depends on the value in <var>GoForward</var>.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.FindNextControl.Result">
        <short>The (next) control.</short>
      </element>
      <element name="TWinControl.FindNextControl.CurrentControl">
        <short>
          The control which has the focus. If Nil, the first control (forward) or last control (backward) in TabOrder is returned, depending on GoForward.
        </short>
      </element>
      <element name="TWinControl.FindNextControl.GoForward">
        <short>False to find the preceding control.</short>
      </element>
      <element name="TWinControl.FindNextControl.CheckTabStop">
        <short>When True: only find controls with TabStop=True.</short>
      </element>
      <element name="TWinControl.FindNextControl.CheckParent">
        <short>When True: only find controls with Parent=Self.</short>
      </element>

      <element name="TWinControl.SelectFirst">
        <short>Returns the first control in tab order.</short>
        <descr/>
        <seealso/>
      </element>

      <element link="#lcl.controls.TControl.RealGetText" name="TWinControl.RealGetText"/>
      <element name="TWinControl.RealGetText.Result">
        <short/>
      </element>

      <element name="TWinControl.GetBorderStyle">
        <short>Gets the value for the BorderStyle property.</short>
        <descr/>
        <seealso>
          <link id="TWinControl.BorderStyle"/>
        </seealso>
      </element>
      <element name="TWinControl.GetBorderStyle.Result">
        <short>Value for the BorderStyle property.</short>
      </element>

      <element name="TWinControl.GetClientOrigin">
        <short>Gets the top, left screen coordinates for the client area in the control.</short>
        <descr>
        </descr>
        <seealso>
          <link id="#lcl.controls.TControl.GetClientOrigin">TControl.GetClientOrigin</link>
        </seealso>
      </element>
      <element name="TWinControl.GetClientOrigin.Result">
        <short>
          TPoint instance with the screen coordinates for the origin of the control.
        </short>
      </element>

      <element name="TWinControl.GetClientRect">
        <short>Gets the value for the ClientRect property.</short>
        <descr>
          <p>
            GetClientRect is an overridden method in TWinControl used to get the value for the ClientRect property. ClientRect contains the visual client area for the control.
          </p>
          <p>
            GetClientRect extends the ancestor method to synchronize values in the control and its widgetset class using the Handle for the control. It uses values in ComponentState and the control flags for the TWinControl instance to determine the actions needed in the method. If an action cannot be determined, or the handle is not available, values in ClientWidth and ClientHeight are used as the Width and Height in the TRect instance.
          </p>
        </descr>
        <seealso>
          <link id="#lcl.controls.TControl.GetClientRect">TControl.GetClientRect</link>
        </seealso>
      </element>
      <element name="TWinControl.GetClientRect.Result">
        <short>Value for the ClientRect property.</short>
      </element>

      <element name="TWinControl.GetControlOrigin">
        <short>The screen coordinates for the control.</short>
        <descr>
        </descr>
        <seealso>
          <link id="#lcl.controls.TControl.GetControlOrigin">TControl.GetControlOrigin</link>
        </seealso>
      </element>
      <element name="TWinControl.GetControlOrigin.Result">
        <short/>
      </element>

      <element link="#lcl.controls.TControl.GetDeviceContext" name="TWinControl.GetDeviceContext"/>
      <element name="TWinControl.GetDeviceContext.Result">
        <short/>
      </element>
      <element name="TWinControl.GetDeviceContext.WindowHandle">
        <short/>
      </element>

      <element name="TWinControl.GetParentBackground">
        <short>Gets the value for the ParentBackground property.</short>
        <descr/>
        <seealso>
          <link id="TWinControl.ParentBackground"/>
        </seealso>
      </element>
      <element name="TWinControl.GetParentBackground.Result">
        <short>Value for the property.</short>
      </element>

      <element name="TWinControl.IsControlMouseMsg">
        <short>Sends the mouse message to a child control.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.IsControlMouseMsg.Result">
        <short>True if a child control was found at the mouse coordinates.</short>
      </element>
      <element name="TWinControl.IsControlMouseMsg.TheMessage">
        <short/>
      </element>

      <element name="TWinControl.CreateHandle">
        <short>Creates the Handle for the widget, if not already created.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.CreateParams">
        <short>
          Initializes the window creation parameter record with the settings for the control.
        </short>
        <descr>
          <p>
            <var>CreateParams</var> is a procedure used to initialize and/or update creation parameters in the <var>Params</var> argument. CreateParams is called from the <var>CreateWnd</var> method when the window handle is allocated for the control.
          </p>
          <p>
            CreateParams ensures that values in the <var>TCreateParams</var> record instance contain the values needed for the class instance. The following members in the record are update:
          </p>
          <dl>
            <dt>Caption</dt>
            <dd>Set to the value in the Caption property.</dd>
            <dt>Style</dt>
            <dd>
              Includes flag values: WS_CHILD, WS_CLIPSIBLINGS, WS_CLIPCHILDREN, and WS_TABSTOP when needed.
            </dd>
            <dt>ExStyle</dt>
            <dd>Includes style values needed for the value in ControlStyle and BorderStyle.</dd>
            <dt>WndParent</dt>
            <dd>Set to the handle in ParentWindow, or Parent.Handle when assigned.</dd>
            <dt>X, Y, Width, Height</dt>
            <dd>Set to the property values in the class instance.</dd>
          </dl>
        </descr>
        <seealso>
          <link id="TWinControl.CreateWnd"/>
          <link id="#lcl.lcltype.TCreateParams">TCreateParams</link>
        </seealso>
      </element>
      <element name="TWinControl.CreateParams.Params">
        <short>Create parameters updated in the method.</short>
      </element>

      <element name="TWinControl.CreateWnd">
        <short>Creates the interface object (widget) and assigns the value in Handle.</short>
        <descr>
          <p>
            Raises a catchable debugger exception for various conditions, including:
          </p>
          <ul>
            <li>
              The control, or its <var>Parent</var>, has the value <var>csDestroying</var> in the <var>ComponentState</var> property.
            </li>
            <li>
              The method has been called recursively, as indicated by values in the window control flags.
            </li>
            <li>
              The method has been called at run-time before LCL component streaming has been completed.
            </li>
            <li>
              The <var>Handle</var> was not successfully created in the widgetset class.
            </li>
          </ul>
          <p>
            Ensures that the realized bounds for the control is reset prior to creating the Handle for the control and any child <var>Controls</var>. An <var>EInvalidOperation</var> exception is raised if the handle for the Parent control is not valid when the method is called.
          </p>
          <p>
            Calls the <var>InvalidatePreferredSize</var> method for the control, and any child controls, and calls <var>AdjustSize</var>. If an error occurred while creating the Handle, auto-sizing is not enabled for the control.
          </p>
          <p>
            CreateWnd is called from the <var>CreateHandle</var> method.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.CreateHandle"/>
        </seealso>
      </element>

      <element name="TWinControl.DestroyHandle">
        <short>Destroys the handle for the control and all child controls.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.DestroyWnd">
        <short>Destroys the interface object (widget).</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.DoFlipChildren">
        <short>Flip children horizontally (mirrors the Left position).</short>
        <descr>
          <p>
            Child controls arranged in left-to-right order appear in right-to-left order after flipping. All anchors are adjusted accordingly.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.FlipChildren"/>
        </seealso>
      </element>

      <element name="TWinControl.FinalizeWnd">
        <short>Prepares to remove the window (called before the Handle is destroyed).</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.FixupTabList">
        <short>Assigns sequential TabOrder values to all child controls.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.FontChanged">
        <short>Implements the event handler signalled when the Font has been changed for the control.</short>
        <descr>
          <!--
            TODO: Override needs its own description.

            Used as the OnChange event handler for the Font in the control.
            Notifies the widgetset class when the Handle is valid.
            Updates the control flags for the windowed control to include or exclude wcfFontChanged.
            Calls the inherited method to Invalidate and Resize the control, and to send a  CM_FONTCHANGED control message to the processing loop.
            Notifies child controls that the parent font has been changed.
          -->
        </descr>
        <seealso>
          <link id="TControl.FontChanged"/>
        </seealso>
      </element>
      <element name="TWinControl.FontChanged.Sender">
        <short>Object instance (TWinControl) for the event notification.</short>
      </element>

      <element name="TWinControl.InitializeWnd">
        <short>Copies cached control properties to the just created widget.</short>
        <descr>
          <p>
            Gets called after the Handle is created, and before child handles are created.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TWinControl.Loaded">
        <short>
          Called when the control has been loaded from a resource, transfers the loaded property values to the widget.
        </short>
        <descr/>
        <seealso>
          <link id="TControl.Loaded"/>
        </seealso>
      </element>

      <element name="TWinControl.FormEndUpdated">
        <short>
          Realizes all cached changes after a bulk update of the form. Calls inherited <var>FormEndUpdated</var>, then informs each child control.
        </short>
        <descr/>
        <seealso>
          <link id="TControl.FormEndUpdated"/>
        </seealso>
      </element>

      <element name="TWinControl.MainWndProc">
        <short>This method allows handling messages in Windows.</short>
        <descr>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.MainWndProc.Msg">
        <short/>
      </element>

      <element name="TWinControl.ParentFormHandleInitialized">
        <short>
          Called after all child handles for the ParentForm are created; notifies all children of the end of the handle creation phase.
        </short>
        <descr/>
        <seealso>
          <link id="TControl.ParentFormHandleInitialized"/>
        </seealso>
      </element>

      <element name="TWinControl.ChildHandlesCreated">
        <short>
          Called after all child handles have been created; resets wcfCreatingChildHandles.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.GetMouseCapture">
        <short>Gets the value for the MouseCapture property.</short>
        <descr>
          <p>
            GetMouseCapture is a Boolean function used to get the value for the MouseCapture property. It is overridden in TWinControl to ensure that the Handle for the control has been allocated. The return value is True when HandleAllocated returns True, and GetCaptureControl returns the current class instance.
          </p>
        </descr>
        <seealso>
          <link id="TControl.MouseCapture"/>
          <link id="TControl.GetMouseCapture"/>
          <link id="GetCaptureControl"/>
        </seealso>
      </element>
      <element name="TWinControl.GetMouseCapture.Result">
        <short>Value for the MouseCapture property.</short>
      </element>

      <element name="TWinControl.RealSetText">
        <short>Sets the text / caption for the control.</short>
        <descr>
          <p>
            <var>RealSetText</var> is an overridden method in TWinControl. It ensures that the new value is applied to the widgetset class when its Handle has been allocated, and the control size is adjusted when needed/enabled. The inherited method is called to apply AValue to the Text and/or Caption properties for the control.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.WSSetText"/>
          <link id="TControl.Caption"/>
          <link id="TControl.Text"/>
          <link id="TControl.RealSetText"/>
          <link id="TControl.RealGetText"/>
          <link id="TControl.AdjustSize"/>
        </seealso>
      </element>
      <element name="TWinControl.RealSetText.AValue">
        <short>New value for the text / caption for the control.</short>
      </element>

      <element name="TWinControl.RemoveFocus">
        <short>Notifies the parent when the control loses focus.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.RemoveFocus.Removing">
        <short/>
      </element>

      <element link="#lcl.controls.TControl.SendMoveSizeMessages" name="TWinControl.SendMoveSizeMessages"/>
      <element name="TWinControl.SendMoveSizeMessages.SizeChanged">
        <short/>
      </element>
      <element name="TWinControl.SendMoveSizeMessages.PosChanged">
        <short/>
      </element>

      <element link="#lcl.controls.TWinControl.BorderStyle" name="TWinControl.SetBorderStyle">
        <short>Sets the value for the BorderStyle property.</short>
        <descr/>
        <seealso>
          <link id="TWinControl.BorderStyle"/>
        </seealso>
      </element>
      <element name="TWinControl.SetBorderStyle.NewStyle">
        <short>New value for the BorderStyle property.</short>
      </element>

      <element name="TWinControl.SetColor">
        <short>Sets the value for the Color property.</short>
        <descr>
          <p>
            SetColor is an overridden method in TWinControl used to set the value for the Color property. It calls the inherited method on entry, and ensures that the new property value is applied to the internal TBrush instance used in the control. This includes translating the value clDefault to the actual brush color used for the platform.
          </p>
          <p>
            If the Handle has been allocated for the control, the widgetset class is updated. Otherwise, control flags are updated to include the value wcfColorChanged.
          </p>
          <p>
            The NotifyControls method is called to send the CM_PARENTCOLORCHANGED control message to the child controls.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Color"/>
          <link id="TControl.SetColor"/>
        </seealso>
      </element>
      <element name="TWinControl.SetColor.Value">
        <short/>
      </element>

      <element name="TWinControl.SetChildZPosition">
        <short>
          Updates the position of the child control in the Z plane (i.e. front-to-back).
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.SetChildZPosition.AChild">
        <short/>
      </element>
      <element name="TWinControl.SetChildZPosition.APosition">
        <short/>
      </element>

      <element name="TWinControl.SetParentBackground">
        <short>Sets the value for the ParentBackground property.</short>
        <descr/>
        <seealso>
          <link id="TWinControl.ParentBackground"/>
        </seealso>
      </element>
      <element name="TWinControl.SetParentBackground.AParentBackground">
        <short>New value for the property.</short>
      </element>

      <element name="TWinControl.ShowControl">
        <short>Asks the parent to show itself.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.ShowControl.AControl">
        <short>The control to show, here: ignored!</short>
      </element>

      <element name="TWinControl.UpdateControlState">
        <short>
          Updates the visible state for the control; updates the widget set class when  already created.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.UpdateShowing">
        <short>
          When the widget should be visible and has not yet been created, it's created along with all children.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.WndProc">
        <short>
          Adds special handling for focus and input messages, and notifies the DockManager.
        </short>
        <descr>
          <p>
            Handles the following messages:
          </p>
          <dl>
            <dt>LM_SETFOCUS</dt>
            <dd>Gets the parent form and show this control as focused</dd>
            <dt>LM_KILLFOCUS</dt>
            <dd>Removes focus from this control</dd>
            <dt>LM_NCHITTEST</dt>
            <dd>Checks the transparency for the control, etc.</dd>
            <dt>Mouse messages</dt>
            <dd>Sent to the DockManager</dd>
          </dl>
        </descr>
        <seealso>
          <link id="TControl.WndProc"/>
        </seealso>
      </element>
      <element name="TWinControl.WndProc.Message">
        <short/>
      </element>

      <element name="TWinControl.WSSetText">
        <short>
          Sends text to the widget (from WM_SETTEXT?).
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.WSSetText.AText">
        <short>The text to send.</short>
      </element>

      <element name="TWinControl.WindowHandle">
        <short>
          For internal use; allows direct access to the Handle for the control, bypassing any getter/setter methods.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.BorderStyle">
        <short>
          Indicates if borders are displayed around the control.
        </short>
        <descr>
          <p>
            BorderStyle is a TBorderStyle property which indicates whether borders are drawn for the control. bsSingle indicates that borders are drawn for the control. The default value for the property is bsNone, and indicates that borders are not drawn for the control.
          </p>
          <p>
            Changing the value for the property causes the widgetset class to be updated when the Handle has been allocated for the control.
          </p>
          <p>
            BorderStyle is used in the CreateParams method. It causes the WS_EX_CLIENTEDGE extended window style flag to be included in the control when the property is set to bsSingle.
          </p>
          <p>
            BorderStyle is used along with BorderWidth in descendent classes which allow their borders to be drawn with a raised or lowered appearance.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.BorderWidth"/>
          <link id="TBorderStyle"/>
          <link id="TFormBorderStyle"/>
        </seealso>
      </element>

      <element name="TWinControl.OnGetSiteInfo">
        <short>
          Provides information about the DockSite for the control.
        </short>
        <descr>
          <p>
            The handler can adjust the <var>InfluenceRect</var>, within which mouse moves are recognized by this control. The handler also can deny any drops, depending on the dragging operation for the control.
          </p>
          <p>
            <var>OnGetSiteInfo</var> occurs before the <var>OnDockOver</var> event handler.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.OnDockOver"/>
        </seealso>
      </element>

      <element name="TWinControl.OnGetDockCaption">
        <short>
          This handler can provide a special DockCaption, different than the Caption default.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.ParentBackground">
        <short>Indicates if the control uses the background for its Parent control.</short>
        <descr>
          <p>
            <var>ParentBackground</var> is a <var>Boolean</var> property which indicates if the background for the <var>Parent</var> control is drawn as the background for the current control instance.
          </p>
          <p>
            ParentBackground is <b>True</b> when <var>csParentBackground</var> is included in the <var>ControlStyle</var> property. Setting the value in ParentBackground causes ControlStyle to be updated to include or exclude the csParentBackground enumeration value; it is included when <b>True</b>.
          </p>
        </descr>
        <seealso>
          <link id="TControl.ControlStyle"/>
          <link id="TControl.Parent"/>
          <link id="TControlStyleType"/>
          <link id="TControlStyle"/>
        </seealso>
      </element>

      <element name="TWinControl.BorderWidth">
        <short>Width of the Border around the control; default is zero.</short>
        <descr>
          <p>
            BorderWidth is a TBorderWidth property which contains the size of a border drawn for the control. The default value for the property is 0 (zero). Changing the value for the property causes a CM_BORDERCHANGED control message to be sent to the processing loop for the control.
          </p>
          <p>
            BorderWidth is significant when BorderStyle is set to bsSingle. Descendent classes, which allow their borders to be drawn using a raised or lowered appearance, may use the property value when the control is drawn. It indicates the amount of space to reserve for the borders in the bounds rectangle for the control.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.BorderStyle"/>
        </seealso>
      </element>

      <element name="TWinControl.BoundsLockCount">
        <short>
          For internal use: When greater zero, updates of the BoundsRect are blocked.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.Brush">
        <short>
          The Brush used to paint the background of the control.
        </short>
        <descr>
          <p>
            Brush is a read-only TBrush property which provides the tool used to paint the interior of the control. The value in Brush is allocated and configured in the CreateBrush method, called when the value for the property is read but has not been assigned.
          </p>
          <p>
            The Color property in Brush is updated when a new value is assigned to the Color property in the control.
          </p>
          <p>
            Brush is used in the EraseBackground method and provides the Handle used to draw the background rectangle for the control.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.CreateBrush"/>
          <link id="TWinControl.EraseBackground"/>
          <link id="TControl.Color"/>
          <link id="#lcl.graphics.TBrush">TBrush</link>
        </seealso>
      </element>

      <element name="TWinControl.CachedClientHeight">
        <short>
          The intended ClientHeight, as sent to the widget set class.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.CachedClientWidth">
        <short>
          The intended ClientWidth, as sent to the widget set class.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.ChildSizing">
        <short>
          Parameters for child control arrangement and spacing.
        </short>
        <descr>
          <p>
            ChildSizing is a TControlChildSizing property which contains the class used to apply sizing and layout for  child controls in the control instance.
          </p>
        </descr>
        <seealso>
          <link id="TControlChildSizing"/>
        </seealso>
      </element>

      <element name="TWinControl.ControlCount">
        <short>
          The number of child controls in the Controls property.
        </short>
        <descr>
          <p>
            ControlCount is a read-only Integer property which contains the number of child controls stored in the indexed Controls property.
          </p>
          <p>
            The value is updated when control instances are created using the current class instance as the Parent for the control. The value is used in the AlignControls method when the Controls are positioned, aligned, and resized. It is also used to determine whether additional actions are needed in methods like DoChildSizingChange, InvalidatePreferredChildSizes, DoAutoSize, and DoAllAutoSize.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.Controls"/>
          <link id="TWinControl.AlignControls"/>
        </seealso>
      </element>

      <element name="TWinControl.Controls">
        <short>Provides indexed access to the child controls for the class instance.</short>
        <descr>
          <p>
            Controls is a read-only indexed TControl property which provides access to child controls by their ordinal position in the list.
          </p>
          <p>
            The Index argument contains the ordinal position for the requested child control, and must be in the range 0..ControlCount-1. The index also indicates the display or tab order for the child controls. The physical order for the controls  in the list my be changed when the FixupTabList method is called during LCL component streaming.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.ControlCount"/>
        </seealso>
      </element>
      <element name="TWinControl.Controls.Index">
        <short>Ordinal position for the child control requested in the property value.</short>
      </element>

      <element name="TWinControl.DefWndProc">
        <short>
          The default WndProc on Windows widgetset and platforms.
        </short>
      </element>

      <element name="TWinControl.DockClientCount">
        <short>The number of clients docked into this control.</short>
        <descr>
          <p>
            The docked controls can be accessed in<link id="TWinControl.DockClients">DockClients[]</link>.
          </p>
          <p>
            <var>DockClientCount</var> is equivalent to DockClients.Count, but handles the special case when DockClients is <b>Nil</b>.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.DockClients"/>
        </seealso>
      </element>

      <element name="TWinControl.DockClients">
        <short>The indexed list of controls docked into this control.</short>
        <descr/>
        <seealso>
          <link id="TWinControl.DockClientCount"/>
        </seealso>
      </element>
      <element name="TWinControl.DockClients.Index">
        <short>Index of the requested docked client.</short>
      </element>

      <element name="TWinControl.DockManager">
        <short>The docking layout manager for this control.</short>
        <descr>
          <p>
            A <var>DockSite</var> can be managed (using a <var>DockManager</var>),  or unmanaged (positioning docked controls in the event handlers). The <var>DockManager</var> determines the placement for docked controls by setting <var>DropOnControl</var> and <var>DropAlign</var> before the drop, and by resizing and positioning the control when it's dropped.
          </p>
          <p>
            A <var>DockManager</var> is used only when <var>UseDockManager</var> is set to <b>True</b>. Setting <var>UseDockManager</var> to <b>True</b> creates the  <var>DockManager</var> using the <var>DefaultDockManagerClass</var> for this DockSite, if not previously assigned.
          </p>
          <p>
            An unmanaged DockSite, without a DockManager, can handle the placement of dropped controls in the <var>OnDockOver</var> and <var>OnDockDrop</var> event handlers.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.UseDockManager"/>
          <link id="TWinControl.DockSite"/>
          <link id="TWinControl.OnDockDrop"/>
          <link id="TWinControl.OnDockOver"/>
          <link id="TDockManager"/>
        </seealso>
      </element>

      <element name="TWinControl.DockSite">
        <short>
          Allows controls to be drag-dock'd into this control.
        </short>
        <descr>
          <p>
            A DockSite reacts on controls dragged over this control, signals acceptance and where a dragged control would be dropped.
          </p>
          <remark>
            A DockSite should initially be empty, not containing any child controls.
          </remark>
        </descr>
        <seealso>
          <link id="TWinControl.DockManager"/>
          <link id="TWinControl.UseDockManager"/>
        </seealso>
      </element>

      <element name="TWinControl.DoubleBuffered">
        <short>Allows to reduce flicker in the painting of the control.</short>
        <descr>
          <p>
            <var>Paint</var> requests are typically buffered in the message queue. When a paint message arrives, all elements of the control are drawn onto the screen, according to their type, style, state and content.
          </p>
          <p>
            This can cause flicker, when stacked controls wipe out preceding paintings, e.g. when unchanged text is erased from the screen before it is painted again, when it takes some time to retrieve the text of list entries, or wrapping long text at the current control boundaries. Owner-drawing also can cause noticeable flicker.
          </p>
          <p>
            To reduce such flicker, <var>DoubleBuffered</var> controls use a bitmap buffer into which all painting is redirected. When the bitmap has been updated, a paint request is queued for the control. When that paint request is received again, the prepared bitmap is output in one fast BitBlt transfer, eliminating any flicker.
          </p>
          <p>
            All this happens automatically when <var>DoubleBuffered</var> is set to <b>True</b>; no additional changes are required in application or custom control code.
          </p>
        </descr>
      </element>

      <element name="TWinControl.Handle">
        <short>
          A reference to the widgetset class instance associated with this control.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.IsFlipped">
        <short>Used in Carbon and Cocoa widgetsets</short>
        <descr>
          <p>
            IsFlipped is a read-only Boolean property. It is used in the Carbon and Cocoa widgetsets for these Mac platforms.
          </p>
        </descr>
        <seealso/>
      </element>

      <!-- HERE -->
      <element name="TWinControl.IsResizing">
        <short>
          Check IsResizing and drop or delay changes to the control, until the new size has been determined.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.TabOrder">
        <short>
          Determines the sequence of control navigation when the user presses the Tab key.
        </short>
        <descr/>
        <seealso>
          <link id="TWinControl.TabStop"/>
        </seealso>
      </element>

      <element name="TWinControl.TabStop">
        <short>
          Allows the user to navigate to this control, by pressing the Tab key.
        </short>
        <descr/>
        <seealso>
          <link id="TWinControl.TabOrder"/>
        </seealso>
      </element>

      <element name="TWinControl.OnAlignInsertBefore">
        <short>
          Handler for custom-aligned child controls; determines the order of control placement.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.OnAlignPosition">
        <short>
          Handler for custom-aligned child controls, determines the position of the child control.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.OnDockDrop">
        <short>Notification handler for the drop of a control to be docked.</short>
      </element>

      <element name="TWinControl.OnDockOver">
        <short>
          Event handler for moves of a control over this docksite; determines acceptance or rejection of an possible drop.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.OnEnter">
        <short>
          Handler for control receiving the focus.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.OnExit">
        <short>
          Handler for control loosing the focus; This is a good place for checking the finished user input.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.OnKeyDown">
        <short>
          Handler for keyboard key pressed.
        </short>
        <descr>
          <p>
            This handler can filter keys, for special use in e.g. non-textual controls. The handler receives all keystrokes, including control and other non-visual keys. Keys are encoded as <b>virtual</b> keys, with separate active modifier keys.
          </p>
          <p>
            Text input should be checked in an OnKeyPress handler.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.OnKeyUp"/>
          <link id="TWinControl.OnKeyPress"/>
        </seealso>
      </element>

      <element name="TWinControl.OnKeyPress">
        <short>
          Handler for a character entered by the user.
        </short>
        <descr>
          <p>
            This handler only receives characters, not control or other special key codes. Control keys should be handled by an <var>OnKeyDown</var> handler instead. The handler can also be used to convert the character into a different one.
          </p>
          <remark>
            We recommend using <var>OnUTF8KeyPress</var> to prevent data loss. Characters are converted from UTF-8 to the system encoding in <var>OnKeyPressEvent</var>, with possible loss of characters outside the <b>ANSI</b> codepage.
          </remark>
        </descr>
        <seealso>
          <link id="TWinControl.OnKeyDown"/>
          <link id="TWinControl.OnUTF8KeyPress"/>
        </seealso>
      </element>

      <element name="TWinControl.OnKeyUp">
        <short>
          Handler for keyboard key released.
        </short>
        <descr>
          <p>
            Unlike OnKeyDown, this event occurs only once for auto-repeated keys.
          </p>
          <p>
            For details see <link id="TWinControl.OnKeyDown"/>.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.OnKeyDown"/>
          <link id="TWinControl.OnKeyPress"/>
        </seealso>
      </element>

      <element name="TWinControl.OnUnDock">
        <short>Event handler for control being undocked from this DockSite.</short>
        <descr>
          <p>
            The handler can be used to disallow undocking.
          </p>
        </descr>
      </element>

      <element name="TWinControl.OnUTF8KeyPress">
        <short>
          Handler for a character entered by the user.
        </short>
        <descr>
          <p>
            This handler receives characters codes only, not control or other special key codes. Control keys should be handled by an <var>OnKeyDown</var> handler instead. The event handler can also convert the character code into a different value.
          </p>
          <p>
            While <link id="TWinControl.OnKeyPress">OnKeyPress</link> receives only <b>ANSI</b> characters (with possible loss of characters outside the <b>ANSI</b> codepage), the <var>OnUTF8KeyPress</var> handler receives the <b>UTF-8</b>-encoded character code.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.OnKeyPress"/>
          <link id="TWinControl.OnKeyDown"/>
        </seealso>
      </element>

      <element name="TWinControl.ParentDoubleBuffered">
        <short>Value from the DoubleBuffered property in a Parent control.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.ParentWindow">
        <short>The Handle for the parent widget.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.Showing">
        <short>
          Cached widget visibility, not necessarily in sync with the widget.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.UseDockManager">
        <short>
          Determines whether a DockManager is used for this DockSite.
        </short>
        <descr>
          <p>
            When <var>UseDockManager</var> is set to <b>True</b>, and DockSite is also set to <b>True</b>, a <var>DockManager</var> is created automatically. When set to <b>False</b>, an existing <var>DockManager</var> is ignored. </p>
          <p>
            If you want to use a special DockManager, install it before setting <var>UseDockManager</var> to <b>True</b>.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.DockSite"/>
          <link id="TWinControl.DockManager"/>
          <link id="TWinControl.CreateDockManager"/>
        </seealso>
      </element>

      <element name="TWinControl.DesignerDeleting">
        <short>
          Indicates whether the wcfDesignerDeleting flag is included  in the flags for the control.
        </short>
        <descr>
          <p>
            <var>DesignerDeleting</var> is a <var>Boolean</var> property which indicates if the wcfDesignerDeleting is includes in the control flags for the TWinControl instance. When set to True, wcfDesignerDeleting is included in the control flag values. When set to False, it is removed. Used in TPairSplitter only.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TWinControl.IsSpecialSubControl">
        <short>Indicates if the control has the wcfSpecialSubControl control flag.</short>
        <descr>
          <p>
            <var>IsSpecialSubControl</var> is a read-only <var>Boolean</var> property. Its vale is True when wcfSpecialSubControl has been included in the WinControlFlags for the control. Used in <var>TCustomPairSplitter</var> only.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TWinControl.VisibleDockClientCount">
        <short>The number of visible docked controls.</short>
        <seealso>
          <link id="TWinControl.DockClientCount"/>
          <link id="TWinControl.DockClients"/>
        </seealso>
      </element>

      <element name="TWinControl.AutoSizePhases">
        <short>Translates state flags into AutoSizePhases.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.AutoSizePhases.Result">
        <short/>
      </element>

      <element name="TWinControl.AutoSizeDelayed" link="#lcl.controls.TControl.AutoSizeDelayed"/>
      <element name="TWinControl.AutoSizeDelayed.Result">
        <short/>
      </element>

      <element name="TWinControl.AutoSizeDelayedReport" link="#lcl.controls.TControl.AutoSizeDelayedReport"/>
      <element name="TWinControl.AutoSizeDelayedReport.Result" link="#lcl.controls.TControl.AutoSizeDelayedReport.Result"/>

      <element name="TWinControl.AutoSizeDelayedHandle">
        <short>
          Returns true if AutoSize should be skipped / delayed because of its handle.
        </short>
      </element>

      <element name="TWinControl.BeginUpdateBounds">
        <short>
          Starts an update to the Bounds property; disables SetBounds by incrementing  BoundsLockCount.
        </short>
        <descr/>
        <seealso>
          <link id="TWinControl.EndUpdateBounds"/>
        </seealso>
      </element>

      <element name="TWinControl.EndUpdateBounds">
        <short>
          Ends an update to the Bounds property; decrements BoundsLockCount and eventually calls SetBounds.
        </short>
        <descr/>
        <seealso>
          <link id="TWinControl.BeginUpdateBounds"/>
        </seealso>
      </element>

      <element name="TWinControl.LockRealizeBounds">
        <short>
          Disables sending bounds to the widget, by incrementing the internal FRealizeBoundsLockCount.
        </short>
        <descr/>
        <seealso>
          <link id="TWinControl.UnlockRealizeBounds"/>
        </seealso>
      </element>

      <element name="TWinControl.UnlockRealizeBounds">
        <short>
          Enables sending bounds to the widget again, eventually updates the widget.
        </short>
        <descr/>
        <seealso>
          <link id="TWinControl.LockRealizeBounds"/>
        </seealso>
      </element>

      <element name="TWinControl.ControlAtPos">
        <short>Get the child control at the given client position.</short>
        <descr>
          <p>WinControls are found before Controls (if overlapping).</p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.ControlAtPos.Result">
        <short>The found control, <b>Nil</b> if none found.</short>
      </element>
      <element name="TWinControl.ControlAtPos.Pos">
        <short>The client coordinates.</short>
      </element>
      <element name="TWinControl.ControlAtPos.AllowDisabled">
        <short>Allow finding disabled controls.</short>
      </element>
      <element name="TWinControl.ControlAtPos.AllowWinControls">
        <short>Allow finding TWinControls, in addition to TControls.</short>
      </element>
      <element name="TWinControl.ControlAtPos.OnlyClientAreas">
        <short>Only search in client areas.</short>
      </element>
      <element name="TWinControl.ControlAtPos.Flags">
        <short>Encoded Allow... conditions.</short>
      </element>

      <element name="TWinControl.ContainsControl">
        <short>
          Returns True if this is a parent for the given control.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.ContainsControl.Result">
        <short>True when we are a parent of Control.</short>
      </element>
      <element name="TWinControl.ContainsControl.Control">
        <short>The control examined as a child control.</short>
      </element>

      <element name="TWinControl.DoAdjustClientRectChange">
        <short>
          Asks the widget if ClientRect has changed since the last AlignControl execution; calls AdjustSize on change.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.DoAdjustClientRectChange.InvalidateRect">
        <short/>
      </element>

      <element name="TWinControl.InvalidateClientRectCache">
        <short>
          The ClientRect is cached; call this procedure to invalidate the cache, so that the next ClientRect value is fetched from the widget set class.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.InvalidateClientRectCache.WithChildControls">
        <short>Also invalidate all child controls, if True.</short>
      </element>

      <element name="TWinControl.ClientRectNeedsInterfaceUpdate">
        <short>
          The ClientRect is cached - check if the cache is valid.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.ClientRectNeedsInterfaceUpdate.Result">
        <short>True if update needed.</short>
      </element>

      <element name="TWinControl.SetBounds">
        <short>Sets the control bounds and adjusts child and docked controls.</short>
        <seealso>
          <link id="TControl.SetBounds"/>
        </seealso>
      </element>
      <element name="TWinControl.SetBounds.aLeft">
        <short/>
      </element>
      <element name="TWinControl.SetBounds.aTop">
        <short/>
      </element>
      <element name="TWinControl.SetBounds.aWidth">
        <short/>
      </element>
      <element name="TWinControl.SetBounds.aHeight">
        <short/>
      </element>

      <element name="TWinControl.GetChildrenRect">
        <short>
          Returns the Client rectangle relative to the controls left, top.
        </short>
        <descr>
          <p>
            If Scrolled is true, the rectangle is moved by the current scrolling values
            (for an example see TScrollingWincontrol).
          </p>
        </descr>
        <seealso>
          <link id="#lcl.controls.TControl.GetChildrenRect">TControl.GetChildrenRect</link>
        </seealso>
      </element>
      <element name="TWinControl.GetChildrenRect.Result">
        <short/>
      </element>
      <element name="TWinControl.GetChildrenRect.Scrolled">
        <short/>
      </element>

      <element name="TWinControl.DisableAlign">
        <short>Disables auto-sizing for the control and its parent.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.EnableAlign">
        <short>Re-enables auto-sizing for the control and its parent.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.ReAlign">
        <short>Adjusts the size and placement for the control and all of its children.</short>
        <descr>
          <p>
            Calls the inherited AdjustSize method.
          </p>
        </descr>
        <seealso>
          <link id="TControl.AdjustSize"/>
        </seealso>
      </element>

      <element name="TWinControl.ScrollBy_WS">
        <short>Scrolls the control using the handle for the widget set class.</short>
        <descr/>
        <errors>
          Raises an Exception if the handle has not been allocated for the widget set class instance. Raised with the message 'TWinControl.ScrollBy_WS: Handle not allocated'.
        </errors>
        <seealso>
          <link id="TWinControl.HandleAllocated"/>
        </seealso>
      </element>
      <element name="TWinControl.ScrollBy_WS.DeltaX">
        <short/>
      </element>
      <element name="TWinControl.ScrollBy_WS.DeltaY">
        <short/>
      </element>

      <element name="TWinControl.ScrollBy">
        <short>Scrolls the control (and all child controls) by the specified amounts.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.ScrollBy.DeltaX">
        <short>Increment for Left.</short>
      </element>
      <element name="TWinControl.ScrollBy.DeltaY">
        <short>Increment for Top.</short>
      </element>

      <element link="#lcl.controls.TControl.WriteLayoutDebugReport" name="TWinControl.WriteLayoutDebugReport"/>
      <element name="TWinControl.WriteLayoutDebugReport.Prefix">
        <short/>
      </element>

      <element name="TWinControl.AutoAdjustLayout">
        <short>
          Automatically adjusts the size and layout for the control (and all of its children).
        </short>
        <descr>
          <p>
            <var>AutoAdjustLayout</var> is an overridden procedure used to automatically adjust the size and layout for the control. All children in the <var>Controls</var> property also call their AutoAdjustLayout method, and the inherited method is called to adjust and resize the current control instance.
          </p>
          <p>
            AutoAdjustLayout calls DisableAutoSizing on entry, and EnableAutoSizing prior to exit from the method.
          </p>
        </descr>
        <seealso>
          <link id="TControl.AutoAdjustLayout"/>
          <link id="TControl.DisableAutoSizing"/>
          <link id="TControl.EnableAutoSizing"/>
          <link id="TControl.DoAutoAdjustLayout"/>
          <link id="TWinControl.Controls"/>
        </seealso>
      </element>
      <element name="TWinControl.AutoAdjustLayout.AMode">
        <short>Layout mode applied in the method.</short>
      </element>
      <element name="TWinControl.AutoAdjustLayout.AFromPPI">
        <short/>
      </element>
      <element name="TWinControl.AutoAdjustLayout.AToPPI">
        <short/>
      </element>
      <element name="TWinControl.AutoAdjustLayout.AOldFormWidth">
        <short/>
      </element>
      <element name="TWinControl.AutoAdjustLayout.ANewFormWidth">
        <short/>
      </element>

      <element name="TWinControl.FixDesignFontsPPIWithChildren">
        <short>
          Fixes the design-time PPI settings for the control font, and applies the changes to child controls.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.FixDesignFontsPPIWithChildren.ADesignTimePPI">
        <short/>
      </element>

      <element name="TWinControl.Create">
        <short>Constructor for the class instance.</short>
        <descr>
          <p>
            Create is the overridden constructor for the class instance. Create calls the inherited method using TheOwner as the owner for the class instance. Create allocates resources needed in the class instance, and sets the default values for the following properties:
          </p>
          <dl>
            <dt>ParentDoubleBuffered</dt>
            <dd>Set to True</dd>
            <dt>ChildSizing</dt>
            <dd>Sets DoChildSizingChange as the OnChange event handler</dd>
            <dt>Brush</dt>
            <dd>
              Set to Nil; few controls require a brush, and it is created on DoRemainingKeyDown
            </dd>
            <dt>TabOrder</dt>
            <dd>Set to -1</dd>
            <dt>TabStop</dt>
            <dd>Set to False</dd>
          </dl>
          <p>
            Create calls the InvalidateClientRectCache method to invalidate a cached client rectangle, and to force the value to be read from the LCL interface.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.InvalidateClientRectCache"/>
        </seealso>
      </element>
      <element name="TWinControl.Create.TheOwner">
        <short>Owner of the class instance.</short>
      </element>

      <element name="TWinControl.CreateParented">
        <short>Constructor for a control that is the child of the given widget.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.CreateParented.AParentWindow">
        <short/>
      </element>

      <element name="TWinControl.CreateParentedControl" link="#lcl.controls.TWinControl.CreateParented"/>
      <element name="TWinControl.CreateParentedControl.Result" link="#lcl.controls.TWinControl.CreateParented.Result"/>
      <element name="TWinControl.CreateParentedControl.AParentWindow" link="#lcl.controls.TWinControl.CreateParented.AParentWindow"/>

      <element name="TWinControl.Destroy">
        <short>Destructor for the class instance.</short>
        <descr>
          <p>
            <var>Destroy</var> is the overridden destructor for the class instance.
          </p>
          <p>
            Destroy call RemoveFocus to ensure that the control cannot receive focus from a Parent control. If a handle has been allocated for the windowed control, the DestroyHandle method is called.
          </p>
          <p>
            Destroy iterates over Controls to remove the value in the Parent property for each child control, and to remove an assigned HostDockSite. It does not actually free the child Controls; they are freed by the owner of the control instance (usually a TForm instance).
          </p>
          <p>
            Destroy ensures that any controls in the DockClients property remove the current class instance from their host dock site.
          </p>
          <p>
            Destroy frees resources allocated in the constructor, or in other class methods, including the DockManager and DockCients. Destroy calls the inherited destructor prior to exiting from the method.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Parent"/>
          <link id="TWinControl.Controls"/>
          <link id="TWinControl.RemoveControl"/>
          <link id="TWinControl.DockManager"/>
          <link id="TWinControl.DockClients"/>
          <link id="TControl.HostDockSite"/>
        </seealso>
      </element>

      <element name="TWinControl.DockDrop">
        <short>
          Handler for a DragManager dmDragDrop message, sent when a dragged control has been dropped onto this docksite.
        </short>
        <descr>
          <p>
            Asks the dropped control to dock itself into this docksite, updates its Parent, HostDockSite, and the DockClients for the old and new DockSite.
          </p>
          <p>
            When a DockManager is installed, it is used to position the docked control (InsertControl).
          </p>
          <p>
            Finally, an OnDockDrop event is signalled.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.DoDockClientMsg"/>
          <link id="TWinControl.OnDockDrop"/>
          <link id="TDragDockObject"/>
        </seealso>
      </element>
      <element name="TWinControl.DockDrop.DragDockObject">
        <short/>
      </element>
      <element name="TWinControl.DockDrop.X">
        <short/>
      </element>
      <element name="TWinControl.DockDrop.Y">
        <short/>
      </element>

      <element name="TWinControl.CanFocus">
        <short>Is this control allowed to receive the focus when parent form is visible?</short>
        <descr>
          <p>
            Checks if the control can get focus when parent form is visible, i.e. if all its parents except the form are visible and enabled.
          </p>
          <p>A possible usage:</p>
<code>
if FormFoo.EditFoo.CanFocus then
  FormFoo.ActiveControl := FormFoo.EditFoo;
</code>
          <remark>
            CanFocus returns True even if the parent form isn't actually visible, and a subsequent SetFocus call could throw an exception. Use <var>CanSetFocus</var> in this case.
          </remark>
        </descr>
        <seealso>
          <link id="TWinControl.CanSetFocus"/>
          <link id="TWinControl.SetFocus"/>
          <link id="TWinControl.CanFocus"/>
        </seealso>
      </element>
      <element name="TWinControl.CanFocus.Result">
        <short/>
      </element>

      <element name="TWinControl.CanSetFocus">
        <short>Is this control allowed to receive the focus?</short>
        <descr>
          <p>
            Checks if the control can receive focus, i.e. if all its parents are visible and enabled.
          </p>
          <p>A possible usage:</p>
<code>
if MyControl.CanSetFocus then
  MyControl.SetFocus;
</code>
          <p>
            <var>CanSetFocus</var> should be preferred over <var>CanFocus</var> if used in CanSetFocus/SetFocus combination because it checks also if the parent form can receive focus and thus prevents the "cannot focus an invisible window" LCL exception.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.CanFocus"/>
          <link id="TWinControl.SetFocus"/>
        </seealso>
      </element>
      <element name="TWinControl.CanSetFocus.Result">
        <short/>
      </element>

      <element name="TWinControl.GetControlIndex">
        <short>
          Finds the index value for the given control, in <link id="TWinControl.Controls"/>
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.GetControlIndex.Result">
        <short>The ordinal position in Controls, -1 if not found.</short>
      </element>
      <element name="TWinControl.GetControlIndex.AControl">
        <short>The child control to locate in the method.</short>
      </element>

      <element link="#lcl.controls.TWinControl.SetChildZPosition" name="TWinControl.SetControlIndex"/>
      <element name="TWinControl.SetControlIndex.AControl">
        <short/>
      </element>
      <element name="TWinControl.SetControlIndex.NewIndex">
        <short/>
      </element>

      <element name="TWinControl.Focused">
        <short>Checks whether the control has focus.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.Focused.Result">
        <short>True when the control has focus.</short>
      </element>

      <element name="TWinControl.PerformTab">
        <short>Sets the focus to the next (or preceding) control.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.PerformTab.Result">
        <short>True when the focus has been transferred.</short>
      </element>
      <element name="TWinControl.PerformTab.ForwardTab">
        <short>
          The direction of Tab movement; True for the next control in the TabOrder, False for the preceding control.
        </short>
      </element>

      <element name="TWinControl.FindChildControl">
        <short>
          Finds a child control by name.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.FindChildControl.Result">
        <short>True when the control has been found.</short>
      </element>
      <element name="TWinControl.FindChildControl.ControlName">
        <short>The Name of the control to find.</short>
      </element>

      <element name="TWinControl.SelectNext">
        <short>Transfers the focus to the next child control.</short>
        <descr>
          <p>
            The search wraps around on the boundaries of the TabOrder array. When no next control can be found, the focus remains unchanged.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.FindNextControl"/>
        </seealso>
      </element>
      <element name="TWinControl.SelectNext.CurControl">
        <short>The control which is assumed to have the focus.</short>
      </element>
      <element name="TWinControl.SelectNext.GoForward">
        <short>False when the control preceding CurControl shall be found.</short>
      </element>
      <element name="TWinControl.SelectNext.CheckTabStop">
        <short>When True, only select a control that can receive the focus.</short>
      </element>

      <element link="#lcl.controls.TControl.SetTempCursor" name="TWinControl.SetTempCursor"/>
      <element name="TWinControl.SetTempCursor.Value">
        <short/>
      </element>

      <element name="TWinControl.BroadCast">
        <short>
          Posts the specified message to all of the child controls.
        </short>
        <seealso>
          <link id="TWinControl.NotifyControls"/>
        </seealso>
      </element>
      <element name="TWinControl.BroadCast.ToAllMessage">
        <short>The message sent in the method.</short>
      </element>

      <element name="TWinControl.NotifyControls">
        <short>Sends a message to all child controls.</short>
        <descr/>
        <seealso>
          <link id="TWinControl.BroadCast"/>
        </seealso>
      </element>
      <element name="TWinControl.NotifyControls.Msg">
        <short>The message ID.</short>
      </element>

      <element name="TWinControl.DefaultHandler">
        <short>Handles all messages that the control doesn't fully handle itself.</short>
        <descr>
          <p>
            This implementation sends the message to the widget's message handler.
          </p>
          <p>
            Override this method to implement your own message handling. If the message Result is non-zero, the message already has been handled; otherwise, set the Result to a non-zero value (depending on the message ID) when the message has been handled.
          </p>
        </descr>
        <seealso>
          <link id="#rtl.system.TObject.DefaultHandler">TObject.DefaultHandler</link>
        </seealso>
      </element>
      <element name="TWinControl.DefaultHandler.AMessage">
        <short>The message to process.</short>
      </element>

      <element link="#lcl.controls.TControl.GetTextLen" name="TWinControl.GetTextLen"/>
      <element name="TWinControl.GetTextLen.Result">
        <short/>
      </element>

      <element name="TWinControl.Invalidate">
        <short>Schedules a repaint request.</short>
        <descr>
          <p>
            This implementation calls the Invalidate method for the widgetset class instance.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TWinControl.AddControl">
        <short>Tells the widgetset to add a Handle object to a parent Handle object.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.InsertControl">
        <short>Inserts the specified control into the Controls property.</short>
      </element>
      <element name="TWinControl.InsertControl.AControl">
        <short>The control to insert.</short>
      </element>
      <element name="TWinControl.InsertControl.Index">
        <short>Insert at index (optional).</short>
      </element>

      <element name="TWinControl.RemoveControl">
        <short>Removes the specified control from the Controls property.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.RemoveControl.AControl">
        <short>The control to remove.</short>
      </element>

      <element name="TWinControl.GetEnumeratorControls">
        <short>Gets an enumerator for the Controls property.</short>
        <descr>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.GetEnumeratorControls.Result">
        <short>The TWinControlEnumerator instance.</short>
      </element>

      <element name="TWinControl.GetEnumeratorControlsReverse">
        <short>Gets a reverse-order enumerator for the Controls property.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.GetEnumeratorControlsReverse.Result">
        <short>The TWinControlEnumerator instance.</short>
      </element>

      <element link="#lcl.controls.TControl.Repaint" name="TWinControl.Repaint"/>
      <element link="#lcl.controls.TControl.Update" name="TWinControl.Update"/>

      <element name="TWinControl.SetFocus">
        <short>
          Ensures that the control or window handle has focus.
        </short>
        <descr>
          <p>
            <var>SetFocus</var> is a procedure used to give focus to the current control. SetFocus calls <var>GetParentForm</var> for the control instance, and uses its <var>FocusControl</var> method to change the focused control.
          </p>
          <p>
            If the parent Form is unassigned (contains <b>Nil</b>), the LCL interface is used to change focus to the handle for the control. No actions are performed in the method when Form is unassigned and the control does not have an allocated handle.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TWinControl.FlipChildren">
        <short>
          Flip children horizontally. That means mirroring the Left position and anchoring.
        </short>
        <descr>
          <p>
            Child controls arranged in left-to-right order appear in right-to-left order after flipping. All anchors are adjusted accordingly.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.DoFlipChildren"/>
        </seealso>
      </element>
      <element name="TWinControl.FlipChildren.AllLevels">
        <short>Flip recursive?</short>
      </element>

      <element name="TWinControl.ScaleBy" link="#lcl.controls.TWinControl.ChangeScale"/>
      <element name="TWinControl.ScaleBy.Multiplier" link="#lcl.controls.TWinControl.ChangeScale.Multiplier"/>
      <element name="TWinControl.ScaleBy.Divider" link="#lcl.controls.TWinControl.ChangeScale.Divider"/>

      <element name="TWinControl.GetDockCaption">
        <short>Returns the caption for the docked control.</short>
      </element>
      <element name="TWinControl.GetDockCaption.Result">
        <short/>
      </element>
      <element name="TWinControl.GetDockCaption.AControl">
        <short/>
      </element>

      <element name="TWinControl.UpdateDockCaption">
        <short>Updates the Caption to reflect the names of the docked clients.</short>
        <descr>
          <p>
            Called when this is a hostdocksite and either the list of docked clients have changed, or one of their captions.
          </p>
          <p>
            When a control is currently being undocked, but still is in the DockClients list, Exclude is set to this control.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.UpdateDockCaption.Exclude">
        <short>Control to exclude from the DockCaption.</short>
      </element>

      <element name="TWinControl.GetTabOrderList">
        <short>Fill the list with all TabStop controls, recursing into child controls.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.GetTabOrderList.List">
        <short>The list to which the controls shall be added.</short>
      </element>

      <element name="TWinControl.HandleAllocated">
        <short>
          Check whether a widget has been assigned to this control.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.HandleAllocated.Result">
        <short>True when a widget exists (Handle is not Nil).</short>
      </element>

      <element name="TWinControl.ParentHandlesAllocated">
        <short>Returns True if all Parents have handles allocated, and are not being destroyed.</short>
        <descr>
          <p>
            ParentHandlesAllocated is an overridden method in TWinControl which checks whether Handles are valid for all controls in the component hierarchy for the current control.
          </p>
          <p>
            ParentHandlesAllocated visits each of the controls, starting with the current class instance, and checks whether the control has an allocated handle and is not being destroyed. It navigates to the next Parent control in the hierarchy, and exits when the Parent control is unassigned.
          </p>
          <p>
            The return value is True when all of the controls in the hierarchy have an allocated Handle and are not being destroyed. The return value is False if any control is found in the hierarchy that does not have a valid handle allocated, or ComponentState indicates its handle is being freed.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.HandleAllocated"/>
          <link id="TWinControl.Handle"/>
          <link id="TControl.Parent"/>
          <link id="TControl.ParentHandlesAllocated"/>
        </seealso>
      </element>
      <element name="TWinControl.ParentHandlesAllocated.Result">
        <short>True when all of the controls in the Parent hierarchy have a valid handle.</short>
      </element>

      <element name="TWinControl.HandleNeeded">
        <short>
          Call this method when your code requires a valid Handle for this control.
        </short>
        <descr>
          <p>
            An attempt is made to create a widget, when not already done.
          </p>
          <remark>
            In certain situations it may be impossible to create a widget right now!
          </remark>
        </descr>
        <seealso/>
      </element>

      <element name="TWinControl.BrushCreated">
        <short>
          Has a <link id="TWinControl.Brush">Brush</link> been created for this control?
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.BrushCreated.Result">
        <short>True when a Brush has been created.</short>
      </element>

      <element name="TWinControl.EraseBackground">
        <short>
          Fills the display rectangle for the control with the color and pattern in Brush.
        </short>
        <descr>
          <p>
            EraseBackground is called during Paint requests from the WMEraseBkgnd method, which provides a valid device context in the DC argument. No actions are performed in the method when DC contains 0 (unassigned).
          </p>
          <p>
            The FillRect routine is called to perform the operation using the Width, Height, and the handle in the Brush property.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.Brush"/>
          <link id="TControl.Height"/>
          <link id="TControl.Width"/>
        </seealso>
      </element>
      <element name="TWinControl.EraseBackground.DC">
        <short>The device context to use; may be clipped to a certain shape.</short>
      </element>

      <element name="TWinControl.IntfUTF8KeyPress">
        <short>
          Called by the interface after the navigation and specials keys are handled;
          i.e. after KeyDown but before KeyPress.
        </short>
        <descr>
          <p>
            Essentially expands a repeat count into multiple keystrokes. Cannot be used for SysKeys.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.IntfUTF8KeyPress.Result">
        <short>True when multiple keystrokes have been processed.</short>
      </element>
      <element name="TWinControl.IntfUTF8KeyPress.UTF8Key">
        <short>The UTF-8 encoding of the character.</short>
      </element>
      <element name="TWinControl.IntfUTF8KeyPress.RepeatCount">
        <short>Must be greater than zero, the exact value is ignored.</short>
      </element>
      <element name="TWinControl.IntfUTF8KeyPress.SystemKey">
        <short>Must be False, else nothing happens.</short>
      </element>

      <element name="TWinControl.IntfGetDropFilesTarget">
        <short>Searches for a Parent form that can be used as a file drop target.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.IntfGetDropFilesTarget.Result">
        <short>
          The TCustomForm instance that allows file drop actions, or Nil when file drag/drop is not supported.
        </short>
      </element>

      <element name="TWinControl.PaintTo">
        <short>Paints the control using the handle for the widget set class.</short>
        <descr>
          <p>
            <var>PaintTo</var> is a procedure used to draw the control using the handle for the widget set class. An overloaded variant is provided which uses the handle in a <var>TCanvas</var> instance as the target for the drawing operation.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.PaintTo.DC">
        <short>Device context (or Handle) used for the operation.</short>
      </element>
      <element name="TWinControl.PaintTo.X">
        <short>Horizontal coordinate where the control is drawn.</short>
      </element>
      <element name="TWinControl.PaintTo.Y">
        <short>Vertical coordinate where the control is drawn.</short>
      </element>
      <element name="TWinControl.PaintTo.ACanvas">
        <short>TCanvas instance with the handle used in the operation.</short>
      </element>

      <element name="TWinControl.SetShape">
        <short>Specifies the non-rectangular shape of the widget.</short>
        <descr>
          <p>
            SetShape is an overloaded procedure used to set the shape for the control to the non-rectangular value in AShape. The overloaded methods allow AShape to be either a TBitmap or a TRegion value.
          </p>
          <p>
            When TBitmap is used, the widget set class calls its SetShape method to apply the TBitmap handle to the handle for the widget. No actions are performed in the method when a handle has not been allocated for the widget set class.
          </p>
          <p>
            When TRegion is used,  SetWindowRgn in the LCL interface is called to apply the region in AShape to the handle for the control.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.SetShape.AShape">
        <short>Shape for the control; TBitmap or TRegion in overloaded methods.</short>
      </element>

      <element name="TGraphicControl">
        <short>
          <var>TGraphicControl</var> is the base class for all lightweight controls.
        </short>
        <descr>
          <p>
            <var>TGraphicControl</var> supports simple lightweight controls that do not need the ability to accept keyboard input,  and do not contain other controls. Since lightweight controls do not wrap GUI widgets, they use fewer resources than controls based on <var>TWinControl</var>. If you want to accept keyboard input, or need to support child controls, use a <var>TCustomControl</var> instead.
          </p>
          <p>
            <var>TGraphicControl</var> provides a <var>Canvas</var> property for access to the control's drawing surface and a virtual <var>Paint</var> method and an <var>OnPaint</var> handler, called in response to paint requests received by the parent control.
          </p>
          <p>
            Override the Paint method, or supply your own <var>OnPaint</var> handler, to do the actual drawing of the control.
          </p>
        </descr>
        <seealso>
          <link id="TCustomControl"/>
          <link id="TGraphicControl.Paint"/>
          <link id="TGraphicControl.OnPaint"/>
          <link id="#lcl.graphics.TCanvas">TCanvas</link>
        </seealso>
      </element>

      <element name="TGraphicControl.FCanvas"/>
      <element name="TGraphicControl.FOnPaint"/>

      <element name="TGraphicControl.WMPaint">
        <short>Handles a LM_PAINT message for the control.</short>
      </element>
      <element name="TGraphicControl.WMPaint.Message">
        <short>Message handled in the method.</short>
      </element>

      <element name="TGraphicControl.WSRegisterClass" link="#lcl.lclclasses.TLCLComponent.WSRegisterClass"/>

      <element name="TGraphicControl.FontChanged">
        <short>Performs actions needed when the Font for the control has been changed.</short>
        <descr>
          <p>
            FontChanged is an overridden method in TGraphicControl used to perform actions needed when the Font for the control has been changed. It is the routine used as the OnChange event handler for the Font property, and is assigned in the inherited constructor for the class instance.
          </p>
          <p>
            Sender contains the object instance for the event notification, and is provided to maintain compatibility with the TNotifyEvent signature for the event handler. It is not used in TGraphicControl, but is passed as an argument to the inherited method.
          </p>
          <p>
            FontChanged ensures that the new value for the Font property is also applied to the Canvas for the control. This includes the PixelsPerInch setting for the Font. FontChanged calls the inherited method prior to exit.
          </p>
        </descr>
        <seealso>
          <link id="TControl.FontChanged"/>
          <link id="TControl.Font"/>
          <link id="TControl.Create"/>
          <link id="#lcl.graphics.TFont.PixelsPerInch">TFont.PixelsPerInch</link>
        </seealso>
      </element>
      <element name="TGraphicControl.FontChanged.Sender">
        <short>Object instance for the event notification.</short>
      </element>

      <element name="TGraphicControl.Paint">
        <short>
          Implements the default handler used to draw the control.
        </short>
        <descr>
          <p>
            Paint is a method which causes the control to be drawn using the drawing mechanism for the control. In TGraphicControl, like TCustomControl, the OnPaint event handler is used (when assigned). Assign a routine to the OnPaint handler to perform the drawing operations needed for the control.
          </p>
        </descr>
        <seealso>
          <link id="TGraphicControl.OnPaint"/>
        </seealso>
      </element>

      <element name="TGraphicControl.DoOnChangeBounds">
        <short>Performs action needed when the bounds for the control have been changed.</short>
        <descr>
          <p>
            DoOnChangeBounds is an overridden method in TGraphicControl. It calls the inherited method on entry to update control flags and signal OnChangeBounds event handlers for the control. The Handle in Canvas is freed prior to exiting from the method. The handle is re-allocated the next time it is accessed.
          </p>
          <p>
            DoOnChangeBounds is called when the component is loaded using the LCL streaming mechanism, and from the ChangeBounds method when the control is resized.
          </p>
        </descr>
        <seealso>
          <link id="TGraphicControl.Canvas"/>
          <link id="TControlCanvas.FreeHandle"/>
          <link id="TControl.DoOnChangeBounds"/>
          <link id="TControl.OnChangeBounds"/>
          <link id="TControl.ChangeBounds"/>
          <link id="TControl.LoadedAll"/>
          <link id="TControlFlag"/>
        </seealso>
      </element>

      <element name="TGraphicControl.DoOnParentHandleDestruction">
        <short>Performs actions when the handle for the parent control is freed.</short>
        <descr>
          <p>
            <var>DoOnParentHandleDestruction</var> is overridden in <var>TGraphicControl</var> to re-implement the method in the ancestor class. It ensures that Handle for the Canvas is freed when the parent handler is destroyed.
          </p>
        </descr>
        <seealso>
          <link id="TGraphicControl.Canvas"/>
          <link id="TControlCanvas.FreeHandle"/>
          <link id="TControl.DoOnParentHandleDestruction"/>
        </seealso>
      </element>

      <element name="TGraphicControl.OnPaint">
        <short>
          Event handler signalled to paint the control.
        </short>
        <descr>
          <p>
            OnPaint is a TNotifyEvent with the event handler signalled to paint the control. Applications must implement and assign a routine to the event handler to perform the drawing operation. TGraphicControl does not provide a default drawing mechanism.
          </p>
          <p>
            Use the Canvas for the control to perform drawing operations. The Font and Brush in Canvas are automatically configured to use values assigned to the corresponding properties in the control. BorderStyle, however, is not automatically applied. Use the Pen in Canvas as needed to draw the BorderStyle for the control.
          </p>
          <p>
            OnPaint is signalled (when assigned) from the Paint method.
          </p>
        </descr>
        <seealso>
          <link id="TGraphicControl.Canvas"/>
          <link id="TGraphicControl.Paint"/>
          <link id="TControl.Font"/>
          <link id="TControl.Color"/>
          <link id="TWinControl.BorderStyle"/>
        </seealso>
      </element>

      <element name="TGraphicControl.CMCursorChanged">
        <short>Handles the CM_CURSORCHANGED message for the control.</short>
        <descr>
          <p>
            CMCursorChanged is an overridden method in TGraphicControl.  It ensures that the control is Visible before the temporary cursor shape is changed.
          </p>
          <p>
            <var>Visible</var> must be set to <b>True</b>, and the <var>Parent</var> control (with the window handle) must be assigned before the control can be displayed. No actions are performed in the method if Visible is <b>False</b>, or Parent is <b>Nil</b>.
          </p>
          <p>
            In addition, the mouse must be over the control to apply the cursor shape using <var>SetTempCursor</var> and the value in the <var>Cursor</var> property.
          </p>
        </descr>
        <seealso>
          <link id="TControl.CMCursorChanged"/>
          <link id="TControl.Visible"/>
          <link id="TControl.Parent"/>
          <link id="TControl.Cursor"/>
          <link id="TControl.SetTempCursor"/>
        </seealso>
      </element>

      <element name="TGraphicControl.Create">
        <short>Constructor for the class instance.</short>
        <descr>
          <p>
            Create is the overridden constructor for the class instance. It calls the inherited method on entry using AOwner as the owner of the class instance. Create allocates a TControlCanvas instance used for the Canvas property.
          </p>
        </descr>
        <seealso>
          <link id="TGraphicControl.Canvas"/>
          <link id="TControlCanvas"/>
          <link id="TControl.Create"/>
        </seealso>
      </element>
      <element name="TGraphicControl.Create.AOwner">
        <short>Owner of the class instance.</short>
      </element>

      <element name="TGraphicControl.Destroy">
        <short>Destructor for the class instance.</short>
        <descr>
          <p>
            Destroy is the overridden destructor for the class instance. It  ensures that resources allocated for the Canvas property are freed. It calls the inherited destructor prior to exiting from the method.
          </p>
        </descr>
        <seealso>
          <link id="TGraphicControl.Canvas"/>
        </seealso>
      </element>

      <element name="TGraphicControl.Canvas">
        <short>A clipped window into the parent Canvas.</short>
        <descr>
          <p>
            Don't paint on the entire Canvas! Instead use the dimensions of the <var>TGraphicControl</var> stored in the <var>ClientRect</var>.
          </p>
          <p>
            If you ask for the <var>Canvas.Width</var> or <var>Canvas.Height</var>, you are actually getting the Canvas dimensions from the Parent control.
          </p>
        </descr>
        <seealso>
          <link id="TControl.ClientRect"/>
          <link id="TControl.ClientWidth"/>
          <link id="TControl.ClientHeight"/>
          <link id="TControl.BoundsRect"/>
          <link id="#lcl.graphics.TCanvas">TCanvas</link>
        </seealso>
      </element>

      <element name="TCustomControl">
        <short>
          The base class for windowed controls which paint themselves.
        </short>
        <descr>
          <p>
            In contrast to <var>TGraphicControl</var>, a <var>TCustomControl</var> can accept keyboard input (and receive Focus), and can have child controls.
          </p>
          <p>
            Override the Paint method or supply your own OnPaint handler, to do the actual drawing of the control.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl"/>
          <link id="TGraphicControl"/>
        </seealso>
      </element>

      <element name="TCustomControl.FCanvas"/>
      <element name="TCustomControl.FOnPaint"/>

      <element link="#lcl.lclclasses.TLCLComponent.WSRegisterClass" name="TCustomControl.WSRegisterClass"/>

      <element name="TCustomControl.WMPaint">
        <short>Handles LM_PAINT messages for the control.</short>
        <descr>
          <p>
            Re-implements the method from the ancestor class to update ControlState prior to handling the specified Message. Includes the value csCustomPaint in ControlState before calling the inherited method. Removes csCustomPaint from ControlState after the message has been handled.
          </p>
          <p>
            No actions are performed in the method when the control is being freed, or when a Handle has not been allocated for the control.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.WMPaint"/>
        </seealso>
      </element>
      <element name="TCustomControl.WMPaint.Message">
        <short>Message handled in the method.</short>
      </element>

      <element name="TCustomControl.DestroyWnd">
        <short>Destroys the handle for the Canvas and the interface object.</short>
        <descr>
          <p>
            DestroyWnd is an overridden method in TCustomControl. It ensures that the Handle in Canvas is freed before calling the inherited method.
          </p>
        </descr>
        <seealso>
          <link id="TCustomControl.Canvas"/>
          <link id="TWinControl.DestroyWnd"/>
          <link id="TControlCanvas.FreeHandle"/>
        </seealso>
      </element>

      <element name="TCustomControl.PaintWindow">
        <short>The Paint handler plug-in, intercepting paint requests.</short>
        <descr>
          <p>
            <var>PaintWindow</var> is an overridden method in TCustomControl. It ensures that Canvas has an allocated Handle which matches the device context specified in the DC argument. If the Canvas handle does not match DC, the value in the argument is assigned to Canvas.
          </p>
          <p>
            PaintWindow calls the Paint method to signal the OnPaint event handler (when assigned).
          </p>
          <p>
            If Handle value in Canvas was changed in the method, it is reset to 0 (unassigned) prior to exit.
          </p>
          <p>
            PaintWindow does not call the inherited method.
          </p>
        </descr>
        <seealso>
          <link id="TCustomControl.Canvas"/>
          <link id="TCustomControl.Paint"/>
          <link id="TCustomControl.OnPaint"/>
          <link id="TWinControl.PaintWindow"/>
        </seealso>
      </element>
      <element name="TCustomControl.PaintWindow.DC">
        <short>The Device Context used to draw on the Canvas.</short>
      </element>

      <element name="TCustomControl.FontChanged">
        <short>Performs actions needed when the Font for the control has been changed.</short>
        <descr>
          <p>
            FontChanged is an overridden method in TCustomControl used to perform actions needed when the Font for the control has been changed. It is the routine used as the OnChange event handler for the Font property, and is assigned in the inherited constructor for the class instance.
          </p>
          <p>
            Sender contains the object instance for the event notification, and is provided to maintain compatibility with the TNotifyEvent signature for the event handler. It is not used in TGraphicControl, but is passed as an argument to the inherited method.
          </p>
          <p>
            FontChanged ensures that the new value for the Font property is also applied to the Canvas for the control. This includes the PixelsPerInch setting for the Font. FontChanged calls the inherited method prior to exit.
          </p>
        </descr>
        <seealso>
          <link id="TControl.FontChanged"/>
          <link id="TControl.Font"/>
          <link id="TControl.Create"/>
          <link id="#lcl.graphics.TFont.PixelsPerInch">TFont.PixelsPerInch</link>
        </seealso>
      </element>
      <element name="TCustomControl.FontChanged.Sender">
        <short>Object instance (TControl) for the event notification.</short>
      </element>

      <element name="TCustomControl.SetColor">
        <short>Sets the value for the Color property</short>
        <descr>
          <p>
            SetColor is an overridden method in TCustomControl used to set the value in the Color property. It calls the inherited method on entry, and applies the new color value to the Brush in the control Canvas.
          </p>
        </descr>
        <seealso>
          <link id="#lcl.controls.TControl.Color">TControl.Color</link>
          <link id="#lcl.controls.TWinControl.SetColor">TWinControl.SetColor</link>
        </seealso>
      </element>
      <element name="TCustomControl.SetColor.Value">
        <short>New value for the Color property.</short>
      </element>

      <element name="TCustomControl.Paint">
        <short>
          Implements the default handler used to draw the control.
        </short>
        <descr>
          <p>
            Paint is a method which causes the control to be drawn using the drawing mechanism for the control. In TCustomControl, like TGraphicControl, the OnPaint event handler is used (when assigned). Assign a routine to the OnPaint handler to perform the drawing operations needed for the control.
          </p>
          <p>
            Paint called from the PaintWindow method, and occurs when a LM_PAINT message is handled for the control.
          </p>
        </descr>
        <seealso>
          <link id="TCustomControl.OnPaint"/>
          <link id="TCustomControl.PaintWindow"/>
          <link id="TCustomControl.WMPaint"/>
        </seealso>
      </element>

      <element name="TCustomControl.Create">
        <short>Constructor for the class instance.</short>
        <descr>
          <p>
            Create is the overridden constructor for the class instance, and calls the inherited constructor on entry. Create allocates resources for the TControlCanvas instance used in the Canvas property.
          </p>
        </descr>
        <seealso>
          <link id="TCustomControl.Canvas"/>
          <link id="TControlCanvas"/>
        </seealso>
      </element>
      <element name="TCustomControl.Create.AOwner">
        <short>Owner for the class instance.</short>
      </element>

      <element name="TCustomControl.Destroy">
        <short>Destructor for the class instance.</short>
        <descr>
          <p>
            Destroy is the overridden destructor for the class instance.
          </p>
          <p>
            It calls RemoveFocus to prevent the Parent control from giving focus to the free control. It destroys the Handle for the control, and ensures that the control is removed as a Parent or DockSite for its child controls. It does not free the child controls; they are freed by their owner.
          </p>
          <p>
            Controls in the DockClient property are updated to remove the class instance from the HostDockSite property in the docking clients.
          </p>
          <p>
            Destroy frees resource allocated in the constructor, and calls the inherited method proper to exit.
          </p>
        </descr>
        <seealso>
          <link id="TCustomControl.Canvas"/>
        </seealso>
      </element>

      <element name="TCustomControl.Canvas">
        <short>
          The drawing surface for the control.
        </short>
        <descr>
          <p>
            Canvas is a TCanvas property which contains the drawing surface for the control. Resources for the property are allocated in the constructor for the class instance. A TControlCanvas descendant is created and assigned to the member for the property. The Handle for the Canvas is updated when PaintWindow is called for a specific device context.
          </p>
          <p>
            Changing values in the Font or Color properties causes settings in Canvas to be updated. A new value assigned to Font is also assigned to the Canvas in the control, and includes the PixelsPerInch setting for the Font. A new value assigned to Color is applied to the Brush in Canvas. A value assigned to BorderStyle must be handled in the routine assigned to the OnPaint event handler.
          </p>
        </descr>
        <seealso>
          <link id="TCustomControl.Canvas"/>
          <link id="TCustomControl.OnPaint"/>
          <link id="TWinControl.BorderStyle"/>
          <link id="TControl.Font"/>
          <link id="TControlCanvas"/>
          <link id="#lcl.graphics.TCanvas">TCanvas</link>
        </seealso>
      </element>

      <element name="TCustomControl.BorderStyle" link="#lcl.controls.TWinControl.BorderStyle"/>

      <element name="TCustomControl.OnPaint">
        <short>
          Event handler signalled to paint the control.
        </short>
        <descr>
          <p>
            OnPaint is a TNotifyEvent property with the event handler signalled to draw the control on its Canvas. An object procedure which draws all aspects of the control must be implemented and assigned to the property.
          </p>
          <p>
            The Sender argument provides access to properties and methods for the control instance. It must be cast to a TCustomControl to access members for the class type.
          </p>
          <p>
            Use Canvas to render the control in the event handler. The values from Font and Color are already applied to the corresponding properties in Canvas. The BorderStyle property must be applied in code for the handler.
          </p>
          <p>
            OnPaint is signalled from the Paint method.
          </p>
        </descr>
        <seealso>
          <link id="TCustomControl.Paint"/>
          <link id="TCustomControl.Canvas"/>
          <link id="TControl.Font"/>
          <link id="TControl.Color"/>
          <link id="TWinControl.BorderStyle"/>
        </seealso>
      </element>

      <element name="TImageList">
        <short>
          Implements a multi-resolution container for images used in an application.
        </short>
        <descr>
          <p>
            TImageList is a TDragImageList descendant, and sets the visibility for properties in ancestor classes (like TCustomImageList). As a <link id="TDragImageList">TDragImageList</link> descendant, it provides support for using images in the list during drag-and-drop or drag-and-dock operations. Most of the features and functionality for the list are inherited from the <link id="#lcl.imglist.TCustomImageList">TCustomImageList</link> class.
          </p>
        </descr>
        <seealso>
          <link id="TDragImageList"/>
          <link id="#lcl.imglist.TCustomImageList">TCustomImageList</link>
        </seealso>
      </element>

      <element link="#lcl.imglist.TCustomImageList.AllocBy" name="TImageList.AllocBy"/>
      <element link="#lcl.imglist.TCustomImageList.BlendColor" name="TImageList.BlendColor"/>
      <element link="#lcl.imglist.TCustomImageList.BkColor" name="TImageList.BkColor"/>
      <element link="#lcl.imglist.TCustomImageList.DrawingStyle" name="TImageList.DrawingStyle"/>
      <element link="#lcl.imglist.TCustomImageList.Height" name="TImageList.Height"/>
      <element link="#lcl.imglist.TCustomImageList.ImageType" name="TImageList.ImageType"/>
      <element link="#lcl.imglist.TCustomImageList.Masked" name="TImageList.Masked"/>
      <element link="#lcl.imglist.TCustomImageList.Scaled" name="TImageList.Scaled"/>
      <element link="#lcl.imglist.TCustomImageList.ShareImages" name="TImageList.ShareImages"/>
      <element link="#lcl.imglist.TCustomImageList.Width" name="TImageList.Width"/>
      <element link="#lcl.imglist.TCustomImageList.OnChange" name="TImageList.OnChange"/>
      <element link="#lcl.imglist.TCustomImageList.OnGetWidthForPPI" name="TImageList.OnGetWidthForPPI"/>

      <element name="TControlPropertyStorage">
        <short>
          Implements the abstract ancestor class used to get the property list for a control.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlPropertyStorage.GetPropertyList">
        <short>
          Parses the <link id="TControl.SessionProperties"/> string into the given list.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlPropertyStorage.GetPropertyList.List">
        <short/>
      </element>

      <element name="TDockZone">
        <short>
          Represents a node in a <link id="#lcl.controls.TDockTree">TDockTree</link>
      </short>
        <descr>
          <p>
            It encapsulates a dock zone, containing either other zones or a single control.
          </p>
          <p>
            This implementation is specific to <link id="TDockTree"/>. Another DockManager can (and should) use its own class instead.
          </p>
        </descr>
        <seealso>
          <link id="TDockTree"/>
        </seealso>
      </element>

      <element name="TDockZone.FChildControl"/>
      <element name="TDockZone.FChildCount"/>
      <element name="TDockZone.FFirstChildZone"/>
      <element name="TDockZone.FTree"/>
      <element name="TDockZone.FParentZone"/>
      <element name="TDockZone.FOrientation"/>
      <element name="TDockZone.FNextSibling"/>
      <element name="TDockZone.FPrevSibling"/>
      <element name="TDockZone.FBounds"/>

      <element name="TDockZone.GetHeight">
        <short>Gets the value for the Height property.</short>
        <descr/>
        <seealso>
          <link id="TDockZone.Height"/>
        </seealso>
      </element>
      <element name="TDockZone.GetHeight.Result">
        <short>Value for the Height property.</short>
      </element>

      <element name="TDockZone.GetLeft">
        <short>Gets the value for the Left property.</short>
        <descr/>
        <seealso>
          <link id="TDockZone.Left"/>
        </seealso>
      </element>
      <element name="TDockZone.GetLeft.Result">
        <short>Gets the value for the Left property.</short>
      </element>

      <element name="TDockZone.GetLimitBegin">
        <short>Gets the value for the LimitBegin property.</short>
        <descr/>
        <seealso>
          <link id="TDockZone.LimitBegin"/>
        </seealso>
      </element>
      <element name="TDockZone.GetLimitBegin.Result">
        <short>Value for the LimitBegin property.</short>
      </element>

      <element name="TDockZone.GetLimitSize">
        <short>Gets the value for the LimitSize property.</short>
        <descr/>
        <seealso>
          <link id="TDockZone.LimitSize"/>
        </seealso>
      </element>
      <element name="TDockZone.GetLimitSize.Result">
        <short>Value for the LimitSize property.</short>
      </element>

      <element name="TDockZone.GetTop">
        <short>Gets the value for the Top property.</short>
        <descr/>
        <seealso>
          <link id="TDockZone.Top"/>
        </seealso>
      </element>
      <element name="TDockZone.GetTop.Result">
        <short>Value for the Top property.</short>
      </element>

      <element name="TDockZone.GetVisible">
        <short>Gets the value for the Visible property.</short>
        <descr/>
        <seealso>
          <link id="TDockZone.Visible"/>
        </seealso>
      </element>
      <element name="TDockZone.GetVisible.Result">
        <short>Value for the Visible property.</short>
      </element>

      <element name="TDockZone.GetVisibleChildCount">
        <short>Gets the value for the VisibleChildCount property.</short>
        <descr/>
        <seealso>
          <link id="TDockZone.VisibleChildCount"/>
        </seealso>
      </element>
      <element name="TDockZone.GetVisibleChildCount.Result">
        <short>Value for the VisibleChildCount property.</short>
      </element>

      <element name="TDockZone.GetWidth">
        <short>Gets the value for the Width property.</short>
        <descr/>
        <seealso>
          <link id="TDockZone.Width"/>
        </seealso>
      </element>
      <element name="TDockZone.GetWidth.Result">
        <short>Value for the Width property.</short>
      </element>

      <element name="TDockZone.SetLimitBegin">
        <short>Sets the value for the LimitBegin property.</short>
        <descr/>
        <seealso>
          <link id="TDockZone.LimitBegin"/>
        </seealso>
      </element>
      <element name="TDockZone.SetLimitBegin.AValue">
        <short>New value for the LimitBegin property.</short>
      </element>

      <element name="TDockZone.SetLimitSize">
        <short>New value for the LimitSize property.</short>
        <descr/>
        <seealso>
          <link id="TDockZone.LimitSize"/>
        </seealso>
      </element>
      <element name="TDockZone.SetLimitSize.AValue">
        <short>New value for the LimitSize property.</short>
      </element>

      <element name="TDockZone.SetHeight">
        <short>Sets the value for the Height property.</short>
        <descr/>
        <seealso>
          <link id="TDockZone.Height"/>
        </seealso>
      </element>
      <element name="TDockZone.SetHeight.AValue">
        <short>New value for the Height property.</short>
      </element>

      <element name="TDockZone.SetLeft">
        <short>Sets the value for the Left property.</short>
        <descr/>
        <seealso>
          <link id="TDockZone.Left"/>
        </seealso>
      </element>
      <element name="TDockZone.SetLeft.AValue">
        <short>New value for the Left property.</short>
      </element>

      <element name="TDockZone.SetTop">
        <short>Sets the value for the Top property.</short>
        <descr/>
        <seealso>
          <link id="TDockZone.Top"/>
        </seealso>
      </element>
      <element name="TDockZone.SetTop.AValue">
        <short>New value for the Top property.</short>
      </element>

      <element link="#lcl.controls.TDockZone.Width" name="TDockZone.SetWidth">
        <short>Sets the value for the Width property.</short>
        <descr/>
        <seealso>
          <link id="TDockZone.Width"/>
        </seealso>
      </element>
      <element name="TDockZone.SetWidth.AValue">
        <short>New value for the Width property.</short>
      </element>

      <element name="TDockZone.Create">
        <short>Constructor for the class instance.</short>
        <descr>
          <p>
            Stores values passed in the TheTree and TheChild arguments to the Tree and ChildControl property. Sets the initial bounds for the dock zone to an empty rectangle.  This causes the Top, Left, Width, and Height properties to contain 0 (zero).
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TDockZone.Create.TheTree">
        <short>The dock tree to which this zone belongs.</short>
      </element>
      <element name="TDockZone.Create.TheChildControl">
        <short>The control in this zone (or Nil when unassigned).</short>
      </element>

      <element name="TDockZone.FindZone">
        <short>Returns the dock zone containing the given control.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDockZone.FindZone.Result">
        <short>The zone containing AControl as ChildControl.</short>
      </element>
      <element name="TDockZone.FindZone.AControl">
        <short>Control to locate in the dock tree.</short>
      </element>

      <element name="TDockZone.FirstVisibleChild">
        <short>The first visible child zone.</short>
        <descr/>
        <seealso>
          <link id="TDockZone.Visible"/>
        </seealso>
      </element>
      <element name="TDockZone.FirstVisibleChild.Result">
        <short/>
      </element>

      <element name="TDockZone.GetNextVisibleZone">
        <short>The next visible zone.</short>
        <descr/>
        <seealso>
          <link id="TDockZone.Visible"/>
        </seealso>
      </element>
      <element name="TDockZone.GetNextVisibleZone.Result">
        <short>The zone, or <b>Nil</b> if none found.</short>
      </element>

      <element name="TDockZone.NextVisible">
        <short>The next visible zone.</short>
        <descr/>
        <seealso>
          <link id="TDockZone.Visible"/>
        </seealso>
      </element>
      <element name="TDockZone.NextVisible.Result">
        <short/>
      </element>

      <element name="TDockZone.PrevVisible">
        <short>The preceding visible zone.</short>
        <descr/>
        <seealso>
          <link id="TDockZone.Visible"/>
        </seealso>
      </element>
      <element name="TDockZone.PrevVisible.Result">
        <short/>
      </element>

      <element name="TDockZone.AddSibling">
        <short>Inserts NewZone as preceding or following sibling.</short>
        <descr/>
      </element>
      <element name="TDockZone.AddSibling.NewZone">
        <short>The zone to add.</short>
      </element>
      <element name="TDockZone.AddSibling.InsertAt">
        <short>How to add the zone.</short>
      </element>

      <element name="TDockZone.AddAsFirstChild">
        <short>Adds the given zone as the first child.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDockZone.AddAsFirstChild.NewChildZone">
        <short>The zone to add.</short>
      </element>

      <element name="TDockZone.AddAsLastChild">
        <short>Adds the given zone as the last child.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDockZone.AddAsLastChild.NewChildZone">
        <short>The zone to add.</short>
      </element>

      <element name="TDockZone.ReplaceChild">
        <short>
          Replace the <var>OldChild</var> zone by <var>NewChild</var>.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDockZone.ReplaceChild.OldChild">
        <short>The zone to unlink.</short>
      </element>
      <element name="TDockZone.ReplaceChild.NewChild">
        <short>The zone to link in place of OldChild.</short>
      </element>

      <element name="TDockZone.GetLastChild">
        <short>The last child zone.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDockZone.GetLastChild.Result">
        <short/>
      </element>

      <element name="TDockZone.GetIndex">
        <short>Calculates the index of the zone within its parent zone.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDockZone.GetIndex.Result">
        <short/>
      </element>

      <element name="TDockZone.Remove">
        <short>Unlinks the given child zone.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDockZone.Remove.ChildZone">
        <short/>
      </element>

      <element name="TDockZone.ChildControl">
        <short>The control docked in this zone.</short>
        <descr>
          A zone can contain nothing, a control, or child zones.
        </descr>
        <seealso/>
      </element>

      <element name="TDockZone.ChildCount">
        <short>The number of child zones.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDockZone.FirstChild">
        <short>The first child zone.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDockZone.Height">
        <short>The height of the zone.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDockZone.Left">
        <short>The left coordinate of the zone.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDockZone.LimitBegin">
        <short>The free coordinate of the DockZone (Left or Top).</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDockZone.LimitSize">
        <short>The free size of the DockZone (Width or Height).</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDockZone.Orientation">
        <short>
          Whether docking is oriented vertically, horizontally, in pages, or not at all.
        </short>
        <descr>
          <ul>
            <li>doNoOrient: zone contains a TControl and no child zones.</li>
            <li>doHorizontal: zone's children are stacked top-to-bottom.</li>
            <li>doVertical: zone's children are arranged left-to-right.</li>
            <li>doPages: zone's children are pages arranged left-to-right.</li>
          </ul>
        </descr>
        <seealso>
          <link id="TDockOrientation"/>
        </seealso>
      </element>

      <element name="TDockZone.Parent">
        <short>The parent zone in the DockTree.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDockZone.Top">
        <short>The top coordinate for the dock zone.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDockZone.Tree">
        <short>The dock tree of which this dock zone is a part.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDockZone.Visible">
        <short>
          A zone is visible if it contains a visible control, or if any child zone is visible.
        </short>
        <descr/>
        <seealso>
          <link id="TDockZone.VisibleChildCount"/>
        </seealso>
      </element>

      <element name="TDockZone.VisibleChildCount">
        <short>The number of visible child zones.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDockZone.Width">
        <short>The width of this zone.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDockZone.NextSibling">
        <short>The next sibling zone.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDockZone.PrevSibling">
        <short>The preceding sibling zone.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDockZoneClass">
        <short>Class of <link id="TDockZone"/></short>
      </element>

      <element name="TForEachZoneProc">
        <short>The type for a ForEachZone callback procedure, currently unused.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TForEachZoneProc.Zone">
        <short>The iterated zone.</short>
      </element>

      <element name="TDockTreeFlag">
        <short>Represents flag values used in TDockTree.</short>
        <descr/>
        <seealso>
          <link id="TDockTree"/>
        </seealso>
      </element>
      <element name="TDockTreeFlag.dtfUpdateAllNeeded">
        <short/>
      </element>

      <element name="TDockTreeFlags">
        <short>Set type used to store values from the TDockTreeFlag enumeration.</short>
        <descr/>
        <seealso>
          <link id="TDockTreeFlag"/>
        </seealso>
      </element>

      <element name="TDockTree">
        <short>A docking manager for tree-style layouts.</short>
        <descr>
          <p>
            A tree-style layout is organized in layers of a specific (horizontal or vertical) orientation. Every node in the tree is either a container for other nodes, or represents a zone with a single docked control. All child zones of an node have the same DockOrientation.
          </p>
          <p>
            The following documentation is copied from the Controls unit. It is of historical interest only, since it effectively describes the AnchorDocking, implemented in TCustomAnchoredDockManager. AnchorDocking is not related to visual drag-dock procedures, it merely is an attempt to implement just an layout manager.
          </p>
          <remark>
            The TLazDockTree implementation never was finished, due to problems with the anchor "docking" mechanism. Use the EasyDockManager (examples/dockmanager) instead.
          </remark>
          <p>
            This is an abstract class. A real implementation is e.g. in ldocktree.pas.
          </p>
          <p>
            Docking means here: Combining several windows to one. A window can here be a TCustomForm or a floating control (undocked) or a TDockForm. A window can be docked to another to the left, right, top, bottom or "into". The docking source window will be resized, to fit to the docking target window.
          </p>
          <p>
            Example1: Docking "A" (source window) left to "B" (target window)
          </p>
<code>
+---+    +-----+
| A | -&gt; |  B  |
|   |    |     |
+---+    +-----+
</code>
          <p>
            Result: A new docktree will be created. Height of "A" will be resized to the height of "B". A splitter will be inserted between "A" and "B". And all three are children of the newly created TLazDockForm of the newly created TDockTree.
          </p>
<code>
+------------+
|+---+|+----+|
|| A ||| B  ||
||   |||    ||
|+---+|+----+|
+------------+
</code>
          <ul>
            <li>If "A" or "B" were floating controls, the floating dock sites are freed.</li>
            <li>
              If "A" or "B" were forms, their decorations (title bars and borders) are replaced by docked decorations.
            </li>
            <li>
              If "A" had a TDockTree, it is freed and its child dockzones are merged to the docktree of "B".
            </li>
          </ul>
          <p>
            Analog for docking "C" left to "A":
          </p>
<code>
+------------------+
|+---+|+---+|+----+|
|| C ||| A ||| B  ||
||   |||   |||    ||
|+---+|+---+|+----+|
+------------------+
</code>
          <p>
            Example2: Docking A into B
          </p>
<code>
+-----+
|     |  +---+
|  B &lt;+--| A |
|     |  +---+
+-----+
</code>
          <p>
            Result: A new docktree will be created. "A" will be resized to the size of "B". Both will be put into a TLazDockPages control which is the child of the newly created TDockTree.
          </p>
<code>
+-------+
|[B][A] |
|+-----+|
||     ||
||  A  ||
||     ||
|+-----+|
+-------+
</code>
          <p>
            Every DockZone has siblings and children. Siblings can either be:
          </p>
          <ul>
            <li>horizontally (left to right, splitter),</li>
            <li>vertically (top to bottom, splitter), </li>
            <li>or upon each other (as notebook pages).</li>
          </ul>
          <p>
            <b>InsertControl</b> - undock a control and dock it into the dock site.
            For example, to dock Form1 left to a Form2:
          </p>
          <code>InsertControl(Form1,alLeft,Form2);</code>
          <p>
            To dock into a TDockPage, use:
          </p>
          <code>Align=alCustom;</code>
          <p>
            <b>PositionDockRect</b> - calculates where a control would be placed, if it would
            be docked via InsertControl.
          </p>
          <p>
            <b>RemoveControl</b> - removes a control from the dock site.
          </p>

          <p>
            <b>GetControlBounds</b> - TODO: for Delphi compatibility.
          </p>
          <p>
            <b>ResetBounds</b> - TODO: for Delphi compatibility.
          </p>
          <p>
            <b>SetReplacingControl</b> - TODO: for Delphi compatibility.
          </p>
          <p>
            <b>PaintSite</b> - TODO: for Delphi compatibility.
          </p>
        </descr>
        <seealso>
          <link id="TDockManager"/>
        </seealso>
      </element>

      <element name="TDockTree.FBorderWidth">
        <short>The width of the border around a dock zone.</short>
        <descr/>
        <seealso/>
      </element>

      <element link="#lcl.controls.TDockTree.DockSite" name="TDockTree.FDockSite"/>
      <element link="#lcl.controls.TDockTree.DockZoneClass" name="TDockTree.FDockZoneClass"/>
      <element name="TDockTree.FFlags"/>
      <element link="#lcl.controls.TDockTree.BeginUpdate" name="TDockTree.FUpdateCount"/>

      <element name="TDockTree.DeleteZone">
        <short>Destroys the zone and its child zones.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDockTree.DeleteZone.Zone">
        <short/>
      </element>

      <element link="#lcl.controls.TDockTree.DockSite" name="TDockTree.SetDockSite"/>
      <element name="TDockTree.SetDockSite.AValue">
        <short/>
      </element>

      <element link="#lcl.controls.TDockTree.RootZone" name="TDockTree.FRootZone"/>

      <element name="TDockTree.HitTest">
        <short>
          Returns the control and the part of the dockzone at the given coordinates.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDockTree.HitTest.Result">
        <short>The docked control.</short>
      </element>
      <element name="TDockTree.HitTest.MousePos">
        <short>The client coordinates.</short>
      </element>
      <element name="TDockTree.HitTest.HTFlag">
        <short>Returns the zone part at MousePos.</short>
      </element>

      <element name="TDockTree.PaintDockFrame">
        <short>Paints the dock header of the zone containing AControl.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDockTree.PaintDockFrame.ACanvas">
        <short/>
      </element>
      <element name="TDockTree.PaintDockFrame.AControl">
        <short/>
      </element>
      <element name="TDockTree.PaintDockFrame.ARect">
        <short/>
      </element>

      <element name="TDockTree.UpdateAll">
        <short>
          Updates the internal TDockTreeFlags to reflect the update status for the control
        </short>
        <descr>
          <p>
            <var>UpdateAll</var> is a procedure used to update the internal <var>TDockTreeFlags</var> member to reflect the current update status for the control. UpdateAll checks an internal counter, incremented in <var>BeginUpdate</var>, to see if <var>dtfUpdateAllNeeded</var> needs to be included in or excluded from the set of flag values. It is included when the update count is greater than <b>0</b> (<b>zero</b>). Otherwise, it is excluded from the set.
          </p>
          <p>
            UpdateAll is called from the <var>EndUpdate</var> method.
          </p>
        </descr>
        <seealso>
          <link id="TDockTree.BeginUpdate"/>
          <link id="TDockTree.EndUpdate"/>
          <link id="TDockTreeFlags"/>
          <link id="TDockTreeFlag"/>
        </seealso>
      </element>

      <element link="#lcl.controls.TDockTree.DockZoneClass" name="TDockTree.SetDockZoneClass"/>
      <element name="TDockTree.SetDockZoneClass.AValue">
        <short/>
      </element>

      <element name="TDockTree.Create">
        <short>Constructor for the class instance.</short>
        <descr>
          <p>
            Create is the overridden constructor for the class instance. TheDockSite contains the windowed control handled in the docking tree. Create calls the inherited constructor using TheDockSite as the owner for the class instance.
          </p>
          <p>
            Creates allocates resources needed for the RootZone property, and sets the value for its border width to 4.
          </p>
        </descr>
        <seealso>
          <link id="TDockTree.RootZone"/>
          <link id="TDockManager"/>
        </seealso>
      </element>
      <element name="TDockTree.Create.TheDockSite">
        <short>The window control to be managed.</short>
      </element>

      <element name="TDockTree.Destroy">
        <short>Destructor for the class instance.</short>
        <descr>
          <p>
            Frees resources allocated to the RootZone property, and calls the inherited destructor.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TDockTree.BeginUpdate">
        <short>Starts an update process for the class instance.</short>
        <descr>
          <p>
            <var>BeginUpdate</var> is an overridden method in TDockTree. It increments the internal update counter for the class. It is used to consolidate calls to the UpdateAll method until the internal counter reaches zero (0).
          </p>
        </descr>
        <seealso>
          <link id="TDockManager.BeginUpdate"/>
          <link id="TDockManager.EndUpdate"/>
          <link id="TDockTree.UpdateAll"/>
        </seealso>
      </element>

      <element name="TDockTree.EndUpdate">
        <short>Finishes an update process for the class instance.</short>
        <descr>
          <p>
            <var>EndUpdate</var> is an overridden method in TDockTree. BeginUpdate and EndUpdate are used to consolidate calls to the <var>UpdateAll</var> method. EndUpdate decrements the internal update counter, and when it reaches zero (0) calls UpdateAll to remove dtfUpdateAllNeeded from the docking tree flags.
          </p>
        </descr>
        <seealso>
          <link id="TDockManager.EndUpdate"/>
          <link id="TDockManager.BeginUpdate"/>
          <link id="TDockTree.UpdateAll"/>
          <link id="TDockTreeFlags"/>
          <link id="TDockTreeFlag"/>
        </seealso>
      </element>

      <element name="TDockTree.AdjustDockRect">
        <short>Adjusts the zone rectangle for AControl.</short>
        <descr>
          <p>
            ARect initially describes the dockzone into which the control is docked. From that area the zone decoration is excluded, so that ARect describes the area reserved for the docked control.
          </p>
          <p>
            AdjustDockRect is not part of the general docking model. It can implemented and used for any purpose in a dock tree manager. Most docking managers will replace it by a method with more arguments, that allow to identify the zone and its properties immediately.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TDockTree.AdjustDockRect.AControl">
        <short/>
      </element>
      <element name="TDockTree.AdjustDockRect.ARect">
        <short/>
      </element>

      <element link="#lcl.controls.TDockManager.GetControlBounds" name="TDockTree.GetControlBounds"/>
      <element name="TDockTree.GetControlBounds.AControl">
        <short/>
      </element>
      <element name="TDockTree.GetControlBounds.ControlBounds">
        <short/>
      </element>

      <element name="TDockTree.InsertControl">
        <short>
          Positions <var>DropCtl</var> relative <var>Control</var>, using the alignment specified by <var>InsertAt</var>.
        </short>
        <descr>
          <p>
            <var>InsertControl</var> determines the layout and appearance of the just docked control, forcing a repaint of the container control if necessary.
          </p>
          <p>
            When <var>SetReplacingControl</var> has been called with a non-Nil Control before, the dropped control only should replace that control.
          </p>
          <p>
            A tree docking manager organizes the docksite into layers of horizontal or vertical orientation. As long as no more than one control is docked into a docksite, the tree has no orientation at all. The second docked control determines the orientation of the docksite and the dock tree. All further drops are either isogonal (in direction of the zone orientation) or orthogonal (opposite to the zone orientation). On an isogonal drop a new leaf zone is created for the dropped control, as a sibling of the already existing child zones. On an orthogonal drop the zone containing the DropControl becomes the root of another subtree, whose initial members are the leaf zones for <var>Control</var> and <var>DropCtl</var>.
          </p>
          <p>
            One value of <var>InsertAt</var> (<var>alCustom</var>) is reserved for notebook docking, where <var>DropCtl</var> is replaced by a tabbed notebook, and <var>Control</var> and <var>DropCtl</var> are moved into pages of the notebook. The notebook is a docksite of its own, further drops into the notebook are handled by the notebook itself, the <var>DockManager</var> of the host docksite is not involved.
          </p>
        </descr>
        <seealso>
          <link id="TDockManager.RemoveControl"/>
        </seealso>
      </element>
      <element name="TDockTree.InsertControl.AControl">
        <short>The control beneath which to place DropControl.</short>
      </element>
      <element name="TDockTree.InsertControl.InsertAt">
        <short>How to insert DropControl.</short>
      </element>
      <element name="TDockTree.InsertControl.DropControl">
        <short>The control to add.</short>
      </element>

      <element name="TDockTree.LoadFromStream">
        <short>Has an empty implementation in TDockTree.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDockTree.LoadFromStream.SrcStream">
        <short/>
      </element>

      <element name="TDockTree.MessageHandler">
        <short>Has an empty implementation in TDockTree.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDockTree.MessageHandler.Sender">
        <short/>
      </element>
      <element name="TDockTree.MessageHandler.Message">
        <short/>
      </element>

      <element name="TDockTree.PositionDockRect" link="#lcl.controls.TDockManager.PositionDockRect"/>
      <element name="TDockTree.PositionDockRect.AClient">
        <short/>
      </element>
      <element name="TDockTree.PositionDockRect.DropCtl">
        <short/>
      </element>
      <element name="TDockTree.PositionDockRect.DropAlign">
        <short/>
      </element>
      <element name="TDockTree.PositionDockRect.DockRect">
        <short/>
      </element>

      <element link="#lcl.controls.TDockManager.RemoveControl" name="TDockTree.RemoveControl"/>
      <element name="TDockTree.RemoveControl.AControl">
        <short/>
      </element>

      <element link="#lcl.controls.TDockManager.SaveToStream" name="TDockTree.SaveToStream"/>
      <element name="TDockTree.SaveToStream.DestStream">
        <short/>
      </element>

      <element link="#lcl.controls.TDockManager.SetReplacingControl" name="TDockTree.SetReplacingControl"/>
      <element name="TDockTree.SetReplacingControl.AControl">
        <short/>
      </element>

      <element link="#lcl.controls.TDockManager.ResetBounds" name="TDockTree.ResetBounds"/>
      <element name="TDockTree.ResetBounds.Force">
        <short/>
      </element>

      <element link="#lcl.controls.TDockManager.PaintSite" name="TDockTree.PaintSite"/>
      <element name="TDockTree.PaintSite.DC">
        <short/>
      </element>

      <element name="TDockTree.DumpLayout">
        <short>Stores the layout in an file.</short>
      </element>
      <element name="TDockTree.DumpLayout.FileName">
        <short/>
      </element>

      <element name="TDockTree.DockZoneClass">
        <short>The class of all dock zones in this tree.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDockTree.DockSite">
        <short>
          The parent control whose docked clients are managed
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDockTree.RootZone">
        <short>The root zone for the DockTree.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="DockSplitterClass">
        <short>Class type used to create new splitter class instances.</short>
        <descr>
          <p>
            Normally contains a reference to the <var>TSplitter</var> class, as assigned in the initialization section for the <file>extctrls.pp</file> unit.
          </p>
        </descr>
        <seealso>
          <link id="#lcl.extctrls.TSplitter">TSplitter</link>
        </seealso>
      </element>

      <element name="TMouse">
        <short>Provides access to properties of the Mouse.</short>
        <descr>
          <p>
            Contains information about the current mouse position, whether messages are captured by a window, whether it is dragging an object, and how far the mouse must move before a control starts dragging.
          </p>
        </descr>
      </element>

      <element name="TMouse.FWheelScrollLines"/>

      <element link="#lcl.controls.TMouse.Capture" name="TMouse.SetCapture"/>
      <element name="TMouse.SetCapture.Value">
        <short/>
      </element>

      <element link="#lcl.controls.TMouse.Capture" name="TMouse.GetCapture"/>
      <element name="TMouse.GetCapture.Result">
        <short/>
      </element>

      <element link="#lcl.controls.TMouse.CursorPos" name="TMouse.GetCursorPos"/>
      <element name="TMouse.GetCursorPos.Result">
        <short/>
      </element>

      <element link="#lcl.controls.TMouse.IsDragging" name="TMouse.GetIsDragging"/>
      <element name="TMouse.GetIsDragging.Result">
        <short/>
      </element>

      <element link="#lcl.controls.TMouse.CursorPos" name="TMouse.SetCursorPos"/>
      <element name="TMouse.SetCursorPos.AValue">
        <short/>
      </element>

      <element link="#lcl.controls.TMouse.WheelScrollLines" name="TMouse.GetWheelScrollLines"/>
      <element name="TMouse.GetWheelScrollLines.Result">
        <short/>
      </element>

      <element link="#lcl.controls.TMouse.DragImmediate" name="TMouse.GetDragImmediate"/>
      <element name="TMouse.GetDragImmediate.Result">
        <short/>
      </element>

      <element link="#lcl.controls.TMouse.DragImmediate" name="TMouse.SetDragImmediate"/>
      <element name="TMouse.SetDragImmediate.AValue">
        <short/>
      </element>

      <element link="#lcl.controls.TMouse.DragThreshold" name="TMouse.GetDragThreshold"/>
      <element name="TMouse.GetDragThreshold.Result">
        <short/>
      </element>

      <element link="#lcl.controls.TMouse.DragThreshold" name="TMouse.SetDragThreshold"/>
      <element name="TMouse.SetDragThreshold.AValue">
        <short/>
      </element>

      <element name="TMouse.Capture">
        <short>Handle for the capture control.</short>
        <descr/>
      </element>

      <element name="TMouse.CursorPos">
        <short>The screen position for the mouse cursor.</short>
        <descr/>
      </element>

      <element name="TMouse.IsDragging">
        <short>True while dragging an object.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TMouse.WheelScrollLines">
        <short>
          The number of lines to scroll with every notch or unit on the mouse wheel
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TMouse.DragImmediate">
        <short>
          Does dragging start immediately (True), or only after a mouse move?
        </short>
        <descr/>
      </element>

      <element name="TMouse.DragThreshold">
        <short>
          The minimum distance the mouse must move before dragging starts (in delayed mode)
        </short>
        <descr>Default is 5 pixels</descr>
      </element>

      <element name="AnchorAlign">
        <short>Array with sets of anchors used for a given alignment option.</short>
        <descr>
          <p>
            <var>AnchorAlign</var> is an array constant that contains elements with <var>TAnchors</var> set values. Values in AnchorAlign are indexed by <var>TAlign</var> enumeration values. This allows the TAlign value to retrieve the set of Anchors used for the specified align option. For example:
          </p>
<code>
AControl.Align := AnchorAlign[alRight]; // contains [akRight, akTop, akBottom]
</code>
        </descr>
        <seealso/>
      </element>

      <element name="MainAlignAnchor">
        <short/>
        <descr/>
        <seealso/>
      </element>

      <element name="OppositeAnchor">
        <short/>
        <descr/>
        <seealso/>
      </element>

      <element name="ClockwiseAnchor">
        <short/>
        <descr/>
        <seealso/>
      </element>

      <element name="DefaultSideForAnchorKind">
        <short/>
        <descr/>
        <seealso/>
      </element>

      <element name="AnchorReferenceSide">
        <short/>
        <descr/>
        <seealso/>
      </element>

      <element link="FindControlAtPosition" name="FindDragTarget">
        <short>Gets the drag target at the specified screen position.</short>
        <descr>
          <p>
            Disabled controls <b>should</b> be excluded, but are not due to an bug in <var>FindControlAtPosition</var>.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="FindDragTarget.Result">
        <short>The control at Position; <b>Nil</b> if none.</short>
      </element>
      <element name="FindDragTarget.Position">
        <short>The screen position.</short>
      </element>
      <element name="FindDragTarget.AllowDisabled">
        <short>Also finds disabled controls, if True.</short>
      </element>

      <element name="FindControlAtPosition">
        <short>
          Gets the control at the specified screen position.
        </short>
        <descr>
          <p>
            <var>FindControlAtPosition</var> is a <var>TControl</var> function used to get the control at the specified screen position. When <var>AllowDisabled</var> is <b>True</b>, a disabled control can also be located in the routine. In the current implementation, AllowDisabled is ignored (assumed to be True). First a window at the given screen position is searched, then a control within it.
          </p>
        </descr>
        <seealso>
          <link id="TControl"/>
          <link id="FindLCLWindow"/>
          <link id="TWinControl.ControlAtPos"/>
          <link id="TControlAtPosFlag"/>
        </seealso>
      </element>
      <element name="FindControlAtPosition.Result">
        <short>The control found at the specified Position; <b>Nil</b> when not found.</short>
      </element>
      <element name="FindControlAtPosition.Position">
        <short>The screen position examined in the routine.</short>
      </element>
      <element name="FindControlAtPosition.AllowDisabled">
        <short>Finds disabled controls when True.</short>
      </element>

      <element name="FindLCLWindow">
        <short>
          Find the window and its owning control at the given screen coordinates.
        </short>
        <descr>
          <p>
            <var>FindLCLWindow</var> is a <var>TWinControl</var> function used to find the window (and its owner control) at the specified screen coordinates.
          </p>
          <p>
            FindLCLWindow gets the Handle for the window and checks to ensure it is enabled. When it is not enabled, or <var>AllowDisabled</var> is <b>False</b>, parent handles are examined until a suitable window is located. FindOwnerControl is called for the handle to get the return value. The return value is <b>Nil</b> if a Window was not found at the specified position.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="FindLCLWindow.Result">
        <short>
          The control that owns the window at the specified screen position; <b>Nil</b> when a window is not found.
        </short>
      </element>
      <element name="FindLCLWindow.ScreenPos">
        <short>TPoint with the screen coordinates examined in the routine.</short>
      </element>
      <element name="FindLCLWindow.AllowDisabled">
        <short>Allows a disabled window to be returned.</short>
      </element>

      <element name="FindControl">
        <short>Return the TWinControl for the given Handle.</short>
        <descr>
          <p>
            The result is very interface specific; use FindOwnerControl when Handle may be a non-TWinControl handle
          </p>
        </descr>
        <seealso>
          <link id="FindOwnerControl"/>
        </seealso>
      </element>
      <element name="FindControl.Result">
        <short/>
      </element>
      <element name="FindControl.Handle">
        <short/>
      </element>

      <element name="FindOwnerControl">
        <short>
          Returns the TWinControl for the given Handle; the parent control for a non-TWinControl Handle.
        </short>
        <descr>
          <p>
            Handle can also be a child handle (of a TControl), in which case the returned control is the parent of the desired control. Parent, not Owner as suggested by the function name!
          </p>
          <remark>
            The function recursively tries GetParent(Handle), so the result depends on the implementation (meaning) of a parent handle.
          </remark>
        </descr>
      </element>
      <element name="FindOwnerControl.Result">
        <short/>
      </element>
      <element name="FindOwnerControl.Handle">
        <short/>
      </element>

      <element name="FindLCLControl">
        <short>
          Returns the TControl that currently is visible at a screen position.
        </short>
        <descr>
          The result is not reliable during resizing.
        </descr>
        <seealso/>
      </element>
      <element name="FindLCLControl.Result">
        <short/>
      </element>
      <element name="FindLCLControl.ScreenPos">
        <short/>
      </element>

      <element name="SendAppMessage" link="#LCL.LCLProc.SendApplicationMessage"/>
      <element name="SendAppMessage.Result">
        <short/>
      </element>
      <element name="SendAppMessage.Msg">
        <short/>
      </element>
      <element name="SendAppMessage.WParam">
        <short/>
      </element>
      <element name="SendAppMessage.LParam">
        <short/>
      </element>

      <element name="MoveWindowOrg">
        <short>Moves the origin for a windowed control.</short>
        <descr>
          <p>
            <var>MoveWindowOrg</var> is a procedure used to move the origin for a windowed control to the specified position. <var>dc</var> contains the device context for the Window handle used in the routine. <var>X</var> and <var>Y</var> contain the new coordinates in pixels used as the origin (Left and Top respectively) for canvas drawing operations.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="MoveWindowOrg.dc">
        <short>Device context updated in the routine.</short>
      </element>
      <element name="MoveWindowOrg.X">
        <short>Left coordinate for the new window origin.</short>
      </element>
      <element name="MoveWindowOrg.Y">
        <short>Top coordinate for the new window origin.</short>
      </element>

      <element name="RecreateWnd">
        <short>(Re-)Creates the widget set class instance for a TWinControl.</short>
        <descr>
          <p>
            This function was originally a member of TWinControl.
          </p>
          <p>
            From a VCL point of view, that made perfectly sense since the VCL knows when a Win32 widget has to be recreated when properties have changed.
          </p>
          <p>
            The LCL, however, does not know when properties values are changed. But the widget set does. To avoid the old VCL behavior, and to provide a central function for use in the widget set, it has been moved here.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="RecreateWnd.AWinControl">
        <short/>
      </element>

      <element name="DefaultDockManagerClass">
        <short>
          The default class used to create a DockManager in <link id="TWinControl.CreateDockManager"/>.
        </short>
        <seealso>
          <link id="TDockManager"/>
        </seealso>
      </element>

      <element name="CancelDrag">
        <short>Cancels an active drag operation.</short>
        <descr>
          <p>
            <var>CancelDrag</var> is a procedure used to cancel an active drag operation. <var>CancelDrag</var> calls the <var>DragStop</var> method in the currently active <var>DragManager</var>.
          </p>
          <remark>
            No actions are performed in the routine when DragManager has been assigned (contains Nil), or when DragManager returns False from its IsDragging method.
          </remark>
        </descr>
        <seealso>
          <link id="DragManager"/>
          <link id="TDragManager.DragStop"/>
          <link id="TDragManager.IsDragging"/>
        </seealso>
      </element>

      <element name="SetCaptureControl">
        <short>
          Set the mouse capture to AWinControl or its child at the given coordinates.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="SetCaptureControl.Control">
        <short/>
      </element>
      <element name="SetCaptureControl.AWinControl">
        <short/>
      </element>
      <element name="SetCaptureControl.Position">
        <short/>
      </element>

      <element name="GetCaptureControl">
        <short>
          Returns the current capturing TControl instance.
        </short>
        <descr>
          <p>
            Please note: For the interface, only a Handle for TWinControl can capture the mouse. The LCL extends this to allow TControl to capture the mouse.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="GetCaptureControl.Result">
        <short/>
      </element>

      <element name="NewStyleControls">
        <short>Used in SynEdit.</short>
        <descr>
          <var>NewStyleControls</var> is a <var>Boolean</var> variable. Currently used only by SynEdit in <file>synedit.pp</file>.
        </descr>
        <seealso/>
      </element>

      <element name="Mouse">
        <short>The global Mouse object.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="CursorToString">
        <short>
          Returns a string for the name of the cursor as identified by an integer constant.
        </short>
        <descr>
          Calls CursorToIdent to find correct entry in look-up table.
        </descr>
        <seealso>
          <link id="CursorToIdent"/>
        </seealso>
      </element>
      <element name="CursorToString.Result">
        <short>Returns a string with the name of the cursor type corresponding to the integer constant.</short>
      </element>
      <element name="CursorToString.Cursor">
        <short/>
      </element>

      <element name="StringToCursor">
        <short>
          <var>StringToCursor</var> - returns the cursor value corresponding to the name supplied.
        </short>
        <descr>
          <p>
            <var>StringToCursor</var> - returns the cursor value corresponding to the name supplied.
          </p>
          <p>
            Finds the numeric cursor value corresponding to the name <var>S</var> in the cursor look-up table.
          </p>
        </descr>
      </element>
      <element name="StringToCursor.Result">
        <short>The numeric cursor value from the look-up table.</short>
      </element>
      <element name="StringToCursor.S">
        <short>The name of the cursor for which the numeric value is sought.</short>
      </element>

      <element name="GetCursorValues">
        <short>Calls the specified procedure for each of the cursor identifiers.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="GetCursorValues.Proc">
        <short>String procedure called in the routine. </short>
      </element>

      <element name="CursorToIdent">
        <short>
          Uses look-up table to find cursor identifier corresponding to integer cursor constant.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="CursorToIdent.Result">
        <short>Returns true if a valid entry is found in the look-up table.</short>
      </element>
      <element name="CursorToIdent.Cursor">
        <short/>
      </element>
      <element name="CursorToIdent.Ident">
        <short/>
      </element>

      <element name="IdentToCursor">
        <short>
          Searches the Cursor name table for the given cursor name; returns True if found.
        </short>
        <descr>
          If found, the cursor value (handle) is returned in <var>Cursor</var>.
        </descr>
      </element>
      <element name="IdentToCursor.Result">
        <short>Returns True if a valid entry was found in the look-up table.</short>
      </element>
      <element name="IdentToCursor.Ident">
        <short>The name of the cursor for which the numeric value is sought.</short>
      </element>
      <element name="IdentToCursor.Cursor">
        <short>The numeric value of the named cursor.</short>
      </element>

      <element name="CheckTransparentWindow">
        <short>
          Checks whether the handle for a windowed control (or a parent control) is transparent.
        </short>
        <descr>
          <p>
            CheckTransparentWindow is procedure used to check whether the handle for a windowed control (or a parent control) is transparent. CheckTransparentWindow uses the current mouse position to locate controls or forms under the mouse rectangle. The LM_NCHITTEST message is performed for AWinControl to determine if the handle is drawn transparently. Additional Forms in the Z-Order are visited until an opaque windowed control is located. Parent controls are searched too (when needed).
          </p>
          <p>
            CheckTransparentWindow updates the values in Handle and AWinControl to reflect the results from the search. When an overlayed control is not located, the value in Handle is set to 0, and AWinControl is set to Nil.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="CheckTransparentWindow.Handle">
        <short/>
      </element>
      <element name="CheckTransparentWindow.AWinControl">
        <short/>
      </element>

      <element name="CheckMouseButtonDownUp">
        <short>Checks for multiple mouse click events for the specified control.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="CheckMouseButtonDownUp.Result">
        <short/>
      </element>
      <element name="CheckMouseButtonDownUp.AWinHandle">
        <short/>
      </element>
      <element name="CheckMouseButtonDownUp.AWinControl">
        <short/>
      </element>
      <element name="CheckMouseButtonDownUp.LastMouse">
        <short/>
      </element>
      <element name="CheckMouseButtonDownUp.AMousePos">
        <short/>
      </element>
      <element name="CheckMouseButtonDownUp.AButton">
        <short/>
      </element>
      <element name="CheckMouseButtonDownUp.AMouseDown">
        <short/>
      </element>

      <element name="GetKeyShiftState">
        <short>Gets a set of state values for current modifier keys.</short>
        <descr>
          <p>
            <var>GetKeyShiftState</var> is a <var>TShiftState</var> function used to get a set with the current state values for modifier keys. GetKeyShiftState calls <var>GetKeyState</var> to capture the values in the set for the following virtual keyboard keys:
          </p>
          <dl>
            <dt>VK_CONTROL</dt>
            <dd>Includes ssCtrl when the Control key is pressed</dd>
            <dt>VK_SHIFT</dt>
            <dd>Includes ssShift when the Control key is pressed</dd>
            <dt>VK_MENU</dt>
            <dd>Includes ssAlt when the Alt key is pressed</dd>
            <dt>VK_LWIN or VK_RWIN</dt>
            <dd>Includes ssMeta when one of the WIN keys  (or Alt+GR on Mac) is pressed</dd>
          </dl>
          <p>
            The return value is an empty set (<b>[]</b>) when none of the virtual keys have a non-zero value.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="GetKeyShiftState.Result">
        <short/>
      </element>

      <element name="AdjustBorderSpace">
        <short>Adjusts the space around the border for the control.</short>
        <descr>
          <p>RemainingClientRect: remaining clientrect without CurBorderSpace</p>
          <p>CurBorderSpace: current borderspace around RemainingClientRect</p>
          <p>Left, Top, Right, Bottom: apply these borderspaces to CurBorderSpace</p>
          <p>CurBorderSpace will be set to the maximum of CurBorderSpace and Left, Top, Right, Bottom.</p>
          <p>RemainingClientRect will shrink.</p>
          <p>RemainingClientRect will not shrink to negative size.</p>
        </descr>
        <seealso/>
      </element>
      <element name="AdjustBorderSpace.RemainingClientRect">
        <short/>
      </element>
      <element name="AdjustBorderSpace.CurBorderSpace">
        <short/>
      </element>
      <element name="AdjustBorderSpace.Left">
        <short/>
      </element>
      <element name="AdjustBorderSpace.Top">
        <short/>
      </element>
      <element name="AdjustBorderSpace.Right">
        <short/>
      </element>
      <element name="AdjustBorderSpace.Bottom">
        <short/>
      </element>
      <element name="AdjustBorderSpace.Space">
        <short/>
      </element>

      <element name="IsColorDefault">
        <short>Determines if the color for the control is the system default (GTK).</short>
        <descr>
          <p>
            Used by GTK-based widget set classes to determine if the color in a control needs to be compares to the SYS_COLOR_BASE value used in the widget set.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="IsColorDefault.Result">
        <short/>
      </element>
      <element name="IsColorDefault.AControl">
        <short/>
      </element>

      <element name="BidiFlipAlignment">
        <short>Gets the inverse alignment value when BiDiMode is enabled.</short>
        <descr>
          <p>
            Applies to TAlignment value taLeftJustify and taRightJustify. taCenter is always taCenter regardless of BidiMode.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="BidiFlipAlignment.Result">
        <short/>
      </element>
      <element name="BidiFlipAlignment.Alignment">
        <short>TAlignment value converted in the method.</short>
      </element>
      <element name="BidiFlipAlignment.Flip">
        <short>True to flip the alignment value when BiDiMode is enabled.</short>
      </element>

      <element name="BidiFlipAnchors">
        <short>
          Swaps left and right anchor side settings for the specified control when BiDiMode is enabled.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="BidiFlipAnchors.Result">
        <short/>
      </element>
      <element name="BidiFlipAnchors.Control">
        <short/>
      </element>
      <element name="BidiFlipAnchors.Flip">
        <short/>
      </element>

      <element name="BidiFlipRect">
        <short>
          Flips the left and right coordinates relative to the ParentRect when Flip is True.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="BidiFlipRect.Result">
        <short/>
      </element>
      <element name="BidiFlipRect.Rect">
        <short/>
      </element>
      <element name="BidiFlipRect.ParentRect">
        <short/>
      </element>
      <element name="BidiFlipRect.Flip">
        <short/>
      </element>

      <element name="ChangeBiDiModeAlignment">
        <short>Flips the value Alignment to reflect the value needed for BiDi mode.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="ChangeBiDiModeAlignment.Alignment">
        <short>TAligment value updated in the method.</short>
      </element>

      <element name="DbgS">
        <short>Converts items of several data types into strings, for debug output.</short>
        <descr/>
        <errors>[The parameters should have unique names, for every type]</errors>
        <seealso/>
      </element>
      <element name="DbgS.Result">
        <short>The string representing the given parameter(s).</short>
      </element>
      <element name="DbgS.a">
        <short>TAlign value converted in the routine.</short>
      </element>
      <element name="DbgS.Anchors">
        <short>Set of TAnchorKind values converted in the routine.</short>
      </element>
      <element name="DbgS.Side">
        <short>Anchor side enumeration value converted in the routine.</short>
      </element>
      <element name="DbgS.p">
        <short>Auto-size phase converted in the routine.</short>
      </element>
      <element name="DbgS.Phases">
        <short>All elements in this set will be shown as a comma-separated list.</short>
      </element>
      <element name="DbgS.cst">
        <short>Control style flag converted in the routine.</short>
      </element>
      <element name="DbgS.cs">
        <short>Set of control style flags converted in the routine.</short>
      </element>
      <element name="DbgS.fs">
        <short>Form style value converted in the routine.</short>
      </element>

      <element name="assign(variant):TCaption">
        <short>
          Declares an assignment operator used to convert a Variant type to a TCaption type.
        </short>
        <descr>
          <p>
            Declares an assignment operator used to convert a TVariant value to a TCaption value during assignment. Casts the value in AVariant to a String type and assigns it as the return value for the operator. For example:
          </p>
<code>
var
  AVariant: Variant;
  AControl: TControl;
  // ...
  AControl.Caption := AVariant;
</code>
        </descr>
        <seealso/>
      </element>
      <element name="Assign.Result">
        <short>TCaption value for the assignment operator.</short>
      </element>
      <element name="Assign.Variant">
        <short>Variant value converted to a TCaption value prior to assignment.</short>
      </element>

      <element name="CompareLazAccessibleObjectsByDataObject">
        <short>
          Compares the specified pointers containing a Lazarus accessibility object and a accessibility object data.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="CompareLazAccessibleObjectsByDataObject.Result">
        <short/>
      </element>
      <element name="CompareLazAccessibleObjectsByDataObject.o1">
        <short/>
      </element>
      <element name="CompareLazAccessibleObjectsByDataObject.o2">
        <short/>
      </element>

      <element name="CompareDataObjectWithLazAccessibleObject">
        <short>
          Compares the specified pointers containing Lazarus accessibility object data and a accessibility object.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="CompareDataObjectWithLazAccessibleObject.Result">
        <short/>
      </element>
      <element name="CompareDataObjectWithLazAccessibleObject.o">
        <short/>
      </element>
      <element name="CompareDataObjectWithLazAccessibleObject.ao">
        <short/>
      </element>

      <element name="Register">
        <short>
          Register the components provided by this unit or package, so that they can be instantiated.
        </short>
        <descr>
          <p>
            <var>Register</var> is a procedure used to register components in this unit in the Lazarus IDE. Register adds the <var>TImageList</var> component on the <b>Common Controls</b> tab. In addition, the <var>TCustomControl</var> and <var>TGraphicControl</var> components are registered without icons.
          </p>
          <p>
            Register can also be used to register the controls required by an application.
          </p>
        </descr>
        <seealso>
          <link id="#rtl.classes.registercomponents">RegisterComponents</link>
        </seealso>
      </element>

      <topic name="AutoSize">
        <short>
          <var>AutoSize</var> - boolean property that permits the size of a control to be adjusted automatically.
        </short>
        <descr>
          <p>
            <var>AutoSize</var> is a boolean property found in many classes; it permits the size of a control to be adjusted automatically to accommodate differences in the text or graphic contained therein, and allows most efficient use of available space
          </p>
          <p>
            Many controls call  <link id="#lcl.controls.TControl.DoAutoSize">TControl.DoAutoSize</link> to perform the actual auto-sizing.
          </p>
          <p>
            IMPORTANT: Many Delphi controls override this method and many call this method directly after setting some properties.
          </p>
          <p>
            During handle creation not all interfaces can create complete Device Contexts which are needed to calculate things like text size.
          </p>
          <p>
            That's why you should always call <link id="#lcl.controls.TControl.AdjustSize">AdjustSize</link> instead of <var>DoAutoSize</var>.
          </p>
          <p>
            <var>TControl.AdjustSize</var> calls <var>DoAutoSize</var> in a smart fashion.
          </p>
          <p>
            During loading and handle creation the calls are delayed.
          </p>
          <p>
            This method is essentially the same as <link id="#lcl.controls.TWinControl.DoAutoSize">TWinControl.DoAutoSize</link>.  But since <var>DoAutoSize</var> is commonly overridden in descendent components,  it is not useful to perform all tests, which can result in too much overhead. To reduce the overhead, the LCL  calls <var>AdjustSize</var> instead.
          </p>
          <p>
            When setting <var>AutoSize</var> to <b>True</b>, the LCL auto-sizes the width and height for the control. This is one of the most complex parts of the LCL, because the result depends on nearly a hundred properties. Let's start with a simple scenario:
          </p>
          <p>
            The LCL will only auto-size the Width or Height if it is free to resize. In other words, the width is not auto-sized if:
          </p>
          <ul>
            <li>
              The left and right side is anchored. You can anchor the sides with the <var>Anchors</var> property or by setting the <var>Align</var> property to <var>alTop</var>, <var>alBottom</var> or <var>alClient</var>
            </li>
            <li>
              The Width and Height are bound by the <var>Constraints</var> properties. The Constraints can also be overridden by the widgetset. For example the WinAPI does not allow resizing the height of a combobox. And the gtk widgetset does not allow resizing the width of a vertical scrollbar
            </li>
          </ul>
          <p>
            The new size is calculated by the protected method <link id="#lcl.controls.TControl.CalculatePreferredSize">TControl.CalculatePreferredSize</link>. This method asks the widgetset for an appropriate Width and Height. For example a <var>TButton</var> has preferred Width and Height. A <var>TComboBox</var> has only a preferred Height. The preferred Width is returned as 0 and so the LCL does not auto-size the Width - it keeps the width unaltered. Finally a <var>TMemo</var> has no preferred Width or Height. Therefore AutoSize has no effect on a TMemo.
          </p>
          <p>
            Some controls override this method. For example the <var>TGraphicControl</var> descendants like <var>TLabel</var> have no window handle and so cannot query the widgetset. They must calculate their preferred Width and Height themselves.
          </p>
          <p>
            The widget sets must override the <var>GetPreferredSize</var> method for each widget class that has a preferred size (Width or Height or both).
          </p>
          <p><b>Parent.AutoSize</b></p>
          <p>
            The above described the simple explanation. The real algorithm provides far more possibilities and is therefore far more complex.
          </p>
          <p><b>Properties / Methods</b></p>
          <p><b>Left and Top</b></p>
          <p>
            If <var>Parent</var> is not <b>Nil</b> then <var>Left, Top</var> are the pixel distance to the top, left pixel of the parent's client area (not scrolled). Remember the client area is always without the frame and scrollbars of the parent. For Delphi users, some VCL controls like TGroupbox define the client area as the whole control including the frame.  Others do not. The LCL is more consistent, and therefore Delphi incompatible. Left and Top can be negative or bigger than the client area. Some widget sets define a minimum, and maximum somewhere around 10,000 pixels or more.
          </p>
          <p>
            When the client area is scrolled the Left and Top are kept unchanged.
          </p>
          <p>
            During resizing, or when moving, the Left and Top coordinates are not always in sync with the coordinates for the Handle object.
          </p>
          <p>
            When Parent is unassigned (contains Nil),  Left and Top depend on the widgetset and the window manager. Until Lazarus 0.9.25,  this is typically the screen coordinate of the left, top of the client area for the form. This is Delphi incompatible. It is planned to change this to the Left, Top of the window.
          </p>
          <p><b>Hint:</b></p>
          <p>
            Each time you change Left and Top, the LCL starts the movement  instantly. If you want to change both Left and Top, use the following instead:
          </p>
<code>
with Button1 do
    SetBounds(NewLeft,NewTop,Width,Height);
</code>
          <p><b>Width and Height</b></p>
          <p>
            The Size in pixels must not be negative; most widgetsets do not allow Width and/or Height to be Zero (0). Some controls (on some platforms )define a larger minimum constraint. Instead of sizing a control to Width=0 and/or Height=0, set Visible to <b>False</b>. During resizing and moving, Width and Height are not always in sync with the size of the Handle object.
          </p>
          <p><b>BoundsRect</b></p>
          <p>Same as Bounds(Left,Top,Width,Height).</p>
          <p>Common newbie mistake:</p>
<code>
BoundsRect.Left:=3; // WRONG: common newbie mistake
</code>
          <p>
            This has no effect, because reading BoundsRect is a function. It creates a temporary TRect on the stack.
          </p>
          <p><b>ClientRect</b></p>
          <p>
            Left and Top are always 0,0. Width and Height are the visible size in pixels of the client area. Remember the client area is without the frame and without scrollbars. In a scrollable client area the logical client area can be bigger than the visible.
          </p>
          <p><b>ClientOrigin</b></p>
          <p>
            Returns the screen coordinate of the top left coordinate 0,0 of the client area. Note that this value is the position as stored in the interface and is not always in sync with the LCL. When a control is moved, the LCL sets the bounds to the desired position and sends a move message to the interface. It is up to the interface to handle moves instantly or queued.
          </p>
          <p><b>LCLIntf.GetClientBounds</b></p>
          <p>
            Returns the client bounds of a control. Like ClientRect, but Left and Top are the pixel distances to the control's left, top. For example on a TGroupBox the Left, Top are the width and height of the left and top frame border. Scrolling has no effect on GetClientBounds.
          </p>
          <p><b>LCLIntf.GetWindowRect</b></p>
          <p>
            After the call, ARect will be the control area in screen coordinates. That means, Left and Top will be the screen coordinate of the TopLeft pixel of the Handle object and Right and Bottom will be the screen coordinate of the BottomRight pixel.
          </p>
          <p><b>FBaseBoundsLock: integer</b></p>
          <p>
            Increased/Decreased by LockBaseBounds/UnlockBaseBounds. Used to keep FBaseBounds during SetBounds calls.
          </p>
          <p><b>FBaseParentClientSize: TPoint</b></p>
          <p>
            The Parent.ClientRect size valid for the FBaseBounds. FBaseBounds and FBaseParentClientSize are used to calculate the distance for akRight (akBottom). When the parent is resized, the LCL knows what distance to keep.
          </p>
          <p><b>FBoundsRectForNewParent: TRect</b></p>
          <p>
            When changing the Parent of a control the Handle is recreated and many things can happen. Especially for docking forms the process is too unreliable. Therefore the BoundsRect is saved. The VCL uses a similar mechanism.
          </p>
          <p><b>FLastDoChangeBounds: TRect</b></p>
          <p>
            Used to avoid calling OnChangeBounds with the same coordinates. This reduces user defined auto-sizing.
          </p>
          <p>
            <b>FLastResizeClientHeight: integer</b> <br/>
            <b>FLastResizeClientWidth: integer</b> <br/>
            <b>FLastResizeHeight: integer</b> <br/>
            <b>FLastResizeWidth: integer</b>
          </p>
          <p>
            Used to avoid calling OnResize with the same coordinates. This reduces user
            defined auto-sizing.
          </p>
          <p><b>FLoadedClientSize: TPoint</b></p>
          <p>
            During loading many things are delayed and many things are set and worse: in the wrong order. That's why SetClientWidth/SetClientHeight calls are stored and set at end of loading again. This way the LCL can restore the distances (e.g. akRight) used during designing.
          </p>
          <p><b>FReadBounds: TRect</b></p>
          <p>
            Same as FLoadedClientSize, but for SetLeft, SetTop, SetWidth, SetHeight.
          </p>
          <p><b>SetBoundsRectForNewParent(const AValue: TRect);</b></p>
          <p>Used to set FBoundsRectForNewParent. See above.</p>
          <p>
            <b>procedure SetInitialBounds(aLeft, aTop, aWidth, aHeight: integer); virtual;</b>
          </p>
          <p>A smart version of SetBounds, reducing overhead during creation and loading.</p>
          <p>
            <b>
              procedure UpdateBaseBounds(StoreBounds, StoreParentClientSize, UseLoadedValues: boolean); virtual;
            </b>
          </p>
          <p>Commit current bounds to base bounds.</p>
          <p>
            <b>procedure SetClientHeight(Value: Integer);</b> <br/>
            <b>procedure SetClientSize(Value: TPoint);</b> <br/>
            <b>procedure SetClientWidth(Value: Integer); </b>
          </p>
          <p>
            Exists for Delphi compatibility too. Resizes the control, to get the wanted ClientRect size.
          </p>
          <p>
            <b>procedure ChangeBounds(ALeft, ATop, AWidth, AHeight: integer); virtual;</b>
          </p>
          <p>
            This is the internal SetBounds. Applies constraints, updates base bounds, calls OnChangeBound, OnResize, locks bounds.
          </p>
          <p>
            <b>procedure DoSetBounds(ALeft, ATop, AWidth, AHeight: integer); virtual;</b>
          </p>
          <p>This really sets the FLeft, FTop, FWidth, FHeight private variables.</p>
          <p>
            <b>procedure SetBounds(aLeft, aTop, aWidth, aHeight: integer); virtual;</b>
          </p>
          <p>
            This is the standard procedure overridden by many Delphi controls. TWinControl overrides it too. Ignores calls when bounds are locked; lock the FBoundsRealized to avoid overhead to the interface during auto sizing. ChangeBounds is not locked this way.
          </p>
          <p>
            <b>Function GetClientOrigin: TPoint; virtual;</b>
          </p>
          <p>Screen coordinate of Left, Top of client area.</p>
          <p>
            <b>Function GetClientRect: TRect; virtual;</b>
          </p>
          <p>Size of client area. (always Left=0, Top=0)</p>
          <p>
            <b>Function GetScrolledClientRect: TRect; virtual;</b>
          </p>
          <p>Visible client area in ClientRect.</p>
          <p>
            <b>function GetChildsRect(Scrolled: boolean): TRect; virtual;</b>
          </p>
          <p>
            Returns the Client rectangle relative to the control's Left, Top. If Scrolled is true, the rectangle is moved by the current scrolling values (for an example see TScrollingWincontrol).
          </p>
          <p>
            <b>function GetClientScrollOffset: TPoint; virtual;</b>
          </p>
          <p>Returns the scrolling offset of the client area.</p>
          <p>
            <b>function GetControlOrigin: TPoint; virtual;</b>
          </p>
          <p>
            Returns the screen coordinate of the topleft coordinate 0,0 of the control area. (The topleft pixel of the control on the screen) Note that this value is the position as stored in the interface and is not always in sync with the LCL. When a control is moved, the LCL sets the bounds to the wanted position and sends a move message to the interface. It is up to the interface to handle moves instantly or queued.
          </p>
        </descr>
      </topic>

      <topic name="ControlCoordinates">
        <short>
          The coordinates of a control can be specified or retrieved in various ways
        </short>
        <descr>
          <p>
            The following description applies to members of TControl and TWinControl.
          </p>
          <p>
            Every control has an origin (Top, Left) and extent (Width, Height). The origin is relative to its Parent control (client coordinates) or, for floating controls (forms) with Parent=Nil, relative to the screen.
          </p>
          <p>
            The BoundsRect describes the TopLeft and BottomRight coordinates of the control, relative to its Parent.
          </p>
          <p>
            The BoundsRectForNewParent holds the new coordinates, to be used when the Parent of the control is changed later.
          </p>
          <p>
            The ClientRect describes the internal (client) area of a container control (TWinControl), excluding borders. Its Top and Left are always zero. In a TScrollingWinControl...
          </p>
          <p>
            BaseBounds holds the designed Bounds, to be used e.g. when a scale factor is set later.
          </p>
          <p>
            GetControlOrigin returns the origin in screen coordinates. These values are not always in sync with the true screen position, managed by the widgetset.
          </p>
          <p>
            ScreenToClient returns the client coordinates of an point given in the screen coordinates, i.e. the coordinates relative to the control's client origin.
          </p>
          <p>
            ClientToScreen returns the screen coordinates for an point in client coordinates.
          </p>
        </descr>
      </topic>

      <topic name="AnchoringControls">
        <short>How multiple controls can be aligned and resized together, at run-time.</short>
        <descr>
          <p>
            The tree-style layout of a form allows one to specify table-style areas, with a common width or height of all controls in the same area (using container controls like e.g. TPanel).
          </p>
          <p>
            Delphi introduced control anchoring to the sides of the Parent control. This means when a control in a form has Anchors[akRight]=True, its right side keeps its distance from the right side of its Parent, when its Parent is resized.
          </p>
          <p>
            The default anchors [akLeft,akTop] keep every control anchored to the origin (TopLeft) of their Parent control (of form). This will cause controls to disappear when the form is shrunken, or the user has to scroll through the form's client area.
          </p>
          <p>
            When a control shall e.g. use the available space, left over to its right, Anchors=[akLeft,akRight] will result in a variable-width control.
          </p>
          <p>
            The Align property allows one to stack controls at their Parent's sides, e.g. all controls with Align=alTop are stacked at the top of their Parent. The remaining space in the Parent can be occupied by a single control, of Align=alClient.
          </p>
          <p>
            Both Anchors and Align are tightly coupled, changing one property will affect the other one. This is harmless in so far, as the IDE (form designer) keeps all adjustments in sync, free of conflicts.
          </p>
          <p>
            Some people found this approved layout method too restrictive, and too complicated to use, and now LCL controls <b>also</b> can be anchored <b>freely</b> to each other. This layout management is traditionally referred to as "Anchor Docking", even if it is not related to docking at all.
          </p>
          <remark>
            This freedom requires that the GUI designer is responsible for consistent anchor specifications, which do not result in unresolvable cyclic references or other contradictions.
          </remark>
          <p>
            Anchor docking allows one to anchor every side of a control to an arbitrary side of another control, i.e. the left side of an Edit control can be anchored to the right side of its associated Label.
          </p>
          <p>
            <b>Example1</b>
          </p>
          <p>
            If you want to have the top of B the same as the top of C:
          </p>
<pre>
+-----+  +-----+
|  B  |  |  C  |
|     |  +-----+
+-----+
</pre>
          <p>
            use:
          </p>
<code>
B.AnchorSide[akTop].Control:=C;
B.AnchorSide[akTop].Side:=asrTop;
</code>
          <p>
            When you want to have a gap between both controls, set e.g. B.Borderspacing.Right to the desired amount. Setting C.Borderspacing.Left will have the same effect, and both can be used together; the resulting gap then reflects the maximum value of both properties.
          </p>
          <p>
            BorderSpacing is in effect even for controls without special anchoring, when AutoSize is used.
          </p>
          <p>
            Anchor docking also allows one to center a control relative to another control.
          </p>
          <p>
            <b>Example2</b>
          </p>
          <p>
            For centering A relative to B:
          </p>
<pre>
+-------+
|       | +---+
|   B   | | A |
|       | +---+
+-------+
</pre>

          <p>
            use:
          </p>
<code>
A.AnchorSide[akTop].Side:=asrCenter;
A.AnchorSide[akTop].Control:=B;
</code>
          <p>
            Or use this, it's equivalent:
          </p>
<code>
A.AnchorSide[akBottom].Side:=asrCenter;
A.AnchorSide[akBottom].Control:=B;
</code>
          <p>
            TControlChildSizing and TControlChildrenLayout offers additional means for aligning and separating controls.
          </p>
        </descr>
      </topic>

    </module>
    <!-- Controls -->
  </package>
</fpdoc-descriptions>
