<?xml version="1.0" encoding="UTF-8"?>
<fpdoc-descriptions>
  <package name="lcl">
    <!--
      ====================================================================
        Controls
      ====================================================================
     -->
    <module name="controls">
      <short>
        Contains types, constants, classes, and routines used to implement visual controls.
      </short>
      <descr>
        <p>
          <file>controls.pp</file> contains classes, types, constants, and routines used to implement visual controls used in the Lazarus Component Library (<b>LCL</b>). Most of the classes are base classes, or used in the implementation of controls defined in others units.
        </p>
        <p>
          The following components are added to the <b>Common Controls</b> tab in the Lazarus IDE component palette:
        </p>
        <ul>
          <li>TImageList</li>
        </ul>
        <p>
          The following components are registered but not displayed on the  Lazarus IDE component palette:
        </p>
        <ul>
          <li>TCustomControl</li>
          <li>TGraphicControl</li>
        </ul>
        <p>
          This file is part of the Lazarus Component Library (LCL).
        </p>
      </descr>

      <!-- unresolved external references; interface uses clause -->
      <element name="Classes"/>
      <element name="SysUtils"/>
      <element name="TypInfo"/>
      <element name="Types"/>
      <element name="Laz_AVL_Tree"/>
      <element name="LCLStrConsts"/>
      <element name="LCLType"/>
      <element name="LCLProc"/>
      <element name="Graphics"/>
      <element name="LMessages"/>
      <element name="LCLIntf"/>
      <element name="InterfaceBase"/>
      <element name="ImgList"/>
      <element name="PropertyStorage"/>
      <element name="Menus"/>
      <element name="ActnList"/>
      <element name="LCLClasses"/>
      <element name="LResources"/>
      <element name="LCLPlatformDef"/>
      <element name="GraphType"/>
      <element name="UITypes"/>
      <element name="LazMethodList"/>
      <element name="LazLoggerBase"/>
      <element name="LazTracer"/>
      <element name="LazUtilities"/>

      <!-- included from controlconsts.inc -->
      <element name="CM_BASE">
        <short>Starting value for control message constants defined in the LCL.</short>
      </element>
      <element name="CM_LCLOFFSET">
        <short>Control message constant.</short>
      </element>
      <element name="CM_ACTIVATE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_DEACTIVATE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_GOTFOCUS">
        <short>Control message constant.</short>
      </element>
      <element name="CM_LOSTFOCUS">
        <short>Control message constant.</short>
      </element>
      <element name="CM_CANCELMODE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_DIALOGKEY">
        <short>Control message constant.</short>
      </element>
      <element name="CM_DIALOGCHAR">
        <short>Control message constant.</short>
      </element>
      <element name="CM_FOCUSCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_PARENTFONTCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_PARENTCOLORCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_HITTEST">
        <short>Control message constant.</short>
      </element>
      <element name="CM_VISIBLECHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_ENABLEDCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_COLORCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_FONTCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_CURSORCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_CTL3DCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_PARENTCTL3DCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_TEXTCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_MOUSEENTER">
        <short>Control message constant.</short>
      </element>
      <element name="CM_MOUSELEAVE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_MENUCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_APPKEYDOWN">
        <short>Control message constant.</short>
      </element>
      <element name="CM_APPSYSCOMMAND">
        <short>Control message constant.</short>
      </element>
      <element name="CM_BUTTONPRESSED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_SHOWINGCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_ENTER">
        <short>Control message constant.</short>
      </element>
      <element name="CM_EXIT">
        <short>Control message constant.</short>
      </element>
      <element name="CM_DESIGNHITTEST">
        <short>Control message constant.</short>
      </element>
      <element name="CM_ICONCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_WANTSPECIALKEY">
        <short>Control message constant.</short>
      </element>
      <element name="CM_INVOKEHELP">
        <short>Control message constant.</short>
      </element>
      <element name="CM_WINDOWHOOK">
        <short>Control message constant.</short>
      </element>
      <element name="CM_RELEASE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_SHOWHINTCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_PARENTSHOWHINTCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_SYSCOLORCHANGE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_WININICHANGE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_FONTCHANGE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_TIMECHANGE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_TABSTOPCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_UIACTIVATE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_UIDEACTIVATE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_DOCWINDOWACTIVATE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_CONTROLLISTCHANGE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_GETDATALINK">
        <short>Control message constant.</short>
      </element>
      <element name="CM_CHILDKEY">
        <short>Control message constant.</short>
      </element>
      <element name="CM_DRAG">
        <short>Control message constant.</short>
      </element>
      <element name="CM_HINTSHOW">
        <short>Control message constant.</short>
      </element>
      <element name="CM_DIALOGHANDLE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_ISTOOLCONTROL">
        <short>Control message constant.</short>
      </element>
      <element name="CM_RECREATEWND">
        <short>Control message constant.</short>
      </element>
      <element name="CM_INVALIDATE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_SYSFONTCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_CONTROLCHANGE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_CHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_DOCKCLIENT">
        <short>Control message constant.</short>
      </element>
      <element name="CM_UNDOCKCLIENT">
        <short>Control message constant.</short>
      </element>
      <element name="CM_FLOAT">
        <short>Control message constant.</short>
      </element>
      <element name="CM_BORDERCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_BIDIMODECHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_PARENTBIDIMODECHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_ALLCHILDRENFLIPPED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_ACTIONUPDATE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_ACTIONEXECUTE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_HINTSHOWPAUSE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_DOCKNOTIFICATION">
        <short>Control message constant.</short>
      </element>
      <element name="CM_MOUSEWHEEL">
        <short>Control message constant.</short>
      </element>
      <element name="CM_ISSHORTCUT">
        <short>Control message constant.</short>
      </element>
      <element name="CM_UPDATEACTIONS">
        <short>Control message constant.</short>
      </element>
      <element name="CM_INVALIDATEDOCKHOST">
        <short>Control message constant.</short>
      </element>
      <element name="CM_SETACTIVECONTROL">
        <short>Control message constant.</short>
      </element>
      <element name="CM_POPUPHWNDDESTROY">
        <short>Control message constant.</short>
      </element>
      <element name="CM_CREATEPOPUP">
        <short>Control message constant.</short>
      </element>
      <element name="CM_DESTROYHANDLE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_MOUSEACTIVATE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_CONTROLLISTCHANGING">
        <short>Control message constant.</short>
      </element>
      <element name="CM_BUFFEREDPRINTCLIENT">
        <short>Control message constant.</short>
      </element>
      <element name="CM_UNTHEMECONTROL">
        <short>Control message constant.</short>
      </element>
      <element name="CM_DOUBLEBUFFEREDCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_PARENTDOUBLEBUFFEREDCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_THEMECHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_GESTURE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_CUSTOMGESTURESCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_GESTUREMANAGERCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_STANDARDGESTURESCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_INPUTLANGCHANGE">
        <short>Control message constant.</short>
      </element>
      <element name="CM_TABLETOPTIONSCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_PARENTTABLETOPTIONSCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_APPSHOWBTNGLYPHCHANGED">
        <short>Control message constant.</short>
      </element>
      <element name="CM_APPSHOWMENUGLYPHCHANGED">
        <short>Control message constant.</short>
      </element>

      <!-- included from controlconsts.inc -->
      <element name="CN_BASE">
        <short>Starting value for control notification messages in the LCL.</short>
      </element>
      <element name="CN_CHARTOITEM">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_COMMAND">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_COMPAREITEM">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_CTLCOLORBTN">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_CTLCOLORDLG">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_CTLCOLOREDIT">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_CTLCOLORLISTBOX">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_CTLCOLORMSGBOX">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_CTLCOLORSCROLLBAR">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_CTLCOLORSTATIC">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_DELETEITEM">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_DRAWITEM">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_HSCROLL">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_MEASUREITEM">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_PARENTNOTIFY">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_VKEYTOITEM">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_VSCROLL">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_KEYDOWN">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_KEYUP">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_CHAR">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_SYSKEYUP">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_SYSKEYDOWN">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_SYSCHAR">
        <short>Control notification message constant.</short>
      </element>
      <element name="CN_NOTIFY">
        <short>Control notification message constant.</short>
      </element>

      <element name="mrNone">
        <short>Modal dialog left with None button.</short>
      </element>
      <element name="mrOK">
        <short>Modal dialog left with OK button.</short>
      </element>
      <element name="mrCancel">
        <short>Modal dialog left with Cancel button.</short>
      </element>
      <element name="mrAbort">
        <short>Modal dialog aborted.</short>
      </element>
      <element name="mrRetry">
        <short>Modal dialog left with Retry button.</short>
      </element>
      <element name="mrIgnore">
        <short>Modal dialog left with Ignore button.</short>
      </element>
      <element name="mrYes">
        <short>Modal dialog left with Yes button.</short>
      </element>
      <element name="mrNo">
        <short>Modal dialog left with No button.</short>
      </element>
      <element name="mrAll">
        <short>Modal dialog left with All button.</short>
      </element>
      <element name="mrNoToAll">
        <short>Modal dialog left with NoToAll button.</short>
      </element>
      <element name="mrYesToAll">
        <short>Modal dialog left with YesToAll button.</short>
      </element>
      <element name="mrClose">
        <short>Modal dialog left with Close button.</short>
      </element>
      <element name="mrLast">
        <short>Last (highest) value of modal results.</short>
      </element>

      <element name="GetModalResultStr">
        <short>
          Deprecated; Use the ModalResultStr array from the <file>UITypes</file> unit.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="GetModalResultStr.Result">
        <short/>
      </element>
      <element name="GetModalResultStr.ModalResult">
        <short/>
      </element>

      <element name="ModalResultStr">
        <short>
          Gets the string representation for a modal result value.
        </short>
        <descr>
          <p>
            <var>ModalResultStr</var> is an indexed <var>ShortString</var> property used to get the string representation for the specified TModalResult constant. The read access specifier for the property has been deprecated; Use the ModalResultStr array from the <file>UITypes</file> unit  directly.
          </p>
        </descr>
        <seealso>
          <link id="#lcl.uitypes.ModalResultStr">ModalResultStr</link>
          <link id="#lcl.uitypes.TModalResult">TModalResult</link>
        </seealso>
      </element>

      <element name="fsSurface">
        <short>
          Alias to the fsSurface constant in the <file>GraphType</file> unit.
        </short>
      </element>

      <element name="fsBorder">
        <short>
          Alias to the fsBorder constant in the <file>GraphType</file> unit.
        </short>
      </element>

      <element name="bvNone">
        <short>
          Alias to the bvNone constant in the <file>GraphType</file> unit.
        </short>
      </element>

      <element name="bvLowered">
        <short>
          Alias to the bvLowered constant in the <file>GraphType</file> unit.
        </short>
      </element>

      <element name="bvRaised">
        <short>
          Alias to the bvRaised constant in the <file>GraphType</file> unit.
        </short>
      </element>

      <element name="bvSpace">
        <short>
          Alias to the bvSpace constant in the <file>GraphType</file> unit.
        </short>
      </element>

      <element name="ssModifier">
        <short>Defines the key used for shortcuts on different platforms.</short>
        <descr>
          <p>
            <var>ssModifier</var> is a constant which defines the modifier for keyboard shortcuts,  like Ctrl+C (Copy), Ctrl+Z (UnDo), Ctrl+X (Cut), and Ctrl+V (paste). Mac and iOS use the Meta key (instead of the Ctrl key) for those shortcuts.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="GUID_ObjInspInterface">
        <short>GUID for the Object Inspector in the Lazarus IDE.</short>
        <descr>
          Value is '{37417989-8C8F-4A2D-9D26-0FA377E8D8CC}'
        </descr>
        <seealso/>
      </element>

      <element name="IObjInspInterface">
        <short>Defines an interface used in the Lazarus Object Inspector.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="IObjInspInterface.AllowAdd">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="IObjInspInterface.AllowAdd.Result">
        <short/>
      </element>

      <element name="IObjInspInterface.AllowDelete">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="IObjInspInterface.AllowDelete.Result">
         <short/>
      </element>

      <element name="TWinControlClass">
        <short>
          <var>TWinControlClass</var> - class of <var>TWinControl</var>.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlClass">
        <short>
          <var>TControlClass</var> - class of <var>TControl</var>.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TCMMouseWheel">
        <short>Defines a structure used for mouse wheel control messages.</short>
        <descr>
          <p>Holds mouse wheel details that include:</p>
          <ul>
            <li>the Message associated with the wheel</li>
            <li>the shift state (i.e. whether Shift, Alt, Control keys have been pressed)</li>
            <li>the mouse position</li>
            <li>the message Result</li>
          </ul>
        </descr>
        <seealso/>
      </element>

      <element name="TCMMouseWheel.Msg">
        <short>Cardinal value with the CM_MOUSEWHEEL identifier for the mouse wheel message.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCMMouseWheel.ShiftState">
        <short>State of the modifier for keys and mouse buttons.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCMMouseWheel.Unused">
        <short>Inserted for alignment only.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCMMouseWheel.WheelData">
        <short>
          Number of notches or units the mouse wheel was moved. Negative for mouse wheel up movements.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCMMouseWheel.Pos">
        <short>Mouse position as a TSmallPoint value.</short>
      </element>
      <element name="TCMMouseWheel.XPos">
        <short>Mouse X position as a SmallInt value.</short>
      </element>
      <element name="TCMMouseWheel.YPos">
        <short>Mouse Y position as a SmallInt value.</short>
      </element>
      <element name="TCMMouseWheel.Result">
        <short>
          Result for the mouse wheel message. Zero (0) indicates the message was handled.
        </short>
      </element>

      <element  name="TCMHitTest">
        <short>Alias for the TLMNCHitTest type.</short>
        <descr/>
        <seealso>
          <link id="#lcl.lmessages.TLMNCHitTest"/>
        </seealso>
      </element>

      <element  name="TCMDesignHitTest">
        <short>Alias for the TLMMouse type.</short>
        <descr/>
        <seealso>
          <link id="#lcl.lmessages.TLMMouse"/>
        </seealso>
      </element>

      <element name="TCMControlChange">
        <short>Contains values representing a Control Change Message.</short>
        <descr>
          <p>
            <var>TCMControlChange</var> is a record type which contains values representing the arguments and the result for a Control Change Message. <var>TCMControlChange</var> is the type passed to the <var>CMControlChange</var> method in <var>TCustomFlowPanel</var>.
          </p>
        </descr>
        <seealso>
          <link id="#lcl.extctrls.TCustomFlowPanel.CMControlChange">TCustomFlowPanel.CMControlChange</link>
        </seealso>
      </element>
      <element name="TCMControlChange.Msg">
        <short>Mouse message constant for the change notification.</short>
      </element>
      <element name="TCMControlChange.Control">
        <short>Control to receive the change message.</short>
      </element>
      <element name="TCMControlChange.Inserting">
        <short>Indicates if the control message is an insert operation.</short>
      </element>
      <element name="TCMControlChange.Result">
        <short>Result for the control change message.</short>
      </element>

      <element name="TCMChanged">
        <short>Not used in the current LCL implementation.</short>
      </element>
      <element name="TCMChanged.Msg">
        <short/>
      </element>
      <element name="TCMChanged.Unused">
        <short/>
      </element>
      <element name="TCMChanged.Child">
        <short/>
      </element>
      <element name="TCMChanged.Result">
        <short/>
      </element>

      <element name="TCMControlListChange">
        <short>Not used in the current LCL implementation.</short>
      </element>
      <element name="TCMControlListChange.Msg">
        <short/>
      </element>
      <element name="TCMControlListChange.Control">
        <short/>
      </element>
      <element name="TCMControlListChange.Inserting">
        <short/>
      </element>
      <element name="TCMControlListChange.Result">
        <short/>
      </element>

      <element name="TCMDialogChar">
        <short>Alias for the TLMKey type.</short>
        <seealso>
          <link id="#lcl.lmessages.TLMKey"/>
        </seealso>
        <notes><note>Used in LazReport controls.</note></notes>
      </element>

      <element name="TCMDialogKey">
        <short>Alias for the TLMKey type.</short>
        <seealso>
          <link id="#lcl.lmessages.TLMKey"/>
        </seealso>
        <notes><note>Used in the jvcllaz package.</note></notes>
      </element>

      <element name="TCMEnter">
        <short>Alias for the TLMEnter type.</short>
        <seealso>
          <link id="#lcl.lmessages.TLMEnter">TLMEnter</link>
        </seealso>
      </element>

      <element name="TCMExit">
        <short>Alias for the TLMExit type.</short>
        <seealso>
          <link id="#lcl.lmessages.TLMExit"/>
        </seealso>
      </element>

      <element name="TCMCancelMode">
        <short>Contains information representing a CM_CANCELMODE control message.</short>
        <notes><note>Used in the jvcllaz package.</note></notes>
      </element>
      <element name="TCMCancelMode.Msg">
        <short/>
      </element>
      <element name="TCMCancelMode.Unused">
        <short/>
      </element>
      <element name="TCMCancelMode.Sender">
        <short/>
      </element>
      <element name="TCMCancelMode.Result">
        <short/>
      </element>

      <element name="TCMChildKey">
        <short>Not used in the current LCL implementation.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCMChildKey.Msg">
        <short/>
      </element>
      <element name="TCMChildKey.Unused"/>
      <element name="TCMChildKey.CharCode">
        <short>VK_XXX constants for TLMKeyDown/Up, ASCII for TLMChar.</short>
      </element>
      <element name="TCMChildKey.Sender">
        <short/>
      </element>
      <element name="TCMChildKey.Result">
        <short/>
      </element>

      <element name="TAlign">
        <short>Alignment options for a control, within its Parent control.</short>
        <descr>
          <p>
            <var>TAlign</var> is an enumeration type with values that indicate the alignment for a control within its Parent. The enumeration includes the following values and meanings:
          </p>
          <dl>
            <dt>alNone</dt>
            <dd>fixed position and extent</dd>
            <dt>alTop</dt>
            <dd>stacked at top, full width</dd>
            <dt>alBottom</dt>
            <dd>stacked at bottom, full width</dd>
            <dt>alLeft</dt>
            <dd>stacked at left, full height</dd>
            <dt>alRight</dt>
            <dd>stacked at right, full height</dd>
            <dt>alClient</dt>
            <dd>filling entire remaining client area</dd>
            <dt>alCustom</dt>
            <dd>other alignment, in drag-dock: notebook</dd>
          </dl>
          <p>
            At most, one control can have alClient alignment for a given form or container.
          </p>
          <p>
            The order of multiple controls with the same (stackable) alignment is determined by their Left and/or Top coordinate. The precedence of conflicting alignment requests (e.g. one at top, one at right) is resolved.
          </p>
        </descr>
      </element>
      <element name="TAlign.alNone">
        <short>Control has fixed size and position.</short>
      </element>
      <element name="TAlign.alTop">
        <short>Control stacked at top, full width.</short>
      </element>
      <element name="TAlign.alBottom">
        <short>Control stacked at bottom, full width.</short>
      </element>
      <element name="TAlign.alLeft">
        <short>Control stacked at left, full height.</short>
      </element>
      <element name="TAlign.alRight">
        <short>Control stacked at right, full height.</short>
      </element>
      <element name="TAlign.alClient">
        <short>Control fills remaining client area.</short>
      </element>
      <element name="TAlign.alCustom">
        <short>Control has special alignment.</short>
        <descr/>
      </element>

      <element name="TAlignSet">
        <short>Set of alignment options.</short>
        <seealso>
          <link id="#lcl.controls.TAlign">TAlign</link>
        </seealso>
      </element>

      <element name="TAnchorKind">
        <short>The control side to be anchored.</short>
        <descr>
          With the TAnchorSideReference value asrCenter, the sides mean horizontal or vertical alignment of the control's center.
        </descr>
      </element>
      <element name="TAnchorKind.akTop">
        <short>Top side (or center vertically).</short>
      </element>
      <element name="TAnchorKind.akLeft">
        <short>Left side (or center horizontally).</short>
      </element>
      <element name="TAnchorKind.akRight">
        <short>Right side (or center horizontally).</short>
      </element>
      <element name="TAnchorKind.akBottom">
        <short>Bottom side (or center vertically).</short>
      </element>

      <element name="TAnchors">
        <short>Set type used to store values from the TAnchorKind enumeration.</short>
        <descr>
          <p>
            TAnchors is the the type used to implement the Anchors property in TControl and descendent classes.
          </p>
        </descr>
        <seealso>
          <link id="TAnchorKind"/>
          <link id="TControl.Anchors"/>
        </seealso>
      </element>

      <element name="TAnchorSideReference">
        <short>The side of another control, to which this control's side is anchored.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TAnchorSideReference.asrTop">
        <short>Anchor to the top side.</short>
      </element>
      <element name="TAnchorSideReference.asrBottom">
        <short>Anchor to the bottom side.</short>
      </element>
      <element name="TAnchorSideReference.asrCenter">
        <short>Anchor to the center of the other control.</short>
      </element>

      <element name="asrLeft">
        <short>Anchor to the left side (=asrTop).</short>
        <descr/>
        <seealso/>
      </element>

      <element name="asrRight">
        <short>Anchor to the right side (=asrBottom).</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TCaption">
        <short>A string type used for the caption on a control.</short>
        <descr>
          <p>
            <var>TCaption</var> is an alias for the <var>TTranslateString</var> type. It allows a string value defined using the type to be recognized in the LCL translation system. TCaption is the type used to implement properties like TControl.Caption, TControl.Text, TControl.AccessibleName, TControl.AccessibleValue, et. al.
          </p>
        </descr>
      </element>

      <element name="TCursor">
        <short>Defines the range of values used for cursor shapes.</short>
        <descr>
          <p>
            <var>TCursor</var> is an Integer type which defines the range of values used for cursor shapes. <var>TCursor</var> includes the following values:
          </p>
          <p><b>Standard Cursors</b></p>
          <dl>
            <dt>crDefault</dt>
            <dd>TCursor(0) - current cursor unchanged</dd>
            <dt>crNone</dt>
            <dd>TCursor(-1) - hide cursor</dd>
            <dt>crArrow</dt>
            <dd>TCursor(-2) - normal cursor</dd>
            <dt>crCross</dt>
            <dd>TCursor(-3) - graphics cursor, for pixel or rectangle selection</dd>
            <dt>crIBeam</dt>
            <dd>TCursor(-4) - text cursor, for setting insertion point</dd>
          </dl>
          <p><b>Sizing Cursors</b></p>
          <dl>
            <dt>crSize</dt>
            <dd>TCursor(-22)</dd>
            <dt>crSizeAll</dt>
            <dd>TCursor(-22)</dd>
            <dt>crSizeNESW</dt>
            <dd>TCursor(-6) - diagonal north east - south west</dd>
            <dt>crSizeNS</dt>
            <dd>TCursor(-7)</dd>
            <dt>crSizeNWSE</dt>
            <dd>TCursor(-8)</dd>
            <dt>crSizeWE</dt>
            <dd>TCursor(-9)</dd>
            <dt>crSizeNW</dt>
            <dd>TCursor(-23)</dd>
            <dt>crSizeN</dt>
            <dd>TCursor(-24)</dd>
            <dt>crSizeNE</dt>
            <dd>TCursor(-25)</dd>
            <dt>crSizeW</dt>
            <dd>TCursor(-26)</dd>
            <dt>crSizeE</dt>
            <dd>TCursor(-27)</dd>
            <dt>crSizeSW</dt>
            <dd>TCursor(-28)</dd>
            <dt>crSizeS</dt>
            <dd>TCursor(-29)</dd>
            <dt>crSizeSE</dt>
            <dd>TCursor(-30)</dd>
          </dl>
          <p><b>Drag and Drop Cursors</b></p>
          <dl>
            <dt>crDrag</dt>
            <dd>TCursor(-12) - dragging, drop allowed</dd>
            <dt>crNoDrop</dt>
            <dd>TCursor(-13) - dragging, drop disallowed/rejected</dd>
            <dt>crMultiDrag</dt>
            <dd>TCursor(-16) - dragging multiple items</dd>
            <dt>crNo</dt>
            <dd>TCursor(-18)</dd>
            <dt>Splitter Cursors</dt>
            <dd></dd>
            <dt>crHSplit</dt>
            <dd>TCursor(-14)</dd>
            <dt>crVSplit</dt>
            <dd>TCursor(-15)</dd>
          </dl>
          <p><b>Other  Cursors</b></p>
          <dl>
            <dt>crUpArrow</dt>
            <dd>TCursor(-10)</dd>
            <dt>crHourGlass</dt>
            <dd>TCursor(-11) - busy</dd>
            <dt>crSQLWait</dt>
            <dd>TCursor(-17)</dd>
            <dt>crAppStart</dt>
            <dd>TCursor(-19)</dd>
            <dt>crHelp</dt>
            <dd>TCursor(-20)</dd>
            <dt>crHandPoint</dt>
            <dd>TCursor(-21)</dd>
          </dl>
        </descr>
      </element>

      <element name="TFormStyle">
        <short>Defines special form behavior.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TFormStyle.fsNormal">
        <short>An ordinary (overlapping) form.</short>
      </element>
      <element name="TFormStyle.fsMDIChild">
        <short>The form is an MDI child.</short>
      </element>
      <element name="TFormStyle.fsMDIForm">
        <short>The form is an MDI parent form, containing MDI child forms.</short>
      </element>
      <element name="TFormStyle.fsStayOnTop">
        <short>The form is in the foreground, on top of all other application forms.</short>
      </element>
      <element name="TFormStyle.fsSplash">
        <short>The form is used as a Splash form.</short>
        <descr>
          <p>
            Signifies that the form cannot become the main form in an application. Implies that the form responds to fewer messages; generally, paint messages and little else. May affect the border style and even the window class used for the form on some widgetsets.
          </p>
        </descr>
      </element>
      <element name="TFormStyle.fsSystemStayOnTop">
        <short>The form stays system-wide on top.</short>
        <descr>
          <p>
            Used in forms for a modal system dialogs. Prevents another form from having a higher Z-order value than the current one. Generally treated the same as fsStayOnTop except for macOS Cocoa.
          </p>
        </descr>
      </element>

      <element name="TFormBorderStyle">
        <short>Represents border styles available for a Form.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TFormBorderStyle.bsNone">
        <short>A border is not used or displayed.</short>
      </element>
      <element name="TFormBorderStyle.bsSingle">
        <short>Single line border, the form cannot be resized.</short>
      </element>
      <element name="TFormBorderStyle.bsSizeable">
        <short>The form can be resized (standard).</short>
      </element>
      <element name="TFormBorderStyle.bsDialog">
        <short>The form is a dialog, cannot be resized.</short>
      </element>
      <element name="TFormBorderStyle.bsToolWindow">
        <short>Single line border, small caption, not resizable.</short>
      </element>
      <element name="TFormBorderStyle.bsSizeToolWin">
        <short>Small caption, form can be resized.</short>
      </element>

      <element name="TBorderStyle">
        <short>Possible types of borders (with or without border).</short>
        <seealso>
          <link id="#lcl.controls.TFormBorderStyle">TFormBorderStyle</link>
        </seealso>
      </element>

      <element name="TControlBorderStyle">
        <short>Possible types of control borders (with or without border).</short>
        <descr>
          <p>
            A subset of TFormBorderStyle, listing only the styles available to a control that is not a form.
          </p>
        </descr>
        <seealso>
          <link id="#lcl.controls.TFormBorderStyle">TFormBorderStyle</link>
        </seealso>
      </element>

      <element name="TControlRoleForForm">
        <short>Possible default actions on special keys.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlRoleForForm.crffDefault">
        <short>This control is notified when the user presses Return.</short>
      </element>
      <element name="TControlRoleForForm.crffCancel">
        <short>This control is notified when the user presses Escape.</short>
      </element>

      <element name="TControlRolesForForm">
        <short>Set type used to store values from the TControlRoleForForm enumeration.</short>
        <descr>
          <p>
            TControlRolesForForm is the type returned from the TCustomForm.GetRolesForControl method.
          </p>
        </descr>
        <seealso>
          <link id="TControlRoleForForm"/>
          <link id="#lcl.forms.TCustomForm">TCustomForm</link>
        </seealso>
      </element>

      <element name="TBevelCut">
        <short>Alias for the TGraphicsBevelCut type.</short>
        <descr>
          <p>
            <var>TBevelCut</var> is the type used to represent bevel styles passed as arguments to methods in widgetset classes.
          </p>
        </descr>
        <seealso>
          <link id="#lazutils.graphtype.TGraphicsBevelCut">TGraphicsBevelCut</link>
        </seealso>
      </element>

      <element name="TMouseButton">
        <short>Enumeration of recognized mouse buttons.</short>
        <descr>
          <p>
            These are <b>logical</b> buttons; the left and right physical buttons can be swapped for left-handed users.
          </p>
        </descr>
      </element>
      <element name="TMouseButton.mbLeft">
        <short>
          Represents the left mouse button. It might be physically the right button if the system is configured to act like that, for example for a left handled person.
        </short>
      </element>
      <element name="TMouseButton.mbRight">
        <short>
          Represents the right mouse button. It might be physically the left button if the system is configured to act like that, for example for a left handled person.
        </short>
      </element>
      <element name="TMouseButton.mbMiddle">
        <short>Represents the middle mouse button.</short>
      </element>
      <element name="TMouseButton.mbExtra1">
        <short>Represents the first extra mouse button.</short>
      </element>
      <element name="TMouseButton.mbExtra2">
        <short>Represents the second extra mouse button.</short>
      </element>

      <element name="fsAllStayOnTop">
        <short>Set of form styles, which make a form stay on top.</short>
        <descr/>
        <seealso>
          <link id="TFormStyle"/>
        </seealso>
      </element>

      <element name="fsAllNonSystemStayOnTop">
        <short>
          Set of form styles, except those which make a form stay on top of all other forms of the system.
        </short>
        <seealso>
          <link id="TFormStyle"/>
        </seealso>
      </element>

      <element name="crHigh">
        <short>Highest defined cursor constant (0).</short>
      </element>
      <element name="crDefault">
        <short>Indicates that the default cursor from the system should be utilized.</short>
      </element>
      <element name="crNone">
        <short>Indicates that the cursor should be invisible.</short>
      </element>
      <element name="crArrow">
        <short>The Arrow cursor, which is the most common and the default one in most cases.</short>
      </element>
      <element name="crCross">
        <short>A cursor utilized for graphics, for pixel or rectangle selection, often in the shape of a cross.</short>
      </element>
      <element name="crIBeam">
        <short>A text cursor, for setting insertion point. Often used in text editors.</short>
      </element>
      <element name="crSize">
        <short>A generic sizing cursor, to indicate that here one may drag to resize something. Is the same as crSizeAll.</short>
      </element>
      <element name="crSizeNESW">
        <short>A cursor for resizing which runs diagonally from NorthEast to SouthWest (-6).</short>
      </element>
      <element name="crSizeNS">
        <short>A cursor for resizing which cursor runs from North to South (-7).</short>
      </element>
      <element name="crSizeNWSE">
        <short>A cursor for resizing which cursor runs from NorthWest to SouthEast.</short>
      </element>
      <element name="crSizeWE">
        <short>A cursor for resizing which has an arrow with two points, one to the left and another to the right, to indicate resizing possibility in both directions.</short>
      </element>
      <element name="crSizeNW">
        <short>A cursor for resizing which has an arrow pointing to the left-top corner, to indicate resizing possibility in this direction.</short>
      </element>
      <element name="crSizeN">
        <short>A cursor for resizing which has an arrow pointing upwards, to indicate resizing possibility in this direction.</short>
      </element>
      <element name="crSizeNE">
        <short>A cursor for resizing which has an arrow pointing to the right-top corner, to indicate resizing possibility in this direction.</short>
      </element>
      <element name="crSizeW">
        <short>A cursor for resizing which has an arrow pointing to the left, to indicate resizing possibility in this direction.</short>
      </element>
      <element name="crSizeE">
        <short>A cursor for resizing which has an arrow pointing to the right, to indicate resizing possibility in this direction.</short>
      </element>
      <element name="crSizeSW">
        <short>A cursor for resizing which has an arrow pointing to the left-bottom corner, to indicate resizing possibility in this direction.</short>
      </element>
      <element name="crSizeS">
        <short>A cursor for resizing which has an arrow pointing downwards, to indicate resizing possibility in this direction.</short>
      </element>
      <element name="crSizeSE">
        <short>A cursor for resizing which has an arrow pointing to the right-bottom corner, to indicate resizing possibility in this direction.</short>
      </element>
      <element name="crUpArrow">
        <short>Up Arrow cursor constant (-10).</short>
      </element>
      <element name="crHourGlass">
        <short>Busy cursor constant, utilized to indicate that one should wait while an action is done.</short>
      </element>
      <element name="crDrag">
        <short>A cursor to indicate that one can drop a dragged item in this area.</short>
      </element>
      <element name="crNoDrop">
        <short>A cursor to indicate that one cannot drop a dragged item in this area.</short>
      </element>
      <element name="crHSplit">
        <short>Horizontal Splitter cursor constant (-14).</short>
      </element>
      <element name="crVSplit">
        <short>Vertical Split cursor constant (-15).</short>
      </element>
      <element name="crMultiDrag">
        <short>Multiple Object dragging cursor constant (-16).</short>
      </element>
      <element name="crSQLWait">
        <short>Waiting for SQL cursor constant (-17).</short>
      </element>
      <element name="crNo">
        <short>Shows a negative sign. See also <link id="crNoDrop"/>.
        </short>
      </element>
      <element name="crAppStart">
        <short>Application starting cursor.</short>
      </element>
      <element name="crHelp">
        <short>"What's This" Help cursor constant (-20).</short>
      </element>
      <element name="crHandPoint">
        <short>Pointing hand cursor constant (-21).</short>
      </element>
      <element name="crSizeAll">
        <short>All Directions sizing cursor constant (-22).</short>
      </element>
      <element name="crLow">
        <short>Lowest defined cursor constant (-30).</short>
      </element>

      <element name="TCaptureMouseButtons">
        <short>Set type used to store TMouseButton values.</short>
        <descr>
          <p>
            <var>TCaptureMouseButtons</var> is a set type used to store <var>TMouseButton</var> enumeration values. TCaptureMouseButtons is the type used to implement the <var>CaptureMouseButtons</var> property in <var>TControl</var>.
          </p>
        </descr>
        <seealso>
          <link id="TMouseButton"/>
          <link id="TControl.CaptureMouseButtons"/>
        </seealso>
      </element>

      <element name="TWndMethod">
        <short>Method type for WindowProc handlers.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWndMethod.TheMessage">
        <short>Message with the command constant and key code processed in the handler.</short>
      </element>

      <element name="TControlStyleType">
        <short>Enumerated type with values for features or behaviors for a control.</short>
        <descr>
          <p>
            <var>TControlStyleType</var> is an enumeration type with values that represent features or behaviors that can be enabled or disabled in a control. Zero or more values from TControlStyleType can be stored in the <var>TControlStyle</var> set type used to implement the <var>ControlStyle</var> property in <var>TControl</var>.
          </p>
          <p>
            When an enumeration value is present in the set, it indicates that the corresponding feature or behavior is enabled for the control. Conversely, when the value is omitted from the set the feature or behavior is disabled.
          </p>
        </descr>
        <seealso>
          <link id="TControlStyle"/>
          <link id="TControl.ControlStyle"/>
        </seealso>
      </element>
      <element name="TControlStyleType.csAcceptsControls">
        <short>
          Indicates that one can add child controls to this control in the form designer.
        </short>
      </element>
      <element name="TControlStyleType.csCaptureMouse">
        <short>Control focus and style changes when under the mouse cursor.</short>
      </element>
      <element name="TControlStyleType.csDesignInteractive">
        <short>Control handles mouse events at design-time.</short>
      </element>
      <element name="TControlStyleType.csClickEvents">
        <short>Control responds to mouse click events.</short>
      </element>
      <element name="TControlStyleType.csFramed">
        <short>Control has a 3D frame; used on scroll bars in the current LCL version.</short>
      </element>
      <element name="TControlStyleType.csSetCaption">
        <short>
          Indicates that the Caption for a control is updated when a value is assigned to the Name property. As long as Name=Text, changing the Name will set the Caption. When, for example, a button's Name and Caption have the value 'Button1' and the Name is changed to 'Button2' then the Caption is changed as well. When Name and Caption differ, this flag has no effect. This flag has no effect when loading the control using the LCL component streaming mechanism.
        </short>
      </element>
      <element name="TControlStyleType.csOpaque">
        <short>
          Control is drawn with a non-transparent background; implementation is widgetset-specific.
        </short>
      </element>
      <element name="TControlStyleType.csDoubleClicks">
        <short>Indicates that the control understands mouse double click events.</short>
      </element>
      <element name="TControlStyleType.csTripleClicks">
        <short>Indicates that the control understands mouse triple click events.</short>
      </element>
      <element name="TControlStyleType.csQuadClicks">
        <short>Indicates that the control understands mouse quadruple click events.</short>
      </element>
      <element name="TControlStyleType.csFixedWidth">
        <short>Indicates that the control cannot change its width.</short>
      </element>
      <element name="TControlStyleType.csFixedHeight">
        <short>Indicates that the control cannot change its height (e. g. a combo-box).</short>
      </element>
      <element name="TControlStyleType.csNoDesignVisible">
        <short>Indicates that the control is invisible in the form designer.</short>
      </element>
      <element name="TControlStyleType.csReplicatable">
        <short>Control can be drawn using the TWinControl.PaintTo method.</short>
      </element>
      <element name="TControlStyleType.csNoStdEvents">
        <short>Key messages are handler by widgetset classes instead of control events.</short>
      </element>
      <element name="TControlStyleType.csDisplayDragImage">
        <short>Display images from the drag imagelist during a drag operation over the control.</short>
      </element>
      <element name="TControlStyleType.csReflector">
        <short>
          Control responds to size, focus, and dialog messages and can be used as an ActiveX control (Windows).
        </short>
      </element>
      <element name="TControlStyleType.csActionClient">
        <short>Control includes support for TBasicAction.</short>
      </element>
      <element name="TControlStyleType.csMenuEvents">
        <short>Control responds to menu and menu item events.</short>
      </element>
      <element name="TControlStyleType.csNoFocus">
        <short>Indicates that the control or form cannot receive focus.</short>
      </element>
      <element name="TControlStyleType.csNeedsBorderPaint">
        <short>
          Indicates that the client area for the control needs to be redrawn including its borders. LCL controls do not use this value in their control styles property. Implemented for JVCL controls and its theme engine.
        </short>
      </element>
      <element name="TControlStyleType.csParentBackground">
        <short>
          Indicates whether the background for the parent control is used to fill the client area in the control. Used for controls which have a window handle for the parent control and do not use csOpaque in their control style. On some platforms (like WinXP and Windows 7), csParentBackground can be used to reduce flicker when the parent control is resized.
        </short>
      </element>
      <element name="TControlStyleType.csDesignNoSmoothResize">
        <short>WYSIWYG resizing is not used on the design surface.</short>
      </element>
      <element name="TControlStyleType.csDesignFixedBounds">
        <short>Control cannot be moved or resized on the designer surface.</short>
      </element>
      <element name="TControlStyleType.csHasDefaultAction">
        <short>Control executes a default action when the Space or Enter key is pressed.</short>
      </element>
      <element name="TControlStyleType.csHasCancelAction">
        <short>
          Control executes an action when the Escape key is pressed or the form/dialog is closed using the window decoration.
        </short>
      </element>
      <element name="TControlStyleType.csNoDesignSelectable">
        <short>Control cannot be selected at design-time.</short>
      </element>
      <element name="TControlStyleType.csOwnedChildrenNotSelectable">
        <short>Child controls owned by this control are not selectable in the designer.</short>
      </element>
      <element name="TControlStyleType.csAutoSize0x0">
        <short>If the preferred size is 0x0 then control is shrunk to 0x0</short>
      </element>
      <element name="TControlStyleType.csAutoSizeKeepChildLeft">
        <short>When AutoSize is <b>True</b>, do not move child controls horizontally.</short>
      </element>
      <element name="TControlStyleType.csAutoSizeKeepChildTop">
        <short>When AutoSize is <b>True</b>, do not move child controls vertically.</short>
      </element>
      <element name="TControlStyleType.csRequiresKeyboardInput">
        <short>
          Indicates that a control requires keyboard input to be utilized by the user. Used for the Android (and other) platforms to activate the virtual keyboard when an active control needs to respond to input values. Used primarily for devices that do not have a hardware keyboard.
        </short>
      </element>

      <element name="TControlStyle">
        <short>Set type used to store values from the TControlStyleType enumeration.</short>
        <descr>
          <p>
            <var>TControlStyle</var> is a set type used to store zero or more values from the <var>TControlStyleType</var> enumeration. Values from TControlStyleType are included in the set when the corresponding feature or behavior is enabled for a control.
          </p>
          <p>
            TControlStyle is the type used to implement the ControlStyle property in TControl and descendent classes.
          </p>
        </descr>
        <seealso>
          <link id="TControlStyleType"/>
          <link id="TControl.ControlStyle"/>
        </seealso>
      </element>

      <element name="csMultiClicks">
        <short>Set of style values which require/provide multiple clicks on a control.</short>
      </element>

      <element name="TControlStateType">
        <short>State flags of a Control.</short>
        <descr>
          <p>
            TControlStateType is an enumeration type which contains values that represent  state information for control class instances, including:
          </p>
          <ul>
            <li>csLButtonDown</li>
            <li>csClicked</li>
            <li>csPalette</li>
            <li>csReadingState</li>
            <li>csAlignmentNeeded</li>
            <li>csFocusing</li>
            <li>csCreating</li>
            <li>csPaintCopy</li>
            <li>csCustomPaint</li>
            <li>csDestroyingHandle</li>
            <li>csDocking</li>
            <li>csVisibleSetInLoading</li>
          </ul>
          <p>
            Values from the TControlStateType enumeration are stored in the TControlState type, and used to implement the ControlState property in TControl.
          </p>
        </descr>
        <seealso>
          <link id="TControlState"/>
          <link id="TControl.ControlState"/>
        </seealso>
      </element>
      <element name="TControlStateType.csLButtonDown">
        <short>Indicates the Left mouse button was down for the control.</short>
      </element>
      <element name="TControlStateType.csClicked">
        <short>Indicates the control was clicked; occurs after button down/up processing.</short>
      </element>
      <element name="TControlStateType.csPalette">
        <short>Palettes are not currently implemented in LCL.</short>
      </element>
      <element name="TControlStateType.csReadingState">
        <short>Indicates the ReadState method has been called for the control.</short>
      </element>
      <element name="TControlStateType.csFocusing">
        <short>Indicates the focus for the control has been changed.</short>
      </element>
      <element name="TControlStateType.csCreating">
        <short>Introduced for Delphi compatibility; not used in LCL.</short>
      </element>
      <element name="TControlStateType.csPaintCopy">
        <short>Indicates a device context was copied  in PaintControls.</short>
      </element>
      <element name="TControlStateType.csCustomPaint">
        <short>
          Indicates a custom paint method is used to draw the control; determines the handler called to paint the control.
        </short>
      </element>
      <element name="TControlStateType.csDestroyingHandle">
        <short>Used to suppress message processing when the control is freed.</short>
      </element>
      <element name="TControlStateType.csDocking">
        <short>Indicates the Dock method has been called for a control.</short>
      </element>
      <element name="TControlStateType.csVisibleSetInLoading">
        <short>
        Indicates the control is being loaded using the LCL component streaming mechanism.
        </short>
      </element>

      <element name="TControlState">
        <short>Set of control states used in a control.</short>
        <seealso>
          <link id="TControlStateType"/>
        </seealso>
      </element>

      <element name="TControlCanvas">
        <short>
          Base class which provides a canvas property used in graphic controls.
        </short>
        <descr>
          <p>
            <var>TControlCanvas</var> is a <var>TCanvas</var> descendant that implements the base class which provides a canvas used in graphic controls. TControlCanvas extends the ancestor class  by including a property representing the <var>TControl</var> associated with the canvas, a window handle for the associated control, and the device context for the handle.
          </p>
          <p>
            TControlCanvas is used in the implementation of classes like <var>TGraphicControl</var> and <var>TCustomControl</var>, and other visual controls.
          </p>
        </descr>
        <seealso>
          <link id="#lcl.graphics.TCanvas">TCanvas</link>
          <link id="TGraphicControl"/>
          <link id="TCustomControl"/>
        </seealso>
      </element>

      <element name="TControlCanvas.FControl"/>
      <element name="TControlCanvas.FDeviceContext"/>
      <element name="TControlCanvas.FWindowHandle"/>

      <element name="TControlCanvas.SetControl">
        <short>Sets the value for the Control property.</short>
        <descr/>
        <seealso>
          <link id="TControlCanvas.Control"/>
        </seealso>
      </element>
      <element name="TControlCanvas.SetControl.AControl">
        <short>New value for the Control property.</short>
      </element>

      <element name="TControlCanvas.CreateHandle">
        <short>Ensures that a handle exists for the class instance.</short>
        <descr>
          <p>
            Calls the inherited method on entry when a value has not been assigned to the Control property.
          </p>
          <p>
            Otherwise, Control is used to check for an existing device context (HDC) for the class instance. When assigned, its value is copied into the Handle for the control.When not assigned, the HandleNeeded method in TWinControl is called to create the window handle and get its device context. If Control is not derived from TWinControl, its Parent is used to call the HandleNeeded method.
          </p>
          <p>
            This is done to prevent resource leaks that might occur when directly accessing he window Handle before it has actually been allocated (recursive calls to the method).
          </p>
          <p>
            If the device context remains unassigned, the GetDeviceContext method in Control is called to get the device context for the window Handle.
          </p>
        </descr>
        <seealso>
          <link id="TControlCanvas.Control"/>
          <link id="TWinControl.HandleNeeded"/>
          <link id="TWinControl.Handle"/>
          <link id="TControl.GetDeviceContext"/>
          <link id="#lcl.graphics.TCanvas.CreateHandle">TCanvas.CreateHandle</link>
        </seealso>
      </element>

      <element name="TControlCanvas.GetDefaultColor">
        <short>Gets the color value used for clDefault.</short>
        <descr>
          <p>
            <var>GetDefaultColor</var> is used to resolve the default color (<var>clDefault</var>) to the TColor value used for the brush or font on the canvas. The <var>ADefaultColorType</var> argument indicates which value is needed in  the return value. See <var>TDefaultColorType</var> for the values available in the argument.
          </p>
          <p>
            GetDefaultColor is overridden in <var>TControlCanvas</var> to ensure that the <var>Control</var> is used (when assigned) to retrieve the default color by calling its GetDefaultColor method. If Control is not assigned, the inherited method is called to get the default color value (unresolved in the ancestor class).
          </p>
        </descr>
        <seealso>
          <link id="TControlCanvas.Control"/>
          <link id="#lcl.graphics.TCanvas.GetDefaultColor">TCanvas.GetDefaultColor</link>
          <link id="#lcl.controls.TControl.GetDefaultColor">TControl.GetDefaultColor</link>
          <link id="#lcl.graphics.TDefaultColorType">TDefaultColorType</link>
        </seealso>
      </element>
      <element name="TControlCanvas.GetDefaultColor.Result">
        <short>
          TColor value for the specified color type. clDefault when the Control has not been assigned for the class instance.
        </short>
      </element>
      <element name="TControlCanvas.GetDefaultColor.ADefaultColorType">
        <short>Identifies whether the font or brush color is resolved in the method.</short>
      </element>

      <element name="TControlCanvas.Create">
        <short>Constructor for the class instance.</short>
        <descr>
          <p>
            <var>Create</var> is the overridden constructor for the class instance. Create calls the inherited constructor, and sets the default unassigned values for the device context, window handle, and control used in the class instance. The device context and window handle are maintained in methods which use the respective members. Use the <var>Control</var> property to set the owner for the class instance.
          </p>
        </descr>
        <seealso>
          <link id="TControlCanvas.Control"/>
          <link id="TControlCanvas.Destroy"/>
        </seealso>
      </element>

      <element name="TControlCanvas.Destroy">
        <short>Destructor for the class instance.</short>
        <descr>
          <p>
            <var>Destroy</var> is the overridden destructor for the class instance. Destroy ensures that a device context allocated for the window handle in <var>Control</var> is freed prior calling the inherited destructor.
          </p>
        </descr>
        <seealso>
          <link id="TControlCanvas.Control"/>
          <link id="TControlCanvas.Create"/>
        </seealso>
      </element>

      <element name="TControlCanvas.FreeHandle">
        <short>
          Frees the Handle for the control canvas, and its device context when assigned.
        </short>
        <descr>
          <p>
            <var>FreeHandle</var> is an overridden method in TControlCanvas. It calls the inherited method on entry to set the value in <var>Handle</var> to 0 (the unassigned value). If a device context (DC) has been allocated for the window handle (HWND), the <var>ReleaseDC</var> routine is called to release the device context.
          </p>
            <p>
              FreeHandle is called when a new value is assigned to the <var>Control</var> property, or when the class instance is freed.
            </p>
        </descr>
        <seealso>
          <link id="TControlCanvas.Destroy"/>
          <link id="TControlCanvas.Control"/>
          <link id="#lcl.graphics.TCanvas.Handle">TCanvas.Handle</link>
          <link id="#lcl.graphics.TCanvas.FreeHandle">TCanvas.FreeHandle</link>
          <link id="#lcl.lclintf.ReleaseDC">ReleaseDC</link>
        </seealso>
      </element>

      <element name="TControlCanvas.ControlIsPainting">
        <short>Indicates if the Control has called but not completed its Paint method.</short>
        <descr>
          <p>
            <var>ControlIsPainting</var> is a <var>Boolean</var> function which indicates if the <var>Control</var> has called but not completed its <var>Paint</var> method. ControlIsPainting returns <b>True</b> when the Control has been assigned (contains a non-Nil value) and its <var>IsProcessingPaintMsg</var> method returns <b>True</b>.
          </p>
          <p>
            ControlIsPainting is used in the implementation of the <var>CreateHandle</var> method.
          </p>
        </descr>
        <seealso>
          <link id="TControl.IsProcessingPaintMsg"/>
        </seealso>
      </element>
      <element name="TControlCanvas.ControlIsPainting.Result">
        <short><b>True</b> when the Control has been assigned is repainting.</short>
      </element>

      <element name="TControlCanvas.Control">
        <short>The Control object for which the Canvas is used.</short>
        <descr>
          <p>
            <var>Control</var> is a <var>TControl</var> property which represents the control associated with the canvas in the class instance. Setting the value in Control causes an existing Window handle (and its device context) in the class instance to be freed. The handle and its device context are recreated (eventually) when the control is displayed.
          </p>
        </descr>
        <seealso>
          <link id="TControl"/>
        </seealso>
      </element>

      <element name="PHintInfo">
        <short>Pointer to a THintInfo instance.</short>
        <descr>
          <p>
            <var>PHintInfo</var> is a <var>Pointer</var> to a <var>THintInfo</var> instance. PHintInfo is the type passed as an argument to the <var>TControlShowHintEvent</var> event handler procedure, and the <var>DoOnShowHint</var> method in <var>TControl</var>.
          </p>
        </descr>
        <seealso>
          <link id="THintInfo"/>
          <link id="TControlShowHintEvent"/>
          <link id="TControl.DoOnShowHint"/>
        </seealso>
      </element>

      <element name="THintInfo">
        <short>
          Contains content and state information for Hints displayed for a window or control.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="THintInfo.HintControl">
        <short>Control for the hint display.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="THintInfo.HintWindowClass">
        <short>Window class for the hint display.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="THintInfo.HintPos">
        <short>TPoint with the screen coordinates for the hint display.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="THintInfo.HintMaxWidth">
        <short>Maximum width for the hint.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="THintInfo.HintColor">
        <short>Color for the hint window.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="THintInfo.CursorRect">
        <short>Rectangle with the coordinates and size for the cursor.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="THintInfo.CursorPos">
        <short>TPoint with the location for the mouse cursor.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="THintInfo.ReshowTimeout">
        <short>
          If set to a value greater than Zero (0), call after value milliseconds OnShowHint again.
        </short>
        <descr>
          Used to update the hint text display after the specified delay while it is showing.
        </descr>
        <seealso/>
      </element>

      <element name="THintInfo.HideTimeout">
        <short>Duration in milliseconds for the hint display.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="THintInfo.HintStr">
        <short>
          String value displayed as a hint for the associated control.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="THintInfo.HintData">
        <short>
          Pointer to the data used to derive the hint text.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TImageListHelper">
        <short>
          Helper class for TCustomImageList useful for images on TControl instances.
        </short>
        <descr>
          <p>
            <var>TImageListHelper</var> is a helper class for <var>TCustomImageList</var>. TImageListHelper extends TCustomImageList to provide additional properties and methods that are useful when working with <var>TControl</var> class instances.
          </p>
          <p>
            Use the overloaded <var>DrawForControl</var> method to render an image from the multiple resolution image list to a control canvas.
          </p>
          <p>
            Use the <var>ResolutionForControl</var> property to access a scaled image resolution with images of a specified width used on a control instance.
          </p>
        </descr>
        <seealso>
          <link id="TImageListHelper.DrawForControl"/>
          <link id="TImageListHelper.ResolutionForControl"/>
          <link id="#lcl.imglist.TCustomImageList">TCustomImageList</link>
          <link id="TControl"/>
        </seealso>
      </element>

      <element name="TImageListHelper.GetResolutionForControl">
        <short>Gets the value for the ResolutionForControl property.</short>
        <descr/>
        <seealso>
          <link id="TImageListHelper.ResolutionForControl"/>
        </seealso>
      </element>
      <element name="TImageListHelper.GetResolutionForControl.Result">
        <short>Value for the property.</short>
      </element>
      <element name="TImageListHelper.GetResolutionForControl.AImageWidth">
        <short>ImageWidth desired in the scaled image resolution.</short>
      </element>
      <element name="TImageListHelper.GetResolutionForControl.AControl">
        <short>
          Control which provides the PPI display density for scaled images in the resolution.
        </short>
      </element>

      <element name="TImageListHelper.DrawForControl">
        <short>
          Draws an image scaled to the display density (PPI) for the specified control.
        </short>
        <descr>
          <p>
            <var>DrawForControl</var> is an overloaded procedure used to draw the specified image scaled to the display density (PPI) for the specified control. DrawForControl calls the <var>DrawForPPI</var> method in the image list to render the selected image using the display density and drawing effect required.
          </p>
          <p>
            <var>ACanvas</var> contains the control canvas where the image is drawn. <var>AX</var> and <var>AY</var> contains the left and top coordinates on the canvas where the image is drawn.
          </p>
          <p>
            <var>AIndex</var> specifies the ordinal position in the scaled image list for the image drawn in the method.
          </p>
          <p>
            <var>AImageWidthAt96PPI</var> contains the width for the image at 96 PPI. The actual image width is scaled to the display density using scaling factor required for the control.
          </p>
          <p>
            <var>AControl</var> contains the <var>TControl</var> instance that provides the display density and canvas scaling factor required for the image.
          </p>
          <p>
            When <var>AEnabled</var> is <b>True</b>, the image is drawn using its Enabled state. Otherwise, it is rendered using the disabled state.
          </p>
          <p>
            <var>ADrawEffect</var> contains the <var>TGraphicsDrawEffect</var> used when rendering the image to the control canvas.
          </p>
        </descr>
        <seealso>
          <link id="#lcl.imglist.TCustomImageList.DrawForPPI">TCustomImageList.DrawForPPI</link>
        </seealso>
      </element>
      <element name="TImageListHelper.DrawForControl.ACanvas">
        <short>Canvas where the image is drawn.</short>
      </element>
      <element name="TImageListHelper.DrawForControl.AX">
        <short>Horizontal position on the canvas where the image is drawn.</short>
      </element>
      <element name="TImageListHelper.DrawForControl.AY">
        <short>Vertical position on the canvas where the image is drawn.</short>
      </element>
      <element name="TImageListHelper.DrawForControl.AIndex">
        <short>Ordinal position for the image drawn in the method.</short>
      </element>
      <element name="TImageListHelper.DrawForControl.AImageWidthAt96PPI">
        <short>Image width using the standard display density.</short>
      </element>
      <element name="TImageListHelper.DrawForControl.AControl">
        <short>
          Control with the display density (Font PPI) and canvas scaling factor used in the method.
        </short>
      </element>
      <element name="TImageListHelper.DrawForControl.AEnabled">
        <short>Indicates the image is drawn in the enabled state when <b>True</b>.</short>
      </element>
      <element name="TImageListHelper.DrawForControl.ADrawEffect">
        <short>Indicates the TGraphicsDrawEffect applied to the image.</short>
      </element>

      <element name="TImageListHelper.ResolutionForControl">
        <short>
          Provides access to an image resolution with the specified width scaled to the display density for a control.
        </short>
        <descr>
          <p>
            <var>ResolutionForControl</var> is a read-only <var>TScaledImageListResolution</var> property which provides access to a scaled image resolution suitable for the control in <var>AControl</var>. <var>AImageWidth</var> contains the image width requested from the multi-resolution image list. <var>AControl</var> contains the <var>TControl</var> instance which provides the display density (PPI) and the scaling factor used to generate the scaled image resolution.
          </p>
        </descr>
        <seealso>
          <link id="#lcl.imglist.TScaledImageListResolution">TScaledImageListResolution</link>
          <link id="TControl"/>
          <link id="TControlCanvas"/>
        </seealso>
      </element>
      <element name="TImageListHelper.ResolutionForControl.AImageWidth">
        <short>Image width requested in the image list </short>
      </element>
      <element name="TImageListHelper.ResolutionForControl.AControl">
        <short>
          Control which provides the display density and scaling factor for the scaled image resolution.
        </short>
      </element>

      <element name="TDragImageListResolution">
        <short>
          Implements an image list resolution with features used in Drag and Drop operations.
        </short>
        <descr>
          <p>
            <var>TDragImageListResolution</var> is a <var>TCustomImageListResolution</var> descendant which implements an image list resolution with features used in Drag and Drop operations. TDragImageListResolution is used in the implementation of <var>TDragImageList</var>.
          </p>
        </descr>
        <seealso>
          <link id="TDragImageList.DraggingResolution"/>
          <link id="TDragImageList.Resolution"/>
        </seealso>
      </element>

      <element name="TDragImageListResolution.FDragging"/>
      <element name="TDragImageListResolution.FDragHotspot"/>
      <element name="TDragImageListResolution.FOldCursor"/>
      <element name="TDragImageListResolution.FLastDragPos"/>
      <element name="TDragImageListResolution.FLockedWindow"/>

      <element name="TDragImageListResolution.GetImageList">
        <short>Gets the value for the ImageList property.</short>
        <descr/>
        <seealso>
          <link id="TDragImageListResolution.ImageList"/>
        </seealso>
      </element>
      <element name="TDragImageListResolution.GetImageList.Result">
        <short>Value for the property.</short>
      </element>

      <element name="TDragImageListResolution.WSRegisterClass"  link="#lcl.lclclasses.TLCLComponent.WSRegisterClass"/>

      <element name="TDragImageListResolution.ImageList">
        <short>List with images used in Drag and Drop operations.</short>
        <descr>
          <p>
            <var>ImageList</var> is a read-only <var>TDragImageList</var> property which provides access to the images used for Drag and Drag operations, and methods used to render the images.
          </p>
        </descr>
        <seealso>
          <link id="TDragImageList"/>
          <link id="TControl.GetDragImages"/>
          <link id="TControl.ControlStyle"/>
          <link id="TControlStyleType"/>"
        </seealso>
      </element>

      <element name="TDragImageListResolution.Create">
        <short>Constructor for the class instance.</short>
        <descr>
          <p>
            <var>Create</var> is the overridden constructor for <var>TDragImageListResolution</var>. Create calls the inherited constructor using TheOwner as the owner for the class instance. Create sets the initial the values for internal members in the class instance.
          </p>
        </descr>
        <seealso>
          <link id="#rtl.classes.TComponent.Create">TComponent.Create</link>
        </seealso>
      </element>
      <element name="TDragImageListResolution.Create.TheOwner">
        <short>Owner of the new class instance.</short>
      </element>

      <element name="TDragImageListResolution.GetHotSpot">
        <short>Gets the HotSpot for the image resolution.</short>
        <descr>
          <p>
            <var>GetHotSpot</var> is an overridden <var>TPoint</var> function which gets the <var>HotSpot</var> for the image list resolution. GetHotSpot uses the value from the <var>DragHotspot</var> property. It contains the screen coordinates where the Drag and Drop operation was started. X is is the horizontal position, and Y is the vertical position in the <var>TPoint</var> type.
          </p>
        </descr>
        <seealso>
          <link id="TDragImageListResolution.DragHotspot"/>
        </seealso>
      </element>
      <element name="TDragImageListResolution.GetHotSpot.Result">
        <short>Value for the HotSpot.</short>
      </element>

      <element name="TDragImageListResolution.BeginDrag">
        <short>
          Starts display of images in the resolution for a Drag and Drop operation.
        </short>
        <descr>
          <p>
            <var>BeginDrag</var> is a <var>Boolean</var> function used to start display of images in the resolution for a Drag and Drop operation. The return value is <b>True</b> if the widgetset successfully received the BeginDrag notification.
          </p>
          <remark>
            No actions are performed in the method if the widgetset class does note successfully start the drag operation.
          </remark>
          <p>
            BeginDrag calls the <var>DragLock</var> method to lock the window handle for the control, and to start displaying the drag image for the operation. The current screen cursor is captured, and the <var>DragCursor</var> in <var>ImageList</var> is displayed for the operation.
          </p>
        </descr>
        <seealso>
          <link id="TDragImageListResolution.Dragging"/>
          <link id="TDragImageListResolution.EndDrag"/>
          <link id="TDragImageListResolution.DragLock"/>
          <link id="TDragImageListResolution.ImageList"/>
          <link id="TDragImageList.DragCursor"/>
        </seealso>
      </element>
      <element name="TDragImageListResolution.BeginDrag.Result">
        <short><b>True</b> if the Drag operation was successfully started.</short>
      </element>
      <element name="TDragImageListResolution.BeginDrag.Window">
        <short>Window handle where images are displayed for the operation.</short>
      </element>
      <element name="TDragImageListResolution.BeginDrag.X">
        <short>Horizontal screen position where the operation was started.</short>
      </element>
      <element name="TDragImageListResolution.BeginDrag.Y">
        <short>Vertical screen position where the operation was started.</short>
      </element>

      <element name="TDragImageListResolution.DragLock">
        <short>
          Shows the Drag image and optionally locks the Window handle during the Drag operation.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDragImageListResolution.DragLock.Result">
        <short>
          <b>True</b> if the drag operation was started or the drag image position was updated.
        </short>
      </element>
      <element name="TDragImageListResolution.DragLock.Window">
        <short>Window handle used as the lock handle when not already assigned.</short>
      </element>
      <element name="TDragImageListResolution.DragLock.X">
        <short>Horizontal coordinate for the drag image.</short>
      </element>
      <element name="TDragImageListResolution.DragLock.Y">
        <short>Vertical coordinate for the drag image.</short>
      </element>

      <element name="TDragImageListResolution.DragMove">
        <short>Moves the dragging image to the specified position.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDragImageListResolution.DragMove.Result">
        <short/>
      </element>
      <element name="TDragImageListResolution.DragMove.X">
        <short/>
      </element>
      <element name="TDragImageListResolution.DragMove.Y">
        <short/>
      </element>

      <element name="TDragImageListResolution.DragUnlock">
        <short>Hides the Drag image and removes the update lock for the Window.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDragImageListResolution.EndDrag">
        <short>Removes the drag lock and restores the saved cursor when the drag operation has ended.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDragImageListResolution.EndDrag.Result">
        <short/>
      </element>

      <element name="TDragImageListResolution.HideDragImage">
        <short>Notifies the widgetset class to hide the drag image.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDragImageListResolution.ShowDragImage">
        <short>Notifies the widgetset class to display the drag image.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDragImageListResolution.DragHotspot">
        <short>Contains the mouse position for the drag image.</short>
        <descr>
          DragHotspot is a TPoint property which contains the mouse position for the Drag hostspot. The value in DragHotspot is updated when TDragImageList sets the image used for the resolution, and in the BeginDrag method.
        </descr>
        <seealso/>
      </element>

      <element name="TDragImageListResolution.Dragging">
        <short>Indicates that BeginDrag has been called for the image resolution.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDragImageList">
        <short>A list of Images used during Drag operations.</short>
        <descr>
          <p>
            A drag image is shown when a DragImageList is supplied at all, <b>and</b> when no accepting target is under the mouse, or the source control style includes csDisplayDragImage, or AlwaysShowDragImage is set in the DragObject.
          </p>
          <p>
            In drag-dock operations typically no drag image is shown, since the DockRect frame already gives all required visual feedback.
          </p>
          <p>
            This is a general overview of the usage of this class:
          </p>
          <ul>
            <li>
              SetDragImage selects an image from the list, and defines the hotspot within this image. (the hotspot typically is the offset of the mouse position to the origin of the dragged control)
            </li>
            <li>BeginDrag starts dragging, the image is shown at the starting location.</li>
            <li>DragMove moves the image.</li>
            <li>EndDrag stops dragging, the image is removed from the screen.</li>
          </ul>
        </descr>
      </element>

      <element name="TDragImageList.FDragCursor"/>
      <element name="TDragImageList.FDragging"/>
      <element name="TDragImageList.FDragHotspot"/>
      <element name="TDragImageList.FImageIndex"/>

      <element name="TDragImageList.FLastDragPos">
        <short>Remember position where the image was painted.</short>
      </element>

      <element name="TDragImageList.FLockedWindow">
        <short>The window whose updates are locked while dragging.</short>
      </element>

      <element name="TDragImageList.FOldCursor"/>

      <element name="TDragImageList.SetDragCursor">
        <short>Sets the value for the DragCursor property.</short>
        <descr/>
        <seealso>
          <link id="TDragImageList.DragCursor"/>
        </seealso>
      </element>
      <element name="TDragImageList.SetDragCursor.AValue">
        <short>New value for the DragCursor property.</short>
      </element>

      <element name="TDragImageList.GetDragHotSpot">
        <short>Gets the value for the DragHostSpot property.</short>
        <descr/>
        <seealso>
          <link id="TDragImageList.DragHotSpot"/>
          <link id="#lcl.imglist.TCustomImageList.GetHotSpot"/>
        </seealso>
      </element>
      <element name="TDragImageList.GetDragHotSpot.Result">
        <short>Value for the DragHostSpot property.</short>
      </element>

      <element name="TDragImageList.SetDragHotspot">
        <short>Sets the value for the DragHostSpot property.</short>
        <descr/>
        <seealso>
          <link id="TDragImageList.DragHotSpot"/>
        </seealso>
      </element>
      <element name="TDragImageList.SetDragHotspot.ADragHotSpot">
        <short>New value for the DragHostSpot property.</short>
      </element>

      <element name="TDragImageList.WSRegisterClass"  link="#lcl.lclclasses.TLCLComponent.WSRegisterClass"/>

      <element name="TDragImageList.Initialize">
        <short>initializes the cursor shape and image index for the list.</short>
        <descr>
          <p>
            Initialize is an overridden method in TDragImageList. It calls the inherited method on entry. It sets the default values in DragCursor (crNone) and the internal selected image index (0).
          </p>
        </descr>
        <seealso>
          <link id="#lcl.imglist.TCustomImageList.Initialize">TCustomImageList.Initialize</link>
        </seealso>
      </element>

      <element name="TDragImageList.BeginDrag">
        <short>Start dragging an image; returns <b>True</b> if successful.</short>
        <descr>
          Locks a window for updates, remembers the current cursor shape, and sets the new cursor shape.
        </descr>
        <seealso/>
      </element>
      <element name="TDragImageList.BeginDrag.Result">
        <short><b>True</b> if successful.</short>
      </element>
      <element name="TDragImageList.BeginDrag.Window">
        <short>The associated window.</short>
      </element>
      <element name="TDragImageList.BeginDrag.X">
        <short>The mouse position.</short>
      </element>
      <element name="TDragImageList.BeginDrag.Y">
        <short>The mouse position.</short>
      </element>

      <element name="TDragImageList.DragLock">
        <short>Show drag image during drag operation.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDragImageList.DragLock.Result">
        <short><b>True</b> if Dragging and image shown.</short>
      </element>
      <element name="TDragImageList.DragLock.Window">
        <short>The locked window.</short>
      </element>
      <element name="TDragImageList.DragLock.XPos">
        <short>The mouse position.</short>
      </element>
      <element name="TDragImageList.DragLock.YPos">
        <short>The mouse position.</short>
      </element>

      <element name="TDragImageList.DragMove">
        <short>Shows the drag image at a new location.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDragImageList.DragMove.Result">
        <short><b>True</b> if Dragging and image moved.</short>
      </element>
      <element name="TDragImageList.DragMove.X">
        <short>The new mouse position.</short>
      </element>
      <element name="TDragImageList.DragMove.Y">
        <short>The new mouse position.</short>
      </element>

      <element name="TDragImageList.DragUnlock">
        <short>Hide the drag image.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDragImageList.EndDrag">
        <short>Finish dragging of the image, restore the old cursor shape.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDragImageList.EndDrag.Result">
        <short><b>True</b> when dragging was started before.</short>
      </element>

      <element name="TDragImageList.HideDragImage">
        <short>Hides the drag image without unlocking the window.</short>
        <descr>
          <p>
            Calls the <var>HideDragImage</var> method in <var>DraggingResolution</var>. No actions are performed in the method when an image resolution is not available in  the DraggingResolution property.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TDragImageList.SetDragImage">
        <short>Set index of dragged image and hotspot.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDragImageList.SetDragImage.Result">
        <short>Always <b>True</b>.</short>
      </element>
      <element name="TDragImageList.SetDragImage.Index">
        <short>List index of the image to use.</short>
      </element>
      <element name="TDragImageList.SetDragImage.HotSpotX">
        <short>Offset from mouse position to image position.</short>
      </element>
      <element name="TDragImageList.SetDragImage.HotSpotY">
        <short>Offset from mouse position to image position.</short>
      </element>

      <element name="TDragImageList.ShowDragImage">
        <short>Displays the drag image.</short>
        <descr>
          <p>
            Calls the <var>ShowDragImage</var> method in <var>DraggingResolution</var>. No actions are performed in the method when an image resolution is not available in  the DraggingResolution property.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TDragImageList.DragCursor">
        <short>The cursor shape to use while dragging.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDragImageList.DragHotspot">
        <short>
          The position of the HotSpot image, i.e. the offset to the mouse position while dragging.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDragImageList.Dragging">
        <short><b>True</b> if dragging in progress.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDragImageList.DraggingResolution">
        <short>Gets the scaled image resolution with the drag images for the list.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDragImageList.Resolution">
        <short>Gets the image resolution for the specified image width.</short>
        <descr>
          <p>
            <var>Resolution</var> is a read-only indexed <var>TDragImageListResolution</var> property which provides the image resolution for images with the width specified in <var>AImageWidth</var>. Reading the property value causes the image resolution to be cast to the required <var>TDragImageListResolution</var> type.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TDragImageList.Resolution.AImageWidth">
        <short>Image width requested in the image resolution.</short>
      </element>

      <element name="TKeyEvent">
        <short>Defines an event handler for key events.</short>
        <descr>
          <p>
            <var>TKeyEvent</var> is an object procedure type which specifies a handler for key events.
          </p>
          <p>
            <var>TKeyEvent</var> is the type used to implement the <var>OnKeyDown</var> and <var>OnKeyUp</var> event handlers in <var>TWinControl</var>. Applications must implement an object procedure using the signature for the event, and assign it to the event handler to respond to the notification.
          </p>
          <p>
            See <link id="TKeyPressEvent"/> for the handler used to implement OnKeyPress events.
          </p>
        </descr>
      </element>
      <seealso>
        <link id="TWinControl.OnKeyDown"/>
        <link id="TWinControl.OnKeyUp"/>
        <link id="TControl.AddHandlerOnKeyDown"/>
        <link id="TControl.AddHandlerOnKeyUp"/>
        <link id="TKeyPressEvent"/>
      </seealso>
      <element name="TKeyEvent.Sender">
        <short>TObject for the key event.</short>
      </element>
      <element name="TKeyEvent.Key">
        <short>ScanCode for the key in the event.</short>
      </element>
      <element name="TKeyEvent.Shift">
        <short>TShiftState modifier for the specified key.</short>
      </element>

      <element name="TKeyPressEvent">
        <short>Specifies an event handler for key press events.</short>
        <descr>
          <p>
            <var>TKeyPressEvent</var> is an object procedure type that defines an event handler for key press events.
          </p>
          <p>
            <var>TKeyPressEvent</var> is the type used to implement the <var>OnKeyPress</var> event handler in <var>TWinControl</var>. Applications must implement an object procedure using the signature for the event handler, and assign it to the property to respond to the event notification.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.OnKeyPress"/>
        </seealso>
      </element>
      <element name="TKeyPressEvent.Sender">
        <short>TObject for the event notification.</short>
      </element>
      <element name="TKeyPressEvent.Key">
        <short>Character value for the key press in the event notification.</short>
      </element>

      <element name="TUTF8KeyPressEvent">
        <short>Specifies an event handler for UTF-8-encoded key press events.</short>
        <descr>
          <p>
            <var>TUTF8KeyPressEvent</var> is an object procedure type which specifies an event handler for UTF-8-encoded key press events.
          </p>
          <p>
            <var>TUTF8KeyPressEvent</var> is the type used to implement the <var>OnUTF8KeyPress</var> event handler in <var>TWinControl</var>. Applications must implement an object procedure using the signature for the event handler, and assign it to the property to respond to the event notification.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.OnUTF8KeyPress"/>
        </seealso>
      </element>
      <element name="TUTF8KeyPressEvent.Sender">
        <short>TObject for the event notification.</short>
      </element>
      <element name="TUTF8KeyPressEvent.UTF8Key">
        <short>Value for the UTF-8-encoded character in the key press event.</short>
      </element>

      <element name="TMouseEvent">
        <short>Specifies an event handler used to respond to mouse button events.</short>
        <descr>
          <p>
            <var>TMouseEvent</var> is an object procedure type which specifies an event handler for mouse button events.
          </p>
          <p>
            <var>TMouseEvent</var> is the type used to implement the <var>OnMouseDown</var> and <var>OnMouseUp</var> event handlers in <var>TControl</var>. Applications must implement an object procedure using the signature for the event handler, and assign it to the property to respond to the event notification.
          </p>
        </descr>
        <seealso>
          <link id="TControl.OnMouseDown"/>
          <link id="TControl.OnMouseUp"/>
        </seealso>
      </element>
      <element name="TMouseEvent.Sender">
        <short>TObject for the event notification.</short>
      </element>
      <element name="TMouseEvent.Button">
        <short>Mouse button for the event notification.</short>
      </element>
      <element name="TMouseEvent.Shift">
        <short>Modifier applied to the mouse button.</short>
      </element>
      <element name="TMouseEvent.X">
        <short>Horizontal position for the mouse cursor in the button event.</short>
      </element>
      <element name="TMouseEvent.Y">
        <short>Vertical position for the mouse cursor in the button event.</short>
      </element>

      <element name="TMouseMoveEvent">
        <short>Specifies an event handler used to respond to mouse movement events.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TMouseMoveEvent.Sender">
        <short>TObject for the event notification.</short>
      </element>
      <element name="TMouseMoveEvent.Shift">
        <short>Key modifier in effect for the event.</short>
      </element>
      <element name="TMouseMoveEvent.X">
        <short>Horizontal mouse coordinates.</short>
      </element>
      <element name="TMouseMoveEvent.Y">
        <short>Vertical mouse coordinates.</short>
      </element>

      <element name="TMouseWheelEvent">
        <short>Specifies an event handler used to respond to mouse wheel events.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TMouseWheelEvent.Sender">
        <short>The control under the mouse.</short>
      </element>
      <element name="TMouseWheelEvent.Shift">
        <short>State of the modifier keys and mouse buttons.</short>
      </element>
      <element name="TMouseWheelEvent.WheelDelta">
        <short>How many notches the wheel has been turned.</short>
      </element>
      <element name="TMouseWheelEvent.MousePos">
        <short>The mouse position, in client coordinates.</short>
      </element>
      <element name="TMouseWheelEvent.Handled">
        <short>Set Handled to <b>True</b> when the event was handled.</short>
      </element>

      <element name="TMouseWheelUpDownEvent">
        <short>Type of OnMouseWheelUp/Down event handlers.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TMouseWheelUpDownEvent.Sender">
        <short>The control under the mouse.</short>
      </element>
      <element name="TMouseWheelUpDownEvent.Shift">
        <short>State of the modifier keys and mouse buttons.</short>
      </element>
      <element name="TMouseWheelUpDownEvent.MousePos">
        <short>The mouse position, in client coordinates.</short>
      </element>
      <element name="TMouseWheelUpDownEvent.Handled">
        <short>Set Handled to <b>True</b> when the event was handled.</short>
      </element>

      <element name="TGetDockCaptionEvent">
        <short>Specifies an event handler used to get the caption for a docked control.</short>
        <descr>
          <p>
            <var>TGetDockCaptionEvent</var> is an object procedure type which specifies an event handler used to get the caption for a docked control. It allows a value other than the Caption for a control to be displayed when a control is docked.
          </p>
          <p>
            Use <var>AControl</var> to examine properties for the docked control. Assign a value to the <var>ACaption</var> argument to set the docking caption for the control.
          </p>
          <p>
            <var>TGetDockCaptionEvent</var> is the type used to implement the <var>OnGetDockCaption</var> event handler in <var>TWinControl</var>. Applications must implement an object procedure using the signature for the type, and assign it to the property to allow responding to the event notification.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.OnGetDockCaption"/>
          <link id="TWinControl."/>
        </seealso>
      </element>
      <element name="TGetDockCaptionEvent.Sender">
        <short>TObject for the event notification.</short>
      </element>
      <element name="TGetDockCaptionEvent.AControl">
        <short>Control with the default caption value.</short>
      </element>
      <element name="TGetDockCaptionEvent.ACaption">
        <short>Caption to use for the docked control.</short>
      </element>

      <element name="TDragKind">
        <short>Indicates whether the control performs drag-drop or drag-dock.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDragKind.dkDrag">
        <short>Control is dragged for dropping.</short>
      </element>
      <element name="TDragKind.dkDock">
        <short>Control is dragged for docking.</short>
      </element>

      <element name="TDragMode">
        <short>Indicates whether dragging can start automatically.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDragMode.dmManual">
        <short>Dragging can start only by explicit code.</short>
      </element>
      <element name="TDragMode.dmAutomatic">
        <short>Dragging starts when the left mouse button is pressed on the control.</short>
      </element>

      <element name="TDragState">
        <short>Values representing State changes while dragging.</short>
        <descr>
          These values are sent in drag messages, allowing the control to perform special actions when the mouse moves over, enters, or leaves the control.
        </descr>
        <seealso/>
      </element>
      <element name="TDragState.dsDragEnter">
        <short>Mouse has just entered the control.</short>
      </element>
      <element name="TDragState.dsDragLeave">
        <short>Mouse has just left the control.</short>
      </element>
      <element name="TDragState.dsDragMove">
        <short>Mouse is moving over the control.</short>
      </element>

      <element name="TDragMessage">
        <short>Message types used in DragManager.</short>
        <descr>
          <p>
            All messages are sent to the target control, except dmDragDrop and dmDragCancel is sent to the source control.
          </p>
          <dl>
            <dt>dmDragEnter</dt>
            <dd>Mouse enters control</dd>
            <dt>dmDragLeave</dt>
            <dd>Mouse leaves control</dd>
            <dt>dmDragMove</dt>
            <dd>Mouse moves over control (after dmDragEnter)</dd>
            <dt>dmDragDrop</dt>
            <dd>Control dropped</dd>
            <dt>dmDragCancel</dt>
            <dd>Dragging aborted</dd>
            <dt>dmFindTarget</dt>
            <dd>Find child control under the mouse</dd>
          </dl>
        </descr>
      </element>
      <element name="TDragMessage.dmDragEnter">
        <short>mouse enters control.</short>
      </element>
      <element name="TDragMessage.dmDragLeave">
        <short>mouse leaves control.</short>
      </element>
      <element name="TDragMessage.dmDragMove">
        <short>mouse moves over control (after dmDragEnter).</short>
      </element>
      <element name="TDragMessage.dmDragDrop">
        <short>control dropped.</short>
      </element>
      <element name="TDragMessage.dmDragCancel">
        <short>dragging aborted.</short>
      </element>
      <element name="TDragMessage.dmFindTarget">
        <short>find possible target control under the mouse.</short>
      </element>

      <element name="TDragOverEvent">
        <short>The type of an OnDragOver handler.</short>
        <descr>
          <p>An OnDragOver event is sent by a control, when an object is dragged over it.
            The handler can specify whether a drop will be accepted or rejected.</p>
          <remark>
            <var>Source</var> is polymorphic, can be either the DragObject or the dragged control! This depends on DragObject.AutoCreated, for no sane reason.
          </remark>
        </descr>
        <seealso>
          <link id="TDockOverEvent"/>
        </seealso>
      </element>
      <element name="TDragOverEvent.Sender">
        <short>The possible drop target (control).</short>
      </element>
      <element name="TDragOverEvent.Source">
        <short>The object (TDragObject or TControl) being dragged.</short>
      </element>
      <element name="TDragOverEvent.X">
        <short>X coordinate of the mouse on screen.</short>
      </element>
      <element name="TDragOverEvent.Y">
        <short>Y coordinate of the mouse on screen.</short>
      </element>
      <element name="TDragOverEvent.State">
        <short>The current DragState (entering, leaving or moving over the target).</short>
      </element>
      <element name="TDragOverEvent.Accept">
        <short>Set Accept to <b>False</b> to reject an drop (default is <b>True</b>).</short>
      </element>

      <element name="TDragDropEvent">
        <short>The type of an OnDragDrop notification handler.</short>
        <descr>
          An OnDragDrop event is generated by the target control, on the drop of a dragged object.
        </descr>
        <seealso>
          <link id="TDockDropEvent"/>
          <link id="TEndDragEvent"/>
          <link id="TControl.OnDragDrop"/>
        </seealso>
      </element>
      <element name="TDragDropEvent.Sender">
        <short>The target control of the drop.</short>
      </element>
      <element name="TDragDropEvent.Source">
        <short>The dragged control.</short>
      </element>
      <element name="TDragDropEvent.X">
        <short>The <b>client</b> coordinates of the drop.</short>
      </element>
      <element name="TDragDropEvent.Y">
        <short>The <b>client</b> coordinates of the drop.</short>
      </element>

      <element name="TStartDragEvent">
        <short>The type of an OnStartDrag handler.</short>
        <descr>
          <p>
            An OnStartDrag event is generated for a control when it is dragged and its DragKind is dkDrag. The handler can provide a specific DragDrop object. Otherwise, a standard TDragDropObjectEx is automatically created by the DragManager.
          </p>
        </descr>
        <seealso>
          <link id="TStartDragEvent"/>
        </seealso>
      </element>
      <element name="TStartDragEvent.Sender">
        <short>The control to be dragged.</short>
      </element>
      <element name="TStartDragEvent.DragObject">
        <short>Supply your own DragObject, or leave it <b>Nil</b> for automatic creation.</short>
      </element>

      <element name="TEndDragEvent">
        <short>The type of an OnEndDrag handler.</short>
        <descr>
          <p>
            An OnEndDrag event is sent for a dragged control, when the drag operation is finished. This happens regardless of whether the operation was drag-drop or drag-dock, and whether the operation ended with a drop or was cancelled.
          </p>
          <p>
            Check for an unassigned value in Target  to distinguish between a drop and a cancelled operation (Nil).
          </p>
        </descr>
        <seealso>
          <link id="TDragDropEvent"/>
          <link id="TDockDropEvent"/>
        </seealso>
      </element>
      <element name="TEndDragEvent.Sender">
        <short>The dragged control.</short>
      </element>
      <element name="TEndDragEvent.Target">
        <short>The drop target (control), or <b>Nil</b> if cancelled.</short>
      </element>
      <element name="TEndDragEvent.X">
        <short>The mouse coordinate, in client coordinates if dropped, else in screen coordinates.</short>
      </element>
      <element name="TEndDragEvent.Y">
        <short>The mouse coordinate, in client coordinates if dropped, else in screen coordinates.</short>
      </element>

      <element name="TDragObject">
        <short>Base class for managing drag operations and user feedback.</short>
        <descr>
          <p>
            Every dragging operation has an associated DragObject, holding references to the source and target controls, and other parameters for the customization of the visual user feedback.
          </p>
          <p>
            A default <var>DragObject</var> is created automatically when a dragging operation starts, and is destroyed when the operation has ended;  you do not need to  maintain it. But an application can provide a customized <var>DragObject</var> in the <link id="TControl.OnStartDrag"/> or <link id="TControl.OnStartDock"/> handlers for the source control (the one being dragged).
          </p>
          <remark>
            AutoCreated DragObjects imply different behavior in the DragOver and DragDrop events, where the Source becomes the dragged control, while the DragObject itself is passed as Source.
          </remark>
          <p>
            <var>TDragObject</var> is the ancestor of a whole tree of dragging objects, with the main branches supporting either drag-drop or drag-dock operations. The type of the operation is determined using the <link id="TControl.DragKind"/> property in the source control.
          </p>
          <remark>
            In contrast to the Delphi implementation, Lazarus has moved a couple of methods into the drag performers; these methods are no longer available for customization.
          </remark>
          <p>
            A Lazarus DragObject mainly supplies the cursor and images, used in visual user feedback. Drag-drop operations typically signal acceptance of an possible drop by variations of the mouse cursor, and optionally can attach to it shapes of the dragged object(s). Drag-dock operations instead show a docking rectangle, that snaps to possible target locations when the mouse moves over docksites.
          </p>
        </descr>
        <seealso>
          <link id="TDragControlObject"/>
          <link id="TDragDockObject"/>
        </seealso>
      </element>

      <element name="TDragObject.FAlwaysShowDragImages"/>
      <element name="TDragObject.FDragPos"/>
      <element name="TDragObject.FControl"/>
      <element name="TDragObject.FDragTarget"/>
      <element name="TDragObject.FDragTargetPos"/>
      <element name="TDragObject.FAutoFree"/>
      <element name="TDragObject.FAutoCreated"/>
      <element name="TDragObject.FDropped"/>

      <element name="TDragObject.EndDrag">
        <short>Called when a dragging operation ends.</short>
        <descr>
          The default implementation calls Control.DoEndDrag, which in turn invokes an OnEndDrag handler.
        </descr>
      </element>
      <element name="TDragObject.EndDrag.Target">
        <short>The control onto which the dragged object is dropped (can be Nil).</short>
      </element>
      <element name="TDragObject.EndDrag.X">
        <short>Horizontal mouse coordinate when the method is called.</short>
      </element>
      <element name="TDragObject.EndDrag.Y">
        <short>Vertical mouse coordinate when the method is called.</short>
      </element>

      <element name="TDragObject.GetDragImages">
        <short>Returns a list of images for dragging.</short>
        <descr>
          <p>
            The returned <link id="TDragImageList"/> provides methods for the selection and display of an image shown while dragging. This implementation returns <b>Nil</b>, and must be overridden (e.g. in <var>TDragControlObject</var>).
          </p>
        </descr>
        <seealso>
          <link id="TDragControlObject"/>
        </seealso>
      </element>
      <element name="TDragObject.GetDragImages.Result">
        <short>The ImageList to use, is <b>Nil</b> by default!</short>
      </element>

      <element name="TDragObject.GetDragCursor">
        <short>Returns the dragging cursor type (shape).</short>
        <descr>
          In drag-drop operations the cursor signals acceptance or rejection of an drop, depending on Accepted.
        </descr>
        <seealso/>
      </element>
      <element name="TDragObject.GetDragCursor.Result">
        <short>The cursor to show.</short>
      </element>
      <element name="TDragObject.GetDragCursor.Accepted">
        <short>Which cursor to return (rejected:crNoDrop or accepted:crDrag).</short>
      </element>
      <element name="TDragObject.GetDragCursor.X">
        <short/>
      </element>
      <element name="TDragObject.GetDragCursor.Y">
        <short/>
      </element>

      <element name="TDragObject.Create">
        <short>Remembers the dragged control.</short>
        <descr/>
        <seealso>
          <link id="#rtl.system.TObject.Create">TObject.Create</link>
        </seealso>
      </element>
      <element name="TDragObject.Create.AControl">
        <short>The control being dragged.</short>
      </element>

      <element name="TDragObject.AutoCreate">
        <short>
          Special constructor which enforces destruction of the object at the end of the dragging operation.
        </short>
        <descr>
          <p>
            This constructor sets the <var>AutoCreated</var> and <var>AutoFree</var> flags. <var>AutoFree</var> is tested by the <var>DragManager</var> at the end of the dragging operation.
          </p>
        </descr>
      </element>
      <element name="TDragObject.AutoCreate.AControl">
        <short>The control being dragged.</short>
      </element>

      <element name="TDragObject.HideDragImage">
        <short>Asks the image list to hide the drag image.</short>
        <seealso>
          <link id="TDragObject.ShowDragImage"/>
        </seealso>
      </element>

      <element name="TDragObject.ShowDragImage">
        <short>Asks the image list to show the drag image.</short>
        <descr/>
        <seealso>
          <link id="TDragObject.HideDragImage"/>
        </seealso>
      </element>

      <element name="TDragObject.AlwaysShowDragImages">
        <short>Should the image of dragged objects always be shown?</short>
        <descr>
          This is another chance for enforcing the display of a drag image, even if a drop is acceptable.
        </descr>
        <seealso/>
      </element>

      <element name="TDragObject.AutoCreated">
        <short>Was the drag object created automatically?</short>
        <descr>This property is of little use, more important is the AutoFree property.</descr>
      </element>

      <element name="TDragObject.AutoFree">
        <short>Indicates whether the object shall be destroyed at the end of the dragging operation.</short>
        <descr>
          This is a Lazarus specific property, introduced to get rid of the special Delphi TDrag...Ex classes.
        </descr>
      </element>

      <element name="TDragObject.Control">
        <short>The control that is dragged (source).</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDragObject.DragPos">
        <short>Current mouse position in screen coordinates.</short>
        <seealso>
          <link id="TDragObject.DragTargetPos"/>
        </seealso>
      </element>

      <element name="TDragObject.DragTarget">
        <short>The control over which the object currently is dragged (target).</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDragObject.DragTargetPos">
        <short>Mouse position in client coordinates of the DragTarget.</short>
        <seealso>
          <link id="TDragObject.DragPos"/>
        </seealso>
      </element>

      <element name="TDragObject.Dropped">
        <short>Indicates whether the drag object has been dropped yet.</short>
        <descr>
          Contains <b>False</b> while dragging is in progress, or when dragging has been aborted.
        </descr>
      </element>

      <element name="TDragObjectClass">
        <short>A <link id="TDragObject"/> class type.</short>
      </element>
      <element name="TDragObjectEx">
        <short>A drag object that is automatically destroyed after use.</short>
        <seealso>
          <link id="TDragObject"/>
        </seealso>
      </element>

      <element name="TDragObjectEx">
        <short>Extends TDragObject to automatically free itself in the DragManager.</short>
        <descr>
          <p>
            <var>TDragObjectEx</var> is a <var>TDragObject</var> descendant. It provides an overridden constructor which sets the <var>AutoFree</var> property to <b>True</b>.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TDragObjectEx.Create">
        <short>Constructor for the class instance.</short>
        <descr>
          <p>
            <var>Create</var> is the overridden constructor for the class instance. Create sets the value in <var>AutoFree</var> to <b>True</b>. <var>AutoFree</var> is tested by the <var>DragManager</var> at the end of a dragging operation.
          </p>
        </descr>
        <seealso>
          <link id="TDragObject.AutoFree"/>
        </seealso>
      </element>
      <element name="TDragObjectEx.Create.AControl">
        <short>Control for the class instance.</short>
      </element>

      <element name="TDragControlObject">
        <short>A drag object for dragging a control.</short>
        <descr>
          <p>
            While a <var>TDragObject</var> can be used for dragging controls, this class <b>knows</b> that it drags a control, and asks it for a <var>DragCursor</var> and <var>DragImages</var>.
          </p>
        </descr>
        <seealso>
          <link id="TDragObject"/>
        </seealso>
      </element>

      <element name="TDragControlObject.GetDragCursor">
        <short>Asks the Control to provide a drag cursor.</short>
      </element>
      <element name="TDragControlObject.GetDragCursor.Result">
        <short/>
      </element>
      <element name="TDragControlObject.GetDragCursor.Accepted">
        <short/>
      </element>
      <element name="TDragControlObject.GetDragCursor.X">
        <short/>
      </element>
      <element name="TDragControlObject.GetDragCursor.Y">
        <short/>
      </element>

      <element name="TDragControlObject.GetDragImages">
        <short>Asks the Control to provide an ImageList.</short>
      </element>
      <element name="TDragControlObject.GetDragImages.Result">
        <short>The Image list to be used in dragging this control.</short>
      </element>
      <element name="TDragControlObjectEx" link="#lcl.controls.TDragControlObject"/>
      <element name="TDragControlObjectEx.Create">
        <short>Creates an object to be destroyed after use.</short>
      </element>
      <element name="TDragControlObjectEx.Create.AControl">
        <short>The control to drag.</short>
      </element>

      <element name="TDockOrientation">
        <short>Orientation of DockZones and docked controls, similar to <link id="TAlign"/></short>
        <descr>
          <p>
            This is a Delphi relic, bound to TDockTree and not very useful in application code. All <var>DockZones</var> in a <var>DockTree</var> have an orientation, horizontal or vertical, indicating how controls are arranged in the dock zone. When a control is docked into a zone, it obtains the orientation of that zone.
          </p>
          <remark>
            The orientation for the control can be stored as the opposite for the dock zone, depending on the DockManager used.
          </remark>
        </descr>
        <seealso/>
      </element>
      <element name="TDockOrientation.doNoOrient">
        <short>no orientation applies (like alNone).</short>
      </element>
      <element name="TDockOrientation.doHorizontal">
        <short>siblings are arranged horizontally, children top-to-bottom.</short>
      </element>
      <element name="TDockOrientation.doVertical">
        <short>siblings are arranged vertically, children left-to-right.</short>
      </element>
      <element name="TDockOrientation.doPages">
        <short>children are pages in a tabbed control.</short>
      </element>

      <element name="TDockDropEvent">
        <short>The type of an OnDockDrop handler.</short>
        <descr>
          <p>
            An OnDockDrop event is sent by the drop target (dock site) on the drop of a dragged object.
          </p>
        </descr>
        <seealso>
          <link id="TDragDropEvent"/>
        </seealso>
      </element>
      <element name="TDockDropEvent.Sender">
        <short>The drop target (docksite control).</short>
      </element>
      <element name="TDockDropEvent.Source">
        <short>The DragDock object, containing information about the dragged object.</short>
      </element>
      <element name="TDockDropEvent.X" link="#lcl.controls.TDragOverEvent.X">
        <short/>
      </element>
      <element name="TDockDropEvent.Y" link="#lcl.controls.TDragOverEvent.Y">
        <short/>
      </element>

      <element name="TDockOverEvent">
        <short>The type of an OnDockOver handler.</short>
        <descr>
          <p>
            An OnDockOver event is sent by a dock site, when an object is dragged over it. The handler can specify whether a drop will be accepted or rejected.
          </p>
        </descr>
        <seealso>
          <link id="TDragOverEvent"/>
        </seealso>
      </element>
      <element name="TDockOverEvent.Sender">
        <short>The possible drop target.</short>
      </element>
      <element name="TDockOverEvent.Source" link="#lcl.controls.TDockDropEvent.Source">
        <short/>
      </element>
      <element name="TDockOverEvent.X" link="#lcl.controls.TDragOverEvent.X">
        <short/>
      </element>
      <element name="TDockOverEvent.Y" link="#lcl.controls.TDragOverEvent.Y">
        <short/>
      </element>
      <element name="TDockOverEvent.State" link="#lcl.controls.TDragOverEvent.State">
        <short/>
      </element>
      <element name="TDockOverEvent.Accept" link="#lcl.controls.TDragOverEvent.Accept">
        <short/>
      </element>

      <element name="TUnDockEvent">
        <short>The type used for OnUnDock event handler.</short>
        <descr>
          <p>
            An UnDock event is sent by a dock site, before a control is undocked from it. The handler can reject undocking, by setting Allow to <b>False</b>.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TUnDockEvent.Sender">
        <short>The docksite from which the object is undocked.</short>
      </element>
      <element name="TUnDockEvent.Client">
        <short>The control to be undocked.</short>
      </element>
      <element name="TUnDockEvent.NewTarget">
        <short>The new docksite for Client, <b>Nil</b> when undocked into floating state.</short>
      </element>
      <element name="TUnDockEvent.Allow">
        <short>Set Allow to <b>False</b> to reject undocking.</short>
      </element>

      <element name="TStartDockEvent">
        <short>The type of an OnStartDock handler.</short>
        <descr>
          <p>
            An OnStartDock event is sent by a control when it shall be dragged and its DragKind is dkDock. The handler can provide a specific DragDock object, else a standard TDragDockObjectEx is automatically created by the DragManager.
          </p>
        </descr>
        <seealso>
          <link id="TStartDragEvent"/>
        </seealso>
      </element>
      <element name="TStartDockEvent.Sender">
        <short>The control being dragged.</short>
      </element>

      <element name="TStartDockEvent.DragObject">
        <short>Supply your own TDragDockObject, or leave it <b>Nil</b> to request automatic creation.</short>
      </element>

      <element name="TGetSiteInfoEvent">
        <short>An OnGetSiteInfo handler returns information about a docksite.</short>
        <descr>
          <p>
            An OnGetSiteInfo event is sent by the DragManager to all docksites. The handler can adjust the snapping rectangle (InfluenceRect), and can reject an drop.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TGetSiteInfoEvent.Sender">
        <short>The dock site near the mouse pointer.</short>
      </element>
      <element name="TGetSiteInfoEvent.DockClient">
        <short>The dragged control.</short>
      </element>
      <element name="TGetSiteInfoEvent.InfluenceRect">
        <short>The screen rectangle where a drop or mouse move is directed to this docksite.</short>
      </element>
      <element name="TGetSiteInfoEvent.MousePos">
        <short>The current position of the mouse.</short>
      </element>
      <element name="TGetSiteInfoEvent.CanDock">
        <short>Set CanDock to <b>False</b> to reject docking.</short>
      </element>

      <element name="TDrawDockImageEvent">
        <short>Event handler used to draw the docking image in a drag and dock operation.</short>
        <descr>
          <p>
            <var>TDrawDockImageEvent</var> is an object procedure type which specifies an event handler used to draw the docking image for TDragDockObject instances. <var>TDrawDockImageEvent</var> is the type used to implement the <var>OnDrawDockImage</var> variable in the <file>Controls</file> unit.
          </p>
        </descr>
        <seealso>
          <link id="OnDrawDockImage"/>
        </seealso>
      </element>
      <element name="TDrawDockImageEvent.Sender">
        <short/>
      </element>
      <element name="TDrawDockImageEvent.AOldRect">
        <short/>
      </element>
      <element name="TDrawDockImageEvent.ANewRect">
        <short/>
      </element>
      <element name="TDrawDockImageEvent.AOperation">
        <short/>
      </element>

      <element name="OnDrawDockImage">
        <short>Routine used to draw dock images in drag/dock operations </short>
        <descr>
          <p>
            <var>OnDrawDockImage</var> is a <var>TDrawDockImageEvent</var> variable which contains the default routine used to draw the docking image in a drag/dock operation. It is used in <var>TDragDockObject</var> methods which draw docking images likes <var>HideDockImage</var>, <var>ShowDockImage</var>, and <var>MoveDockInage</var>.
          </p>
        </descr>
        <seealso>
          <link id="TDragDockObject.ShowDockImage"/>
          <link id="TDragDockObject.HideDockImage"/>
          <link id="TDragDockObject.MoveDockImage"/>
        </seealso>
      </element>

      <element name="TDragDockObject">
        <short>A drag object for drag-dock.</short>
        <descr>
          <p>
            This object type serves two main purposes: it allows one to distinguish between drag-drop and drag-dock operations, and it implements docking specific information and behavior.
          </p>
          <p>
            The primary use is for tree docking, as assumed by methods in <var>TControl</var> and <var>TWinControl</var>.
          </p>
        </descr>
        <seealso>
          <link id="TDragObject"/>
        </seealso>
      </element>

      <element name="TDragDockObject.FDockOffset"/>
      <element name="TDragDockObject.FDockRect"/>
      <element name="TDragDockObject.FDropAlign"/>
      <element name="TDragDockObject.FDropOnControl"/>
      <element name="TDragDockObject.FEraseDockRect"/>
      <element name="TDragDockObject.FFloating"/>
      <element name="TDragDockObject.FIncreaseDockArea"/>

      <element name="TDragDockObject.AdjustDockRect">
        <short>Adjust the DockRect relative to the dragging hotspot (DockOffset).</short>
        <descr>
          <remark>
            The parameter type is bad, should be <b>var</b>. Ignore it please.
          </remark>
          <p>
            The default implementation adjusts the stored FDockRect, by DockOffset.
            This adjustment will make the DockRect appear right over the control, when dragging starts, regardless of where the user clicked onto the control.
          </p>
          <p>
            You'll rarely have to override this method, since the DockRect is adjusted by every target site's DockManager later.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TDragDockObject.AdjustDockRect.ARect">
        <short>Not used; please ignore it.</short>
      </element>

      <element name="TDragDockObject.GetDragCursor">
        <short>Gets the drag cursor shape for the class instance.</short>
        <descr/>
        <seealso>
          <link id="TDragObject.GetDragCursor"/>
        </seealso>
      </element>
      <element name="TDragDockObject.GetDragCursor.Result">
        <short/>
      </element>
      <element name="TDragDockObject.GetDragCursor.Accepted">
        <short/>
      </element>
      <element name="TDragDockObject.GetDragCursor.X">
        <short/>
      </element>
      <element name="TDragDockObject.GetDragCursor.Y">
        <short/>
      </element>

      <element name="TDragDockObject.EndDrag">
        <short>Finish docking.</short>
        <descr>Invokes Control.DoEndDock.</descr>
        <seealso>
          <link id="TControl.DoEndDock"/>
        </seealso>
      </element>
      <element name="TDragDockObject.EndDrag.Target">
        <short>The target docksite, or <b>Nil</b> to make the Control float.</short>
      </element>
      <element name="TDragDockObject.EndDrag.X">
        <short/>
      </element>
      <element name="TDragDockObject.EndDrag.Y">
        <short/>
      </element>

      <element name="TDragDockObject.InitDock">
        <short>Initializes the dragging coordinates.</short>
        <descr>
          <p>
            Determines the hotspot offset for adjusting the floating DockRect. Since the undocked extent of the control doesn't change while dragging, we fix the hotspot offset here.
          </p>
          <p>Usage:</p>
          <code>OffsetRect(DockRect, FDockOffset);</code>
        </descr>
      </element>
      <element name="TDragDockObject.InitDock.APosition">
        <short/>
      </element>

      <element name="TDragDockObject.ShowDockImage">
        <short>Shows the DockRect, remembers the coordinates in EraseDockRect.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDragDockObject.HideDockImage">
        <short>Hides the DockRect, invalidates EraseDockRect to prevent further erases.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDragDockObject.MoveDockImage">
        <short>Moves an already visible DockRect.</short>
        <descr>
          <p>Checks the DockRect for changes against EraseDockRect, to prevent flicker.</p>
          <p>Remembers the drawn frame coordinates in EraseDockRect.</p>
        </descr>
      </element>

      <element name="TDragDockObject.HasOnDrawImage">
         <short>Checks for an assigned OnDrawDockImage event handler.</short>
        <descr>
          <p>
            <var>HasOnDrawImage</var> is a <var>Boolean</var> function used to determine if an event handler has been assigned to the <var>OnDrawDockImage</var> property. The return value is <b>True</b> if a routine has been assigned to the property. If an event handler has not been supplied,  the <var>HintDockImage</var> routine is assigned to the event handler, and the return value is set to <b>True</b>.
          </p>
          <p>
            For platforms where the Alpha blending is not enabled for Forms, the return value is always <b>False</b> (determined by calling <var>GetSystemMetrics</var> for the <var>SM_LCLHasFormAlphaBlend</var> metric in the widgetset class).
          </p>
          <p>
            <var>HasOnDrawImage</var> is used in methods like <var>ShowDockImage</var>, <var>HideDockImage</var>, and <var>MoveDockImage</var>.
          </p>
        </descr>
        <seealso>
          <link id="TDragDockObject.ShowDockImage"/>
          <link id="TDragDockObject.HideDockImage"/>
          <link id="TDragDockObject.MoveDockImage"/>
        </seealso>
      </element>
      <element name="TDragDockObject.HasOnDrawImage.Result">
         <short><b>True</b> when an event handler has been assigned to OnDrawDockImage.</short>
      </element>

      <element name="TDragDockObject.DockOffset">
        <short>The hotspot offset of the dragged DockRect.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDragDockObject.DockRect">
        <short>Screen coordinates for a possible drop location.</short>
        <descr>
          <p>
            <var>DockRect</var> gives feedback to the user where the dragged control may be dropped. When no docksite signals acceptance, the DockRect uses the floating state of the dragged control. When a drop will dock the control, the DockRect signifies the approximate position for the docked control.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TDragDockObject.DropAlign">
        <short>How the dragged control will be docked, relative to the target control.</short>
        <descr>
          <p>
            When the target is a DockTree, DropAlign indicates the placement of the control relative to DropOnControl. Other docking methods require a specialized (derived) DragDockObject.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TDragDockObject.DropOnControl">
        <short>
          The already docked control, relative to which the dragged control will be docked. <b>Nil</b> for an empty docksite.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDragDockObject.Floating">
        <short>The final state of the dragged control (after drop).</short>
        <descr><b>True</b> when the dragged control becomes or stays floating.</descr>
        <seealso/>
      </element>

      <element name="TDragDockObject.IncreaseDockArea">
        <short>Determines whether the dock site shall be enlarged.</short>
        <descr>Not normally used, perhaps a special AnchorDocking property?</descr>
        <seealso/>
      </element>

      <element name="TDragDockObject.EraseDockRect">
         <short>Area to be erased when refreshing the display for the docking rectangle.</short>
        <descr>
          <p>
            <var>EraseDockRect</var> is a <var>TRect</var> property that represents the area to be erased when redrawing the docking rectangle. The value in EraseDockRect is assigned in InitDock, and updated to contain the value from DockRect when the docking rectangle has been altered in methods like ShowDockImage, HideDockImage, and MoveDockImage.
          </p>
          <p>
            EraseDockRect is passed as an argument to OnDrawDockImage, and to the underlying widgetset class.
          </p>
        </descr>
        <seealso>
          <link id="TDragDockObject.DockRect"/>
          <link id="TDragDockObject.InitDock"/>
          <link id="TDragDockObject.ShowDockImage"/>
          <link id="TDragDockObject.HideDockImage"/>
          <link id="TDragDockObject.MoveDockImage"/>
        </seealso>
      </element>

      <element name="TDragDockObjectEx">
        <short>A drag object for docking that is automatically destroyed after use.</short>
      </element>

      <element name="TDragDockObjectEx.Create">
        <short>Creates an object to be destroyed after use.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDragDockObjectEx.Create.AControl">
        <short/>
      </element>

      <element name="TDragManager">
        <short>
          The abstract base class used to manage dragging of controls (for drop or dock operations).
        </short>
        <descr>
          <p>
            TDragManager specifies an object-oriented version of the Delphi drag manager. It is implemented by the TDragManagerDefault descendant.
          </p>
          <remark>
            The registered dock sites should be stored in a persistent list, not in a DragManager instance.
          </remark>
        </descr>
        <seealso/>
      </element>

      <element name="TDragManager.FDragImmediate"/>
      <element name="TDragManager.FDragThreshold"/>

      <element name="TDragManager.KeyUp">
        <short>Handler for keyboard key released.</short>
        <descr>When the Ctrl key is released, a drop is enabled again.</descr>
        <seealso/>
      </element>
      <element name="TDragManager.KeyUp.Key">
        <short/>
      </element>
      <element name="TDragManager.KeyUp.Shift">
        <short/>
      </element>

      <element name="TDragManager.KeyDown">
        <short>Handler for keyboard key pressed.</short>
        <descr>
          <p>When (and while) the Ctrl key is pressed, dropping is disabled.</p>
          <p>The Esc key aborts the current dragging operation immediately.</p>
        </descr>
        <seealso/>
      </element>
      <element name="TDragManager.KeyDown.Key">
        <short/>
      </element>
      <element name="TDragManager.KeyDown.Shift">
        <short/>
      </element>

      <element name="TDragManager.CaptureChanged">
        <short>Aborts the dragging operation, when the capturing control has changed.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDragManager.CaptureChanged.OldCaptureControl">
        <short/>
      </element>

      <element name="TDragManager.MouseMove">
        <short>Generates visual feedback for mouse movement in a drag operation.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDragManager.MouseMove.Shift">
        <short/>
      </element>
      <element name="TDragManager.MouseMove.X">
        <short/>
      </element>
      <element name="TDragManager.MouseMove.Y">
        <short/>
      </element>

      <element name="TDragManager.MouseUp">
        <short>Ends dragging.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDragManager.MouseUp.Button">
        <short/>
      </element>
      <element name="TDragManager.MouseUp.Shift">
        <short/>
      </element>
      <element name="TDragManager.MouseUp.X">
        <short/>
      </element>
      <element name="TDragManager.MouseUp.Y">
        <short/>
      </element>

      <element name="TDragManager.MouseDown">
        <short>NOP.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDragManager.MouseDown.Button">
        <short/>
      </element>
      <element name="TDragManager.MouseDown.Shift">
        <short/>
      </element>
      <element name="TDragManager.MouseDown.X">
        <short/>
      </element>
      <element name="TDragManager.MouseDown.Y">
        <short/>
      </element>

      <element name="TDragManager.Create">
        <short>Initializes the Delphi default dragging parameters.</short>
        <descr>
          <p>The Delphi VCL sets DragImmediate=<b>True</b> and DragThreshold=5.</p>
          <remark>A docking operation never should start immediately.</remark>
        </descr>
      </element>
      <element name="TDragManager.Create.TheOwner">
        <short/>
      </element>

      <element name="TDragManager.IsDragging">
        <short>Check if dragging is in progress.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDragManager.IsDragging.Result">
        <short><b>True</b> if dragging.</short>
      </element>

      <element name="TDragManager.Dragging">
        <short><b>True</b> if the specified control is being dragged.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDragManager.Dragging.Result">
        <short/>
      </element>
      <element name="TDragManager.Dragging.AControl">
        <short/>
      </element>

      <element name="TDragManager.RegisterDockSite">
        <short>Adds the control to the list of registered docking sites.</short>
        <descr>
          <remark>
            This should become a class method, maintaining the list of registered docking sites outside any DragManager instance.
          </remark>
        </descr>
        <seealso/>
      </element>
      <element name="TDragManager.RegisterDockSite.Site">
        <short>The DockSite to register.</short>
      </element>
      <element name="TDragManager.RegisterDockSite.DoRegister">
        <short><b>True</b> for adding, <b>False</b> for removing the site.</short>
      </element>

      <element name="TDragManager.DragStart">
        <short>Starts dragging a control.</short>
        <descr>
          <p>
            A DragObject must be created, depending on the Control.DragKind. The mouse has to be captured, and visual feedback must be initialized.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TDragManager.DragStart.AControl">
        <short>The control that initiates the drag operation.</short>
      </element>
      <element name="TDragManager.DragStart.AImmediate">
        <short> <b>False</b> when dragging should start only when the mouse is moved (delayed).</short>
      </element>
      <element name="TDragManager.DragStart.AThreshold">
        <short>How much the mouse must move before delayed dragging starts.</short>
      </element>

      <element name="TDragManager.DragMove">
        <short>Updates the visual dragging feedback.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDragManager.DragMove.APosition">
        <short>Mouse position in <b>screen</b> coordinates.</short>
      </element>

      <element name="TDragManager.DragStop">
        <short>Ends dragging.</short>
        <descr>
          <p>The visual feedback is reset.</p>
          <p>
            All related controls are notified of the outcome of the operation (drop, dock, abort).
          </p>
          <p>Finally all temporary objects are destroyed.</p>
        </descr>
        <seealso/>
      </element>
      <element name="TDragManager.DragStop.ADrop">
        <short> <b>False</b> when dragging was aborted.</short>
      </element>

      <element name="TDragManager.CanStartDragging">
         <short>
           Indicates if the mouse coordinates are within the drag threshold for the specified control.
        </short>
        <descr>
          <p>
            <var>CanStartDragging</var> is an abstract virtual <var>Boolean</var> function used to determine if the mouse has been moved beyond the threshold that initiates a drag operation. The result is <b>True</b> when the mouse coordinates in X and Y are located within the client rectangle and threshold for the specified control in <var>Site</var>.
          </p>
          <p>
            CanStartDragging must be implemented in a descendent class, like <var>TDragManagerDefault</var>.
          </p>
        </descr>
        <seealso>
        </seealso>
      </element>
      <element name="TDragManager.CanStartDragging.Result">
        <short/>
      </element>
      <element name="TDragManager.CanStartDragging.Site">
        <short/>
      </element>
      <element name="TDragManager.CanStartDragging.AThreshold">
        <short/>
      </element>
      <element name="TDragManager.CanStartDragging.X">
        <short/>
      </element>
      <element name="TDragManager.CanStartDragging.Y">
        <short/>
      </element>

      <element name="TDragManager.DragImmediate">
        <short>Start dragging immediately, on MouseDown?</short>
        <descr>This is the default value for e.g. BeginDrag.</descr>
        <seealso/>
      </element>

      <element name="TDragManager.DragThreshold">
        <short>
          The threshold amount for mouse movement before delayed dragging starts (default is 5 pixels).
        </short>
        <seealso/>
      </element>

      <element name="DragManager">
        <short>The current DragManager (always TDragManagerDefault).</short>
        <descr>
          <remark>
            A <var>DragManager</var> must be implemented in the <file>Controls</file> unit; it requires access to private members in the classes declared in the unit.
          </remark>
        </descr>
        <seealso>
          <link id="TDragManager"/>
        </seealso>
      </element>

      <element name="TDockManager">
        <short>The layout manager for a docksite.</short>
        <descr>
          <p>
            <var>TDockManager</var> is an abstract class for managing the controls on a dock site. Every docksite can have a DockManager, which arranges the docked controls. See <link id="TDockTree">TDockTree</link> for more info.
          </p>
        </descr>
        <seealso>
          <link id="TDockTree"/>
        </seealso>
      </element>

      <element name="TDockManager.Create">
        <short>Creates an DockManager for ADockSite.</short>
      </element>
      <element name="TDockManager.Create.ADockSite">
        <short>This is the TWinControl acting as the docksite.</short>
      </element>

      <element name="TDockManager.BeginUpdate">
        <short>Starts updating the DockSite layout.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDockManager.EndUpdate">
        <short>Finishes updating the DockSite layout.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDockManager.GetControlBounds">
        <short>Returns the zone bounds of a docked control.</short>
        <descr>
          <p>
            The TDockTree manager returns the bounds of the dockzone, including the dock header.
          </p>
          <p>
            When the Control is not docked, an empty Rect(0,0,0,0) is returned.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TDockManager.GetControlBounds.Control">
        <short>The docked control.</short>
      </element>
      <element name="TDockManager.GetControlBounds.AControlBounds">
        <short>The enclosing rectangle, in client coordinates of the docksite.</short>
      </element>

      <element name="TDockManager.GetDockEdge">
        <short>Determine the DropAlign.</short>
        <descr>
          <p>
            ADockObject contains valid DragTarget, DragPos and DragTargetPos relative dock site. DockRect is undetermined.
          </p>
          <p>
            DropOnControl may be <b>Nil</b> if nothing has been docked yet, or no target control exists at the mouse coordinates.
          </p>
          <p>
            Returns <b>True</b> if ADockObject.DropAlign has been determined. If <b>False</b>, the DropAlign has to be determined by default procedures.
          </p>
        </descr>
      </element>
      <element name="TDockManager.GetDockEdge.Result">
        <short><b>True</b> if the DropAlign was determined.</short>
      </element>
      <element name="TDockManager.GetDockEdge.ADockObject">
        <short>The DragDockObject holding all information about the drag-dock operation.</short>
      </element>

      <element name="TDockManager.InsertControl">
        <short>
          Position <var>DropCtl</var> relative <var>Control</var>, using the alignment specified by <var>InsertAt</var>.
        </short>
        <descr>
          <p>
            InsertControl determines the placement of the just docked control, forcing a repaint of the container control if necessary.
          </p>
          <remark>
            When SetReplacingControl has been called with a non-Nil Control before, the dropped control only should replace that control.
          </remark>
          <p>
            An overloaded version passes the DragDockObject to the dockmanager, allowing to pass more information about the drop. It allows one to implement other than tree-style docksites.
          </p>
        </descr>
        <seealso>
          <link id="TDockManager.RemoveControl"/>
        </seealso>
      </element>
      <element name="TDockManager.InsertControl.Control">
        <short>The control relative to which insert.</short>
      </element>
      <element name="TDockManager.InsertControl.InsertAt">
        <short>How to insert relative to Control.</short>
      </element>
      <element name="TDockManager.InsertControl.DropCtl">
        <short>The control to insert.</short>
      </element>
      <element name="TDockManager.InsertControl.ADockObject">
        <short>The DragDockObject holding all information about the drag-dock operation.</short>
      </element>

      <element name="TDockManager.LoadFromStream">
        <short>Restores the layout of the docksite from the specified stream.</short>
        <descr>
          <p>
            The controls to be docked can be retrieved by using <var>ReloadDockedControl</var> in the docksite. This method returns only existing controls of the given name, owned by the owner of the docksite, by default.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.ReloadDockedControl"/>
          <link id="TDockManager.SaveToStream"/>
        </seealso>
      </element>
      <element name="TDockManager.LoadFromStream.Stream">
        <short>The stream with the layout information.</short>
      </element>

      <element name="TDockManager.MessageHandler">
        <short>Handles the messages sent to a docksite.</short>
        <descr>
          <p>
            This handler must handle all mouse messages, related to the client area of the docksite that is not covered by docked controls (dock headers, et. al.).
          </p>
          <p>
            Handling mouse messages while dragging is not required. Painting of the docksite has to be implemented in PaintSite.
          </p>
        </descr>
        <seealso>
          <link id="TDockManager.PaintSite"/>
        </seealso>
      </element>
      <element name="TDockManager.MessageHandler.Sender">
        <short/>
      </element>
      <element name="TDockManager.MessageHandler.Message">
        <short>The message to be processed.</short>
      </element>

      <element name="TDockManager.PaintSite">
        <short>Handles special painting of the docksite.</short>
        <descr>
          <p>
            While the docked controls paint themselves, the eventual dockheaders and other decorations have to be painted by the DockManager.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TDockManager.PaintSite.DC">
        <short>The device context, used to paint.</short>
      </element>

      <element name="TDockManager.PositionDockRect">
        <short>Determines the DockRect while dragging a control over the docksite.</short>
        <descr>
          <p>
            This method updates DockRect to provide visual feedback when a control is dragged over the docksite. The initial DragDockObject.DockRect spans the entire DockSite.
          </p>
          <p>
            The Delphi-compatible version only can use the parameters determined by the default processing in the docksite.
          </p>
          <p>
            The Lazarus version can update the DockObject with better-suited parameters. A DockManager here can implement any algorithm for the placement of a dropped control. The default implementation calls the Delphi compatible version. When you override the Lazarus version, you may have to determine the dock sibling and DropAlign again, when the default determination (in TControl and TWinControl) is inappropriate.
          </p>
        </descr>
        <seealso>
          <link id="TDragDockObject"/>
        </seealso>
      </element>
      <element name="TDockManager.PositionDockRect.Client">
        <short>The dropped control.</short>
      </element>
      <element name="TDockManager.PositionDockRect.DropCtl">
        <short>
          The control relative to which Client shall be docked; <b>Nil</b> for docking into the docksite.
        </short>
      </element>
      <element name="TDockManager.PositionDockRect.DropAlign">
        <short>How to dock, relative to DropCtl.</short>
      </element>
      <element name="TDockManager.PositionDockRect.DockRect">
        <short>The screen rectangle of the docksite, to be adjusted by this method.</short>
      </element>
      <element name="TDockManager.PositionDockRect.ADockObject">
        <short>The DragDockObject holding all information about the drag-dock operation.</short>
      </element>

      <element name="TDockManager.RemoveControl">
        <short>Removes the undocked control from the docksite layout.</short>
        <descr>
          <p>
            When <var>SetReplacingControl</var> has been called with a non-<b>Nil</b> argument before, the layout of the docksite should not be changed. Instead, the next inserted control should take the place and role of this control.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TDockManager.RemoveControl.Control">
        <short>Control to remove.</short>
      </element>

      <element name="TDockManager.ResetBounds">
        <short><var>ResetBounds</var> refreshes the layout of the docksite.</short>
        <descr>
          <p>
            This method typically notifies the DockManager when the DockSite calls its Resize method. When the extent of the docksite has changed, the DockManager should reposition and resize all docked controls accordingly.
          </p>
          <p>
            The layout always should be refreshed when <var>Force</var> is <b>True</b>. This is required when e.g. the visibility of docked controls has changed, but not the size of the docksite.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TDockManager.ResetBounds.Force">
        <short>When <b>True</b>, always update the layout.</short>
      </element>

      <element name="TDockManager.SaveToStream">
        <short>Saves the docksite layout to <var>Stream</var>.</short>
        <descr/>
        <seealso>
          <link id="TDockManager.LoadFromStream"/>
        </seealso>
      </element>
      <element name="TDockManager.SaveToStream.Stream">
        <short>Write the layout information into this stream.</short>
      </element>

      <element name="TDockManager.SetReplacingControl">
        <short>Specifies the control to be replaced subsequently.</short>
        <descr>
          <p>
            This method is called by <var>ReplaceDockedControl</var>, to announce a pending replacement of <var>Control</var> by another control. The next <var>RemoveControl</var> should be ignored, and <var>InsertControl</var> should only exchange the controls, without reorganizing the layout of the docksite. When <var>Control</var> is <b>Nil</b>, this call signals the end of the exchange [obsolete].
          </p>
          <remark>
            The name "SetReplacingControl" is a misnomer, it should read "SetControlToBeReplaced".
          </remark>
          <p>
            The intended purpose of this method is the replacement of a docked control by a Notebook, preserving the DockZone. This operation should be handled by an DockManager internally, and calls to this method should be ignored.
          </p>
        </descr>
        <seealso>
          <link id="TDockManager.InsertControl"/>
          <link id="TDockManager.RemoveControl"/>
        </seealso>
      </element>
      <element name="TDockManager.SetReplacingControl.Control">
        <short>The control to be replaced later.</short>
      </element>

      <element name="TDockManager.AutoFreeByControl">
        <short>Returns <b>True</b> if the DockManager should be destroyed together with the docksite.</short>
        <descr>
          <p>
            This is a Lazarus-specific extension of the Delphi TDockManager. It allows multiple docksites to share the same DockManager instance.
          </p>
        </descr>
      </element>
      <element name="TDockManager.AutoFreeByControl.Result">
        <short><b>True</b> if the DockManager should be destroyed together with the docksite.</short>
      </element>

      <element name="TDockManager.IsEnabledControl">
        <short>
          Determines whether the specified control is a windowed control using the current dock manager.
        </short>
        <descr>
          When the return value is <b>True</b>, the Control can be docked using the dock manager.
        </descr>
        <seealso/>
      </element>
      <element name="TDockManager.IsEnabledControl.Result">
        <short><b>True</b> when Control can be docked using the dock manager.</short>
      </element>
      <element name="TDockManager.IsEnabledControl.Control">
        <short>Control examined in the method.</short>
      </element>

      <element name="TDockManagerClass">
        <short>
          The DockManager class type, for use when a DockManager is automatically created.
        </short>
        <seealso>
          <link id="TWinControl.CreateDockManager"/>
          <link id="DefaultDockManagerClass"/>
        </seealso>
      </element>

      <element name="TConstraintSize">
        <short>Range for control size constraints.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TSizeConstraintsOption">
         <short>Enumerated type with options used in TSizeConstraints.</short>
        <descr>
          Not used in the current LCL Implementation.
        </descr>
        <seealso/>
      </element>
      <element name="TSizeConstraintsOption.scoAdviceWidthAsMin">
        <short/>
      </element>
      <element name="TSizeConstraintsOption.scoAdviceWidthAsMax">
        <short/>
      </element>
      <element name="TSizeConstraintsOption.scoAdviceHeightAsMin">
        <short/>
      </element>
      <element name="TSizeConstraintsOption.scoAdviceHeightAsMax">
        <short/>
      </element>

      <element name="TSizeConstraintsOptions">
        <short>Set type used to store values from the TSizeConstraintsOption enumeration.</short>
        <descr/>
        <seealso>
          <link id="TSizeConstraintsOption"/>
        </seealso>
      </element>

      <element name="TSizeConstraints">
        <short>Holds maximum and minimum values that can be used in sizing objects.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TSizeConstraints.FControl"/>
      <element name="TSizeConstraints.FMaxHeight"/>
      <element name="TSizeConstraints.FMaxInterfaceHeight"/>
      <element name="TSizeConstraints.FMaxInterfaceWidth"/>
      <element name="TSizeConstraints.FMaxWidth"/>
      <element name="TSizeConstraints.FMinHeight"/>
      <element name="TSizeConstraints.FMinInterfaceHeight"/>
      <element name="TSizeConstraints.FMinInterfaceWidth"/>
      <element name="TSizeConstraints.FMinWidth"/>
      <element name="TSizeConstraints.FOnChange"/>
      <element name="TSizeConstraints.FOptions"/>

      <element name="TSizeConstraints.SetOptions">
         <short>Sets the value for the Options property.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TSizeConstraints.SetOptions.AValue">
         <short>New value for the Options property.</short>
      </element>

      <element name="TSizeConstraints.Change">
        <short>Calls an OnChange handler if assigned.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TSizeConstraints.AssignTo">
        <short>Copies property values to the specified persistent object.</short>
        <descr/>
        <seealso>
          <link id="#rtl.classes.TPersistent.Assign">TPersistent.Assign</link>
        </seealso>
      </element>
      <element name="TSizeConstraints.AssignTo.Dest">
        <short>Persistent object where property values are stored.</short>
      </element>

      <element name="TSizeConstraints.SetMaxHeight">
        <short>Sets the value for the MaxHeight property.</short>
        <descr/>
        <seealso>
          <link id="TSizeConstraints.MaxHeight"/>
        </seealso>
      </element>
      <element name="TSizeConstraints.SetMaxHeight.Value">
        <short>New value for the MaxHeight property.</short>
      </element>

      <element name="TSizeConstraints.SetMaxWidth">
        <short>Sets the value for the MaxWidth property.</short>
        <descr/>
        <seealso>
          <link id="TSizeConstraints.MaxWidth"/>
        </seealso>
      </element>
      <element name="TSizeConstraints.SetMaxWidth.Value">
        <short>New value for the MaxWidth property.</short>
      </element>

      <element name="TSizeConstraints.SetMinHeight">
        <short>Sets the value for the MinHeight property.</short>
        <descr/>
        <seealso>
          <link id="TSizeConstraints.MinHeight"/>
        </seealso>
      </element>
      <element name="TSizeConstraints.SetMinHeight.Value">
        <short>New value for the MinHeight property.</short>
      </element>

      <element name="TSizeConstraints.SetMinWidth">
        <short>Sets the value for the MinWidth property.</short>
        <descr/>
        <seealso>
          <link id="TSizeConstraints.MinWidth"/>
        </seealso>
      </element>
      <element name="TSizeConstraints.SetMinWidth.Value">
        <short>New value for the MinWidth property.</short>
      </element>

      <element name="TSizeConstraints.Create">
         <short>Constructor for the class instance.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TSizeConstraints.Create.AControl">
         <short>TControl instance where the size constraints are applied.</short>
      </element>

      <element name="TSizeConstraints.UpdateInterfaceConstraints">
        <short>Asks the interface for size constraints.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TSizeConstraints.SetInterfaceConstraints">
        <short>Used by the interface to set the interface constraints.</short>
        <descr>Should only be used by custom components, not by applications.</descr>
        <seealso/>
      </element>
      <element name="TSizeConstraints.SetInterfaceConstraints.MinW">
        <short/>
      </element>
      <element name="TSizeConstraints.SetInterfaceConstraints.MinH">
        <short/>
      </element>
      <element name="TSizeConstraints.SetInterfaceConstraints.MaxW">
        <short/>
      </element>
      <element name="TSizeConstraints.SetInterfaceConstraints.MaxH">
        <short/>
      </element>

      <element name="TSizeConstraints.EffectiveMinWidth">
        <short>Determines the minimum applicable width, given the local and interface constraints.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TSizeConstraints.EffectiveMinWidth.Result">
        <short>Zero means no constraints.</short>
      </element>

      <element name="TSizeConstraints.EffectiveMinHeight">
        <short>Determines the minimum applicable height, given the local and interface constraints.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TSizeConstraints.EffectiveMinHeight.Result">
        <short>Zero means no constraints.</short>
      </element>

      <element name="TSizeConstraints.EffectiveMaxWidth">
        <short>Determines the maximum applicable width, given the local and interface constraints.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TSizeConstraints.EffectiveMaxWidth.Result">
        <short>Zero means no constraints.</short>
      </element>

      <element name="TSizeConstraints.EffectiveMaxHeight">
        <short>Determines the maximum applicable height, given the local and interface constraints.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TSizeConstraints.EffectiveMaxHeight.Result">
        <short>Zero means no constraints.</short>
      </element>

      <element name="TSizeConstraints.MinMaxWidth">
        <short>Determines the constrained Width, and transfers it to the widget.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TSizeConstraints.MinMaxWidth.Result">
        <short>The constrained width.</short>
      </element>
      <element name="TSizeConstraints.MinMaxWidth.Width">
        <short>The suggested width.</short>
      </element>

      <element name="TSizeConstraints.MinMaxHeight">
        <short>Determines the constrained Height, and transfers it to the widget.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TSizeConstraints.MinMaxHeight.Result">
        <short>The constrained height.</short>
      </element>
      <element name="TSizeConstraints.MinMaxHeight.Height">
        <short>The suggested height.</short>
      </element>

      <element name="TSizeConstraints.AutoAdjustLayout">
        <short>
          Adjusts width and height values in the class using the specified scaling factors.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TSizeConstraints.AutoAdjustLayout.AXProportion">
        <short>Scaling factor applied to width values.</short>
      </element>
      <element name="TSizeConstraints.AutoAdjustLayout.AYProportion">
        <short>Scaling factor applied to height values.</short>
      </element>

      <element name="TSizeConstraints.MaxInterfaceHeight">
        <short>The maximum height allowed by the widget.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TSizeConstraints.MaxInterfaceWidth">
        <short>The maximum width allowed by the widget.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TSizeConstraints.MinInterfaceHeight">
        <short>The minimum height allowed by the widget.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TSizeConstraints.MinInterfaceWidth">
        <short>The minimum width allowed by the widget.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TSizeConstraints.Control">
        <short>The <var>Control</var> to which these constraints apply.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TSizeConstraints.Options">
        <short>Options used to determine the size constraints.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TSizeConstraints.OnChange">
        <short>Event handler for a change in the constraints.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TSizeConstraints.MaxHeight">
        <short>The maximum height.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TSizeConstraints.MaxWidth">
        <short>The maximum width.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TSizeConstraints.MinHeight">
        <short>The minimum height.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TSizeConstraints.MinWidth">
        <short>The minimum width.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TConstrainedResizeEvent">
        <short>Specifies an event handler signalled to resize a control to the specified size constraints.</short>
        <descr>
          <p>
            <var>TConstrainedResizeEvent</var> is an object procedure type that specifies an event handler signalled to resize a control to the specified size constraints. Used to implement the <var>OnConstrainedResize</var> event in <var>TControl</var>.
          </p>
        </descr>
        <seealso>
          <link id="TControl.OnConstrainedResize"/>
        </seealso>
      </element>
      <element name="TConstrainedResizeEvent.Sender">
        <short>TObject for the event notification.</short>
      </element>
      <element name="TConstrainedResizeEvent.MinWidth">
        <short/>
      </element>
      <element name="TConstrainedResizeEvent.MinHeight">
        <short/>
      </element>
      <element name="TConstrainedResizeEvent.MaxWidth">
        <short/>
      </element>
      <element name="TConstrainedResizeEvent.MaxHeight">
        <short/>
      </element>

      <element name="TSpacingSize">
        <short>Alias to the Integer type.</short>
        <descr>
          <p>
            <var>TSpacingSize</var> is an alias to the <var>Integer</var> type. TSpacingSize is used for values that represent spacing around or between controls. TSpacingSize is the type used to implement properties in <var>TControlBorderSpacingDefault</var> and <var>TControlBorderSpacing</var>.
          </p>
        </descr>
        <seealso>
          <link id="TControlBorderSpacingDefault"/>
          <link id="TControlBorderSpacing"/>
          <link id="TControl.AnchorAsAlign"/>
          <link id="TControl.AnchorClient"/>
          <link id="TControl.AnchorParallel"/>
          <link id="TControl.AnchorToCompanion"/>
          <link id="TControl.AnchorToNeighbour"/>
        </seealso>
      </element>

      <element name="TControlCellAlign">
        <short>Modes for aligning a control in a table cell.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlCellAlign.ccaFill">
        <short>Cause the cell to fill the available space for the cell.</short>
      </element>

      <element name="TControlCellAlign.ccaLeftTop">
        <short>Cell is aligned to the Left and Top coordinates.</short>
      </element>

      <element name="TControlCellAlign.ccaRightBottom">
        <short>Cell is aligned to the Right and Bottom coordinates.</short>
      </element>

      <element name="TControlCellAlign.ccaCenter">
        <short>Cell is aligned to the center of the its width and height.</short>
      </element>

      <element name="TControlCellAligns">
        <short>Set type used to store values from the TControlCellAlign enumeration.</short>
        <descr/>
        <seealso>
          <link id="TControlCellAlign"/>
        </seealso>
      </element>

      <element name="TControlBorderSpacingDefault">
        <short>Defines the default values for TControlBorderSpacing.</short>
        <descr>
          <p>
            <var>TControlBorderSpacingDefault</var> is a record type which defines the default values for properties in a <var>TControlBorderSpacing</var> instance. Used to differentiate default values in derived <var>TControl</var> classes.
          </p>
        </descr>
        <seealso>
          <link id="TControl.BorderSpacing"/>
          <link id="TControlBorderSpacing"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacingDefault.Left"/>
      <element name="TControlBorderSpacingDefault.Top"/>
      <element name="TControlBorderSpacingDefault.Right"/>
      <element name="TControlBorderSpacingDefault.Bottom"/>
      <element name="TControlBorderSpacingDefault.Around"/>

      <element name="PControlBorderSpacingDefault">
        <short>Pointer to a TControlBorderSpacingDefault type.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlBorderSpacing">
        <short>Describes the (minimum) spacing around a control.</short>
        <descr>
          <p>
            TControlBorderSpacing defines the spacing around a control. The spacing around its children and between its children is defined in <link id="TWinControl.ChildSizing"/>.
          </p>
          <dl>
            <dt>
              Left, Top, Right, Bottom: Integer;
            </dt>
            <dd>
              Defines the space available to the auto-sized control. For example: Control A lies left of control B. A has borderspacing Right=10 and B has borderspacing Left=5. Then A and B will have a minimum space of 10 between.
            </dd>
            <dt>
              Around: Integer;
            </dt>
            <dd>
              Same as Left, Top, Right and Bottom but specified all at once. This will be added to the effective Left, Top, Right and Bottom. Example: Left=3 and Around=5 results in a minimum spacing to the left of 8.
            </dd>
            <dt>
              InnerBorder: Integer;
            </dt>
            <dd>
              This is added to the preferred size. For example: A buttons widget returns 75x25 on GetPreferredSize. CalculatePreferredSize adds 2 times the InnerBorder to the width and height.
            </dd>
            <dt>
              CellAlignHorizontal, CellAlignVertical: TControlCellAlign;
            </dt>
            <dd>
              Used, for example, when the Parents.ChildSizing.Layout defines a table layout.
            </dd>
          </dl>
        </descr>
        <seealso/>
      </element>

      <element name="TControlBorderSpacing.FAround"/>
      <element name="TControlBorderSpacing.FBottom"/>
      <element name="TControlBorderSpacing.FCellAlignHorizontal"/>
      <element name="TControlBorderSpacing.FCellAlignVertical"/>
      <element name="TControlBorderSpacing.FControl"/>
      <element name="TControlBorderSpacing.FInnerBorder"/>
      <element name="TControlBorderSpacing.FLeft"/>
      <element name="TControlBorderSpacing.FOnChange"/>
      <element name="TControlBorderSpacing.FRight"/>
      <element name="TControlBorderSpacing.FTop"/>
      <element name="TControlBorderSpacing.FDefault"/>

      <element name="TControlBorderSpacing.GetAroundBottom">
        <short>Gets the value for the AroundBottom property.</short>
        <descr/>
        <seealso>
          <link id="TControlBorderSpacing.AroundBottom"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.GetAroundBottom.Result">
        <short>Value for the property.</short>
      </element>

      <element name="TControlBorderSpacing.GetAroundLeft">
        <short>Gets the value for the AroundLeft property.</short>
        <descr/>
        <seealso>
          <link id="TControlBorderSpacing.AroundLeft"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.GetAroundLeft.Result">
        <short>Value for the property.</short>
      </element>

      <element name="TControlBorderSpacing.GetAroundRight">
        <short>Gets the value for the AroundRight property.</short>
        <descr/>
        <seealso>
          <link id="TControlBorderSpacing.AroundRight"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.GetAroundRight.Result">
        <short>Value for the property.</short>
      </element>

      <element name="TControlBorderSpacing.GetAroundTop">
        <short>Gets the value for the AroundTop property.</short>
        <descr/>
        <seealso>
          <link id="TControlBorderSpacing.AroundRight"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.GetAroundTop.Result">
        <short>Value for the property.</short>
      </element>

      <element name="TControlBorderSpacing.GetControlRight">
        <short>Gets the value for the ControlRight property.</short>
        <descr/>
        <seealso>
          <link id="TControlBorderSpacing.ControlRight"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.GetControlRight.Result">
        <short>Value for the property.</short>
      </element>

      <element name="TControlBorderSpacing.GetControlTop">
        <short>Gets the value for the ControlTop property.</short>
        <descr/>
        <seealso>
          <link id="TControlBorderSpacing.ControlTop"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.GetControlTop.Result">
        <short>Value for the property.</short>
      </element>

      <element name="TControlBorderSpacing.GetControlWidth">
        <short>Gets the value for the ControlWidth property.</short>
        <descr/>
        <seealso>
          <link id="TControlBorderSpacing.ControlWidth"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.GetControlWidth.Result">
        <short>Value for the property.</short>
      </element>

      <element name="TControlBorderSpacing.IsAroundStored">
        <short>Implements the storage specifier for the Around property.</short>
        <descr/>
        <seealso>
          <link id="TControlBorderSpacing.Around"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.IsAroundStored.Result">
        <short/>
      </element>

      <element name="TControlBorderSpacing.IsBottomStored">
        <short>Implements the storage specifier for the Bottom property.</short>
        <descr/>
        <seealso>
          <link id="TControlBorderSpacing.Bottom"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.IsBottomStored.Result">
        <short/>
    </element>

    <element name="TControlBorderSpacing.IsInnerBorderStored">
      <short>Implements the storage specifier for the InnerBorder property.</short>
      <descr/>
      <seealso>
        <link id="TControlBorderSpacing.InnerBorder"/>
      </seealso>
    </element>
    <element name="TControlBorderSpacing.IsInnerBorderStored.Result">
      <short/>
    </element>

      <element name="TControlBorderSpacing.IsLeftStored">
        <short>Implements the storage specifier for the Left property.</short>
        <descr/>
        <seealso>
          <link id="TControlBorderSpacing.Left"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.IsLeftStored.Result">
        <short/>
      </element>

      <element name="TControlBorderSpacing.IsRightStored">
        <short>Implements the storage specifier for the Right property.</short>
        <descr/>
        <seealso>
          <link id="TControlBorderSpacing.Right"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.IsRightStored.Result">
        <short/>
      </element>

      <element name="TControlBorderSpacing.IsTopStored">
        <short>Implements the storage specifier for the Top property.</short>
        <descr/>
        <seealso>
          <link id="TControlBorderSpacing.Top"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.IsTopStored.Result">
        <short/>
      </element>

      <element name="TControlBorderSpacing.SetAround">
        <short>Sets the value for the Around property.</short>
        <descr/>
        <seealso>
          <llink id="TControlBorderSpacing.Around"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.SetAround.AValue">
        <short>New value for the Around property.</short>
      </element>

      <element name="TControlBorderSpacing.SetBottom">
        <short>Sets the value for the Bottom property.</short>
        <descr/>
        <seealso>
          <llink id="TControlBorderSpacing.Bottom"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.SetBottom.AValue">
        <short>New value for the Bottom property.</short>
      </element>

      <element name="TControlBorderSpacing.SetCellAlignHorizontal">
        <short>Sets the value for the CellAlignHorizontal property.</short>
        <descr/>
        <seealso>
          <link id="TControlBorderSpacing.CellAlignHorizontal"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.SetCellAlignHorizontal.AValue">
        <short>New value for the CellAlignHorizontal property.</short>
      </element>

      <element name="TControlBorderSpacing.SetCellAlignVertical">
        <short>Sets the value for the SetCellAlignVertical property.</short>
        <descr/>
        <seealso>
          <link id="TControlBorderSpacing.CellAlignVertical"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.SetCellAlignVertical.AValue">
        <short>New value for the SetCellAlignVertical property.</short>
      </element>

      <element name="TControlBorderSpacing.SetInnerBorder">
        <short>Sets the value for the InnerBorder property.</short>
        <descr/>
        <seealso>
          <link id="TControlBorderSpacing.InnerBorder"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.SetInnerBorder.AValue">
        <short>New value for the InnerBorder property.</short>
      </element>

      <element name="TControlBorderSpacing.SetLeft">
        <short>Sets the value for the Left property.</short>
        <descr/>
        <seealso>
          <link id="TControlBorderSpacing.Left"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.SetLeft.AValue">
        <short>New value for the Left property.</short>
      </element>

      <element name="TControlBorderSpacing.SetRight">
        <short>Sets the value for the Right property.</short>
        <descr/>
        <seealso>
          <link id="TControlBorderSpacing.Right"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.SetRight.AValue">
        <short>New value for the Right property.</short>
      </element>

      <element name="TControlBorderSpacing.SetSpace">
        <short>Sets the value for the indexed Space property.</short>
        <descr/>
        <seealso>
          <link id="TControlBorderSpacing.Space"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.SetSpace.Kind">
        <short>Identifies the ordinal position in the indexed property.</short>
      </element>
      <element name="TControlBorderSpacing.SetSpace.AValue">
        <short>New value for the indexed Space property.</short>
      </element>

      <element name="TControlBorderSpacing.SetTop">
        <short>Sets the value for the Top property.</short>
        <descr/>
        <seealso>
          <link id="TControlBorderSpacing.Top"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.SetTop.AValue">
        <short>New value for the Top property.</short>
      </element>

      <element name="TControlBorderSpacing.Change">
        <short>Invalidates the control and signals the OnChange event handler.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlBorderSpacing.Change.InnerSpaceChanged">
        <short>Currently ignored (distinction no longer required).</short>
      </element>

      <element name="TControlBorderSpacing.Create">
        <short>Constructor for the class instance.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlBorderSpacing.Create.OwnerControl">
        <short>The associated control which owns the class instance.</short>
      </element>
      <element name="TControlBorderSpacing.Create.ADefault">
        <short>
          Pointer to an record with default settings; can be <b>Nil</b> for all zero defaults.
        </short>
      </element>

      <element name="TControlBorderSpacing.Assign">
        <short>Copies property values from the specified persistent object.</short>
        <descr/>
        <seealso>
          <link id="#rtl.classes.TPersistent">TPersistent</link>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.Assign.Source">
        <short>Persistent object with the values copied in the method.</short>
      </element>

      <element name="TControlBorderSpacing.AssignTo">
        <short>
          Copies property value from the class instance to the specified persistent object.
        </short>
        <descr/>
        <seealso>
          <link id="#rtl.classes.TPersistent">TPersistent</link>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.AssignTo.Dest">
        <short>Persistent object where property values are stored.</short>
      </element>

      <element name="TControlBorderSpacing.IsEqual">
        <short><b>True</b> when the specified spacing is the same as the current settings.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlBorderSpacing.IsEqual.Result">
        <short/>
      </element>
      <element name="TControlBorderSpacing.IsEqual.Spacing">
        <short/>
      </element>

      <element name="TControlBorderSpacing.GetSpaceAround">
        <short>Returns the bounds with added Around space.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlBorderSpacing.GetSpaceAround.SpaceAround">
        <short>Out parameter, initial contents are ignored!</short>
      </element>

      <element name="TControlBorderSpacing.GetSideSpace">
        <short>The space on a control side, including Around space.</short>
        <descr/>
        <seealso>
          <link id="TControlBorderSpacing.Space"/>
          <link id="TControlBorderSpacing.GetSideSpace"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.GetSideSpace.Result">
        <short>The space value.</short>
      </element>
      <element name="TControlBorderSpacing.GetSideSpace.Kind">
        <short>The requested edge.</short>
      </element>

      <element name="TControlBorderSpacing.GetSpace">
        <short>Gets the value for the indexed Space property.</short>
        <descr/>
        <seealso>
          <link id="TControlBorderSpacing.Space"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.GetSpace.Result">
        <short>Value for the indexed Space property.</short>
      </element>
      <element name="TControlBorderSpacing.GetSpace.Kind">
        <short>Ordinal position for the value in the indexed property.</short>
      </element>

      <element name="TControlBorderSpacing.AutoAdjustLayout">
        <short>Automatically adjusts the size of the control using the specified proportions.</short>
        <descr>
          <p>
            <var>AutoAdjustLayout</var> is a procedure used to automatically adjust the size of the control using the specified proportions.
          </p>
          <p>
            <var>AXProportion</var> and <var>AYProportion</var> are <var>Double</var> values which contain the scaling factor applied to width and height values in  corresponding properties. For example, 1.25 indicates an increase to 125% of the original value, and 0.5 indicates a 50% decrease in the original value.
          </p>
          <p>
            <var>AutoAdjustLayout</var> scales the value in width and height for properties, including:
          </p>
          <ul>
            <li>Around</li>
            <li>InnerBorder</li>
            <li>Left</li>
            <li>Top</li>
            <li>Right</li>
            <li>Bottom</li>
          </ul>
          <p>
            When property values are altered in the scaling operation, the <var>InvalidatePreferredSize</var> method is called to recalculate the dimensions for the control. The <var>Change</var> method is called when value(s) in <var>InnerBorder</var> have been altered.
          </p>
        </descr>
        <seealso>
          <link id="TControlBorderSpacing.Around"/>
          <link id="TControlBorderSpacing.InnerBorder"/>
          <link id="TControlBorderSpacing.Left"/>
          <link id="TControlBorderSpacing.Top"/>
          <link id="TControlBorderSpacing.Right"/>
          <link id="TControlBorderSpacing.Bottom"/>
        </seealso>
      </element>
      <element name="TControlBorderSpacing.AutoAdjustLayout.AXPxproportion">
        <short>Scaling factor applied to width values.</short>
      </element>
      <element name="TControlBorderSpacing.AutoAdjustLayout.AYProportion">
        <short>Scaling factor applied to height values.</short>
      </element>

      <element name="TControlBorderSpacing.Control">
        <short>The control to which this border spacing applies.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlBorderSpacing.Space">
        <short>Kind of array access to the space at every side.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlBorderSpacing.Space.Kind">
        <short>The side for which the space is requested.</short>
      </element>

      <element name="TControlBorderSpacing.AroundLeft">
         <short>Spacing used around and on the left-hand side of the control.</short>
        <descr>
          <p>
            <var>AroundLeft</var> is a read-only <var>Integer</var> property which indicates the spacing used around and on the left-hand side of the control.
          </p>
          <p>
            AroundLeft represents the total space reserved on all sides of the control, plus any additional space reserved on it left-hand edge. The value for the property is calculated as the sum of the values from the <var>Around</var> and <var>Left</var> properties. Updates must be performed to the Around and Left properties.
          </p>
        </descr>
        <seealso>
          <link id="TControlBorderSpacing.Around"/>
          <link id="TControlBorderSpacing.Left"/>
        </seealso>
      </element>

      <element name="TControlBorderSpacing.AroundTop">
         <short>Space reserved around and on the top edge of the control.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlBorderSpacing.AroundRight">
         <short>Space reserved around and on the right-hand side of the control.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlBorderSpacing.AroundBottom">
         <short>Space reserved around and on the bottom edge of the control.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlBorderSpacing.ControlLeft">
         <short>
           Space reserved on the left-hand edge of the control relative to the position for the control.
        </short>
        <descr>
          <p>
            <var>ControlLeft</var> is a read-only <var>Integer</var> property that indicates the space reserved on the left-hand edge of the control relative to the position for the control class instance. The value in <var>ControlLeft</var> is calculated as the difference between the <var>Left</var> position for the control and the values in the <var>Around</var> and <var>Left</var> properties. For example:
          </p>
          <code>FControl.Left-Around-Left</code>
          <p>
            If a <var>TControl</var> instance is not available in <var>Control</var>, the value for the property is <b>0</b> (<b>zero</b>).
          </p>
        </descr>
        <seealso>
          <link id="TControlBorderSpacing.Around"/>
          <link id="TControlBorderSpacing.Left"/>
          <link id="TControl.Left"/>
        </seealso>
      </element>

      <element name="TControlBorderSpacing.ControlTop">
         <short>
           Space reserved on the top edge of the control relative to the position for the control.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlBorderSpacing.ControlWidth">
         <short>
           Total width for the control including spacing values in Around, Left, and Right.
        </short>
        <descr>
          <p>
            <var>ControlWidth</var> is a read-only <var>Integer</var> property that contains the total width for the control including spacing values in the <var>Around</var>, <var>Left</var>, and <var>Right</var> properties. The property value is calculated using the following formula:
          </p>
          <code>TControl.Width + (2 * Around) + Left + Right</code>
          <p>
            If a <var>TControl</var> instance is not available in <var>Control</var>, the value for the property is <b>0</b> (<b>zero</b>).
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TControlBorderSpacing.ControlHeight">
         <short>
           Total height for the control including spacing values in Around, Top, and Bottom.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlBorderSpacing.ControlRight">
         <short>
           Space reserved on the right-hand edge of the control relative to the position for the control.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlBorderSpacing.ControlBottom">
         <short>
           Space reserved on the bottom edge of the control relative to the position for the control.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlBorderSpacing.OnChange">
        <short>Event handler for a change in border spacing.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlBorderSpacing.Left">
        <short>The space at the left border.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlBorderSpacing.Top">
        <short>The space at the top border.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlBorderSpacing.Right">
        <short>The space at the right border.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlBorderSpacing.Bottom">
        <short>The space at the bottom border.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlBorderSpacing.Around">
        <short>The space to add on each side of a control.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlBorderSpacing.InnerBorder">
        <short>
          Space added to the widget's <link id="TControl.GetPreferredSize">preferred size</link>
        </short>
        <descr>
          <p>
            When <link id="TControl.GetPreferredSize">calculating the preferred size</link> of control, the LCL asks the widget first.
          </p>
          <p>
            When the widget returns a preferred size, e.g. a TButton widget, then the InnerBorder is added twice to this size - e.g. to the Height for top and bottom space.
          </p>
          <p>
            If the widget does not return a preferred size, the InnerBorder has no effect.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TControlBorderSpacing.CellAlignHorizontal">
        <short>The horizontal alignment inside a table cell.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlBorderSpacing.CellAlignVertical">
        <short>The vertical alignment inside a table cell.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TAnchorSideChangeOperation">
        <short>Operations in <link id="TControl.ForeignAnchorSideChanged"/></short>
        <descr/>
        <seealso/>
      </element>
      <element name="TAnchorSideChangeOperation.ascoAdd">
        <short>AnchorSide added.</short>
      </element>
      <element name="TAnchorSideChangeOperation.ascoRemove">
        <short>AnchorSide removed.</short>
      </element>
      <element name="TAnchorSideChangeOperation.ascoChangeSide">
        <short>AnchorSide changed.</short>
      </element>

      <element name="TAnchorSide">
        <short>Specifies how the side of a control is anchored to other controls.</short>
        <descr>
          <p>
            Class holding the reference sides of the anchors of a TControl. Every TControl has four AnchorSides: AnchorSide[akLeft], AnchorSide[akRight], AnchorSide[akTop] and AnchorSide[akBottom]. Normally if Anchors contain akLeft, and the Parent is resized, the LCL tries to keep the distance between the left side of the control and the right side of its parent client area. With AnchorSide[akLeft] you can define a different reference side. The kept distance is defined by the BorderSpacing. For example:
          </p>
<code>
+-----+  +-----+
|  B  |  |  C  |
|     |  +-----+
+-----+
</code>
          <p>
            If you want to have the top of B the same as the top of C use
          </p>
  <code>
  B.AnchorSide[akTop].Side:=asrTop;
  B.AnchorSide[akTop].Control:=C;
  </code>
          <p>
            If you want to keep a distance of 10 pixels between B and C use
          </p>
  <code>
  B.BorderSpacing.Right:=10;
  B.AnchorSide[akRight].Side:=asrLeft;
  B.AnchorSide[akRight].Control:=C;
  </code>
          <p>
            Do not setup in both directions, because this will create a circle, and circles are not allowed.
          </p>
          <p>
            Another example:
          </p>
<code>
+-------+
|       | +---+
|   B   | | A |
|       | +---+
+-------+
</code>
          <p>
            Centering A relative to B:
          </p>
<code>
  A.AnchorSide[akTop].Side:=asrCenter;
  A.AnchorSide[akTop].Control:=B;
</code>
          <p>
            Or use this equivalent:
          </p>
<code>
  A.AnchorSide[akBottom].Side:=asrCenter;
  A.AnchorSide[akBottom].Control:=B;
</code>
        </descr>
        <seealso/>
      </element>

      <element name="TAnchorSide.FControl"/>
      <element name="TAnchorSide.FKind"/>
      <element name="TAnchorSide.FOwner"/>
      <element name="TAnchorSide.FSide"/>

      <element name="TAnchorSide.IsSideStored">
        <short>Determines if the Control uses an anchor on the side specified in Kind.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TAnchorSide.IsSideStored.Result">
        <short/>
      </element>

      <element name="TAnchorSide.SetControl">
        <short>Sets the value for the Control property.</short>
        <descr/>
        <seealso>
          <link id="TAnchorSide.Control"/>
        </seealso>
      </element>
      <element name="TAnchorSide.SetControl.AValue">
        <short>New value for the Control property.</short>
      </element>

      <element name="TAnchorSide.SetSide">
        <short>Sets the value for the Side property.</short>
        <descr/>
        <seealso>
          <link id="TAnchorSide.Side"/>
        </seealso>
      </element>
      <element name="TAnchorSide.SetSide.AValue">
        <short>New value for the Side property.</short>
      </element>

      <element name="TAnchorSide.GetOwner">
        <short>Gets the owner of the persistent object.</short>
        <descr/>
        <seealso>
          <link id="#rtl.classes.TPersistent">TPersistent</link>
        </seealso>
      </element>
      <element name="TAnchorSide.GetOwner.Result">
        <short>Owner of the persistent object.</short>
      </element>

      <element name="TAnchorSide.Create">
        <short>Constructor for the class instance.</short>
        <descr>
          <p>
            <var>Create</var> is the constructor for the class instance.
          </p>
          <p>
            Create calls the inherited constructor, and sets the values in the <var>Owner</var>, <var>Kind</var>, and <var>Side</var> properties. The default value for Side is <var>asrTop</var>.
          </p>
        </descr>
        <seealso></seealso>
      </element>
      <element name="TAnchorSide.Create.TheOwner">
        <short>Owner of the class instance.</short>
      </element>
      <element name="TAnchorSide.Create.TheKind">
        <short>TAnchorKind value for the Kind property.</short>
      </element>

      <element name="TAnchorSide.Destroy">
        <short>Destructor for the class instance.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TAnchorSide.GetSidePosition">
        <short>Get information about the target control, side and side position.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TAnchorSide.GetSidePosition.ReferenceControl">
        <short>The control we are anchored to.</short>
      </element>
      <element name="TAnchorSide.GetSidePosition.ReferenceSide">
        <short>The side we are anchored to.</short>
      </element>
      <element name="TAnchorSide.GetSidePosition.Position">
        <short>Position of the side to anchor to.</short>
      </element>

      <element name="TAnchorSide.CheckSidePosition">
        <short>
          Checks for anchor cycles and invalid targets, and returns information about the target side.
        </short>
        <descr/>
        <errors>
          Can raise an exception with the message: <b>'TAnchorSide.CheckSidePosition invalid Side'.</b>
        </errors>
        <seealso/>
      </element>
      <element name="TAnchorSide.CheckSidePosition.Result">
        <short> <b>False</b> when errors have been found.</short>
      </element>
      <element name="TAnchorSide.CheckSidePosition.NewControl">
        <short/>
      </element>
      <element name="TAnchorSide.CheckSidePosition.NewSide">
        <short/>
      </element>
      <element name="TAnchorSide.CheckSidePosition.ReferenceControl">
        <short>The control we are anchored to.</short>
      </element>
      <element name="TAnchorSide.CheckSidePosition.ReferenceSide">
        <short>The side we are anchored to.</short>
      </element>
      <element name="TAnchorSide.CheckSidePosition.Position">
        <short>Position of the side to anchor to.</short>
      </element>

      <element name="TAnchorSide.Assign">
        <short>
          Copies properties from the specified persistent object into the current class instance.
        </short>
        <descr>
          <p>
            <var>Assign</var> is an overridden method in <var>TAnchorSide</var> used to copy property values from the persistent object in <var>Source</var> into the current class instance. When Source is derived from <var>TAnchorSide</var>, the following properties are copied:
          </p>
          <ul>
            <li>Side</li>
            <li>Control</li>
          </ul>
          <p>
            If Source is not derived from TAnchorSide, the inherited method is called using Source as an argument.
          </p>
        </descr>
        <seealso>
          <link id="#rtl.classes.TPersistent">TPersistent</link>
        </seealso>
      </element>
      <element name="TAnchorSide.Assign.Source">
        <short>Persistent object with the properties copied in the method.</short>
      </element>

      <element name="TAnchorSide.IsAnchoredToParent">
        <short><b>True</b> when we are anchored to our parent, at least on the ParentSide.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TAnchorSide.IsAnchoredToParent.Result">
        <short/>
      </element>
      <element name="TAnchorSide.IsAnchoredToParent.ParentSide">
        <short/>
      </element>

      <element name="TAnchorSide.FixCenterAnchoring">
        <short>Remove conflicting anchors.</short>
        <descr>
          <p>
            With <var>asrCenter</var>, both sides are controlled by one anchor. Disable opposite anchor and all aligning.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TAnchorSide.Owner">
        <short>The control being anchored.</short>
        <descr>
          <p>
            For example:
          </p>
          <code>AButton1.AnchorSide[akBottom].Owner = AButton1</code>
        </descr>
        <seealso/>
      </element>

      <element name="TAnchorSide.Kind">
        <short>The control side being anchored.</short>
        <descr>
          <p>
            Every control has four AnchorSide elements, one for each side. For example:
          </p>
          <code>AButton1.AnchorSide[akLeft].Kind := akLeft.</code>
        </descr>
        <seealso/>
      </element>

      <element name="TAnchorSide.Control">
        <short>The target control of the anchor.</short>
        <descr>
          <p>
            For example: if the right side of a Button1 is anchored to the left side of Edit1, then:
          </p>
          <code>Button1.AnchorSide[akRight].Control // contains Edit1</code>
          <p>and</p>
          <code>Button1.AnchorSide[akRight].Side // contains asrLeft</code>
        </descr>
        <seealso/>
      </element>

      <element name="TAnchorSide.Side">
        <short>The side of the target Control, to which we anchor.</short>
        <descr>
          <p>
            For example, if the right side of a Button1 is anchored to the left side of Edit1, then:
          </p>
          <code>Button1.AnchorSide[akRight].Control=Edit1</code>
          <p>and</p>
          <code>Button1.AnchorSide[akRight].Side=asrLeft</code>
        </descr>
        <seealso/>
      </element>

      <element name="TControlActionLink">
        <short>Links an Action to a control.</short>
        <descr>
          <p>
            An ActionLink is created when an Action is assigned to the control.
            TControl.Action effectively becomes TControl.ActionLink.Action.
          </p>
          <p>
            An ActionLink propagates changes in Action properties to the client control. It's assumed that properties of the <b>same value</b> (in the Control and Action) are linked to the Action, and follow changes to the Action properties.
          </p>
          <p>
            Linked control properties are (by default):
          </p>
          <ul>
            <li>Caption</li>
            <li>Enabled</li>
            <li>Hint</li>
            <li>
              HelpContext, HelpKeyword, HelpType: these are linked only if all three property values match.
            </li>
            <li>Visible</li>
            <li>OnClick is linked to Action.Execute</li>
          </ul>
          <p>
            The control can update itself, when it receives a Change notification from the ActionLink <link id="TControl.ActionChange"/>.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TControlActionLink.FClient">
        <short>The client control that is linked to the action.</short>
        <descr>It can be assumed that FClient is not Nil.</descr>
      </element>

      <element name="TControlActionLink.AssignClient">
        <short>Called during construction, sets FClient to the given control.</short>
        <seealso>
          <link id="#rtl.classes.TBasicActionLink">TBasicActionLink</link>
        </seealso>
      </element>
      <element name="TControlActionLink.AssignClient.AClient">
        <short>The control linked to the action.</short>
      </element>

      <element name="TControlActionLink.SetCaption">
        <short>Sets the client's Caption, if the old values match.</short>
        <descr/>
        <seealso>
          <link id="#lcl.actnlist.TActionLink.SetCaption">TActionLink.SetCaption</link>
        </seealso>
      </element>
      <element name="TControlActionLink.SetCaption.Value">
        <short/>
      </element>

      <element name="TControlActionLink.SetEnabled">
        <short>Sets the client's Enabled property, if the old values match.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlActionLink.SetEnabled.Value">
        <short/>
      </element>

      <element name="TControlActionLink.SetHint">
        <short>Sets client's Hint, if the old values match.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlActionLink.SetHint.Value">
        <short/>
      </element>

      <element name="TControlActionLink.SetHelpContext">
        <short>Sets the HelpContext, if the old Help properties match (IsHelpLinked).</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlActionLink.SetHelpContext.Value">
        <short/>
      </element>

      <element name="TControlActionLink.SetHelpKeyword">
        <short>Sets the HelpKeyword, if the old Help properties match (IsHelpLinked).</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlActionLink.SetHelpKeyword.Value">
        <short/>
      </element>

      <element name="TControlActionLink.SetHelpType">
        <short>Sets the HelpType, if the old Help properties match (IsHelpLinked).</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlActionLink.SetHelpType.Value">
        <short/>
      </element>

      <element name="TControlActionLink.SetVisible">
        <short>Sets the Visible property in the client, if the old values match.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlActionLink.SetVisible.Value">
        <short/>
      </element>

      <element name="TControlActionLink.SetOnExecute">
        <short>Set OnClick handler for the client, if the old values match.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlActionLink.SetOnExecute.Value">
        <short/>
      </element>

      <element name="TControlActionLink.IsOnExecuteLinked">
        <short><b>True</b> if the client's OnClick is the action's OnExecute handler.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlActionLink.IsOnExecuteLinked.Result">
        <short/>
      </element>

      <element name="TControlActionLink.DoShowHint">
        <short>Compose the hint string, depending on HintShortCuts.</short>
        <descr/>
        <seealso>
          <link id="#lcl.forms.TApplication.HintShortCuts">TApplication.HintShortCuts</link>
        </seealso>
      </element>
      <element name="TControlActionLink.DoShowHint.Result">
        <short>Always <b>True</b>.</short>
      </element>
      <element name="TControlActionLink.DoShowHint.HintStr">
        <short>The hint to show.</short>
      </element>

      <element link="#lcl.actnlist.TActionLink.IsCaptionLinked" name="TControlActionLink.IsCaptionLinked"/>
      <element name="TControlActionLink.IsCaptionLinked.Result"/>

      <element link="#lcl.actnlist.TActionLink.IsEnabledLinked" name="TControlActionLink.IsEnabledLinked"/>
      <element name="TControlActionLink.IsEnabledLinked.Result"/>

      <element name="TControlActionLink.IsHelpLinked">
        <short>Help properties are assumed linked only when all these properties match.</short>
        <descr>Compares the HelpContext, HelpKeyword and HelpType properties.</descr>
        <seealso>
          <link id="#lcl.actnlist.TActionLink.IsHelpLinked">TActionLink.IsHelpLinked</link>
        </seealso>
      </element>
      <element name="TControlActionLink.IsHelpLinked.Result">
        <short><b>True</b> only if all three Control properties match the Action properties.</short>
      </element>

      <element link="#lcl.actnlist.TActionLink.IsHintLinked" name="TControlActionLink.IsHintLinked"/>
      <element name="TControlActionLink.IsHintLinked.Result"/>

      <element link="#lcl.actnlist.TActionLink.IsVisibleLinked" name="TControlActionLink.IsVisibleLinked"/>
      <element name="TControlActionLink.IsVisibleLinked.Result"/>

      <element name="TControlActionLinkClass">
        <short>Class of <link id="TControlActionLink"/></short>
        <descr/>
        <seealso>
          <link id="TControlActionLink"/>
        </seealso>
      </element>

      <element name="ELayoutException">
        <short>
          Exception raised when a loop is detected when adjusting the size for controls.
        </short>
        <descr>
          <p>
            <var>ELayoutException</var> is an <var>Exception</var> descendant that implements  the exception raised when a loop is detected when adjusting the size for controls, or when an invalid value is assigned to the control width or height.
          </p>
        </descr>
        <seealso>
          <link id="TControl.AdjustSize"/>
          <link id="TControl.EnableAutoSizing"/>
          <link id="TControl.ChangeBounds"/>
          <link id="TControl.Width"/>
          <link id="TControl.Height"/>
        </seealso>
      </element>

      <element name="TControlAutoSizePhase">
        <short>Represents AutoSizing phases for controls.</short>
        <descr>
          <p>
            <var>TControlAutoSizePhase</var> is an enumerated type with values that represent phases or steps in the auto-sizing process for controls. Values from TControlAutoSizePhase are stored in the <var>TControlAutoSizePhases</var> set type.
          </p>
        </descr>
        <seealso>
          <link id="TControlAutoSizePhases"/>
          <link id="TControl.AutoSizePhases"/>
          <link id="TWinControl.AutoSizePhases"/>
        </seealso>
      </element>
      <element name="TControlAutoSizePhase.caspNone">
        <short/>
      </element>
      <element name="TControlAutoSizePhase.caspChangingProperties">
        <short/>
      </element>
      <element name="TControlAutoSizePhase.caspCreatingHandles">
        <short>Create/Destroy handles.</short>
      </element>
      <element name="TControlAutoSizePhase.caspComputingBounds">
        <short/>
      </element>
      <element name="TControlAutoSizePhase.caspRealizingBounds">
        <short/>
      </element>
      <element name="TControlAutoSizePhase.caspShowing">
        <short>Makes a handle visible.</short>
      </element>

      <element name="TControlAutoSizePhases">
        <short>Set type used to store values from the TControlAutoSizePhase enumeration.</short>
        <descr/>
        <seealso>
          <link id="TControlAutoSizePhase"/>
        </seealso>
      </element>

      <element name="TTabOrder">
        <short>Type used for <link id="TWinControl.TabOrder"/></short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlShowHintEvent">
        <short>Type used to implement an OnShowHint event handler.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlShowHintEvent.Sender">
         <short>TObject for the event notification.</short>
      </element>
      <element name="TControlShowHintEvent.HintInfo">
         <short>Hint information used to derive hint value.</short>
      </element>

      <element name="TContextPopupEvent">
        <short>Handler type for OnContextPopup.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TContextPopupEvent.Sender">
        <short>The clicked control.</short>
      </element>
      <element name="TContextPopupEvent.MousePos">
        <short>
          Mouse position in client coordinates; (-1,-1) if the event was not generated by a mouse click.
        </short>
      </element>
      <element name="TContextPopupEvent.Handled">
        <short>
          Set Handled to <b>True</b> when everything was handled; <b>False</b> shows the associated PopupMenu, by default.
        </short>
      </element>

      <element name="TControlFlag">
        <short>Flags mostly for pending actions.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlFlag.cfLoading">
        <short>
          Set by TControl.ReadState, and unset by TControl.Loaded when all controls for the form have finished loading.
        </short>
      </element>
      <element name="TControlFlag.cfAutoSizeNeeded">
        <short>Set when AutoSize was delayed.</short>
      </element>
      <element name="TControlFlag.cfLeftLoaded">
        <short>Set when Left was set during loading.</short>
      </element>
      <element name="TControlFlag.cfTopLoaded">
        <short>Set when Top was set during loading.</short>
      </element>
      <element name="TControlFlag.cfWidthLoaded">
        <short>Set when Width was set during loading.</short>
      </element>
      <element name="TControlFlag.cfHeightLoaded">
        <short>Set when Height was set during loading.</short>
      </element>
      <element name="TControlFlag.cfClientWidthLoaded">
        <short>Set when ClientWidth was set during loading.</short>
      </element>
      <element name="TControlFlag.cfClientHeightLoaded">
        <short>Set when ClientHeight was set during loading.</short>
      </element>
      <element name="TControlFlag.cfBoundsRectForNewParentValid">
        <short>Set when BoundsRectForNewParent has been initialized.</short>
      </element>
      <element name="TControlFlag.cfBaseBoundsValid">
        <short>Indicates if the rectangle in the base bounds for a control is valid.</short>
      </element>
      <element name="TControlFlag.cfPreferredSizeValid">
        <short>Set when PreferredSize has been calculated (CalculatePreferredSize).</short>
      </element>
      <element name="TControlFlag.cfPreferredMinSizeValid">
        <short/>
      </element>
      <element name="TControlFlag.cfOnChangeBoundsNeeded">
        <short/>
      </element>
      <element name="TControlFlag.cfProcessingWMPaint">
        <short>Set (in WndProc) while processing an LM_PAINT message.</short>
      </element>
      <element name="TControlFlag.cfKillChangeBounds">
        <short/>
      </element>
      <element name="TControlFlag.cfKillInvalidatePreferredSize">
        <short/>
      </element>
      <element name="TControlFlag.cfKillAdjustSize">
        <short/>
      </element>

      <element name="TControlFlags">
        <short>Set type used to store values from the TControlFlag enumeration.</short>
        <descr/>
        <seealso>
          <link id="TControlFlag"/>
        </seealso>
      </element>

      <element name="TControlHandlerType">
        <short>Notification handler types.</short>
        <descr>
          <p>
            Notification handlers only receive a Sender argument, and must know themselves why they have been invoked.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TControlHandlerType.chtOnResize">
        <short>Notification request for OnResize.</short>
      </element>
      <element name="TControlHandlerType.chtOnChangeBounds">
        <short>Notification request for OnChangeBounds.</short>
      </element>
      <element name="TControlHandlerType.chtOnVisibleChanging">
        <short>Notification request for OnVisibleChanging.</short>
      </element>
      <element name="TControlHandlerType.chtOnVisibleChanged">
        <short>Notification request for OnVisibleChanged.</short>
      </element>
      <element name="TControlHandlerType.chtOnEnabledChanging">
        <short>Notification request for OnEnabledChanging.</short>
      </element>
      <element name="TControlHandlerType.chtOnEnabledChanged">
        <short>Notification request for OnEnabledChanged.</short>
      </element>
      <element name="TControlHandlerType.chtOnKeyDown">
        <short>Notification request for OnKeyDown.</short>
      </element>

      <element name="TLayoutAdjustmentPolicy">
        <short>
          Indicates the policy for the LCL to execute automatic adjustments in the form layout.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TLayoutAdjustmentPolicy.lapDefault">
        <short>Widgetset dependent.</short>
      </element>
      <element name="TLayoutAdjustmentPolicy.lapFixedLayout">
        <short>A fixed absolute layout on all platforms.</short>
      </element>
      <element name="TLayoutAdjustmentPolicy.lapAutoAdjustWithoutHorizontalScrolling">
        <short>
          Smartphone platforms use this one, the x axis is stretched to fill the screen and the y axis is scaled to fit the DPI.
        </short>
      </element>
      <element name="TLayoutAdjustmentPolicy.lapAutoAdjustForDPI">
        <short>For desktops using High DPI, scale x and y to fit the DPI.</short>
      </element>

      <element name="TLazAccessibilityRole">
        <short>Indicates the role which a accessible object takes in the user interface.</short>
        <descr/>
        <seealso>
          <link id="TLazAccessibleObject"/>
        </seealso>
      </element>
      <element name="TLazAccessibilityRole.larIgnore">
        <short>Something to be ignored. For example a blank space between other objects.</short>
      </element>
      <element name="TLazAccessibilityRole.larAnimation">
        <short>An object that displays an animation.</short>
      </element>
      <element name="TLazAccessibilityRole.larButton">
        <short>A button.</short>
      </element>
      <element name="TLazAccessibilityRole.larCell">
        <short>A cell in a table.</short>
      </element>
      <element name="TLazAccessibilityRole.larChart">
        <short>An object that displays a graphical representation of data.</short>
      </element>
      <element name="TLazAccessibilityRole.larCheckBox">
        <short>An object that can be checked or unchecked, or sometimes in an intermediary state.</short>
      </element>
      <element name="TLazAccessibilityRole.larClock">
        <short>A clock displaying time.</short>
      </element>
      <element name="TLazAccessibilityRole.larColorPicker">
        <short>A control which allows selecting a color.</short>
      </element>
      <element name="TLazAccessibilityRole.larColumn">
        <short>A generic column in a table.</short>
      </element>
      <element name="TLazAccessibilityRole.larComboBox">
        <short>A list of choices that the user can select from.</short>
      </element>
      <element name="TLazAccessibilityRole.larDateField">
        <short>A controls which displays and possibly allows one to choose a date.</short>
      </element>
      <element name="TLazAccessibilityRole.larGrid">
        <short>A grid control which displays cells.</short>
      </element>
      <element name="TLazAccessibilityRole.larGroup">
        <short>A control which groups others, such as a TGroupBox.</short>
      </element>
      <element name="TLazAccessibilityRole.larImage">
        <short>A graphic or picture or an icon.</short>
      </element>
      <element name="TLazAccessibilityRole.larLabel">
        <short>A text label as usually placed near other widgets.</short>
      </element>
      <element name="TLazAccessibilityRole.larListBox">
        <short>A list of items, from which the user can select one or more items.</short>
      </element>
      <element name="TLazAccessibilityRole.larListItem">
        <short>An item in a list of items.</short>
      </element>
      <element name="TLazAccessibilityRole.larMenuBar">
        <short>A main menu bar.</short>
      </element>
      <element name="TLazAccessibilityRole.larMenuItem">
        <short>A item in a menu.</short>
      </element>
      <element name="TLazAccessibilityRole.larProgressIndicator">
        <short>A control which shows a progress indication.</short>
      </element>
      <element name="TLazAccessibilityRole.larRadioButton">
        <short>A radio button, see for example TRadioButton.</short>
      </element>
      <element name="TLazAccessibilityRole.larResizeGrip">
        <short>A grip that the user can drag to change the size of widgets.</short>
      </element>
      <element name="TLazAccessibilityRole.larRow">
        <short>A generic row in a table.</short>
      </element>
      <element name="TLazAccessibilityRole.larScrollBar">
        <short>A control to scroll another one.</short>
      </element>
      <element name="TLazAccessibilityRole.larSpinner">
        <short>A control which allows one to increment / decrement a value.</short>
      </element>
      <element name="TLazAccessibilityRole.larTabControl">
        <short>A control with tabs, like TPageControl.</short>
      </element>
      <element name="TLazAccessibilityRole.larText">
        <short>Text inside of a control, like text in a row cell.</short>
      </element>
      <element name="TLazAccessibilityRole.larTextEditorMultiline">
        <short>A multi-line text editor (for example: TMemo, SynEdit).</short>
      </element>
      <element name="TLazAccessibilityRole.larTextEditorSingleline">
        <short>A single-line text editor (for example: TEdit).</short>
      </element>
      <element name="TLazAccessibilityRole.larToolBar">
        <short>A control that holds ToolButtons.</short>
      </element>
      <element name="TLazAccessibilityRole.larToolBarButton">
        <short>A button on a ToolBar.</short>
      </element>
      <element name="TLazAccessibilityRole.larTrackBar">
        <short>A control which allows one to drag a slider.</short>
      </element>
      <element name="TLazAccessibilityRole.larTreeView">
        <short>A list of items in a tree structure.</short>
      </element>
      <element name="TLazAccessibilityRole.larTreeItem">
        <short>An item in a tree structure.</short>
      </element>
      <element name="TLazAccessibilityRole.larUnknown">
        <short>An item that doesn't fit any of the other categories.</short>
      </element>
      <element name="TLazAccessibilityRole.larWindow">
        <short>A top level window.</short>
      </element>

      <element name="TLazAccessibleObjectEnumerator">
        <short>Implements an enumerator for a list of TLazAccessibleObject instances.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TLazAccessibleObjectEnumerator.GetCurrent">
         <short>Gets the value for the Current property.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TLazAccessibleObjectEnumerator.GetCurrent.Result">
         <short>Value for the property.</short>
      </element>

      <element name="TLazAccessibleObjectEnumerator.Current">
         <short>Current value for the enumerator.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TLazAccessibleObject">
        <short>
          Represents an accessibility object for user or accessibility tool interactions.
        </short>
        <descr>
          <p>
            Every <var>TControl</var> has a <var>TLazAccessibleObject</var> instance associated with it, which means that every <var>TControl</var> is potentially accessible. But to actually be usable, the accessible object needs to have its properties set, the most important of which are the role, description and value. Native windowed classes should already receive accessibility properties from the underlying widgetset, while <var>TCustomControl</var> descendants will use the accessibility properties provided by LCL itself.
          </p>
          <p>
            User applications should add accessibility for their own <var>TCustomControl</var> descendant classes, and possibly customize the descriptions of some elements. It is also possible to make an accessible object invisible to the user, which is done by setting its AccessibleRole property to <var>larIgnored</var>.
          </p>
          <p>
             Accessibility support in Lazarus is also documented on the Wiki at:
             <url href="http://wiki.lazarus.freepascal.org/LCL_Accessibility"/>.
           </p>
        </descr>
        <seealso>
          <link id="TControl"/>
          <link id="TControl.AccessibleRole"/>
          <link id="TControl.AccessibleDescription"/>
          <link id="TControl.AccessibleValue"/>
          <link id="TLazAccessibilityRole"/>
        </seealso>
      </element>

      <element name="TLazAccessibleObject.FPosition"/>
      <element name="TLazAccessibleObject.FSize"/>
      <element name="TLazAccessibleObject.FLastSearchNode"/>
      <element name="TLazAccessibleObject.FLastSearchIndex"/>
      <element name="TLazAccessibleObject.FLastSearchInSubcontrols"/>

      <element name="TLazAccessibleObject.GetPosition">
        <short>Gets the value for the Position property.</short>
      </element>
      <element name="TLazAccessibleObject.GetPosition.Result">
         <short>Value for the property.</short>
      </element>

      <element name="TLazAccessibleObject.GetSize">
        <short>Gets the value for the Size property.</short>
        <seealso>
          <link id="TLazAccessibleObject.Size"/>
        </seealso>
      </element>
      <element name="TLazAccessibleObject.GetSize.Result">
         <short>Value for the property.</short>
     </element>

      <element name="TLazAccessibleObject.SetHandle">
        <short>Sets the value for the Handle property.</short>
        <seealso>
          <link id="TLazAccessibleObject.Handle"/>
        </seealso>
      </element>
      <element name="TLazAccessibleObject.SetHandle.AValue">
         <short>New value for the Handle property.</short>
      </element>

      <element name="TLazAccessibleObject.SetPosition">
        <short>Sets the value for the Position property.</short>
        <seealso>
          <link id="TLazAccessibleObject.Position"/>
        </seealso>
      </element>
      <element name="TLazAccessibleObject.SetPosition.AValue">
        <short>New value for the Position property.</short>
      </element>

      <element name="TLazAccessibleObject.SetSize">
        <short>Sets the value for the Size property.</short>
        <descr></descr>
        <seealso>
          <link id="TLazAccessibleObject.Size"/>
        </seealso>
      </element>
      <element name="TLazAccessibleObject.SetSize.AValue">
         <short>New value for the Size property.</short>
      </element>

      <element name="TLazAccessibleObject.FHandle">
        <short>Member with the Handle for the accessibility object.</short>
      </element>
      <element name="TLazAccessibleObject.FChildrenSortedForDataObject">
        <short>Member with the AVL tree for the sorted child objects.</short>
      </element>
      <element name="TLazAccessibleObject.FAccessibleName">
        <short>Member with the value for AccessibleName.</short>
      </element>
      <element name="TLazAccessibleObject.FAccessibleDescription">
        <short>Member with the value for AccessibleDescription.</short>
      </element>
      <element name="TLazAccessibleObject.FAccessibleValue">
        <short>Member with the value for AccessibleValue.</short>
      </element>
      <element name="TLazAccessibleObject.FAccessibleRole">
        <short>Member with the value for AccessibleRole.</short>
      </element>

      <element name="TLazAccessibleObject.WSRegisterClass"  link="#lcl.lclclasses.TLCLComponent.WSRegisterClass"/>

      <element name="TLazAccessibleObject.GetAccessibleValue">
         <short>Gets the value for the AccessibleValue property.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TLazAccessibleObject.GetAccessibleValue.Result">
         <short>Value for the property.</short>
      </element>

      <element name="TLazAccessibleObject.GetHandle">
        <short>Gets the value for the Handle property.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TLazAccessibleObject.GetHandle.Result">
         <short>Value for the property.</short>
      </element>

      <element name="TLazAccessibleObject.OwnerControl">
        <short>
          The control that this accessible object is attached to. It might be the main accessible object of this control or it might represent a sub-part of a control.
        </short>
        <descr>
          <p>
            The control that this accessible object is attached to. It might be the main accessible object of this control, or it might represent a sub-part of a control which does not have a corresponding TControl, like an item of TTreeView. One can verify if this is the main accessible object of the control by checking if (lAccessibleObject.OwnerControl = lAccessibleObject.OwnerControl.GetAccessibleObject())
          </p>
        </descr>
        <seealso>
          <link id="TControl.GetAccessibleObject"/>
        </seealso>
      </element>

      <element name="TLazAccessibleObject.Parent">
        <short>The parent TLazAccessibleObject of this accessible object.</short>
      </element>

      <element name="TLazAccessibleObject.DataObject">
        <short>Available to be used to connect to an object.</short>
      </element>

      <element name="TLazAccessibleObject.SecondaryHandle">
        <short>Available for Widgetsets to use.</short>
      </element>

      <element name="TLazAccessibleObject.Create">
         <short>Constructor for the class instance.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TLazAccessibleObject.Destroy">
         <short>Destructor for the class instance.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TLazAccessibleObject.HandleAllocated">
        <short>Returns if the handle of this object was already allocated or not.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TLazAccessibleObject.InitializeHandle">
        <short>
          Utilized to set all properties of this property via widgetset routines when creating the handle.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TLazAccessibleObject.SetAccessibleName">
        <short>Sets the value for AccessibleName.</short>
        <descr/>
        <seealso>
          <link id="TLazAccessibleObject.AccessibleName"/>
        </seealso>
      </element>
      <element name="TLazAccessibleObject.SetAccessibleName.AName">
        <short>New value for the AccessibleName property.</short>
      </element>

      <element name="TLazAccessibleObject.SetAccessibleDescription">
        <short>Setter for the property AccessibleDescription.</short>
      </element>

      <element name="TLazAccessibleObject.SetAccessibleValue">
        <short>Setter for the property AccessibleValue.</short>
      </element>

      <element name="TLazAccessibleObject.SetAccessibleRole">
        <short>Setter for the property AccessibleRole.</short>
      </element>

      <element name="TLazAccessibleObject.FindOwnerWinControl">
        <short>Inspect the tree of accessible objects upwards until it finds a parent which is attached directly to a windowed control, a TWinControl.</short>
      </element>

      <element name="TLazAccessibleObject.AddChildAccessibleObject">
        <short>Creates and returns a new child accessibility object.</short>
      </element>
      <element name="TLazAccessibleObject.AddChildAccessibleObject.Result">
        <short>Child accessibility object created in the method.</short>
      </element>
      <element name="TLazAccessibleObject.AddChildAccessibleObject.ADataObject">
        <short/>
      </element>

      <element name="TLazAccessibleObject.InsertChildAccessibleObject">
        <short>Inserts an already created child accessible object as a child of this one.</short>
      </element>

      <element name="TLazAccessibleObject.ClearChildAccessibleObjects">
        <short>
          Removes all children of this control; freed if they are not attached to a TControl instance.
        </short>
      </element>

      <element name="TLazAccessibleObject.RemoveChildAccessibleObject">
        <short>Removes a child accessible object.</short>
      </element>

      <element name="TLazAccessibleObject.GetChildAccessibleObject">
        <short>Obtains a child accessible object by its index.</short>
      </element>

      <element name="TLazAccessibleObject.GetChildAccessibleObjectWithDataObject">
        <short>Obtains a child accessible object by its DataObject property.</short>
      </element>

      <element name="TLazAccessibleObject.GetChildAccessibleObjectsCount">
        <short>Returns the number of direct children that this accessible object has.</short>
      </element>

       <element name="TLazAccessibleObject.GetFirstChildAccessibleObject">
         <short>Searches in sub-controls for the first child accessibility object.</short>
         <descr/>
         <seealso/>
       </element>
       <element name="TLazAccessibleObject.GetFirstChildAccessibleObject.Result">
         <short/>
       </element>

       <element name="TLazAccessibleObject.GetNextChildAccessibleObject">
         <short>Searches in sub-controls for the next child accessibility object.</short>
         <descr/>
         <seealso/>
       </element>
       <element name="TLazAccessibleObject.GetNextChildAccessibleObject.Result">
         <short/>
       </element>

      <element name="TLazAccessibleObject.GetSelectedChildAccessibleObject">
        <short>
          Returns the currently selected child accessible object or <b>Nil</b> if none are selected;  Override this method in your sub class.
        </short>
        <seealso>
          <link id="TControl.GetSelectedChildAccessibleObject"/>
        </seealso>
      </element>

      <element name="TLazAccessibleObject.GetChildAccessibleObjectAtPos">
        <short>
          Returns the child of this control located at a particular position given as a client position for the control.
        </short>
        <seealso>
          <link id="TControl.GetChildAccessibleObjectAtPos"/>
        </seealso>
      </element>

      <element name="TLazAccessibleObject.AccessibleName">
        <short>The name for this accessible object.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TLazAccessibleObject.AccessibleDescription">
        <short>The description of this accessible object.</short>
        <seealso>
          <link id="TControl.AccessibleDescription"/>
        </seealso>
      </element>

      <element name="TLazAccessibleObject.AccessibleValue">
        <short>The value of this accessible object.</short>
        <seealso>
          <link id="TControl.AccessibleValue"/>
        </seealso>
      </element>

      <element name="TLazAccessibleObject.AccessibleRole">
        <short>The role of this accessible object.</short>
        <seealso>
          <link id="TControl.AccessibleRole"/>
        </seealso>
      </element>

      <element name="TLazAccessibleObject.Position">
        <short>The position of this accessible object.</short>
      </element>

      <element name="TLazAccessibleObject.Size">
        <short>The size of this accessible object.</short>
      </element>

      <element name="TLazAccessibleObject.Handle">
        <short>The widgetset handle of this accessible object.</short>
      </element>

      <element name="TLazAccessibleObject.GetEnumerator">
        <short>Default enumerator for the children.</short>
      </element>

      <element name="TControl">
        <short>The base class for visible controls.</short>
        <descr>
          <p>
            <var>TControl</var> is a <var>TLCLComponent</var> descendant which implements the base class for visual controls in the <b>LCL</b> (<b>Lazarus Component Library</b>).  TControl extends ancestor classes, like TLCLComponent and TComponent, with properties and methods needed to configure the appearance and behavior for the visual control and handle user interactions at run-time.
          </p>
          <p>
            Some properties and methods are in all of its descendent classes. Others are implemented as needed in descendent classes. The properties and methods fall into categories like:
          </p>
          <ul>
            <li>Appearance</li>
            <li>Position and Orientation</li>
            <li>Sizing and Aligning</li>
            <li>Assistance and Accessibility</li>
            <li>Drag and Drop</li>
            <li>Docking</li>
            <li>Action Support</li>
            <li>Hi-DPI Awareness and Scaling</li>
            <li>Handler Lists for Event Notifications </li>
            <li>Window and Control Message Handling</li>
            <li>Keyboard and Mouse Message Handling</li>
            <li>Widgetset-specific Members and Methods</li>
          </ul>
          <p>
            Applications do not normally create instances of TControl. It is used as an ancestor for descendent classes which implement additional features or behaviors.
          </p>
          <p>
            TControl does not provide a window handle needed to draw the control in the underlying widgetset class. It includes a Parent property which is the windowed control where the control is hosted. It also provides the handle needed to draw the control.
          </p>
          <p>
            Use TWinControl for a control which provides its own window handle.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl"/>
          <link id="#lcl.lclclasses.TLCLComponent">TLCLComponent</link>
          <link id="#rtl.classes.TComponent">TComponent</link>
        </seealso>
      </element>

      <element name="TControl.FActionLink"/>
      <element name="TControl.FAlign"/>
      <element name="TControl.FAnchors"/>
      <element name="TControl.FAnchorSides"/>
      <element name="TControl.fAnchoredControls"/>
      <element name="TControl.FAutoSizingLockCount"/>
      <element name="TControl.FAutoSizingLockReasons"/>
      <element name="TControl.FBaseBounds"/>
      <element name="TControl.FBaseBoundsLock"/>
      <element name="TControl.FBaseParentClientSize"/>
      <element name="TControl.FBiDiMode"/>
      <element name="TControl.FBorderSpacing"/>
      <element name="TControl.FBoundsRectForNewParent"/>
      <element name="TControl.FCaption"/>
      <element name="TControl.FCaptureMouseButtons"/>
      <element name="TControl.FColor"/>
      <element name="TControl.FConstraints"/>
      <element name="TControl.FControlFlags"/>

      <element name="TControl.FControlHandlers">
        <short>Array of the installable notification handlers.</short>
      </element>

      <element name="TControl.FControlStyle"/>
      <element name="TControl.FDockOrientation"/>
      <element name="TControl.FDragCursor"/>
      <element name="TControl.FDragKind"/>
      <element name="TControl.FDragMode"/>
      <element name="TControl.FFloatingDockSiteClass"/>
      <element name="TControl.FFont"/>
      <element name="TControl.FHeight"/>
      <element name="TControl.FHelpContext"/>
      <element name="TControl.FHelpKeyword"/>
      <element name="TControl.FHelpType"/>
      <element name="TControl.FHint"/>
      <element name="TControl.FHostDockSite"/>
      <element name="TControl.FLastDoChangeBounds"/>
      <element name="TControl.FLastDoChangeClientSize"/>
      <element name="TControl.FLastResizeClientHeight"/>
      <element name="TControl.FLastResizeClientWidth"/>
      <element name="TControl.FLastResizeHeight"/>
      <element name="TControl.FLastResizeWidth"/>
      <element name="TControl.FLeft"/>

      <element name="TControl.FLoadedClientSize">
        <short>Intended ClientSize, initialized during loading.</short>
      </element>

      <element name="TControl.FLRDockWidth"/>
      <element name="TControl.FOnChangeBounds"/>
      <element name="TControl.FOnClick"/>
      <element name="TControl.FOnConstrainedResize"/>
      <element name="TControl.FOnContextPopup"/>
      <element name="TControl.FOnDblClick"/>
      <element name="TControl.FOnDragDrop"/>
      <element name="TControl.FOnDragOver"/>
      <element name="TControl.FOnEditingDone"/>
      <element name="TControl.FOnEndDock"/>
      <element name="TControl.FOnEndDrag"/>
      <element name="TControl.FOnMouseDown"/>
      <element name="TControl.FOnMouseEnter"/>
      <element name="TControl.FOnMouseLeave"/>
      <element name="TControl.FOnMouseMove"/>
      <element name="TControl.FOnMouseUp"/>
      <element name="TControl.FOnMouseWheel"/>
      <element name="TControl.FOnMouseWheelDown"/>
      <element name="TControl.FOnMouseWheelUp"/>
      <element name="TControl.FOnMouseWheelHorz"/>
      <element name="TControl.FOnMouseWheelLeft"/>
      <element name="TControl.FOnMouseWheelUpRight"/>
      <element name="TControl.FOnQuadClick"/>
      <element name="TControl.FOnResize"/>
      <element name="TControl.FOnShowHint"/>
      <element name="TControl.FOnStartDock"/>
      <element name="TControl.FOnStartDrag"/>
      <element name="TControl.FOnTripleClick"/>
      <element name="TControl.FParent"/>
      <element name="TControl.FPopupMenu"/>
      <element name="TControl.FPreferredMinHeight"/>
      <element name="TControl.FPreferredMinWidth"/>
      <element name="TControl.FPreferredWidth"/>
      <element name="TControl.FPreferredHeight"/>
      <element name="TControl.FReadBounds"/>
      <element name="TControl.FSessionProperties"/>
      <element name="TControl.FSizeLock"/>
      <element name="TControl.FTBDockHeight"/>
      <element name="TControl.FTop"/>
      <element name="TControl.FUndockHeight"/>
      <element name="TControl.FUndockWidth"/>
      <element name="TControl.FWidth"/>
      <element name="TControl.FWindowProc"/>
      <element name="TControl.FDesktopFont"/>
      <element name="TControl.FParentBiDiMode"/>
      <element name="TControl.FIsControl"/>
      <element name="TControl.FShowHint"/>
      <element name="TControl.FParentColor"/>
      <element name="TControl.FParentFont"/>
      <element name="TControl.FParentShowHint"/>
      <element name="TControl.FAutoSize"/>
      <element name="TControl.FAutoSizingAll"/>
      <element name="TControl.FAutoSizingSelf"/>
      <element name="TControl.FEnabled"/>
      <element name="TControl.FMouseInClient"/>
      <element name="TControl.FVisible"/>

      <element name="TControl.CaptureMouseButtonsIsStored">
        <short>Implements the storage specifier for the CaptureMouseButtons property.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.CaptureMouseButtonsIsStored.Result">
        <short/>
      </element>

      <element name="TControl.DoActionChange">
        <short>Implements the  OnChange handler routine assigned to the ActionLink.</short>
        <descr>
          <p>
            When an Action is assigned to the control, related properties are updated using <link id="TControl.ActionChange">ActionChange</link>.
          </p>
        </descr>
      </element>
      <element name="TControl.DoActionChange.Sender">
        <short>The changed Action.</short>
      </element>

      <element name="TControl.GetAccessibleDescription">
         <short>Gets the value for the AccessibleDescription property.</short>
        <descr/>
        <seealso>
          <link id="TControl.AccessibleDescription"/>
        </seealso>
      </element>
      <element name="TControl.GetAccessibleDescription.Result">
         <short>Value for the property.</short>
      </element>

      <element name="TControl.GetAccessibleValue">
         <short>Gets the value for the AccessibleValue property.</short>
        <descr/>
        <seealso>
          <link id="TControl.AccessibleValue"/>
        </seealso>
      </element>
      <element name="TControl.GetAccessibleValue.Result">
         <short>Value for the property.</short>
      </element>

      <element name="TControl.GetAccessibleRole">
         <short>Gets the value for the AccessibleRole property.</short>
        <descr/>
        <seealso>
          <link id="TControl.AccessibleRole"/>
        </seealso>
      </element>
      <element name="TControl.GetAccessibleRole.Result">
         <short>Value for the property.</short>
      </element>

      <element name="TControl.GetAutoSizingAll">
        <short>Gets the value for the AutoSizingAll property.</short>
        <descr>
          <p>
            Returns the value from the AutoSizingAll property in the Parent when Parent has been assigned. Otherwise, the existing property value is used.
          </p>
        </descr>
        <seealso>
          <link id="TControl.AutoSizingAll"/>
          <link id="TControl.Parent"/>
        </seealso>
      </element>
      <element name="TControl.GetAutoSizingAll.Result">
        <short>Value for the AutoSizingAll property.</short>
      </element>

      <element name="TControl.GetAnchorSide">
        <short>Gets the value for the indexed AnchorSide property.</short>
        <descr/>
        <seealso>
          <link id="TControl.AnchorSide"/>
          <link id="TAnchorKind"/>
        </seealso>
      </element>
      <element name="TControl.GetAnchorSide.Result">
        <short>Value for the indexed AnchorSide property.</short>
      </element>
      <element name="TControl.GetAnchorSide.Kind">
        <short>TAnchorKind value with the array element accessed for the property value.</short>
      </element>

      <element name="TControl.GetAnchoredControls">
        <short>Gets the value for the indexed AnchoredControls property.</short>
        <descr/>
        <seealso>
          <link id="TControl.AnchoredControls"/>
        </seealso>
      </element>
      <element name="TControl.GetAnchoredControls.Result">
        <short>Value for the indexed AnchoredControls property.</short>
      </element>
      <element name="TControl.GetAnchoredControls.Index">
        <short>Ordinal position in the list of anchored controls for the property value.</short>
      </element>

      <element name="TControl.GetBoundsRect">
        <short>Gets the value for the BoundsRect property.</short>
        <descr/>
        <seealso>
          <link id="TControl.BoundsRect"/>
        </seealso>
      </element>
      <element name="TControl.GetBoundsRect.Result">
        <short>Value for the BoundsRect property.</short>
      </element>

      <element name="TControl.GetClientHeight">
        <short>Gets the value for the ClientHeight property.</short>
        <descr/>
        <seealso>
          <link id="TControl.ClientHeight"/>
        </seealso>
      </element>
      <element name="TControl.GetClientHeight.Result">
        <short>Value for the ClientHeight property.</short>
      </element>

      <element name="TControl.GetClientWidth">
        <short>Gets the value for the ClientWidth property.</short>
        <descr/>
        <seealso>
          <link id="TControl.ClientWidth"/>
        </seealso>
      </element>
      <element name="TControl.GetClientWidth.Result">
        <short>Value for the ClientWidth property.</short>
      </element>

      <element name="TControl.GetLRDockWidth">
        <short>Gets the value for the LRDockWidth property.</short>
        <descr/>
        <seealso>
          <link id="TControl.LRDockWidth"/>
        </seealso>
      </element>
      <element name="TControl.GetLRDockWidth.Result">
        <short>Value for the LRDockWidth property.</short>
      </element>

      <element name="TControl.GetTBDockHeight">
        <short>Gets the value for the TBDockHeight property.</short>
        <descr/>
        <seealso>
          <link id="TControl.TBDockHeight"/>
        </seealso>
      </element>
      <element name="TControl.GetTBDockHeight.Result">
        <short>Value for the TBDockHeight property.</short>
      </element>

      <element name="TControl.GetText">
        <short>Gets the value for the Text property.</short>
        <descr>
          <p>
            Uses RealGetText (which reads the Caption member), instead of GetTextBuf (which calls WM_GETTEXT), when possible.
          </p>
        </descr>
        <seealso>
          <link id="TControl.RealGetText"/>
          <link id="TControl.GetTextBuf"/>
        </seealso>
      </element>
      <element name="TControl.GetText.Result">
        <short>The value for the Text property.</short>
      </element>

      <element name="TControl.GetUndockHeight">
        <short>Gets the value for the UndockHeight property.</short>
        <descr/>
        <seealso>
          <link id="TControl.UndockHeight"/>
        </seealso>
      </element>
      <element name="TControl.GetUndockHeight.Result">
        <short>Value for the UndockHeight property.</short>
      </element>

      <element name="TControl.GetUndockWidth">
        <short>Gets the value for the UndockWidth property.</short>
        <descr/>
        <seealso>
          <link id="TControl.UndockWidth"/>
        </seealso>
      </element>
      <element name="TControl.GetUndockWidth.Result">
        <short>Value for the UndockWidth property.</short>
      </element>

      <element name="TControl.IsAnchorsStored">
        <short>Implements the storage specifier for the Anchors property.</short>
        <descr/>
        <seealso>
          <link id="TControl.Anchors"/>
        </seealso>
      </element>
      <element name="TControl.IsAnchorsStored.Result">
        <short/>
      </element>

      <element name="TControl.IsBiDiModeStored">
        <short>Implements the storage specifier for the BiDiMode property.</short>
        <descr/>
        <seealso>
          <link id="TControl.BiDiMode"/>
        </seealso>
      </element>
      <element name="TControl.IsBiDiModeStored.Result">
        <short/>
      </element>

      <element name="TControl.IsEnabledStored">
        <short>Implements the storage specifier for the Enabled property.</short>
        <descr/>
        <seealso>
          <link id="TControl.Enabled"/>
        </seealso>
      </element>
      <element name="TControl.IsEnabledStored.Result">
        <short/>
      </element>

      <element name="TControl.IsFontStored">
        <short>Implements the storage specifier for the Font property.</short>
        <descr/>
        <seealso>
          <link id="TControl.Font"/>
        </seealso>
      </element>
      <element name="TControl.IsFontStored.Result">
        <short/>
      </element>

      <element name="TControl.IsHintStored">
        <short>Implements the storage specifier for the Hint property.</short>
        <descr>
          <p>
            The return value is <b>True</b> when the property value is not supplied by an Action linked to the control. This occurs when an ActionLink has not been assigned for the control, or when the IsHintLinked property in the ActionLink is set to <b>False</b>.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Hint"/>
        </seealso>
      </element>
      <element name="TControl.IsHintStored.Result">
        <short><b>True</b> when the property value is stored using LCL component streaming.</short>
      </element>

      <element name="TControl.IsHelpContextStored"/>
      <element name="TControl.IsHelpContextStored.Result"/>

      <element name="TControl.IsHelpKeyWordStored"/>
      <element name="TControl.IsHelpKeyWordStored.Result"/>

      <element name="TControl.IsShowHintStored"/>
      <element name="TControl.IsShowHintStored.Result"/>

      <element name="TControl.IsVisibleStored"/>
      <element name="TControl.IsVisibleStored.Result"/>

      <element name="TControl.DoBeforeMouseMessage">
        <short>Generate MouseEnter and MouseLeave events.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.DoConstrainedResize">
        <short>Adjust the intended (given) Bounds, according to Constraints.</short>
        <descr/>
        <seealso>
          <link id="TControl.Constraints"/>
          <link id="TControl.ConstrainedResize"/>
        </seealso>
      </element>
      <element name="TControl.DoConstrainedResize.NewLeft">
        <short/>
      </element>
      <element name="TControl.DoConstrainedResize.NewTop">
        <short/>
      </element>
      <element name="TControl.DoConstrainedResize.NewWidth">
        <short/>
      </element>
      <element name="TControl.DoConstrainedResize.NewHeight">
        <short/>
      </element>

      <element name="TControl.DoMouseDown">
        <short>
          Performs the message handler for mouse button down messages; calls the MouseDown handler.
        </short>
        <descr/>
        <seealso>
          <link id="TControl.DoMouseUp"/>
          <link id="TControl.MouseDown"/>
          <link id="TControl.OnMouseDown"/>
        </seealso>
      </element>
      <element name="TControl.DoMouseDown.Message">
        <short/>
      </element>
      <element name="TControl.DoMouseDown.Button">
        <short/>
      </element>
      <element name="TControl.DoMouseDown.Shift">
        <short/>
      </element>

      <element name="TControl.DoMouseUp">
        <short>
          Performs the message handler for mouse button up messages; calls the MouseUp handler.
        </short>
        <descr/>
        <seealso>
          <link id="TControl.DoMouseDown"/>
          <link id="TControl.MouseUp"/>
          <link id="TControl.OnMouseUp"/>
        </seealso>
      </element>
      <element name="TControl.DoMouseUp.Message">
        <short/>
      </element>
      <element name="TControl.DoMouseUp.Button">
        <short/>
      </element>

      <element name="TControl.SetAccessibleDescription">
         <short>Sets the value for the AccessibleDescription property.</short>
        <descr/>
        <seealso>
          <link id="TControl.AccessibleDescription"/>
        </seealso>
      </element>
      <element name="TControl.SetAccessibleDescription.AValue">
        <short>New value for the AccessibleDescription property.</short>
      </element>

      <element name="TControl.SetAccessibleValue">
        <short>Sets the value for the AccessibleValue property.</short>
        <descr/>
        <seealso>
          <link id="TControl.AccessibleValue"/>
        </seealso>
      </element>
      <element name="TControl.SetAccessibleValue.AValue">
        <short>New value for the AccessibleValue property.</short>
      </element>

      <element name="TControl. SetAccessibleRole">
        <short>Sets the value for the AccessibleRole property.</short>
        <descr/>
        <seealso>
          <link id="TControl.AccessibleRole"/>
        </seealso>
      </element>
      <element name="TControl. SetAccessibleRole.AValue">
        <short>New value for the AccessibleRole property.</short>
      </element>

      <element name="TControl.SetAnchorSide">
        <short>Sets the value for the indexed AnchorSide property.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.SetAnchorSide.Kind">
       <short>Index for the element updated in the method.</short>
      </element>
      <element name="TControl.SetAnchorSide.AValue">
       <short>New value for the AnchorSize property.</short>
      </element>

      <element name="TControl.SetBorderSpacing">
        <short>Sets the value for the BorderSpacing property.</short>
        <descr/>
        <seealso>
          <link id="TControl.BorderSpacing"/>
        </seealso>
      </element>
      <element name="TControl.SetBorderSpacing.AValue">
       <short>New value for the BorderSpacing property.</short>
      </element>

      <element link="#lcl.controls.TControl.BoundsRect" name="TControl.SetBoundsRect"/>
      <element name="TControl.SetBoundsRect.ARect">
        <short/>
      </element>

      <element link="#lcl.controls.TControl.BoundsRectForNewParent" name="TControl.SetBoundsRectForNewParent"/>
      <element name="TControl.SetBoundsRectForNewParent.AValue">
       <short/>
      </element>

      <element link="#lcl.controls.TControl.ClientHeight" name="TControl.SetClientHeight"/>
      <element name="TControl.SetClientHeight.Value">
       <short/>
      </element>

      <element link="#lcl.controls.TControl.ClientRect" name="TControl.SetClientSize"/>
      <element name="TControl.SetClientSize.Value">
       <short/>
      </element>

      <element link="#lcl.controls.TControl.ClientWidth" name="TControl.SetClientWidth"/>
      <element name="TControl.SetClientWidth.Value">
       <short/>
      </element>

      <element name="TControl.SetConstraints">
        <short>Sets the value for the Constraints property.</short>
        <descr/>
        <seealso>
          <link id="TControl.Constraints"/>
        </seealso>
      </element>
      <element name="TControl.SetConstraints.Value">
       <short>New value for the Constraints property.</short>
      </element>

      <element link="#lcl.controls.TControl.DesktopFont" name="TControl.SetDesktopFont"/>
      <element name="TControl.SetDesktopFont.AValue">
       <short/>
      </element>

      <element link="#lcl.controls.TControl.DragCursor" name="TControl.SetDragCursor"/>
      <element name="TControl.SetDragCursor.AValue">
       <short/>
      </element>

      <element link="#lcl.controls.TControl.Font" name="TControl.SetFont"/>
      <element name="TControl.SetFont.Value">
       <short/>
      </element>

      <element link="#lcl.controls.TControl.Height" name="TControl.SetHeight"/>
      <element name="TControl.SetHeight.Value">
       <short/>
      </element>

      <element link="#lcl.controls.TControl.HelpContext" name="TControl.SetHelpContext"/>
      <element name="TControl.SetHelpContext.AValue">
       <short/>
      </element>

      <element link="#lcl.controls.TControl.HelpKeyword" name="TControl.SetHelpKeyword"/>
      <element name="TControl.SetHelpKeyword.AValue">
       <short/>
      </element>

      <element link="#lcl.controls.TControl.HostDockSite" name="TControl.SetHostDockSite"/>
      <element name="TControl.SetHostDockSite.AValue">
       <short/>
      </element>

      <element link="#lcl.controls.TControl.Left" name="TControl.SetLeft"/>
      <element name="TControl.SetLeft.Value">
       <short/>
      </element>

      <element link="#lcl.controls.TControl.MouseCapture" name="TControl.SetMouseCapture"/>
      <element name="TControl.SetMouseCapture.Value">
       <short/>
      </element>

      <element link="#lcl.controls.TControl.ParentShowHint" name="TControl.SetParentShowHint"/>
      <element name="TControl.SetParentShowHint.Value">
       <short/>
      </element>

      <element link="#lcl.controls.TControl.ParentColor" name="TControl.SetParentColor"/>
      <element name="TControl.SetParentColor.Value">
       <short/>
      </element>

      <element link="#lcl.controls.TControl.ParentFont" name="TControl.SetParentFont"/>
      <element name="TControl.SetParentFont.Value">
        <short/>
      </element>

      <element link="#lcl.controls.TControl.PopupMenu" name="TControl.SetPopupMenu"/>
      <element name="TControl.SetPopupMenu.Value">
        <short/>
      </element>

      <element link="#lcl.controls.TControl.ShowHint" name="TControl.SetShowHint"/>
      <element name="TControl.SetShowHint.Value">
        <short/>
      </element>

      <element name="TControl.SetText">
        <short>Sets the value for the Text property.</short>
        <descr>
          Uses the RealSetText method instead of SetTextBuf, when possible.
        </descr>
        <seealso>
          <link id="TControl.Text"/>
          <link id="TControl.RealSetText"/>
          <link id="TControl.SetTextBuf"/>
        </seealso>
      </element>
      <element name="TControl.SetText.Value">
        <short>The new value for the Text property.</short>
      </element>

      <element link="#lcl.controls.TControl.Top" name="TControl.SetTop"/>
      <element name="TControl.SetTop.Value">
        <short/>
      </element>

      <element link="#lcl.controls.TControl.Width" name="TControl.SetWidth"/>
      <element name="TControl.SetWidth.Value">
        <short/>
      </element>

      <element name="TControl.FAccessibleObject">
        <short>Member with the accessibility object for the control.</short>
      </element>
      <element name="TControl.FControlState">
        <short>Member with the value for the ControlState property.</short>
      </element>
      <element name="TControl.FCursor">
        <short>Member with the value for the Cursor property.</short>
      </element>

      <element name="TControl.WSRegisterClass" link="#lcl.lclclasses.TLCLComponent.WSRegisterClass"/>

      <element name="TControl.GetCursor">
        <short>Gets the value for the Cursor property.</short>
        <descr/>
        <seealso>
          <link id="TControl.Cursor"/>
        </seealso>
      </element>
      <element name="TControl.GetCursor.Result">
        <short>Value for the Cursor property.</short>
      </element>

      <element name="TControl.SetCursor">
        <short>Sets the value for the Cursor property.</short>
        <descr>
          <p>
            Calls Perform to send a CM_CURSORCHANGED control message to the processing loop when the member for the property is updated.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Cursor"/>
          <link id="TControl.Perform"/>
          <link id="TControl.CMCursorChanged"/>
        </seealso>
      </element>
      <element name="TControl.SetCursor.Value">
        <short>New value for the Cursor property.</short>
      </element>

      <element name="TControl.SetVisible">
        <short>Sets the value for the Visible property.</short>
        <descr>
          <p>
            Changing the value for the property causes additional actions to be performed.
          </p>
          <p>
            VisibleChanging is called to notify event handler routines for the control. The Perform method is used to send a CM_VISIBLECHANGED control message to the processing loop for the control.
          </p>
          <p>
            Preferred width and  height values in the control, and its children (when derived from TWinControl), are invalidated. To minimize the overhead from the DoAutoSize method, auto-sizing is temporarily disabled when the control is updated. The AdjustSize method is called to perform the equivalent of DoAutoSize without the extra overhead of getting the preferred sizes from the widgetset class. If the control is not Visible but has a Parent control, the AdjustSize method in Parent is called.
          </p>
          <p>
            VisibleChanged is called to notify event handler routines for the control.
          </p>
          <p>
            SetVisible ensures that ControlState is updated to include the value csVisibleSetInLoading when csLoading is included in the ComponentState property.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Visible"/>
        </seealso>
      </element>
      <element name="TControl.SetVisible.Value">
        <short>New value for the Visible property.</short>
      </element>

      <element name="TControl.DoOnParentHandleDestruction">
        <short>Performs actions needed when the handle for the parent control is freed.</short>
        <descr>
          <p>
            Has an empty implementation in TControl, and must be implement in descendent classes.
          </p>
        </descr>
        <seealso>
          <link id="TGraphicControl.DoOnParentHandleDestruction"/>
        </seealso>
      </element>

      <element name="TControl.DoAutoSize">
        <short>For internal use only; call AdjustSize instead.</short>
        <descr>
          <remark>
            IMPORTANT: Many Delphi controls override this method and many call this method directly after setting some properties.
          </remark>
          <p>
            During handle creation not all interfaces can create complete Device Contexts which are needed to calculate things like text size. That's why you should always call <link id="#lcl.controls.TControl.AdjustSize">AdjustSize</link> instead of <var>DoAutoSize</var>.
          </p>
        </descr>
        <seealso>
          <link id="TControl.AutoSize"/>
          <link id="TControl.AdjustSize"/>
        </seealso>
      </element>

      <element name="TControl.DoAllAutoSize">
        <short>Resizes and aligns the control and all of it children.</short>
        <descr>
          <p>
            No actions are performed in the method when AutoSizingAll is <b>True</b>, or when the control is not derived from TWinControl.
          </p>
          <p>
            Calls DoAutoSize while the control includes cfAutoSizeNeeded in its ControlFlags property.
            Called from the AdjustSize and EnableAutoSizing methods.
          </p>
        </descr>
        <errors>
          Raises an EInvalidOperation exception if Parent has not been assigned for the control.
        </errors>
        <seealso>
          <link id="TControl.Parent"/>
          <link id="TControl.AutoSizingAll"/>
          <link id="TControl.AutoSizeDelayed"/>
          <link id="TWinControl.Controls"/>
        </seealso>
      </element>

      <element name="TControl.BeginAutoSizing">
        <short>Sets AutoSizing to <b>True</b>; used to prevent loops.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.EndAutoSizing">
        <short>End of the auto-sizing process, resets AutoSizing to <b>False</b>.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.AnchorSideChanged">
        <short>Request further processing after an anchor side was changed.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.AnchorSideChanged.TheAnchorSide">
        <short>Ignored.</short>
      </element>

      <element name="TControl.ForeignAnchorSideChanged">
        <short>
          Requests further processing after an anchor side has changed, that anchors another control to this one.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.ForeignAnchorSideChanged.TheAnchorSide">
        <short/>
      </element>
      <element name="TControl.ForeignAnchorSideChanged.Operation">
        <short/>
      </element>

      <element name="TControl.SetAlign">
        <short>Sets the value for the Align property.</short>
        <descr>
          <p>
            Changing the value for the property causes additional actions to be performed.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Align"/>
        </seealso>
      </element>
      <element name="TControl.SetAlign.Value">
        <short>New value for the Align property.</short>
      </element>

      <element name="TControl.SetAnchors">
        <short>Sets the value for the Anchors property.</short>
        <descr/>
        <seealso>
          <link id="TControl.Anchors"/>
        </seealso>
      </element>
      <element name="TControl.SetAnchors.AValue">
        <short>New value for the Anchors property.</short>
      </element>

      <element name="TControl.SetAutoSize">
        <short>Sets the value for the AutoSize property.</short>
        <descr>
          <p>
            Calls AdjustSize when the property is enabled.
          </p>
        </descr>
        <seealso>
          <link id="TControl.AdjustSize"/>
          <link id="TControl.AutoSize"/>
        </seealso>
      </element>
      <element name="TControl.SetAutoSize.Value">
        <short>New value for the AutoSize property.</short>
      </element>

      <element name="TControl.BoundsChanged">
        <short>
          Called when the Bounds of the control have been changed; override as required.
        </short>
        <descr>
          Notifications can be performed in this method.
        </descr>
      </element>

      <element name="TControl.CreateControlBorderSpacing">
        <short>
          Creates the default BorderSpacing object instance for the class.
        </short>
        <descr>
          <p>
            Allocates the class instance used for the BorderSpacing property. Can be overridden in descendent controls to use the type or default values needed for the class instance.
          </p>
        </descr>
        <seealso>
          <link id="TControlBorderSpacing"/>
          <link id="TControl.BorderSpacing"/>
        </seealso>
      </element>
      <element name="TControl.CreateControlBorderSpacing.Result">
        <short>The class instance created in the method.</short>
      </element>

      <element name="TControl.DoConstraintsChange">
        <short>Performs actions needed when value(s) in Constraints have been changed.</short>
        <descr>
          <p>
            DoConstraintsChange calls AdjustSize to ensure that the control and any children are sized and positioned to  the new Constraints for the control. The method is overridden in descendent classes, like TWinControl, to perform actions needed for the class instance.
          </p>
          <p>
            Called from the TSizeConstraints.Change method before it signals the OnChange event handler in the constraints class instance.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.DoConstraintsChange"/>
        </seealso>
      </element>
      <element name="TControl.DoConstraintsChange.Sender">
        <short>Not used in the method.</short>
      </element>

      <element name="TControl.DoBorderSpacingChange">
        <short>Reacts on a change in the control's border spacing.</short>
      </element>
      <element name="TControl.DoBorderSpacingChange.Sender">
        <short/>
      </element>
      <element name="TControl.DoBorderSpacingChange.InnerSpaceChanged">
        <short/>
      </element>

      <element name="TControl.IsBorderSpacingInnerBorderStored">
        <short>Checks for a defined (non-zero) value in BorderSpacing.InnerBorder.</short>
      </element>
      <element name="TControl.IsBorderSpacingInnerBorderStored.Result">
        <short><b>True</b> when InnerBorder has been assigned and must be applied to the control.</short>
      </element>

       <element name="TControl.IsCaptionStored">
         <short>Implements the storage specifier for the Caption property.</short>
         <descr>
           <p>
             Returns <b>True</b> if ActionLink has not been assigned, or its IsCaptionLinked property is set to <b>False</b>.
           </p>
         </descr>
         <seealso/>
       </element>
       <element name="TControl.IsCaptionStored.Result">
         <short>
           Returns <b>True</b> if ActionLink has not been assigned, or its IsCaptionLinked property is set to <b>False</b>.
         </short>
       </element>

      <element name="TControl.SendMoveSizeMessages">
        <short>
          Sends Move and Size messages through the LCL message paths.
        </short>
        <descr>
          <p>
            Overridden in TWinControl; in TControl it's a NOP. This method simulates the VCL behavior and has no real effect.
          </p>
        </descr>
      </element>
      <element name="TControl.SendMoveSizeMessages.SizeChanged">
        <short/>
      </element>
      <element name="TControl.SendMoveSizeMessages.PosChanged">
        <short/>
      </element>

      <element name="TControl.ConstrainedResize">
        <short>Signals  the OnConstrainedResize handler.</short>
        <seealso>
          <link id="TControl.OnConstrainedResize"/>
        </seealso>
      </element>
      <element name="TControl.ConstrainedResize.MinWidth">
        <short/>
      </element>
      <element name="TControl.ConstrainedResize.MinHeight">
        <short/>
      </element>
      <element name="TControl.ConstrainedResize.MaxWidth">
        <short/>
      </element>
      <element name="TControl.ConstrainedResize.MaxHeight">
        <short/>
      </element>

      <element name="TControl.CalculatePreferredSize">
        <short>
          Override this method to return the preferred height and width for the control.
        </short>
        <descr>
          <p>
            Calculates the preferred width and height for a control, which is used by the LCL auto-sizing algorithms as the default size. Negative or zero (0) values are treated as undefined and the LCL uses other sizes instead.
          </p>
          <p>
            <var>TWinControl</var> overrides this and asks the interface for theme dependent values. See <link id="TWinControl.CalculatePreferredSize"/> for more information.
          </p>
          <p>
            When WithThemeSpace contains <b>True</b>, space is added for stacking.
          </p>
          <p>
            For example: <var>TRadioButton</var> has a minimum size. But for stacking multiple TRadioButtons there should be some space around the controls. This space is theme-dependent, so the parameter is passed to the widgetset.
          </p>
        </descr>
      </element>
      <element name="TControl.CalculatePreferredSize.PreferredWidth">
        <short>Set this argument to the preferred width.</short>
      </element>
      <element name="TControl.CalculatePreferredSize.PreferredHeight">
        <short>Set this argument to the preferred height.</short>
      </element>
      <element name="TControl.CalculatePreferredSize.WithThemeSpace">
        <short><b>True</b> when space around stacked controls should be added.</short>
      </element>

      <element name="TControl.DoOnResize">
        <short>Signals OnResize event handlers for the control.</short>
        <descr/>
        <seealso>
          <link id="TControl.OnResize"/>
          <link id="TControl.DoCallNotifyHandler"/>
          <link id="TControlHandlerType"/>
        </seealso>
      </element>

      <element name="TControl.DoOnChangeBounds">
        <short>
          Signals OnChangeBounds event handlers for the control.
        </short>
        <descr/>
        <seealso>
          <link id="TControl.OnChangeBounds"/>
          <link id="TControl.DoCallNotifyHandler"/>
          <link id="TControlHandlerType"/>
        </seealso>
      </element>

      <element name="TControl.CheckOnChangeBounds">
        <short>
          Checks for changes and calls <link id="#lcl.Controls.TControl.DoOnChangeBounds">DoOnChangeBounds</link> if needed.
        </short>
        <descr>
          <p>
            Maintains internal members used to track the last bounds rectangle and client size before DoOnChangeBounds is called. Called from the LoadedAll and ChangeBounds methods.
          </p>
        </descr>
        <seealso>
          <link id="TControl.LoadedAll"/>
          <link id="TControl.ChangeBounds"/>
          <link id="TControl.DoOnChangeBounds"/>
        </seealso>
      </element>

      <element name="TControl.Resize">
        <short>Checks for changes and calls DoOnResize if needed.</short>
        <descr>
          <p>
            No actions are performed in the method at design-time, during LCL component streaming, or when AutoSizeDelayed is set to <b>True</b>.
          </p>
          <p>
            Resize updates internal members used to track the current values in the Width, Height, ClientWidth, and ClientHeight properties. It calls DoOnResize to signal OnResize event handler(s) (when assigned) for the control.
          </p>
        </descr>
        <seealso>
          <link id="TControl.DoOnResize"/>
          <link id="TControl.OnResize"/>
          <link id="TControl.DoCallNotifyHandler"/>
          <link id="TControlHandlerType"/>
        </seealso>
      </element>

      <element name="TControl.RequestAlign">
        <short>
          Smart calling of <var>Parent.AlignControls</var> (very indirectly).
        </short>
        <seealso>
          <link id="TWinControl.AlignControls"/>
        </seealso>
      </element>

      <element name="TControl.UpdateAnchorRules">
        <short>Update the rules for anchoring the control.</short>
      </element>

      <element name="TControl.ChangeBounds">
        <short>
          Sets the bounds (left, top, height, width) optionally the BaseBounds of the control.
        </short>
        <descr>
          <p>
            ChangeBounds is called whenever the position or size of the control is set, either via the properties or by the layout engine in the LCL.
          </p>
          <p>
            SetBounds calls ChangeBounds internally with KeepBase set to <b>False</b>, while the LCL layout engine calls it with KeepBase set to <b>True</b>.
          </p>
          <p>
            Override this for code that might change the preferred size or resizes other controls.
          </p>
          <p>
            You can call this function in your custom controls. Keep in mind that the given aLeft, aTop, aWidth, aHeight might not be valid and will be changed by the LCL before applied.
          </p>
        </descr>
      </element>
      <element name="TControl.ChangeBounds.ALeft">
        <short/>
      </element>
      <element name="TControl.ChangeBounds.ATop">
        <short/>
      </element>
      <element name="TControl.ChangeBounds.AWidth">
        <short/>
      </element>
      <element name="TControl.ChangeBounds.AHeight">
        <short/>
      </element>
      <element name="TControl.ChangeBounds.KeepBase">
        <short><b>True</b> when the BaseBounds should not be modified.</short>
      </element>

      <element name="TControl.DoSetBounds">
        <short>Internal function to set the control's bounds (Left, Top, Height, Width).</short>
        <descr>
          <p>
            DoSetBounds is a low level function to set the private variables FLeft, FTop, FWidth, FHeight. Do not call this function, only the LCL calls it.
          </p>
          <p>
            It also updates FClientWidth and FClientHeight accordingly.
          </p>
          <p>
            Override this to update the content layout of the control, for example scroll bars. As always: do not paint here, but call Invalidate and paint in OnPaint or override Paint.
          </p>
        </descr>
      </element>
      <element name="TControl.DoSetBounds.ALeft">
        <short/>
      </element>
      <element name="TControl.DoSetBounds.ATop">
        <short/>
      </element>
      <element name="TControl.DoSetBounds.AWidth">
        <short/>
      </element>
      <element name="TControl.DoSetBounds.AHeight">
        <short/>
      </element>

      <element name="TControl.ScaleConstraints">
        <short>Scales the minimum and maximum Width and Height.</short>
        <descr>
          <p>
            ScaleConstraints is called from the ChangeScale method;  never call it directly. Multiplier and Divider contain the values passed as arguments to the ChangeScale method.
          </p>
        </descr>
        <seealso>
          <link id="TControl.ChangeScale"/>
          <link id="TWinControl.ScaleBy"/>
        </seealso>
      </element>
      <element name="TControl.ScaleConstraints.Multiplier">
        <short>Multiplier used to derive the scaling factor for the control constraints.</short>
      </element>
      <element name="TControl.ScaleConstraints.Divider">
        <short>Divisor used to derive the scaling factor for the control constraints.</short>
      </element>

      <element name="TControl.ChangeScale">
        <short>
          Applies scaling (multiplier and divider) to the bounds coordinates, constraints, and Font in a control.
        </short>
        <descr>
          <p>
            ChangeScale is amethod used to apply scaling, expressed by the Multiplier and Divider arguments, to size values in the control. These values include:
          </p>
          <ul>
            <li>
              The minimum and maximum heights and widths in Constraints (by calling ScaleContraints).
            </li>
            <li>
              The Font height (when ParentFont is not enabled).
            </li>
            <li>
              The bounds rectangle for the control (Left, Top, Bottom, and Right). If the control is the top-most form in a component hierarchy, the Top and Left values are not changed.
            </li>
          </ul>
          <p>
            ChangeScale calls the MulDiv routine in the <file>LCLType</file> unit to calculate the scaled numeric values. The results from the calculations are rounded and returned as an Integer type.
          </p>
          <p>
            No actions are performed in the method when Multiplier and Divider have the same value.
          </p>
          <p>
            ChangeScale can be overridden in descendent classes to perform any additional action needed for the class type.
          </p>
          <p>
            ChangeScale is called from the ScaleControls and ScaleBy methods in the TWinControl descendant.
          </p>
        </descr>
        <seealso>
          <link id="TControl.BaseBounds"/>
          <link id="TControl.BoundsRect"/>
          <link id="TControl.Font"/>
          <link id="TControl.ParentFont"/>
          <link id="TControl.ScaleConstraints"/>
          <link id="TWinControl.ScaleBy"/>
          <link id="TWinControl.ScaleControls"/>
          <link id="#lcl.lcltype.MulDiv">MulDiv</link>
        </seealso>
      </element>
      <element name="TControl.ChangeScale.Multiplier">
        <short>Multiplicand used to calculate the scaled numeric values.</short>
      </element>
      <element name="TControl.ChangeScale.Divider">
        <short>Divisor used to calculate the scaled numeric values.</short>
      </element>

      <element name="TControl.CanAutoSize">
        <short>
          Determines if auto-sizing is possible, and if so, gets the new width and height when enabled.
        </short>
        <descr>
          <p>
            Always returns <b>True</b> in TControl. The values in NewWidth and NewHeight are not updated in TControl. Override the method in descendent classes to return values as needed for the class type.
          </p>
        </descr>
      </element>
      <element name="TControl.CanAutoSize.Result">
        <short>TControl returns <b>True</b>.</short>
      </element>
      <element name="TControl.CanAutoSize.NewWidth">
        <short>Suggested width, can be adjusted in an overridden version.</short>
      </element>
      <element name="TControl.CanAutoSize.NewHeight">
        <short>Suggested height, can be adjusted in an overridden version.</short>
      </element>

      <element name="TControl.SetBiDiMode">
        <short>Sets the value for the BiDiMode property.</short>
        <descr>
        </descr>
        <seealso>
          <link id="TControl.BiDiMode"/>
        </seealso>
      </element>
      <element name="TControl.SetBiDiMode.AValue">
        <short>New value for the BiDiMode property.</short>
      </element>

      <element name="TControl.SetParentBiDiMode">
        <short>Sets the value for the ParentBiDiMode property.</short>
        <descr/>
        <seealso>
          <link id="TControl.ParentBiDiMode"/>
        </seealso>
      </element>
      <element name="TControl.SetParentBiDiMode.AValue">
        <short>New value for the ParentBiDiMode property.</short>
      </element>

      <element name="TControl.IsAParentAligning">
        <short>Determine if a parent control is involved in the alignment process.</short>
      </element>
      <element name="TControl.IsAParentAligning.Result">
        <short/>
      </element>

      <element name="TControl.GetClientOrigin">
        <short>Gets the value for the ClientOrigin property.</short>
        <descr/>
        <seealso>
          <link id="TControl.ClientOrigin"/>
        </seealso>
      </element>
      <element name="TControl.GetClientOrigin.Result">
        <short>Value for the ClientOrigin property.</short>
      </element>

      <element name="TControl.GetClientRect">
        <short>Gets the value for the ClientRect property.</short>
        <descr>
          <p>
            Returns the size for the visual client area in the control. For example, the inner size of a TGroupBox. For a TScrollBox it is the visual size, and not the logical size.
          </p>
          <p>
            The return value is a TRect instance with the Top and Left members set to 0, and the Height and Width members set to the corresponding property values for the control.
          </p>
        </descr>
        <seealso>
          <link id="#lcl.controls.TControl.ClientRect">TControl.ClientRect</link>
        </seealso>
      </element>
      <element name="TControl.GetClientRect.Result">
        <short>Value for the ClientRect property.</short>
      </element>

      <element name="TControl.GetLogicalClientRect">
        <short>Logical client area, can be bigger than the visible client area.</short>
        <descr>
          A <link id="Forms.TScrollingWinControl"/> has a logical client area, of which only a portion can be visible. The origin always is (0,0), regardless of an ScrollOffset.
        </descr>
        <seealso>
          <link id="TControl.BoundsRect"/>
          <link id="TControl.ClientRect"/>
          <link id="TControl.GetScrolledClientRect"/>
        </seealso>
      </element>
      <element name="TControl.GetLogicalClientRect.Result">
        <short>TControl returns the ClientRect.</short>
      </element>

      <element name="TControl.GetScrolledClientRect">
        <short>Get the visible part of the logical client area.</short>
        <descr>
          <p>
            Includes the ScrollOffset in a TScrollingWinControl Parent.
          </p>
          <p>
            For TControl: When the Parent is a TScrollingWinControl, the ClientRect is offset by its ScrollOffset. This Rect can be intersected with the visible ClientArea of the Parent, to get the actual visible part of the control.
          </p>
          <p>
            For TWinControl: The visible ClientRect is offset by ScrollOffset, to reflect the visible part of the logical ClientRect.
          </p>
        </descr>
        <seealso>
          <link id="TControl.ClientRect"/>
          <link id="TControl.GetScrolledClientRect"/>
        </seealso>
      </element>
      <element name="TControl.GetScrolledClientRect.Result">
        <short>The scrolled ClientRect (TopLeft, BottomRight).
        </short>
      </element>

      <element name="TControl.GetClientScrollOffset">
        <short>
          Returns the offset of the scrolled client area (in a scrolling TWinControl).
        </short>
        <descr>
          The overridden method may fail when the TScrollingWinControl has only one scrollbar.
        </descr>
        <seealso>
          <link id="TControl.GetScrolledClientRect"/>
          <link id="#lcl.forms.TScrollingWinControl.GetClientScrollOffset">
            TScrollingWinControl.GetClientScrollOffset</link>
        </seealso>
      </element>
      <element name="TControl.GetClientScrollOffset.Result">
        <short>
          The X and Y offsets of the visible client area, equal to the scrollbar positions.
        </short>
      </element>

      <element name="TControl.GetControlOrigin">
        <short>
          Gets the value for the ControlOrigin property.
        </short>
        <descr>
          Returns the origin (top left pixel) of the control, in screen coordinates.
        </descr>
        <seealso>
          <link id="TControl.ControlOrigin"/>
        </seealso>
      </element>
      <element name="TControl.GetControlOrigin.Result">
        <short>Value for the ControlOrigin property.</short>
      </element>

      <element name="TControl.IsClientHeightStored">
        <short>Implements the storage specifier for the ClientHeight property.</short>
        <descr/>
        <seealso>
          <link id="TControl.ClientHeight"/>
        </seealso>
      </element>
      <element name="TControl.IsClientHeightStored.Result">
        <short><b>True</b> if the value for ClientHeight is stored using LCL component streaming.</short>
      </element>

      <element name="TControl.IsClientWidthStored">
        <short>Implements the storage specifier for the ClientWidth property.</short>
        <descr/>
        <seealso>
          <link id="TControl.ClientWidth"/>
        </seealso>
      </element>
      <element name="TControl.IsClientWidthStored.Result">
        <short><b>True</b> if the property is stored using LCL component streaming.</short>
      </element>

      <element name="TControl.WidthIsAnchored">
        <short><b>True</b> when both the control's left and right side are anchored.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.WidthIsAnchored.Result">
        <short><b>True</b> if the Width varies with the Parent.Width.</short>
      </element>

      <element name="TControl.HeightIsAnchored">
        <short><b>True</b> when both the control's top and bottom side are anchored.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.HeightIsAnchored.Result">
        <short><b>True</b> if the Height varies with the Parent.Height.</short>
      </element>

      <element name="TControl.AutoSizing">
        <short><b>True</b> while auto-sizing is in progress.</short>
      </element>

      <element name="TControl.AutoSizingAll">
        <short>Flag to prevent recursive AutoSizing (in DoAllAutoSize).</short>
        <descr>
          By default Parent.AutoSizingAll is read, because a mere TControl cannot have child controls.
        </descr>
        <seealso/>
      </element>

      <element name="TControl.AutoSizingLockCount">
        <short>Internal counter, increased/decreased by DisableAutoSizing/EnableAutoSizing.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.WMCancelMode">
        <short>
          Handles a LM_CANCELMODE message for the control.
        </short>
        <descr>
          <p>
            Calls the SetCaptureControl routine to clear the value in the CaptureControl variable.
          </p>
        </descr>
      </element>
      <element name="TControl.WMCancelMode.Message">
        <short>Message handled in the method.</short>
      </element>

      <element name="TControl.WMContextMenu">
        <short>
          Handles a LM_CONTEXTMENU message for the control.
        </short>
        <descr>
          <p>
            No actions are performed in the method at design-time, or when the result code in Message has non-zero value.
          </p>
          <p>
            Calls DoContextPopup to signal the OnContextPopup event handler (when assigned). No additional actions are performed in the method if the context menu was displayed and executed in the OnContextPopup event handler.
          </p>
          <p>
            Otherwise, the TPopupMenu instance in the PopupMenu property is displayed and executed by calling its Popup method.
          </p>
          <p>
            The result code in Message is set to 1 if the context menu was displayed and executed in the method.
          </p>
        </descr>
        <seealso>
          <link id="TControl.PopupMenu"/>
          <link id="TControl.DoContextPopup"/>
          <link id="TControl.OnContextPopup"/>
          <link id="#lcl.menus.TPopupMenu">TPopupMenu</link>
        </seealso>
      </element>
      <element name="TControl.WMContextMenu.Message">
        <short>Message examined and optionally handled in the method.</short>
      </element>

      <element name="TControl.WMLButtonDown">
        <short>
          Handles a LM_LBUTTONDOWN (left mouse button down) message for the control.
        </short>
        <descr>
          <p>
            Sets MouseCapture to <b>True</b> when enabled in the ControlStyle property and the left mouse button is included in CaptureMouseButtons. Includes csClicked in ControlState when click events have been enabled in the ControlStyle property.
          </p>
          <p>
            Calls the private DoMouseDown method to perform the mouse button event for the control, and to signal its OnMouseDown event handler (when assigned). No mouse down actions are performed when standard events are ignored by including csNoStdEvents in the ControlStyle property.
          </p>
        </descr>
        <seealso>
          <link id="TControl.ControlStyle"/>
          <link id="TControl.MouseCapture"/>
          <link id="TControl.CaptureMouseButtons"/>
          <link id="TControl.MouseDown"/>
          <link id="TControl.OnMouseDown"/>
          <link id="TMouseButton"/>
        </seealso>
      </element>
      <element name="TControl.WMLButtonDown.Message">
        <short>Message handled in the method.</short>
      </element>

      <element name="TControl.WMRButtonDown">
        <short>
          Handles a LM_RBUTTONDOWN (right mouse button down) message for the control.
        </short>
        <descr>
          <p>
            Sets MouseCapture to <b>True</b> when enabled in the ControlStyle property and the right mouse button is included in CaptureMouseButtons.
          </p>
          <p>
            Calls the private DoMouseDown method to perform the mouse button event for the control, and to signal its OnMouseDown event handler (when assigned). No mouse down actions are performed when standard events are ignored by including csNoStdEvents in the ControlStyle property.
          </p>
        </descr>
        <seealso>
          <link id="TControl.ControlStyle"/>
          <link id="TControl.MouseCapture"/>
          <link id="TControl.CaptureMouseButtons"/>
          <link id="TControl.MouseDown"/>
          <link id="TControl.OnMouseDown"/>
          <link id="TMouseButton"/>
        </seealso>
      </element>
      <element name="TControl.WMRButtonDown.Message">
        <short>Message handled in the method.</short>
      </element>

      <element name="TControl.WMMButtonDown">
        <short>
          Handles a LM_MBUTTONDOWN (middle mouse button down) message for the control.
        </short>
        <descr>
          <p>
            Sets MouseCapture to <b>True</b> when enabled in the ControlStyle property and the middle mouse button is included in CaptureMouseButtons.
          </p>
          <p>
            Calls the private DoMouseDown method to perform the mouse button event for the control, and to signal its OnMouseDown event handler (when assigned). No mouse down actions are performed when standard events are ignored by including csNoStdEvents in the ControlStyle property.
          </p>
        </descr>
        <seealso>
          <link id="TControl.ControlStyle"/>
          <link id="TControl.MouseCapture"/>
          <link id="TControl.CaptureMouseButtons"/>
          <link id="TControl.MouseDown"/>
          <link id="TControl.OnMouseDown"/>
          <link id="TMouseButton"/>
        </seealso>
      </element>
      <element name="TControl.WMMButtonDown.Message">
        <short>Message handled in the method.</short>
      </element>

      <element name="TControl.WMXButtonDown">
        <short>
          Handles a LM_XBUTTONDOWN (extra mouse button down) message for the control.
        </short>
        <descr>
          <p>
            Checks the Keys member in Message to determine whether the first or second extra mouse button is represented in the structure. No actions are performed in the method if Keys does not represent the mbExtra1 or mbExtra2 mouse button.
          </p>
          <p>
            Sets MouseCapture to <b>True</b> when enabled in the ControlStyle property and the mouse button is included in CaptureMouseButtons.
          </p>
          <p>
            Calls the private DoMouseDown method to perform the mouse button event for the control, and to signal its OnMouseDown event handler (when assigned). No mouse down actions are performed when standard events are ignored by including csNoStdEvents in the ControlStyle property.
          </p>
        </descr>
        <seealso>
          <link id="TControl.ControlStyle"/>
          <link id="TControl.MouseCapture"/>
          <link id="TControl.CaptureMouseButtons"/>
          <link id="TControl.MouseDown"/>
          <link id="TControl.OnMouseDown"/>
          <link id="TMouseButton"/>
        </seealso>
      </element>
      <element name="TControl.WMXButtonDown.Message">
        <short>Message examined and optionally handled in the method.</short>
      </element>

      <element name="TControl.WMLButtonDblClk">
        <short>
          Handles a left mouse button double click message for the control.
        </short>
        <descr>
          <p>
            <var>WMLButtonDblClk</var> is a method used to handle a LM_LBUTTONDBLCLK window message for the control. Values in ControlStyle and CaptureMouseButtons are used to determine if MouseCapture is enabled in the method. The MouseDown method is called to update the mouse pointer position and to signal the OnMouseDown event handler (when assigned). The DblClick method is called to signal the OnDblClick event handler (when assigned).
          </p>
        </descr>
        <seealso>
          <link id="TControl.MouseCapture"/>
          <link id="TControl.ControlStyle"/>
          <link id="TControl.CaptureMouseButtons"/>
          <link id="TControl.MouseDown"/>
          <link id="TControl.DblClick"/>
        </seealso>
      </element>
      <element name="TControl.WMLButtonDblClk.Message">
        <short>Window message handled in the method.</short>
      </element>

      <element name="TControl.WMRButtonDblClk">
        <short>
          Message handler for right mouse button double click.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.WMRButtonDblClk.Message">
        <short/>
      </element>

      <element name="TControl.WMMButtonDblClk">
        <short>
          Message handler for middle mouse button double click.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.WMMButtonDblClk.Message">
        <short/>
      </element>

      <element name="TControl.WMXButtonDblClk">
        <short>
          Message handler for extra mouse button double click.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.WMXButtonDblClk.Message">
        <short/>
      </element>

      <element name="TControl.WMLButtonTripleClk">
        <short>
          Message handler for left mouse button triple click.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.WMLButtonTripleClk.Message">
        <short/>
      </element>

      <element name="TControl.WMRButtonTripleClk">
        <short>
          Message handler for right mouse button triple click.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.WMRButtonTripleClk.Message">
        <short/>
      </element>

      <element name="TControl.WMMButtonTripleClk">
        <short>
          Message handler for middle mouse button triple click.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.WMMButtonTripleClk.Message">
        <short/>
      </element>

      <element name="TControl.WMXButtonTripleClk">
        <short>
          Message handler for extra mouse button triple click.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.WMXButtonTripleClk.Message">
        <short/>
      </element>

      <element name="TControl.WMLButtonQuadClk">
        <short>
          Message handler for left mouse button quadruple click.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.WMLButtonQuadClk.Message">
        <short/>
      </element>

      <element name="TControl.WMRButtonQuadClk">
        <short>
          Message handler for right mouse button quadruple click.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.WMRButtonQuadClk.Message">
        <short/>
      </element>

      <element name="TControl.WMMButtonQuadClk">
        <short>
          Message handler for middle mouse button quadruple click.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.WMMButtonQuadClk.Message">
        <short/>
      </element>

      <element name="TControl.WMXButtonQuadClk">
        <short>
          Message handler for extra mouse button quadruple click.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.WMXButtonQuadClk.Message">
        <short/>
      </element>

      <element name="TControl.WMXButtonup">
        <short>
          Message handler for extra mouse button going up.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.WMXButtonup.Message">
        <short/>
      </element>

      <element name="TControl.WMMouseMove">
        <short>
          Message handler for mouse moved.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.WMMouseMove.Message">
        <short/>
      </element>

      <element name="TControl.WMLButtonUp">
        <short>
          Message handler for left mouse button going up.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.WMLButtonUp.Message">
        <short/>
      </element>

      <element name="TControl.WMRButtonUp">
        <short>
          Message handler for right mouse button going up.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.WMRButtonUp.Message">
        <short/>
      </element>

      <element name="TControl.WMMButtonUp">
        <short>
          Message handler for middle mouse button going up.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.WMMButtonUp.Message">
        <short/>
      </element>
      <element name="TControl.WMMouseWheel">
        <short>Handles mouse wheel messages for the control.</short>
      </element>
      <element name="TControl.WMMouseWheel.Message">
        <short>Mouse wheel message handled in the method.</short>
      </element>
      <element name="TControl.WMMouseHWheel">
        <short>Handles horizontal mouse wheel messages for the control.</short>
      </element>
      <element name="TControl.WMMouseHWheel.Message">
        <short>Mouse wheel message handled in the method.</short>
      </element>
      <element name="TControl.WMMove">
        <short>
          Message handler for control moved.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.WMMove.Message">
        <short/>
      </element>

      <element name="TControl.WMSize">
        <short>
          Message handler for changed control size.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.WMSize.Message">
        <short/>
      </element>

      <element name="TControl.WMWindowPosChanged">
        <short>
          Message handler for changed control position.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.WMWindowPosChanged.Message">
        <short/>
      </element>

      <element name="TControl.CMChanged">
        <short>Handles CM_CHANGED control messages for the control.</short>
        <descr>
          <p>
            Calls the WindowProc method in the Parent control (when assigned) to handle the control message in Message.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TControl.CMChanged.Message">
        <short>Control message handled  in the method.</short>
      </element>

      <element name="TControl.LMCaptureChanged">
        <short>
          Message handler signalled when the mouse capture has been  changed.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.LMCaptureChanged.Message">
        <short/>
      </element>

      <element name="TControl.CMBiDiModeChanged">
        <short>
          Message handler for BiDi mode changed.
        </short>
      </element>
      <element name="TControl.CMBiDiModeChanged.Message">
        <short/>
      </element>

      <element name="TControl.CMSysFontChanged">
        <short>
          Message handler for changed system Font.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.CMSysFontChanged.Message">
        <short/>
      </element>

      <element name="TControl.CMEnabledChanged">
        <short>
          Message handler for changed Enabled state.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.CMEnabledChanged.Message">
        <short/>
      </element>

      <element name="TControl.CMHitTest">
        <short>
          Message handler for hit test.
        </short>
        <descr>
          The hit test handler determines the specific part of a control (caption, border...) at the given mouse position.
        </descr>
        <seealso/>
      </element>
      <element name="TControl.CMHitTest.Message">
        <short/>
      </element>

      <element name="TControl.CMMouseEnter">
        <short>
          Message handler for mouse entering the control.
        </short>
        <seealso/>
      </element>
      <element name="TControl.CMMouseEnter.Message">
        <short/>
      </element>

      <element name="TControl.CMMouseLeave">
        <short>
          Message handler for mouse leaving the control.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.CMMouseLeave.Message">
        <short/>
      </element>

      <element name="TControl.CMHintShow">
        <short>
          Message handler for hint display.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.CMHintShow.Message">
        <short/>
      </element>

      <element name="TControl.CMParentBiDiModeChanged">
        <short>Message handler for parent control's BiDi mode changed.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.CMParentBiDiModeChanged.Message">
        <short/>
      </element>

      <element name="TControl.CMParentFontChanged">
        <short>
          Message handler for changed parent Font.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.CMParentFontChanged.Message">
        <short/>
      </element>

      <element name="TControl.CMParentColorChanged">
        <short>
          Message handler for changed parent Color.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.CMParentColorChanged.Message">
        <short/>
      </element>

      <element name="TControl.CMParentShowHintChanged">
        <short>
          Message handler for changed parent ShowHint.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.CMParentShowHintChanged.Message">
        <short/>
      </element>

      <element name="TControl.CMVisibleChanged">
        <short>
          Message handler for changed visibility.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.CMVisibleChanged.Message">
        <short/>
      </element>

      <element name="TControl.CMTextChanged">
        <short>Message handler for control's Text changed.</short>
      </element>
      <element name="TControl.CMTextChanged.Message">
        <short/>
      </element>
      <element name="TControl.CMWantSpecialKey">
        <short>
          Message handler for special character (TAB...).
        </short>
      </element>
      <element name="TControl.CMWantSpecialKey.Message">
        <short/>
      </element>

      <element name="TControl.CMCursorChanged">
        <short>Handles the CM_CURSORCHANGED message for the control.</short>
        <descr>
          <p>
            At run-time, the SetTempCursor method is called to apply the temporary cursor shape in the Cursor property. No actions are performed in the method at design-time.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TControl.CMCursorChanged.Message">
        <short>Control message handled in the method.</short>
      </element>

      <element name="TControl.CalculateDockSizes">
        <short>Saves the docked and undocked extent of the control.</short>
        <descr>
          <p>
            In the floating state, it sets UndockWidth/Height to the current Width/Height. In docked state, it sets LRDockWidth/TBDockHeight to the current Width/Height.
          </p>
          <remark>
            Should save both in any case, independent from DockOrientation or host Align. Rationale: a DockManager will either ignore these values, or use them according to the <b><i>new</i></b> alignment. Without a DockManager both extents are required, because no (valid) alignment information applies.
          </remark>
        </descr>
      </element>

      <element name="TControl.CreateFloatingDockSite">
        <short>
          Create a floating dock site with a client area equal to the given screen coordinates.
        </short>
        <descr>
          The new dock site is owned by the control.
        </descr>
      </element>
      <element name="TControl.CreateFloatingDockSite.Result">
        <short>The dock site, can be <b>Nil</b> for a TWinControl that can float by itself.</short>
      </element>
      <element name="TControl.CreateFloatingDockSite.Bounds">
        <short>The bounds of the client area of the floating window.</short>
      </element>

      <element name="TControl.GetDockEdge">
        <short>Determine the side to which the dragged control shall be docked.</short>
      </element>
      <element name="TControl.GetDockEdge.Result">
        <short/>
      </element>
      <element name="TControl.GetDockEdge.MousePos">
        <short>Mouse position in client coordinates.</short>
      </element>

      <element name="TControl.GetDragImages">
        <short>Get the list of images usable during dragging.</short>
      </element>
      <element name="TControl.GetDragImages.Result">
        <short/>
      </element>

      <element name="TControl.GetFloating">
        <short>Determines whether the control is floating.</short>
        <descr>
          <p>
            Floating state is assumed when the control has a HostDockSite of FloatingDockSiteClass, and is the only docked client.
          </p>
        </descr>
      </element>
      <element name="TControl.GetFloating.Result">
        <short/>
      </element>

      <element name="TControl.GetFloatingDockSiteClass">
        <short>Returns the class for a floating host dock site.</short>
        <descr>
          <p>
            An instance of this class is created whenever a control shall float,
            but cannot (or shall not) float by itself.
          </p>
          <p>
            Only TWinControls can float on the screen (with Parent=Nil), but not ordinary TControls.
          </p>
          <p>
            Since dockable forms are not supported by every platform, a dockable TWinControl may need a floating host which presents a docking handle to the user (e.g. a dock caption).
          </p>
        </descr>
        <seealso>
          <link id="TControl.CreateFloatingDockSite"/>
        </seealso>
      </element>
      <element name="TControl.GetFloatingDockSiteClass.Result">
        <short>The class of a floating host dock site for this control.</short>
      </element>

      <element name="TControl.BeforeDragStart">
        <short>Not implemented in TControl.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.BeginAutoDrag">
        <short>For internal use: user has started dragging the control.</short>
      </element>

      <element name="TControl.DoFloatMsg">
        <short>Handler called when the control starts floating.</short>
        <descr>
          <p>
            Since TControls cannot float for themselves, a FloatHost site is created and the control is docked into it.
          </p>
          <p>
            When the control already has a Parent (FloatHost site), the Parent's position and extent is adjusted to fit the DockRect as its ClientRect.
          </p>
        </descr>
      </element>
      <element name="TControl.DoFloatMsg.ADockSource">
        <short>The DockObject of the current drag-dock operation.</short>
      </element>

      <element name="TControl.DockTrackNoTarget">
        <short>Adjust the DockRect for floating state (no drop target under the mouse).</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.DockTrackNoTarget.Source">
        <short>The dragged DockObject, containing the DockRect to adjust.</short>
      </element>
      <element name="TControl.DockTrackNoTarget.X">
        <short>The mouse position, in screen coordinates.</short>
      </element>
      <element name="TControl.DockTrackNoTarget.Y">
        <short/>
      </element>

      <element name="TControl.DoDock">
        <short>
          Adjusts the control's position and extent for the new docksite.
        </short>
        <descr>
          <p>
            DoDock is an Internal method, called by Dock, to performs actions needed when a control is docked to a docksite.
          </p>
          <p>
            If NewDockSite=Nil, Parent is set to <b>Nil</b> (in preparation of floating the control).
            Otherwise ARect is ignored, and recomputed to fit approximately into the ClientRect of the NewDockSite.
          </p>
          <p>
            Finally the computed coordinates are stored, in BoundsRectForNewParent when the NewDockSite differs from Parent, else in BoundsRect.
          </p>
        </descr>
        <errors>
          A correct implementation should allow for computations in a derived class, and accept and handle the changed bounds without any further adjustments.
        </errors>
        <seealso/>
      </element>
      <element name="TControl.DoDock.NewDockSite">
        <short>The site where the control will be docked, or <b>Nil</b> when it becomes floating.</short>
      </element>
      <element name="TControl.DoDock.ARect">
        <short>The control's new Bounds, in screen coordinates when NewDockSite is Nil, else in client coordinates of NewDockSite.
        </short>
      </element>

      <element name="TControl.DoDragMsg">
        <short>
          Handler for a drag message, sent by the DragManager to the current target control.
        </short>
        <descr>
          <p>These messages can be sent while dragging:
          </p>
          <dl>
            <dt>dmFindTarget</dt>
            <dd>
              Request to determine the possible target control for an drop. A TControl returns itself, a TWinControl finds the child control closest to the mouse position.
            </dd>
            <dt>dmDragEnter, dmDragLeave, dmDragMove</dt>
            <dd>
              Notification of mouse moves. Invokes DragOver, or DockOver if docking. Result indicates acceptance of a drop.
            </dd>
            <dt>dmDragDrop</dt>
            <dd>
              The dragged object has been dropped onto this control. Invokes DragDrop, or DockDrop if docking.
            </dd>
          </dl>
          <p>
            The <var>Source</var> argument of the invoked methods is the DragDockObject when docking. If the DragObject has been AutoCreated, the dragged control is passed as the Source. Otherwise, the DragObject itself is passed as Source.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TControl.DoDragMsg.Result">
        <short>
          Contains the result for the Drag message.
        </short>
        <descr>
          <p>
            The Result member is polymorphic:
          </p>
          <p>
            For dmFindTarget, the result is a reference to the the target control. For dmDragDropm the result is zero (0). For other drag messages, the result indicates acceptance of the drop message.
          </p>
        </descr>
      </element>
      <element name="TControl.DoDragMsg.ADragMessage">
        <short>The task to perform.</short>
      </element>
      <element name="TControl.DoDragMsg.APosition">
        <short>The mouse position in <b>screen</b> coordinates.</short>
      </element>
      <element name="TControl.DoDragMsg.ADragObject">
        <short>The drag object.</short>
      </element>
      <element name="TControl.DoDragMsg.ATarget">
        <short>The drop target, <b>Nil</b> if none.</short>
      </element>
      <element name="TControl.DoDragMsg.ADocking">
        <short>Distinguishes between a drag-drop and drag-dock operation.</short>
      </element>

      <element name="TControl.DoEndDock">
        <short>
          Invokes the <link id="#lcl.Controls.TControl.OnEndDock">OnEndDock</link> handler.
        </short>
      </element>
      <element name="TControl.DoEndDock.Target">
        <short/>
      </element>
      <element name="TControl.DoEndDock.X">
        <short/>
      </element>
      <element name="TControl.DoEndDock.Y">
        <short/>
      </element>

      <element name="TControl.DoEndDrag">
        <short>
          Invokes the <link id="#lcl.Controls.TControl.OnEndDrag">OnEndDrag</link> handler.
        </short>
      </element>
      <element name="TControl.DoEndDrag.Target">
        <short/>
      </element>
      <element name="TControl.DoEndDrag.X">
        <short/>
      </element>
      <element name="TControl.DoEndDrag.Y">
        <short/>
      </element>

      <element name="TControl.DoStartDock">
        <short>
          Invokes the <link id="#lcl.Controls.TControl.OnStartDock">OnStartDock</link> handler.
        </short>
      </element>
      <element name="TControl.DoStartDock.DragObject">
        <short/>
      </element>

      <element name="TControl.DoStartDrag">
        <short>
          Invokes the <link id="#lcl.Controls.TControl.OnStartDrag">OnStartDrag</link> handler.
        </short>
      </element>
      <element name="TControl.DoStartDrag.DragObject">
        <short/>
      </element>

      <element name="TControl.DragCanceled">
        <short>Notifies the control of a cancelled drag.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.DragOver">
        <short>
          Called when an object is dragged over this control; Determines whether a drop is acceptable, using the OnDragOver handler.
        </short>
        <descr>
          <p>
            An OnDragOver handler is required, or any drop will be rejected (Accept becomes <b>False</b>).
          </p>
          <p>
            When an OnDragOver handler is installed, Accept is set to <b>True</b> and can be changed by the handler.
          </p>
          <remark>
            Source can be either a TDragObject, or the dragged control.
          </remark>
        </descr>
        <seealso>
          <link id="TControl.OnDragOver"/>
          <link id="TWinControl.DockOver"/>
        </seealso>
      </element>
      <element name="TControl.DragOver.Source">
        <short>The dragged object, a control or a DragObject.</short>
      </element>
      <element name="TControl.DragOver.X">
        <short>The mouse position in client coordinates.</short>
      </element>
      <element name="TControl.DragOver.Y">
        <short/>
      </element>
      <element name="TControl.DragOver.State">
        <short>State change flag (dsDragEnter, dsDragMove, dsDragLeave).</short>
      </element>
      <element name="TControl.DragOver.Accept">
        <short>Set to <b>True</b> when a drop is allowed.</short>
      </element>

      <element name="TControl.PositionDockRect">
        <short>Get the DockRect for an possible drop.</short>
        <descr>
          <p>
            Calls the <var>DockManager.PositionDockRect</var> in the target site, or <var>DragDockObject.AdjustDockRect</var> after moving the undocked control rectangle to the <var>DragPos</var>. AdjustDockRect takes the hotspot of the DockRect into account.
          </p>
        </descr>
        <seealso>
          <link id="TDragDockObject.AdjustDockRect"/>
        </seealso>
      </element>
      <element name="TControl.PositionDockRect.DragDockObject">
        <short/>
      </element>

      <element name="TControl.SetDragMode">
        <short>Sets the value for the DragMode property.</short>
        <descr/>
        <seealso>
          <link id="TControl.DragMode"/>
        </seealso>
      </element>
      <element name="TControl.SetDragMode.Value">
        <short>New value for the DragMode property.</short>
      </element>

      <element name="TControl.GetDefaultDockCaption">
        <short>Returns the string for the dock caption, by default the control's Name.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.GetDefaultDockCaption.Result">
        <short/>
      </element>

      <element name="TControl.Click">
        <short>
          Signals OnClick and/or executes the ActionLink when the control has been clicked.
        </short>
        <descr>
          <p>
            Performs actions needed when the control has been clicked using the mouse or its keyboard equivalent.
          </p>
          <p>
            Click uses the value in ActionLink (when assigned) to determine whether OnClick and / or Action are executed for the control.
          </p>
          <p>
            When ActionLink has been assigned, it is compared to the routine in the OnClick event handler (when assigned). When the routines differ, the OnCLick event handler is signalled. If an ActionLink exists, the Execute method in ActionLink is called as well.
          </p>
          <p>
            Neither OnClick nor the ActionLink are executed at design-time.
          </p>
        </descr>
        <seealso>
          <link id="TControl.OnClick"/>
          <link id="TControl.ActionLink"/>
          <link id="#rtl.classes.TBasicActionLink.Execute">TBasicActionLink.Execute</link>
        </seealso>
      </element>

      <element name="TControl.DblClick">
        <short>
          Signals the OnDblClick event handler (when assigned).
        </short>
        <descr/>
        <seealso>
          <link id="TControl.OnDblClick"/>
        </seealso>
      </element>

      <element name="TControl.TripleClick">
        <short>
          Signals the OnTripleClick event handler (when assigned).
        </short>
        <descr/>
        <seealso>
          <link id="TControl.OnTripleClick"/>
        </seealso>
      </element>

      <element name="TControl.QuadClick">
        <short>
          Signals the OnQuadClick event handler (when assigned).
        </short>
        <descr/>
        <seealso>
          <link id="TControl.OnQuadClick"/>
        </seealso>
      </element>

      <element name="TControl.GetMousePosFromMessage">
        <short>
          Converts the coordinates in the mouse message from SmallInt to LongInt values.
        </short>
        <descr>
          <p>
            MessageMousePos is a TSmallPoint type with the mouse coordinates as SmallInt values. The return value is a TPoint instance with the LongInt values for the converted mouse coordinates.
          </p>
          <p>
            If the control has a Width or Height that exceeds the maximum value for the SmallInt type, GetCursorPos is called to get the current mouse pointer position and the values are converted from screen to client coordinates. Otherwise, SmallPointToPoint is called to convert the values in MessageMousePos.
          </p>
          <p>
            GetMousePosFromMessage provides coordinates using the type needed in MouseDown, MouseUp, MouseMove, and other mouse message handling methods in the control.
          </p>
        </descr>
        <seealso>
          <link id="TControl.ScreenToClient"/>
          <link id="TControl.MouseUp"/>
          <link id="TControl.MouseDown"/>
          <link id="TControl.MouseMove"/>
          <link id="TControl.OnMouseWheelDown"/>
          <link id="TControl.OnMouseWheelUp"/>
          <link id="#rtl.types.TSmallPoint">TSmallPoint</link>
          <link id="#rtl.types.TPoint">TPoint</link>
        </seealso>
      </element>
      <element name="TControl.GetMousePosFromMessage.Result">
        <short>TPoint instance with the LongInt values for the mouse cursor position.</short>
      </element>
      <element name="TControl.GetMousePosFromMessage.MessageMousePos">
        <short>TSmallPoint instance with the values converted in the method.</short>
      </element>

      <element name="TControl.MouseDown">
        <short>Handler for MouseDown events.</short>
        <descr>
          <p>
            Called by the <var>MouseDown</var> message handler. Handles Focus changes, and notifies the DragManager while dragging. Finally, it calls the <link id="TControl.OnMouseDown"/> handler.
          </p>
        </descr>
      </element>
      <element name="TControl.MouseDown.Button">
        <short>Which buttons are down.</short>
      </element>
      <element name="TControl.MouseDown.Shift">
        <short>Which of Ctrl, Shift or Alt keys are also pressed.</short>
      </element>
      <element name="TControl.MouseDown.X">
        <short>Horizontal Mouse position in <b>client</b> coordinates.</short>
      </element>
      <element name="TControl.MouseDown.Y">
        <short>Vertical Mouse position in <b>client</b> coordinates.</short>
      </element>

      <element name="TControl.MouseMove">
        <short>Handler for MouseMove events.</short>
        <descr>
          <p>
            Called by the <var>MouseMove</var> message handler. The DragManager is notified while the control is being dragged. Finally the <link id="#lcl.Controls.TControl.OnMouseMove">OnMouseMove</link> handler is invoked.
          </p>
        </descr>
      </element>
      <element name="TControl.MouseMove.Shift">
        <short>
          The currently pressed mouse buttons and modifier keys.
        </short>
      </element>
      <element name="TControl.MouseMove.X">
        <short>Horizontal Mouse position in <b>client</b> coordinates.</short>
      </element>
      <element name="TControl.MouseMove.Y">
        <short>Vertical Mouse position in <b>client</b> coordinates.</short>
      </element>

      <element name="TControl.MouseUp">
        <short>
          Invokes the <link id="#lcl.Controls.TControl.OnMouseUp">OnMouseUp</link> handler.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.MouseUp.Button">
        <short>The currently pressed modifier keys.</short>
      </element>
      <element name="TControl.MouseUp.Shift">
        <short>The currently pressed mouse buttons.</short>
      </element>
      <element name="TControl.MouseUp.X">
        <short>Horizontal Mouse position in <b>client</b> coordinates.</short>
      </element>
      <element name="TControl.MouseUp.Y">
        <short>Vertical Mouse position in <b>client</b> coordinates.</short>
      </element>

      <element name="TControl.MouseEnter">
        <short>
          Invokes the <link id="#lcl.Controls.TControl.OnMouseEnter">OnMouseEnter</link> handler.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.MouseLeave">
        <short>
          Invokes the <link id="#lcl.Controls.TControl.OnMouseLeave">OnMouseLeave</link> handler.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.DialogChar">
        <short>Performs actions needed to handle an accelerator key for the control.</short>
        <descr>
          <p>
            Always return <b>False</b> in TControl. The method is overridden in descendent classes to perform actions needed to handle an accelerator character in the Message argument.
          </p>
          <p>
            This method is called even if the control is disabled or hidden. Provided for Delphi VCL compatibility.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.DialogChar"/>
          <link id="TWinControl.SendDialogChar"/>
        </seealso>
      </element>
      <element name="TControl.DialogChar.Result">
        <short><b>True</b> if the accelerator key in Message is handled by the control.</short>
      </element>
      <element name="TControl.DialogChar.Message">
        <short>TLMKey instance with the character code examined in the method.</short>
      </element>

      <element name="TControl.UpdateMouseCursor">
        <short>Changes the cursor shape to the value in the Cursor property.</short>
        <descr>
          <p>
            UpdateMouseCursor is a method used to change the cursor shape displayed when the mouse is hovered over the control. No actions are performed in the method at design-time, or when the screen cursor already has a shape other than crDefault.
          </p>
          <p>
            UpdateMouseCursor calls SetTempCursor to apply the value in the Cursor property to the Parent control.
          </p>
          <p>
            UpdateMouseCursor is called from WMMouseMove after the mouse position has been captured, and before the OnMouseMove event handler is signalled.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TControl.UpdateMouseCursor.X">
        <short>Not used in the method.</short>
      </element>
      <element name="TControl.UpdateMouseCursor.Y">
        <short>Not used in the method.</short>
      </element>

      <element name="TControl.Changed">
        <short>
          Performs actions needed when the value for the control has been changed.
        </short>
        <descr>
          <p>
            In TControl, Changed posts a CM_CHANGED control message to the message processing loop.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TControl.GetPalette">
        <short>
          Override <var>GetPalette</var> to return the handle of a color palette.
        </short>
        <descr>
          <p>
            Always returns 0 (zero) in TControl.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TControl.GetPalette.Result">
        <short>The Palette handle, zero (no Palette) by default.</short>
      </element>

      <element name="TControl.ChildClassAllowed">
        <short>
          Returns <b>True</b> if the specified class is allowed for children of this control.
        </short>
        <descr>
          <p>
            Always returns <b>False</b> in TControl. It is overridden in descendent classes to check whether the class reference in ChildClass is allowed for the control.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.ChildClassAllowed"/>
        </seealso>
      </element>
      <element name="TControl.ChildClassAllowed.Result">
        <short><b>True</b> when the class is allowed as a child control.</short>
      </element>
      <element name="TControl.ChildClassAllowed.ChildClass">
        <short>The class type for the child control.</short>
      </element>

      <element name="TControl.ReadState">
        <short>Updates control flags and reads the data for the component.</short>
        <descr/>
        <seealso>
          <link id="#rtl.classes.TComponent">TComponent</link>
        </seealso>
      </element>
      <element name="TControl.ReadState.Reader">
        <short>TReader instance used to read the component data. </short>
      </element>

      <element name="TControl.Loaded">
        <short>Performs actions needed when LCL component streaming has been completed.</short>
        <descr>
          <p>
            Calls the inherited method on entry.
          </p>
          <p>
            Ensures that values for Width and Height are available in the Bounds rectangle for the control. Explicit values for Width and Height are not always available in the values loaded using LCL component streaming. When this condition is indicated in the control flags, the ClientWidth and ClientHeight loaded from the resource stream are used in the Bounds for the control.
          </p>
          <p>
            Ensures that values for Color, Font, BiDiMode, and ShowHint are set to values in the Parent control when enabled in the ParentColor, ParentFont, ParentBiDiMode, and ParentShowHint properties. The values from Parent are omitted when Parent has not been assigned.
          </p>
          <p>
            Calls UpdateBaseBounds to store the bounds rectangle and client size using the loaded values.
          </p>
          <p>
            If an Action has been assigned in the control, the ActionChange method is called to ensure that default values from the Action are applied to the control.
          </p>
         <p>
            If an ancestor control is still loading its child controls, resize and align operations are deferred for the control. Otherwise, the LoadedAll method is called to adjust the sizes and layouts for the control.
          </p>
        </descr>
        <seealso>
          <link id="#rtl.classes.TComponent">TComponent</link>
        </seealso>
      </element>

      <element name="TControl.LoadedAll">
        <short>
          Called when the control and its child controls have been loaded, and their control state is changed.
        </short>
        <descr>
          <p>
            <var>LoadedAll</var> is a procedure called when the control (and its child controls) have been loaded using the LCL component streaming mechanism, and csLoading is removed from their control state. LoadedAll is called from the Loaded method.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Loaded"/>
        </seealso>
      </element>

      <element name="TControl.DefineProperties">
        <short>
          Defines which non-published properties should be streamed (none here).
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.DefineProperties.Filer">
        <short/>
      </element>

      <element name="TControl.AssignTo">
        <short>
          Implements assignment of the control to an Action object, or  calls the inherited method.
        </short>
        <descr>
          <p>
            Properties copied in the method include:
          </p>
          <ul>
            <li>Enabled</li>
            <li>Hint</li>
            <li>Caption</li>
            <li>Visible</li>
            <li>OnExecute (copied to OnClick in the destination object)</li>
            <li>HelpContext</li>
            <li>HelpKeyword</li>
            <li>HelpType</li>
          </ul>
        </descr>
        <seealso>
          <link id="#rtl.classes.TPersistent.Assign">TPersistent.Assign</link>
        </seealso>
      </element>
      <element name="TControl.AssignTo.Dest">
        <short>Destination object which receives values copied in the method.</short>
      </element>

      <element name="TControl.FormEndUpdated">
        <short>Called for each control on a form where the update count has reached 0 (zero).</short>
        <descr>
          <p>
            FormEndUpdated is overridden in descendent classes, like TWinControl, which provides a container for its child controls.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.GetChildren"/>
        </seealso>
      </element>

      <element name="TControl.InvalidateControl">
        <short>Requests a repaint of the control.</short>
        <descr>
          <p>
            <var>InvalidateControl</var> is an overloaded method used to redraw the bounds rectangle for control. No actions are performed in the method if the Parent control or its Handle are not assigned, during LCL component streaming, or when the control is being freed.
          </p>
          <p>
            When CtrlIsVisible is set to <b>True</b> or the control has a visible design surface, the InvalidateRect routine is called. The BoundsRect for the control is erased and redrawn when the control uses an opaque drawing style, or when it occludes a sibling control in its Parent.
          </p>
          <p>
            InvalidateControl is called from methods like Invalidate and ChangeBounds, and when a new value is assigned to the Visible property.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Invalidate"/>
          <link id="TControl.ChangeBounds"/>
          <link id="TControl.Visible"/>
          <link id="TControl.VisibleChanged"/>
          <link id="TControl.CMVisibleChanged"/>
        </seealso>
      </element>
      <element name="TControl.InvalidateControl.CtrlIsVisible">
        <short><b>True</b> if the control is visible.</short>
      </element>
      <element name="TControl.InvalidateControl.CtrlIsOpaque">
        <short><b>True</b> if the control use an opaque drawing style.</short>
      </element>
      <element name="TControl.InvalidateControl.IgnoreWinControls">
        <short><b>True</b> if TWinControl descendants are ignored in  the method.</short>
      </element>

      <element name="TControl.FontChanged">
        <short>
          Handles changes to the Font property.
        </short>
        <descr>
          <p>
            <var>FontChanged</var> is a procedure used to perform actions needed when the value in the <var>Font</var> property has been changed for the control. FontChanged ensures that values in <var>ParentFont</var> and <var>DesktopFont</var> are set to <b>False</b> to reflect the font assignment.
          </p>
          <p>
            FontChanged calls the <var>Invalidate</var> method to force the control to be redrawn when it is Visible. The CM_FONTCHANGED control change message is performed to reflect the change in the control state. When <var>AutoSize</var> contains <b>True</b>, the <var>InvalidatePreferredSize</var> and <var>AdjustSize</var> methods are called to update the control dimensions using the new font.
          </p>
          <p>
            FontChanged is assigned to the <var>OnChange</var> event handler for the <var>Font</var> property in the constructor for the class instance.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Font"/>
          <link id="TControl.ParentFont"/>
          <link id="TControl.DesktopFont"/>
          <link id="TControl.Invalidate"/>
          <link id="TControl.InvalidatePreferredSize"/>
          <link id="TControl.AdjustSize"/>
          <link id="TControl.IsVisible"/>
          <link id="TControl.AutoSize"/>
          <link id="TControl.Perform"/>
        </seealso>
      </element>
      <element name="TControl.FontChanged.Sender">
        <short>Class instance generating the change notification.</short>
      </element>

      <element name="TControl.ParentFontChanged">
        <short>
          [Delphi compatible] Does nothing here, all work is done in CMParentFontChanged.
        </short>
        <descr/>
        <seealso>
          <link id="TControl.CMParentFontChanged"/>
        </seealso>
      </element>

      <element name="TControl.GetAction">
        <short>Gets the value for the Action property.</short>
        <descr>
          <p>
            The property value is retrieved from ActionLink (when assigned). Otherwise, the property value is Nil.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Action"/>
        </seealso>
      </element>
      <element name="TControl.GetAction.Result">
        <short>Value for the Action property.</short>
      </element>

      <element name="TControl.RealGetText">
        <short>Returns the Caption property.</short>
        <descr>
          <p>
            This method is called by <var>GetText</var>, when GetTextBuf has not been overridden.
          </p>
        </descr>
        <seealso>
          <link id="TControl.GetTextBuf"/>
          <link id="TControl.RealSetText"/>
          <link id="TControl.SetTextBuf"/>
        </seealso>
      </element>
      <element name="TControl.RealGetText.Result">
        <short>Value for the Caption property.</short>
      </element>

      <element name="TControl.RealSetText">
        <short>Sets the value for the Caption property.</short>
        <descr>
          <p>
            RealSetText is a method used to apply the TCaption value in AValue to the text or caption for the control. RealSetText is called by the private <var>SetText</var> method, when <var>SetTextBuf</var> has not been overridden.
          </p>
          <p>
            <b>Notes on TControl.Caption, TControl.Text, et. al.</b>
          </p>
          <p>
            The Delphi VCL implementation relies on the virtual GetTextBuf and SetTextBuf methods to exchange text for controls.. This requires a lot of (unnecessary) copies to move values between Text and Caption.
          </p>
          <p>
            The LCL uses strings to exchange text values because it is more efficient. To maintain VCL compatibility, the virtual RealGetText and RealSetText methods were  introduced. These functions use the LCLInterface. The default GetTextBuf and SetTextBuf implementations calls the RealGetText and RealSetText methods as needed. As long as the GetTextBuf and/or SetTextBuf aren't overridden, GetText and SetText call RealGetText and RealSetText to avoid copying PChar values.
          </p>
          <p>
            To keep things optimal, LCL implementations should always override RealGetText and RealSetText. GetTextBuf and SetTextBuf are only kept for compatibility with Delphi code.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Caption"/>
          <link id="TControl.Text"/>
          <link id="TControl.RealGetText"/>
          <link id="TControl.SetTextBuf"/>
          <link id="TControl.GetTextBuf"/>
        </seealso>
      </element>
      <element name="TControl.RealSetText.Value">
        <short>The string value to store in the Text / Caption properties.</short>
      </element>

      <element name="TControl.TextChanged">
        <short>Performs actions needed when the value for the Text property has been changed.</short>
        <descr>
          <p>
            TextChanged has an empty implementation in TControl, and is overridden in descendent classes to perform any actions needed for the control type. Called from the CMTextChanged message handler.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TControl.GetCachedText">
        <short>Returns the cached Text property (FCaption).</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.GetCachedText.Result">
        <short><b>True</b> if successful.</short>
      </element>
      <element name="TControl.GetCachedText.CachedText">
        <short>Here: FCaption (can be overridden).</short>
      </element>

      <element name="TControl.SetAction">
        <short>Sets the value for the Action property.</short>
        <descr>
          <p>
            Ensures that ActionLink is updated when the value for the property is updated. When Value is unassigned (Nil), ActionLink is freed and set to Nil. The control style flags are also updated to remove the value csActionClient. Otherwise, a new ActionLink class instance is created for ActionLink and Value is assigned to its  Action property. Its OnChange handler is assigned, and the ActionChange method is called to apply values from the action to the control.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Action"/>
        </seealso>
      </element>
      <element name="TControl.SetAction.Value">
        <short>New value for the Action property.</short>
      </element>

      <element name="TControl.SetColor">
        <short>Sets the value for the Color property.</short>
        <descr>
          <p>
            SetColor is a method used to set the value for the Color property to the specified TColor value. Assigning a value to Color causes the ParentColor property to be set to <b>False</b>.
          </p>
          <p>
            SetColor calls Perform to send a CM_COLORCHANGED control message to the widgetset class. Invalidate is called to force the control to be redrawn.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Color"/>
        </seealso>
      </element>
      <element name="TControl.SetColor.Value">
        <short>New value for the Color property.</short>
      </element>

      <element name="TControl.SetEnabled">
        <short>Sets the value for the Enabled property.</short>
        <descr>
          <p>
            Calls EnabledChanging to notify handlers for the chtOnEnabledChanged type. Stores the new value for the property, and performs a CM_ENABLEDCHANGED control message. Calls EnabledChanged to notify handlers for the chtOnEnabledChanged type.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Enabled"/>
        </seealso>
      </element>
      <element name="TControl.SetEnabled.Value">
        <short>New value for the Enabled property.</short>
      </element>

      <element name="TControl.SetHint">
        <short>Sets the value for the Hint property.</short>
        <descr>
          <p>
            Value is a TTranslateString type which allows it be recognized and processed in the LCL translation facilities.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Hint"/>
        </seealso>
      </element>
      <element name="TControl.SetHint.Value">
        <short>New value for the Hint property.</short>
      </element>

      <element name="TControl.SetName">
        <short>Sets the value for the Name property.</short>
        <descr/>
        <seealso>
          <link id="#rtl.classes.TComponent.Name">TComponent.Name</link>
        </seealso>
      </element>
      <element name="TControl.SetName.Value">
        <short>New value for the Name property.</short>
      </element>

      <element name="TControl.SetParent">
        <short>Sets the value for the Parent property.</short>
        <descr/>
        <seealso>
          <link id="TControl.Parent"/>
        </seealso>
      </element>
      <element name="TControl.SetParent.NewParent">
        <short>New value for the the Parent property.</short>
      </element>

      <element name="TControl.SetParentComponent">
        <short>
          Sets the value in the Parent property when the new parent component is a TWinControl instance.
        </short>
        <descr>
          <p>
            Implements the dynamic method inherited from TComponent. When NewParentComponent is derived from TWinControl, the SetParent method is called to re-parent, position, and resize the control.
          </p>
        </descr>
        <seealso>
          <link id="TControl.SetParent"/>
          <link id="TControl.Parent"/>
          <link id="#rtl.classes.TComponent.GetParentComponent">TComponent.GetParentComponent</link>
        </seealso>
      </element>
      <element name="TControl.SetParentComponent.NewParentComponent">
        <short>New TWinControl instance used as the Parent for the control.</short>
      </element>

      <element name="TControl.ParentFormHandleInitialized">
        <short>Internal handler for activities after a form widget has been created.
        </short>
        <descr>
          <p>
            Called by <var>ChildHandlesCreated</var> of parent form.
          </p>
          <p>
            Functions like GetTextWidth require a valid widget and a device context.
            That is why AutoSizing is delayed until the handle in a parent Form is allocated.
          </p>
        </descr>
      </element>

      <element name="TControl.GetMouseCapture">
        <short>Gets the value for the MouseCapture property.</short>
        <descr>
          <p>
            Indicates if the class instance is the current CaptureControl for the LCL framework.
            The property value is <b>True</b> when the following condition are satisfied:
          </p>
          <ul>
            <li>
              Parent is assigned (not Nil).
            </li>
            <li>
              Parent has an allocated window handle.
            </li>
            <li>
              The value in the LCL CaptureContol variable is the current class instance.
            </li>
          </ul>
        </descr>
        <seealso>
          <link id="TControl.MouseCapture"/>
          <link id="GetCaptureControl"/>
        </seealso>
      </element>
      <element name="TControl.GetMouseCapture.Result">
        <short><b>True</b> when the current class instance is the LCL CaptureControl.</short>
      </element>

      <element name="TControl.CaptureChanged">
        <short>Handler for mouse capture moved to a different control.</short>
        <descr>
          <p>
            Notifies the DragManager of a change to the capture control, and to stop dragging this control. A very dangerous implementation; it can cause an immediate abort of dragging before dragging really starts.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TControl.Notification">
        <short>Notification handler for insertion or deletion of components.</short>
        <descr>
          <p>
            First, the inherited <var>TComponent.Notification</var> is called to notify all attached notification handlers.
          </p>
          <p>
            If <var>Operation</var> is <var>opRemove</var>, additional actions are performed, depending on <var>AComponent</var>: the PopupMenu, Action, or anchors for the removed control are detached.
          </p>
        </descr>
        <seealso>
          <link id="#rtl.classes.TComponent.Notification">TComponent.Notification</link>
        </seealso>
      </element>
      <element name="TControl.Notification.AComponent">
        <short>The component being inserted or removed.</short>
      </element>
      <element name="TControl.Notification.Operation">
        <short>The action (opInsert or opRemove).</short>
      </element>

      <element name="TControl.CanTab">
        <short>Determined whether the Tab key can be used for navigation in the control.</short>
        <descr>
          <p>
            Always returns <b>False</b> in TControl. Overridden in TWinControl.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.CanTab"/>
        </seealso>
      </element>
      <element name="TControl.CanTab.Result">
        <short/>
      </element>

      <element name="TControl.GetDeviceContext">
        <short>Returns a device context handle for the control, from Parent.
        </short>
        <descr>
          <p>
            Initializes the device context position to the control origin, and shrinks its clipping rectangle to the bounds for the control.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TControl.GetDeviceContext.Result">
        <short>The device context.</short>
      </element>
      <element name="TControl.GetDeviceContext.WindowHandle">
        <short>Returns the window handle of the device context.</short>
      </element>

      <element name="TControl.GetEnabled">
        <short>Gets the value for the Enabled property.</short>
        <descr/>
        <seealso>
          <link id="TControl.Enabled"/>
        </seealso>
      </element>
      <element name="TControl.GetEnabled.Result">
        <short>Value for the Enabled property.</short>
      </element>

      <element name="TControl.GetPopupMenu">
        <short>Gets the value for the PopupMenu property.</short>
        <descr/>
        <seealso>
          <link id="TControl.PopupMenu"/>
        </seealso>
      </element>
      <element name="TControl.GetPopupMenu.Result">
        <short>Value for the PopupMenu property.</short>
      </element>

      <element name="TControl.DoOnShowHint">
        <short>Invokes the <var>OnShowHint</var> event handler.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.DoOnShowHint.HintInfo">
        <short/>
      </element>

      <element name="TControl.DoMouseWheel">
        <short>
          Invokes the OnMouseWheel handlers, when the wheel has been turned.
        </short>
        <descr>
          <p>
            Multiple wheel handlers can be implemented. First the general OnMouseWheel handler is tried, and if it doesn't report the event handled, then OnMouseWheelUp or OnMouseWheelDown are tried.
          </p>
          <p>
            The actual WheelDelta is available <b>only</b> to the OnMouseWheel handler, not to the up and down handlers [Delphi compatible].
          </p>
        </descr>
        <seealso>
          <link id="TMouseWheelEvent"/>
          <link id="TMouseWheelUpDownEvent"/>
        </seealso>
      </element>
      <element name="TControl.DoMouseWheel.Result">
        <short>Set Result to <b>True</b> if handled.</short>
      </element>
      <element name="TControl.DoMouseWheel.Shift">
        <short>State of the modifier keys and mouse buttons.</short>
      </element>
      <element name="TControl.DoMouseWheel.WheelDelta">
        <short>How many notches the wheel has been turned.</short>
      </element>
      <element name="TControl.DoMouseWheel.MousePos">
        <short>The mouse coordinates.</short>
      </element>

      <element name="TControl.DoMouseWheelDown">
        <short>Invokes the OnMouseWheelDown handler.</short>
      </element>
      <element name="TControl.DoMouseWheelDown.Result">
        <short><b>True</b> if handled.</short>
      </element>
      <element link="#lcl.controls.TMouseWheelEvent.Shift" name="TControl.DoMouseWheelDown.Shift">
        <short/>
      </element>
      <element link="#lcl.controls.TMouseWheelEvent.MousePos" name="TControl.DoMouseWheelDown.MousePos">
        <short/>
      </element>

      <element name="TControl.DoMouseWheelUp">
        <short>Invokes the OnMouseWheelUp handler.</short>
      </element>
      <element name="TControl.DoMouseWheelUp.Result">
        <short><b>True</b> if handled.</short>
      </element>
      <element link="#lcl.controls.TMouseWheelEvent.Shift" name="TControl.DoMouseWheelUp.Shift">
        <short/>
      </element>
      <element link="#lcl.controls.TMouseWheelEvent.MousePos" name="TControl.DoMouseWheelUp.MousePos">
        <short/>
      </element>

      <element name="TControl.DoMouseWheelHorz">
        <short>Performs actions needed to handle horizontal mouse wheel events.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.DoMouseWheelHorz.Result">
        <short><b>True</b> when the mouse wheel event has been handled for the control.</short>
      </element>
      <element name="TControl.DoMouseWheelHorz.Shift">
        <short>Shift state for the mouse wheel event.</short>
      </element>
      <element name="TControl.DoMouseWheelHorz.WheelDelta">
        <short>Number of units (or clicks) the mouse wheel was moved.</short>
      </element>
      <element name="TControl.DoMouseWheelHorz.MousePos">
        <short>TPoint with the mouse coordinates for the event.</short>
      </element>

      <element name="TControl.DoMouseWheelLeft">
        <short>Performs the OnMouseWheelLeft event handler.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.DoMouseWheelLeft.Result">
        <short/>
      </element>
      <element name="TControl.DoMouseWheelLeft.Shift">
        <short/>
      </element>
      <element name="TControl.DoMouseWheelLeft.MousePos">
        <short/>
      </element>

      <element name="TControl.DoMouseWheelRight">
        <short>Performs the OnMouseWheelRight event handler.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.DoMouseWheelRight.Result">
        <short/>
      </element>
      <element name="TControl.DoMouseWheelRight.Shift">
        <short/>
      </element>
      <element name="TControl.DoMouseWheelRight.MousePos">
        <short/>
      </element>

      <element name="TControl.VisibleChanging">
        <short>Notifies all <var>OnVisibleChanging</var> handlers.</short>
      </element>

      <element name="TControl.VisibleChanged">
        <short>Notifies all OnVisibleChanged handlers.</short>
      </element>

      <element name="TControl.EnabledChanging">
        <short>Notifies all OnEnabledChanging handlers.</short>
      </element>

      <element name="TControl.EnabledChanged">
        <short>Notifies all OnEnabledChanged handlers.</short>
      </element>

      <element name="TControl.AddHandler">
        <short>Adds an notification handler.</short>
        <descr>
          Notification handlers allow to notify other components of certain events. When the registered event occurs, all installed (added) handlers are invoked.
        </descr>
      </element>
      <element name="TControl.AddHandler.HandlerType">
        <short>Type of the event.</short>
      </element>
      <element name="TControl.AddHandler.AMethod">
        <short>The handler to be added.</short>
      </element>
      <element name="TControl.AddHandler.AsFirst">
        <short>Unused.</short>
      </element>

      <element name="TControl.RemoveHandler">
        <short>Removes the given notification handler.</short>
        <seealso>
          <link id="TControl.AddHandler"/>
        </seealso>
      </element>
      <element name="TControl.RemoveHandler.HandlerType">
        <short>Type of the notification.</short>
      </element>
      <element name="TControl.RemoveHandler.AMethod">
        <short>The handler to be removed.</short>
      </element>

      <element name="TControl.DoCallNotifyHandler">
        <short>Invokes all notification handlers of the specified type.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.DoCallNotifyHandler.HandlerType">
        <short>The event that has occurred.</short>
      </element>

      <element name="TControl.DoCallKeyEventHandler">
        <short>
          Passes key events for the specified type to the handlers added to the control.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.DoCallKeyEventHandler.HandlerType">
        <short/>
      </element>
      <element name="TControl.DoCallKeyEventHandler.Key">
        <short/>
      </element>
      <element name="TControl.DoCallKeyEventHandler.Shift">
        <short/>
      </element>

      <element name="TControl.DoCallMouseWheelEventHandler">
        <short>Passes mouse wheel events to the handlers added to the control.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.DoCallMouseWheelEventHandler.HandlerType">
        <short/>
      </element>
      <element name="TControl.DoCallMouseWheelEventHandler.Shift">
        <short/>
      </element>
      <element name="TControl.DoCallMouseWheelEventHandler.WheelDelta">
        <short/>
      </element>
      <element name="TControl.DoCallMouseWheelEventHandler.MousePos">
        <short/>
      </element>
      <element name="TControl.DoCallMouseWheelEventHandler.Handled">
        <short/>
      </element>

      <element name="TControl.DoContextPopup">
        <short>Invokes the OnContextPopup handler.</short>
        <seealso/>
      </element>
      <element name="TControl.DoContextPopup.MousePos">
        <short>Mouse position, used to place the menu.</short>
      </element>
      <element name="TControl.DoContextPopup.Handled">
        <short>To be set by the handler, when it has handled the menu display and selection.</short>
      </element>

      <element name="TControl.SetZOrder">
        <short>Moves the control in front or back of all sibling controls.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.SetZOrder.TopMost">
        <short/>
      </element>

      <element name="TControl.GetControlClassDefaultSize">
        <short>Returns the default size for this class of controls (when added to a form).</short>
      </element>
      <element name="TControl.GetControlClassDefaultSize.Result">
        <short/>
      </element>

      <element name="TControl.ColorIsStored">
        <short>Implements the storage specifier for the Color property.</short>
        <descr/>
        <seealso>
          <link id="TControl.Color"/>
        </seealso>
      </element>
      <element name="TControl.ColorIsStored.Result">
        <short/>
      </element>

      <element name="TControl.DoAutoAdjustLayout">
        <short>
          Applies layout changes using the specified policy and scaling proportions to the control.
        </short>
        <descr>
          <p>
            DoAutoAdjustLayout is a method which implements changes to control sizes for the AutoAdjustLayout method. These methods are called when High-DPI and scaling have been enabled in the project options for an application.
          </p>
          <p>
            AMode indicates the automatic layout policy applied in the method. It is a value from the TLayoutAdjustmentPolicy enumeration, and determines whether horizontal / vertical / or both sizes are adjusted in the method. It generally reflects the constraints for the device type where the application is running.
          </p>
          <p>
            AXProportion and AYProportion contain the scaling factors applied to the horizontal and/or vertical sizes.
          </p>
          <p>
            DoAutoAdjustLayout ensures that new values for Height and Width in the control are calculated (when allowed and needed) using the scaling factors, Constraints, BorderSpacing and Anchors for the control. The SetBoundsKeepBase method is called to apply the newly calculated values to the control.
          </p>
          <p>
            Font scaling is performed in AutoAdjustLayout (when needed) and occurs prior to calling DoAutoAdjustLayout.
          </p>
          <p>
            DoAutoAdjustLayout, ScaleFontsPPI, and FixDesignFontsPPI are often overridden in descendent classes to perform additional actions needed for a control or its children.
          </p>
        </descr>
        <seealso>
          <link id="TControl.AutoAdjustLayout"/>
          <link id="TControl.ShouldAutoAdjust"/>
          <link id="TControl.Anchors"/>
          <link id="TControl.BorderSpacing"/>
          <link id="TControl.Constraints"/>
          <link id="TControl.SetBoundsKeepBase"/>
        </seealso>
      </element>
      <element name="TControl.DoAutoAdjustLayout.AMode">
        <short>Identifies the auto-layout policy applied in the method.</short>
      </element>
      <element name="TControl.DoAutoAdjustLayout.AXProportion">
        <short>Scaling factor for horizontal dimensions.</short>
      </element>
      <element name="TControl.DoAutoAdjustLayout.AYProportion">
        <short>Scaling factor for vertical dimensions.</short>
      </element>

      <element name="TControl.DoFixDesignFontPPI">
        <short>Applies the design-time PPI and resizes the specified control font.</short>
        <descr>
          <p>
            Implements the FixDesignFontsPPI method for the control.
          </p>
          <p>
            Performs actions needed to restore the design-time PPI (Pixels Per Inch) for controls when they are loaded using the LCL component streaming mechanism. The design-time PPI for fonts is not stored in .LFM files, and could result in invalid scaling operations when loaded on a machine with a different display density. DoFixDesignFontPPI ensures that the font is resized to the specified design-time PPI.
          </p>
        </descr>
        <seealso>
          <link id="TControl.FixDesignFontsPPI"/>
        </seealso>
      </element>
      <element name="TControl.DoFixDesignFontPPI.AFont">
        <short/>
      </element>
      <element name="TControl.DoFixDesignFontPPI.ADesignTimePPI">
        <short/>
      </element>

      <element name="TControl.DoScaleFontPPI">
        <short>
          Adjusts the height for a given Font to the specified pixels per inch (PPI).
        </short>
        <descr>
          <p>
            Implements the ScaleFontsPPI method for the control.
          </p>
        </descr>
        <seealso>
          <link id="TControl.ScaleFontsPPI"/>
        </seealso>
      </element>
      <element name="TControl.DoScaleFontPPI.AFont">
        <short>Font examined and updated in the method.</short>
      </element>
      <element name="TControl.DoScaleFontPPI.AToPPI">
        <short>Pixels per inch setting adjusted in the method.</short>
      </element>
      <element name="TControl.DoScaleFontPPI.AProportion">
        <short>Scaling factor a applied to the font.</short>
      </element>

      <element name="TControl.GetActionLinkClass">
        <short>The default ActionLink class (TControlActionLink).</short>
        <descr>Used when the control is linked to an Action.</descr>
        <seealso/>
      </element>
      <element name="TControl.GetActionLinkClass.Result">
        <short/>
      </element>

      <element name="TControl.ActionChange">
        <short>Handler for a changed Action.</short>
        <descr>Several properties are copied from the new Action.</descr>
      </element>
      <element name="TControl.ActionChange.Sender">
        <short>The changed Action.</short>
      </element>
      <element name="TControl.ActionChange.CheckDefaults">
        <short>When <b>True</b>, forces update of all properties. Otherwise only properties in default state are overwritten.</short>
      </element>

      <element name="TControl.ActionLink">
        <short>Link to the default Action associated with this control.</short>
      </element>

      <element name="TControl.DesktopFont">
        <short>Indicates if the desktop (system) font is used for the text displayed on this control.</short>
        <descr>
          <p>
            <var>DesktopFont</var> is a <var>Boolean</var> property which indicates whether the default desktop (or system) font is used to display the text on the control. The default value for the property is  set to <b>True</b> in the Create constructor, and indicates that an explicit assignment has not been made to the Font property. When set to <b>True</b>, the System font in Screen is loaded into the Font property.
          </p>
          <p>
            Changing the property value causes a CM_SYSFONTCHANGED message to be performed for the control. DesktopFont is set to <b>False</b> when an explicit TFont value is assigned to the Font property.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Perform"/>
          <link id="TControl.CMSysFontChanged"/>
          <link id="#lcl.forms.TScreen.SystemFont">TScreen.SystemFont</link>
          <link id="#lcl.forms.Screen">Screen</link>
        </seealso>
      </element>

      <element name="TControl.DragCursor">
        <short>The cursor shape shown while the control is dragged.</short>
        <descr>Default is crDrag. When no drop is allowed, the cursor changes temporarily to crNoDrop.</descr>
      </element>

      <element name="TControl.DragKind">
        <short>The operation when the control is dragged - Drag or Dock.</short>
        <descr>Set to dkDrag for drag-drop, or to dkDock for drag-dock operation.</descr>
        <seealso/>
      </element>

      <element name="TControl.DragMode">
        <short>Allows the user to drag the control.</short>
        <descr>
          <p>Default is dmManual, meaning that dragging must be started in code.</p>
          <p>
            Set to dmAutomatic to allow the user to drag this control. In this mode dragging can start immediately (on left mouse button press) or delayed, after the mouse has been moved away by a number of pixels (Threshold).
          </p>
        </descr>
        <seealso>
          <link id="TControl.DragKind"/>
          <link id="TDragManager.DragImmediate"/>
        </seealso>
      </element>

      <element name="TControl.MouseCapture">
        <short><b>True</b> when mouse messages are currently captured by this control.</short>
        <descr>
          <p>
            In normal operation, all mouse messages are sent to the control under the mouse pointer. Mouse messages also can be sent to a capturing control, e.g. when a control is dragged.
          </p>
          <p>
            Applications should capture mouse events only for special purposes, and release the capture as soon as a the target position has been determined. Limited user feedback is possible while the mouse is captured, not all application controls will work properly so long.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TControl.ParentColor">
        <short>
          Use the Color from the Parent control, when enabled.
        </short>
        <descr>
          <p>
            <var>ParentColor</var> determines if the control should use the <var>Color</var> from the Parent control, when enabled. The default value is <b>True</b>.
          </p>
          <p>
            When this property is <b>True</b>, all changes to the <var>Color</var> of the parent will also be applied to the Color of the control, ensuring that they both contain same value. If the Color of the control is changed by the application, then <var>ParentColor</var> will be automatically set to <b>False</b>.
           </p>
           <p>
             Using <var>ParentColor</var> when the <var>Color</var> value is <var>clDefault</var> can cause problems in resolving the actual color value. To obtain the Color property of a control while taking into account clDefault and ParentColor, use the <var>GetColorResolvingParent</var> method. This method might return a non-RGB color, but will never return clDefault. To obtain a purely RGB result use the <var>GetRGBColorResolvingParent</var> method.
           </p>
        </descr>
        <seealso>
          <link id="TControl.Color"/>
          <link id="TControl.GetColorResolvingParent"/>
          <link id="TControl.GetRGBColorResolvingParent"/>
        </seealso>
      </element>

      <element name="TControl.ParentFont">
        <short>
          If <b>True</b>, the Font of the control will be the same as the one from the Parent. Default is <b>True</b>.
        </short>
        <descr>
          <p>
            While <var>ParentFont</var> is <b>True</b>, changes to the font in the Parent are also applied to the Font for the control. This synchronizes them, keeping them set to the same value. If the value in <var>Font</var> is changed by the application, then <var>ParentFont</var> will automatically be set to <b>False</b>.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Font"/>
          <link id="TControl.Parent"/>
        </seealso>
      </element>

      <element name="TControl.ParentShowHint">
        <short>
          If <b>True</b>, the value of ShowHint for the control will be the same as the one from the Parent. Default is <b>True</b>.
        </short>
        <descr>
          <p>
            While <var>ParentShowHint</var> is <b>True</b>, all changes to the <var>ShowHint</var> property of the parent will also be applied to the <var>ShowHint</var> property for the control. This synchronizes them, keeping them with the same value. If the <var>ShowHint</var> property for the control is changed by the application, then <var>ParentShowHint</var> will automatically be set to <b>False</b>.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Hint"/>
          <link id="TControl.ShowHint"/>
        </seealso>
      </element>

      <element name="TControl.SessionProperties">
        <short>
          The stored (saved) properties of the current session, expressed as a string.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.Text">
        <short>The character string associated with the control.</short>
        <descr>
          <p>
            This is the character string, shown in controls with visible text content (<link id="#lcl.StdCtrls.TEdit">TEdit</link>...).
          </p>
          <remark>
            BEWARE: In other controls it can be the Name or Caption of the control, quite tricky to use.
          </remark>
          <p>
            The Delphi VCL implementation stores Text mostly in the widgets, using the virtual <var>Get/SetTextBuf</var> methods to exchange text between widgets and VCL. This means a lot of text copies and message handling in WM_GETTEXT and WM_SETTEXT.
          </p>
          <p>
            The LCL instead (typically) stores Text in a field of the control, and transfers it from/to the widgets only when required.
          </p>
          <p>
            To maintain VCL compatibility, the virtual <var>RealGet/SetText</var> methods have been introduced, which read or write the Caption string directly.
          </p>
          <p>
            The default <var>Get/SetTextBuf</var> implementation calls the <var>RealGet/SetText</var> methods, resulting in a string-to-PCHAR and another PCHAR-to-string conversion. But as long as <var>Get/SetTextBuf</var> is not overridden, <var>Get/SetText</var> can (and does) safely call <var>RealGet/SetText</var> immediately, to avoid the mentioned conversions.
          </p>
          <p>
            To keep things optimal, LCL components should always override RealGet/SetText; Get/SetTextBuf is only kept for compatibility.
          </p>
        </descr>
      </element>

      <element name="TControl.OnConstrainedResize">
        <short>This handler can supply specific Constraints (size limits), when the control is resized.</short>
        <descr/>
        <seealso>
          <link id="TConstrainedResizeEvent"/>
          <link id="TControl.Constraints"/>
        </seealso>
      </element>

      <element name="TControl.OnContextPopup">
        <short>Invoked when a context-sensitive pop-up menu is requested.</short>
        <descr>
          <p>
            The handler can show and handle the menu selection itself. If so, it should set Handled to <b>True</b>. Otherwise the installed PopupMenu is shown.
          </p>
        </descr>
        <seealso>
          <link id="TContextPopupEvent"/>
          <link id="TControl.PopupMenu"/>
        </seealso>
      </element>

      <element name="TControl.OnDblClick">
        <short>Event Handler for double mouse clicks.</short>
        <descr>
          <p>
            Double-clicking is much more common in a Windows environment than in Unix or Linux, where single-clicking is the default method for selecting an object. However, in all environments there could be valid use for a double-click, and a method should be supplied if appropriate.
          </p>
        </descr>
      </element>

      <element name="TControl.OnTripleClick">
        <short>Event handler for triple mouse clicks.</short>
      </element>

      <element name="TControl.OnQuadClick">
        <short>Event handler for quadruple mouse clicks.</short>
      </element>

      <element name="TControl.OnDragDrop">
        <short>This handler determines the action on an drop onto this control, in a drag-drop operation.
        </short>
        <descr>
          <p>
            Unlike for a drag-dock operation, no default action is associated with an drag-drop; the OnDragDrop handler is the only way to do something meaningful on an drag-drop.
          </p>
        </descr>
        <seealso>
          <link id="TDragDropEvent"/>
          <link id="TControl.DragDrop"/>
        </seealso>
      </element>

      <element name="TControl.OnDragOver">
        <short>Event handler for a control being dragged over this control.</short>
        <descr>
          The handler can reject an drop, by setting Accept to <b>False</b>.
        </descr>
        <seealso>
          <link id="TDragOverEvent"/>
        </seealso>
      </element>

      <element name="TControl.OnEndDock">
        <short>Notification handler for the end of a docking operation.</short>
        <descr/>
        <seealso>
          <link id="TEndDragEvent"/>
        </seealso>
      </element>

      <element name="TControl.OnEndDrag">
        <short>Notification handler for the end of a drag operation.</short>
        <descr/>
        <seealso>
          <link id="TEndDragEvent"/>
        </seealso>
      </element>

      <element name="TControl.OnMouseDown">
        <short>Event handler signalled when a mouse down event is handled for the control.</short>
        <descr>
          <p>
            <var>OnMouseDown</var> is signalled (when assigned) from the <var>MouseDown</var> method. It occurs after the parent form has been focused, and an active edit control has been cancelled. If the DragManager is active, it has already been updated with the mouse position prior to the event.
          </p>
          <p>
            An application must implement and assign a TMouseEvent handler routine to the property which responds to the event notification.
          </p>
          <p>
            Use OnMouseUp to perform actions needed when a mouse up event is handled for the control.
          </p>
          <p>
            Use OnMouseMove to perform actions needed when the mouse pointer position has changed for the control.
          </p>
          <p>
            Use OnMouseWheel, OnMouseWheelDown, and OnMouseWheelUp to preforms actions needed when mouse scroll wheel messages are handled for the control.
          </p>
        </descr>
        <seealso>
          <link id="TControl.MouseDown"/>
          <link id="TControl.OnMouseUp"/>
          <link id="TControl.OnMouseMove"/>
          <link id="TControl.OnMouseWheel"/>
          <link id="TControl.OnMouseWheelDown"/>
          <link id="TControl.OnMouseWheelUp"/>
          <link id="TControl.OnClick"/>
          <link id="TMouseEvent"/>
        </seealso>
      </element>

      <element name="TControl.OnMouseMove">
        <short>Event handler for mouse movement within the control.</short>
        <descr>
        </descr>
        <seealso>
        </seealso>
      </element>

      <element name="TControl.OnMouseUp">
        <short>Event handler signalled when a mouse up event is handled for the control.</short>
        <descr>
          <p>
            <var>OnMouseUp</var> is signalled (when assigned) from the <var>MouseUp</var> method. It is signalled when standard mouse events are enabled using the ControlStyle property. The event is signalled after the mouse position has been updated and the event is applied to an active DragManager.
          </p>
          <p>
            An application must implement and assign a TMouseEvent handler routine to the property which responds to the event notification.
          </p>
          <p>
            Use OnMouseDown to perform actions needed when a mouse down event is handled for the control.
          </p>
          <p>
            Use OnMouseMove to perform actions needed when the mouse pointer position has changed for the control.
          </p>
          <p>
            Use OnMouseWheel, OnMouseWheelDown, and OnMouseWheelUp to preforms actions needed when mouse scroll wheel messages are handled for the control.
          </p>
        </descr>
        <seealso>
          <link id="TControl.MouseUp"/>
          <link id="TControl.OnMouseDown"/>
          <link id="TControl.OnMouseMove"/>
          <link id="TControl.OnMouseWheel"/>
          <link id="TControl.OnMouseWheelDown"/>
          <link id="TControl.OnMouseWheelUp"/>
          <link id="TControl.OnClick"/>
          <link id="TMouseEvent"/>
        </seealso>
      </element>

      <element name="TControl.OnMouseEnter">
        <short>Event handler signalled when the mouse pointer has entered the control.</short>
        <descr>
          <p>
            <var>OnMouseEnter</var> is a <var>TNotifyEvent</var> property with the event handler signalled when the mouse pointer has entered the bounds for the control. OnMouseEnter is signalled from the MouseEnter method (when assigned), and occurs after the Parent control has been notified of the event. The Sender argument contains the control for the notification, and must be cast to a TControl type to access the properties or values specific to the class type.
          </p>
          <p>
            Use OnMouseLeave to perform actions needed when the mouse pointer has left the bounds for the control.
          </p>
        </descr>
        <seealso>
          <link id="TControl.MouseEnter"/>
          <link id="TControl.CMMouseEnter"/>
          <link id="TControl.OnMouseLeave"/>
          <link id="#rtl.classes.TNotifyEvent">TNotifyEvent</link>
        </seealso>
      </element>

      <element name="TControl.OnMouseLeave">
        <short>Event handler signalled when the mouse pointer has left the control.</short>
        <descr>
          <p>
            <var>OnMouseLeave</var> is a <var>TNotifyEvent</var> property with the event handler signalled when the mouse pointer has left the bounds for the control. OnMouseLeave is signalled from the MouseLeave method (when assigned), and occurs after the Parent control has been notified of the event. The Sender argument contains the control for the notification, and must be cast to a TControl type to access the properties or values specific to the class type.
          </p>
          <p>
            Use OnMouseEnter to perform actions needed when the mouse pointer has entered  the bounds for the control.
          </p>
        </descr>
        <seealso>
          <link id="TControl.MouseLeave"/>
          <link id="TControl.CMMouseLeave"/>
          <link id="TControl.OnMouseEnter"/>
          <link id="#rtl.classes.TNotifyEvent">TNotifyEvent</link>
        </seealso>
      </element>

      <element name="TControl.OnMouseWheel">
        <short>Event handler for mouse wheel turned.</short>
        <descr>
          <p>
            By default all mouse wheel actions are translated into scroll events. Write an OnMouseWheel handler to react on turns of the mouse wheel.
          </p>
          <p>
            The OnMouseWheelUp and OnMouseWheelDown handlers are notified only, they are not suited for customization of mouse wheel events.
          </p>
        </descr>
        <seealso>
          <link id="TMouseWheelEvent"/>
        </seealso>
      </element>

      <element name="TControl.OnMouseWheelDown">
        <short>Event handler for downward movement of mouse wheel.</short>
        <descr>
        </descr>
        <seealso>
          <link id="TControl.OnMouseWheel"/>
          <link id="TMouseWheelUpDownEvent"/>
        </seealso>
      </element>

      <element name="TControl.OnMouseWheelUp">
        <short>Event handler for upward movement of the mouse wheel.</short>
        <descr>
        </descr>
        <seealso>
          <link id="TControl.OnMouseWheel"/>
          <link id="TMouseWheelUpDownEvent"/>
        </seealso>
      </element>

      <element name="TControl.OnMouseWheelHorz">
        <short>Event handler for horizontal movements of the mouse wheel.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.OnMouseWheelLeft">
        <short>Event handler for left movements of the mouse wheel.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.OnMouseWheelRight">
        <short>Event handler for right movements of the mouse wheel.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.OnStartDock">
        <short>Event handler for the start of a docking operation.</short>
        <descr>
          <p>The handler can provide a special DragDock object, otherwise a default object is created.</p>
        </descr>
        <seealso>
          <link id="TControl.OnStartDrag"/>
          <link id="TDragDockObject"/>
        </seealso>
      </element>

      <element name="TControl.OnStartDrag">
        <short>Event handler for the start of a dragging operation.</short>
        <descr>
          <p>
            The handler can provide a special DragControl object, otherwise a default object is created.
          </p>
        </descr>
        <seealso>
          <link id="TControl.OnStartDock"/>
          <link id="TDragObject"/>
        </seealso>
      </element>

      <element name="TControl.OnEditingDone">
        <short>Event handler signalled when editing is done.</short>
        <descr>
          <p>
            The user has finished editing the value for the control, and the resulting text can be validated. It is called (when assigned) from the <var>EditingDone</var> method, which occurs when focus changes to another control.
          </p>
        </descr>
        <seealso>
          <link id="TControl.EditingDone"/>
        </seealso>
      </element>

      <element name="TControl.FCompStyle">
        <short>Deprecated.</short>
        <descr>
          <remark>
            DEPRECATED. Enables valid use of the <b>'IN'</b> operator (this is a hack for speed). It will be replaced by the use of the widgetset classes. So, don't use it anymore.
          </remark>
        </descr>
        <seealso/>
      </element>

      <element name="TControl.DragDrop">
        <short>Invokes the OnDragDrop handler, when a dragged object is dropped onto this control.</short>
        <seealso>
          <link id="TControl.OnDragDrop"/>
        </seealso>
      </element>
      <element name="TControl.DragDrop.Source">
        <short>The dropped object (control or DragDrop object).</short>
      </element>
      <element name="TControl.DragDrop.X">
        <short>The drop position in client coordinates.</short>
      </element>
      <element name="TControl.DragDrop.Y">
        <short>The drop position in client coordinates.</short>
      </element>

      <element name="TControl.Dock">
        <short>Moves the control into a new docksite.</short>
        <descr>
          <p>
            Calls <link id="TControl.DoDock">DoDock</link> to prepare for the new position of the control, when docked into an unmanaged or floating docksite.
          </p>
          <p>
            When the old and new docksites are different, the control is removed from the DockClients of the old docksite, and added to the DockClients of the new docksite; afterwards the docksites are notified by calling their DoAddDockClient and DoRemoveDockClient methods, to adjust the control's Parent.
          </p>
        </descr>
        <errors>
          An exception is raised if there is already a docking process in progress for this control.
        </errors>
      </element>
      <element name="TControl.Dock.NewDockSite">
        <short>The host site into which which the control is to be docked, <b>Nil</b> for floating.</short>
      </element>
      <element name="TControl.Dock.ARect">
        <short>
          The new Bounds for the control. Expressed in screen coordinates when NewDockSite is Nil. Otherwise, client coordinates for NewDockSite.
        </short>
      </element>

      <element name="TControl.ManualDock">
        <short>Docks a control programmatically.</short>
        <descr>
          <p>
            Docks this control into NewDockSite, relative to DropControl. When NewDockSite is Nil, the control becomes floating.
          </p>
          <p>
            When the new docksite uses an DockManager, and DropControl is not Nil, the control will be docked relative to DropControl, as specified by ControlSide.
          </p>
          <p>
            The interpretation of ControlSide depends on the DockManager of NewDockSite,
            or on the OnDockDrop handler in an unmanaged  docksite.
          </p>
          <p>
            A tree docking manager (TDockTree) should interpret alCustom as NoteBook docking, i.e. a tabbed notebook is created in place of DropControl, and both DropControl and this control are docked into pages of this notebook.
          </p>
        </descr>
      </element>
      <element name="TControl.ManualDock.Result">
        <short><b>True</b> if successfully docked.</short>
      </element>
      <element name="TControl.ManualDock.NewDockSite">
        <short>The site into which the control is docked; <b>Nil</b> to make it float.</short>
      </element>
      <element name="TControl.ManualDock.DropControl">
        <short>The sibling control where the control is inserted; can be Nil.
        </short>
      </element>
      <element name="TControl.ManualDock.ControlSide">
        <short>The side or edge of the DropControl to which the control is docked.
        </short>
      </element>
      <element name="TControl.ManualDock.KeepDockSiteSize">
        <short/>
      </element>

      <element name="TControl.ManualFloat">
        <short>Undocks the control into the floating state.</short>
        <descr>
          TWinControls float for themselves, for TControls a floating host dock site is created, and the control is docked into it.
        </descr>
      </element>
      <element name="TControl.ManualFloat.Result">
        <short><b>True</b> if successfully floated.</short>
      </element>
      <element name="TControl.ManualFloat.TheScreenRect">
        <short>
          The screen area where the floating control is moved; or the client area for a floating host site.
        </short>
      </element>
      <element name="TControl.ManualFloat.KeepDockSiteSize">
        <short/>
      </element>

      <element name="TControl.ReplaceDockedControl">
        <short>Replaces a previously docked control.</short>
        <descr>
          <p>
            This method exists for use by the DockManager for NoteBook docking. It should not be used in application code.
          </p>
          <p>
            Delphi introduced a different method, DockReplaceDockClient, which is used when the replaced Control is in an unmanaged docksite.
          </p>
        </descr>
        <seealso>
          <link id="TControl.ManualDock"/>
        </seealso>
      </element>
      <element name="TControl.ReplaceDockedControl.Result">
        <short><b>True</b> if the docked control has been successfully replaced.</short>
      </element>
      <element name="TControl.ReplaceDockedControl.Control">
        <short>The control to be replaced, will be docked into NewDockSite.</short>
      </element>
      <element name="TControl.ReplaceDockedControl.NewDockSite">
        <short>The new dock site for Control, typically a docking Notebook.
        </short>
      </element>
      <element name="TControl.ReplaceDockedControl.DropControl">
        <short>The control to which Control is docked.</short>
      </element>
      <element name="TControl.ReplaceDockedControl.ControlSide">
        <short>The side of DropControl, to which Control is docked.</short>
      </element>

      <element name="TControl.Docked">
        <short>Indicates if the control has a host dock site.</short>
        <descr>
          <p>
            Docked is a Boolean function which indicates if the control instance is docked to a host  docking site. The return value is <b>True</b> when all of the following conditions are met:
          </p>
          <ul>
            <li>Parent is assigned (not Nil).</li>
            <li>Parent has the same value as the HostDockSite property.</li>
            <li>Parent has a parent form with a different value than Parent itsself.</li>
          </ul>
        </descr>
        <seealso>
          <link id="TControl.HostDockSite"/>
          <link id="TControl.Parent"/>
          <link id="#lcl.forms.GetParentForm">GetParentForm</link>
        </seealso>
      </element>
      <element name="TControl.Docked.Result">
        <short/>
      </element>

      <element name="TControl.Dragging">
        <short>Returns <b>True</b> if the control is being dragged.</short>
      </element>
      <element name="TControl.Dragging.Result">
        <short>Returns <b>True</b> if the control is being dragged.</short>
      </element>

      <element name="TControl.GetAccessibleObject">
        <short>Returns <b>True</b> if the control is being dragged.</short>
      </element>

      <element name="TControl.CreateAccessibleObject">
        <short>
          Creates a TLazAccessibleObject instance for this control.
        </short>
        <descr>
          <p>
            CreateAccessibleObject should just create and return the object instance. It is useful for classes derived from a descendant of TLazAccessibleObject (instead of the base class).
          </p>
        </descr>
        <seealso>
          <link id="TLazAccessibleObject"/>
          <link id="TControl.GetAccessibleObject"/>
        </seealso>
      </element>

      <element name="TControl.GetSelectedChildAccessibleObject">
        <short>
          Returns the currently selected child accessibility object.
        </short>
        <descr>
          <p>
          GetSelectedChildAccessibleObject is provided for controls which wish to override this behavior without sub-classing TLazAccessibleObject.
          </p>
        </descr>
        <seealso>
          <link id="TLazAccessibleObject"/>
          <link id="TLazAccessibleObject.GetSelectedChildAccessibleObject"/>
          <link id="TControl.CreateAccessibleObject"/>
          <link id="TControl.GetAccessibleObject"/>
        </seealso>
      </element>

      <element name="TControl.GetChildAccessibleObjectAtPos">
        <short>
          Returns the child accessibility object at the given position for the control.
        </short>
        <descr>
          <p>
            GetChildAccessibleObjectAtPos returns the accesibility object at the position expressed in client coordinates. This method is provided for controls which wish to override this behavior without sub-classing TLazAccessibleObject.
          </p>
        </descr>
        <seealso>
          <link id="TLazAccessibleObject"/>
          <link id="TLazAccessibleObject.GetChildAccessibleObjectAtPos"/>
          <link id="TControl.CreateAccessibleObject"/>
          <link id="TControl.GetAccessibleObject"/>
        </seealso>
      </element>

      <element name="TControl.ScaleDesignToForm">
        <short>
          Scales a size value from the design-time PPI to the run-time PPI for the parent form.
        </short>
        <descr>
        </descr>
        <seealso/>
      </element>
      <element name="TControl.ScaleDesignToForm.Result">
        <short>Scaled sized value.</short>
      </element>
      <element name="TControl.ScaleDesignToForm.ASize">
        <short>Original size value scaled in the method.</short>
      </element>

      <element name="TControl.ScaleFormToDesign">
        <short>
          Scales a size value from the run-time PPI for the parent form to the design-time PPI.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.ScaleFormToDesign.Result">
        <short>Scaled sized value.</short>
      </element>
      <element name="TControl.ScaleFormToDesign.ASize">
        <short>Original size value scaled in the method.</short>
      </element>

      <element name="TControl.Scale96ToForm">
        <short>
          Scales a size value from 96 PPI to the run-time PPI for the Screen.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.Scale96ToForm.Result">
        <short>
          Scaled size value.
        </short>
      </element>
      <element name="TControl.Scale96ToForm.ASize">
        <short>
          Original size value scaled in the method.
        </short>
      </element>

      <element name="TControl.ScaleFormTo96">
        <short>
          Scales a size value from the PPI for the Parent form (or designer control) to 96 PPI.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.ScaleFormTo96.Result">
        <short>
          Scaled size value.
        </short>
      </element>
      <element name="TControl.ScaleFormTo96.ASize">
        <short>
          Original size value scaled in the method.
        </short>
      </element>

      <element name="TControl.Scale96ToFont">
        <short>
          Scales a size value from 96 PPI to the PPI setting for the Font in the control.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.Scale96ToFont.Result">
        <short>
          Scaled sized value.
        </short>
      </element>
      <element name="TControl.Scale96ToFont.ASize">
        <short>
          Original size value scaled in the method.
        </short>
      </element>

      <element name="TControl.ScaleFontTo96">
        <short>
          Scales a size value from the PPI setting in the Font for the control to 96 PPI.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.ScaleFontTo96.Result">
        <short>
          Scaled size value.
        </short>
      </element>
      <element name="TControl.ScaleFontTo96.ASize">
        <short>
          Original size value scaled in the method.
        </short>
      </element>

      <element name="TControl.ScaleScreenToFont">
        <short>
          Scales a size value from the PPI setting for the Screen to the PPI setting for the Font in the control.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.ScaleScreenToFont.Result">
        <short>
          Scaled size value.
        </short>
      </element>
      <element name="TControl.ScaleScreenToFont.ASize">
        <short>
          Original size value scaled in the method.
        </short>
      </element>

      <element name="TControl.ScaleFontToScreen">
        <short>
          Scales a size value from the PPI setting for the Font to the PPI setting for the Screen.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.ScaleFontToScreen.Result">
        <short>
          Scaled size value.
        </short>
      </element>
      <element name="TControl.ScaleFontToScreen.ASize">
        <short>
          Size value scaled in the method.
        </short>
      </element>

      <element name="TControl.Scale96ToScreen">
        <short>
          Scales a size value from 96 PPI to the PPI setting for the Screen.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.Scale96ToScreen.Result">
        <short>
          Scaled size value.
        </short>
      </element>
      <element name="TControl.Scale96ToScreen.ASize">
        <short>
          Size value scaled in the method.
        </short>
      </element>

      <element name="TControl.ScaleScreenTo96">
        <short>
          Scales a size value from the PPI setting for the Screen to 96 PPI.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.ScaleScreenTo96.Result">
        <short>
          Scaled size value.
        </short>
      </element>
      <element name="TControl.ScaleScreenTo96.ASize">
        <short>
          Size value scaled in the method.
        </short>
      </element>

      <element name="TControl.AdjustSize">
        <short>Smart way to <var>DoAutoSize</var>.
        </short>
        <descr>
          <p>
            <var>AdjustSize</var> is the same as Delphi the <var>TWinControl.DoAutoSize</var> method. But since <var>DoAutoSize</var> is commonly overridden in descendent components, it is not useful to perform all tests, which can result in too much overhead. To reduce this the LCL calls <var>AdjustSize</var> instead.
          </p>
          <p>
            During loading and handle creation the calls are delayed.
          </p>
        </descr>
        <seealso>
          <link id="TControl.AutoSize"/>
        </seealso>
      </element>

      <element name="TControl.AutoSizePhases">
        <short>Auto-sizing phases enabled for the control.</short>
        <descr>
          <p>
            <var>AutoSizePhases</var> is a <var>TControlAutoSizePhases</var> function used to get the <var>Autosizing</var> phases enabled for the control. In general, the values in AutoSizePhases depend on the <var>TWinControlFlag</var> values enabled for the control.
          </p>
          <p>
            For <var>TControl</var>, the values from the Parent control are used. If the Parent control is unassigned, the value is an empty set (<b>[]</b>).
          </p>
          <p>
            For <var>TWinControl</var>, the value from the Parent control are used (when a Parent has been assigned). Otherwise, the windows control flags are used to get the return value. For example:
          </p>
          <dl>
            <dt>wcfCreatingHandle,wcfCreatingChildHandles</dt>
            <dd>Includes caspCreatingHandles in the set</dd>
            <dt>wcfRealizingBounds</dt>
            <dd>Includes caspRealizingBounds in the set</dd>
            <dt>wcfUpdateShowing</dt>
            <dd>Includes caspShowing in the set</dd>
          </dl>
          <p>
            In addition, <var>AutoSizingAll</var> forces <var>caspComputingBounds</var> to be included in the set. <var>caspChangingProperties</var> is included when the internal auto-sizing lock count has a value greater than zero (<b>0</b>).
          </p>
        </descr>
        <seealso>
          <link id="TWinControlFlags"/>
          <link id="TControlAutoSizePhase"/>
        </seealso>
      </element>
      <element name="TControl.AutoSizePhases.Result">
        <short>Set with the TControlAutoSizePhase values.</short>
      </element>

      <element name="TControl.AutoSizeDelayed">
        <short>
          Returns <b>True</b> if auto-sizing has been delayed until some other process is complete.
        </short>
      </element>
      <element name="TControl.AutoSizeDelayed.Result">
        <short><b>True</b> if auto-sizing has been delayed.</short>
      </element>

      <element name="TControl.AutoSizeDelayedReport">
        <short>Returns a string with a debugging message for delayed auto-size requests.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.AutoSizeDelayedReport.Result">
        <short/>
      </element>

      <element name="TControl.AutoSizeDelayedHandle">
        <short>
          Returns <b>True</b> if AutoSize should be skipped or delayed because of its handle.
        </short>
        <descr>
          <p>
            A TControl instance does not have a handle, so it needs a parent control.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TControl.AutoSizeDelayedHandle.Result">
        <short/>
      </element>

      <element name="TControl.AnchorToNeighbour">
        <short>Anchor to Sibling at Side.</short>
        <descr>
          <p>
            Setup <var>AnchorSide</var> to anchor a side to a neighboring sibling control. For example: Right side to Left side, or Top side to Bottom.
          </p>
        </descr>
      </element>
      <element name="TControl.AnchorToNeighbour.Side">
        <short>The side to be anchored to Sibling.</short>
      </element>
      <element name="TControl.AnchorToNeighbour.Space">
        <short>The minimum space to Sibling.</short>
      </element>
      <element name="TControl.AnchorToNeighbour.Sibling">
        <short>The sibling control to which we should anchor.</short>
      </element>

      <element name="TControl.AnchorParallel">
        <short>Anchor parallel to Sibling, at Side.</short>
        <descr/>
      </element>
      <element name="TControl.AnchorParallel.Side">
        <short>The side to anchor to the sibling.</short>
      </element>
      <element name="TControl.AnchorParallel.Space">
        <short>The minimum space to Sibling.</short>
      </element>
      <element name="TControl.AnchorParallel.Sibling">
        <short>The sibling control to which we should anchor.</short>
      </element>

      <element name="TControl.AnchorHorizontalCenterTo">
        <short>Setup AnchorSide to center the control horizontally relative to a sibling.
        </short>
      </element>
      <element name="TControl.AnchorHorizontalCenterTo.Sibling">
        <short>The sibling control to which we should anchor.</short>
      </element>

      <element name="TControl.AnchorVerticalCenterTo">
        <short>Setup AnchorSide to center the control vertically relative to Sibling.
        </short>
      </element>
      <element name="TControl.AnchorVerticalCenterTo.Sibling">
        <short>The sibling control to which we should anchor.</short>
      </element>

      <element name="TControl.AnchorToCompanion">
        <short>
          Anchor to Sibling at Side, with the same extent.
        </short>
        <descr>
          <p>
            Table or tree style anchoring, into a neighbor cell of Sibling. Obtain the row height (or column width) from <var>Sibling</var>.
          </p>
        </descr>
      </element>
      <element name="TControl.AnchorToCompanion.Side">
        <short>The side to anchor to the sibling.</short>
      </element>
      <element name="TControl.AnchorToCompanion.Space">
        <short>The minimum space to Sibling.</short>
      </element>
      <element name="TControl.AnchorToCompanion.Sibling">
        <short>The sibling control to which we should anchor.</short>
      </element>
      <element name="TControl.AnchorToCompanion.FreeCompositeSide">
        <short/>
      </element>

      <element name="TControl.AnchorSame">
        <short>Copy Sibling's anchoring for Side.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.AnchorSame.Side">
        <short>The side to anchor like the sibling does.</short>
      </element>
      <element name="TControl.AnchorSame.Sibling">
        <short>The sibling control from which to inherit anchoring.</short>
      </element>

      <element name="TControl.AnchorAsAlign">
        <short>Anchor to Parent, following same rules as for Align.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.AnchorAsAlign.TheAlign">
        <short/>
      </element>
      <element name="TControl.AnchorAsAlign.Space">
        <short/>
      </element>

      <element name="TControl.AnchorClient">
        <short>Anchor to Parent's full client area.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.AnchorClient.Space">
        <short>The around space.</short>
      </element>

      <element name="TControl.AnchoredControlCount">
        <short>The number of controls anchored to the current control.</short>
      </element>
      <element name="TControl.AnchoredControlCount.Result">
        <short/>
      </element>

      <element name="TControl.AnchoredControls">
        <short>The list of controls which anchored to the current control.</short>
      </element>
      <element name="TControl.AnchoredControls.Index">
        <short/>
      </element>

      <element name="TControl.SetBounds">
        <short>Sets the bounds (Left, Top, Width, Height) of the control.</short>
        <descr>
          <p>
            <var>SetBounds</var> can be used to change the <var>Left</var>, <var>Top</var>, <var>Width</var>, and <var>Height</var> properties as a single action. This reduces the overhead required for the common operation. Use <var>DisableAutoSize</var> and <var>EnableAutoSize</var> to reduce the overhead for recomputing/moving/resizing even further.
          </p>
          <p>
            <var>SetBounds</var> is also called when any one of these properties, or the BoundsRect property is set. SetBounds updates BaseBounds and BaseParentClientSize, which are used by the anchoring mechanism to keep the spacing between controls. For example loading a Form with TMemo and the .lfm contains TMemo's Left and Width, then SetBounds is called two times for the memo.
          </p>
          <p>
            When the user maximizes a window, SetBounds is called for the form, but not for the Memo, keeping the BaseBounds of the Memo. If the Memo is anchored to the right, the Width of the Memo is changed based on the BaseBounds and BaseParentClientSize.
          </p>
          <p>
            Keep in mind that the given aLeft, aTop, aWidth, aHeight might not be valid and will be changed by the LCL before applied.
          </p>
          <p>
            Delphi calls SetBounds more often. SetBounds calls ChangeBounds with the KeepBase argument set to <b>False</b>.
          </p>
        </descr>
      </element>
      <element name="TControl.SetBounds.aLeft">
        <short>The X coordinate of the left side of the control.</short>
      </element>
      <element name="TControl.SetBounds.aTop">
        <short>The Y coordinate of the top of the control.</short>
      </element>
      <element name="TControl.SetBounds.aWidth">
        <short>The width of the control.</short>
      </element>
      <element name="TControl.SetBounds.aHeight">
        <short>The height of the control.</short>
      </element>

      <element name="TControl.SetInitialBounds">
        <short>Sets the bounds of the control initially, when it is created.</short>
        <descr>Does nothing while the control is loaded.</descr>
        <seealso>
          <link id="TControl.SetBounds"/>
        </seealso>
      </element>
      <element name="TControl.SetInitialBounds.aLeft">
        <short>X coordinate for the top, left pixel.</short>
      </element>
      <element name="TControl.SetInitialBounds.aTop">
        <short>Y coordinate for the top, left pixel.</short>
      </element>
      <element name="TControl.SetInitialBounds.aWidth">
        <short>Width of control.</short>
      </element>
      <element name="TControl.SetInitialBounds.aHeight">
        <short>Height of control.</short>
      </element>

      <element name="TControl.SetBoundsKeepBase">
        <short>Set the bounds, keeping the base values.</short>
        <descr>
          <p>
            SetBoundsKeepBase is a procedure used to set the bounds for a Control to the specified values without affecting the bounds in a Parent control.
          </p>
          <p>
            SetBoundsKeepBase calls the ChangeBounds method to update the sized and position for the control to the specified values. If you use this in a custom control, disable LCL auto-sizing for this control prior to calling the method.
          </p>
          <p>
            SetBoundsKeepBase is used in the implementation for several methods, including:
          </p>
          <ul>
            <li>WMSize</li>
            <li>WMMove</li>
            <li>WMWindowPosChanged</li>
            <li>DoAutoSize</li>
            <li>DoAutoAdjustLayout</li>
            <li>DoUndock</li>
            <li>Loaded</li>
          </ul>
        </descr>
        <seealso>
          <link id="TControl.WMSize"/>
          <link id="TControl.WMMove"/>
          <link id="TControl.DoAutoSize"/>
          <link id="TControl.DoAutoAdjustLayout"/>
          <link id="TWinControl.WMWindowPosChanged"/>
          <link id="TWinControl.DoUndock"/>
          <link id="TControl.Loaded"/>
        </seealso>
      </element>
      <element name="TControl.SetBoundsKeepBase.aLeft">
        <short>New Left coordinate for the control.</short>
      </element>
      <element name="TControl.SetBoundsKeepBase.aTop">
        <short>New Right coordinate for the control.</short>
      </element>
      <element name="TControl.SetBoundsKeepBase.aWidth">
        <short>New Width for the control.</short>
      </element>
      <element name="TControl.SetBoundsKeepBase.aHeight">
        <short>New Height for the control.</short>
      </element>

      <element name="TControl.GetPreferredSize">
        <short>Returns default/preferred height and width, for use in auto-sizing.</short>
        <descr>
          <p>
            Called during AutoSize calculations. Only positive values are valid. Negative or 0 are treated as undefined and the LCL uses other sizes instead.
          </p>
          <p>
            WithThemeSpace: If <b>True</b>, adds space for stacking.
          </p>
          <p>
            For example: <var>TRadioButton</var> has a minimum size. But for stacking multiple TRadioButtons there should be some space around. This space is theme dependent, so the parameter is passed to the widgetset
          </p>
          <p>
            <var>TWinControl</var> overrides this and asks the interface for theme dependent values. See <link id="TWinControl.CalculatePreferredSize"/> for more information.
          </p>
        </descr>
      </element>
      <element name="TControl.GetPreferredSize.PreferredWidth">
        <short/>
      </element>
      <element name="TControl.GetPreferredSize.PreferredHeight">
        <short/>
      </element>
      <element name="TControl.GetPreferredSize.Raw">
        <short>
          When <b>False</b>, the values will be adjusted by the constraints, and undefined values will be replaced by GetDefaultWidth/GetDefaultHeight.
        </short>
      </element>
      <element name="TControl.GetPreferredSize.WithThemeSpace">
        <short>If <b>True</b>, adds space for stacking.</short>
      </element>

      <element name="TControl.GetCanvasScaleFactor">
        <short>Gets the scaling factor for the canvas used to render the control.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.GetCanvasScaleFactor.Result">
        <short/>
      </element>

      <element name="TControl.GetDefaultWidth">
        <short>
          The default width for this control, independent of any calculated values like Width and GetPreferredSize.
        </short>
      </element>
      <element name="TControl.GetDefaultWidth.Result">
        <short/>
      </element>

      <element name="TControl.GetDefaultHeight">
        <short>
          The default height for this control, independent of any calculated values like Height and GetPreferredSize.
        </short>
      </element>
      <element name="TControl.GetDefaultHeight.Result">
        <short/>
      </element>

      <element name="TControl.GetDefaultColor">
        <short>Gets the default color for the control.</short>
        <descr>
          <p>
            <var>GetDefaultColor</var> is a <var>TColor</var> function used to resolve the default color (<var>clDefault</var>) to a TColor value for the control. GetDefaultColor can return a color value for either the control background or its text. The <var>DefaultColorType</var> argument identifies which value is needed in the return value. In TControl, the following color types and values are used:
          </p>
          <dl>
            <dt>dctBrush</dt>
            <dd>
              Background or fill color for the control (Color). Returns the clWindow system color.
            </dd>
            <dt>dctFont</dt>
            <dd>
              Text color for the control (Font.Color). Returns the clWindowText system color.
            </dd>
          </dl>
          <p>
            GetDefaultColor uses the value provided by the corresponding method in the widgetset class instance when a value other than clDefault is returned. When not resolved in the widgetset class, the return value is retrieved using the Parent color or the local values in the class instance. If <var>ParentColor</var> is <b>True</b> (and <var>Parent</var> is assigned), the GetDefaultColor method in the Parent control is called to get the specified color type. Otherwise, one of the values from the preceding list is used for the color type.
          </p>
          <p>
            GetDefaultColor is a virtual method and can be overridden in descedent classes to use the colors needed for a specific control.
          </p>
          <p>
            GetDefaultColor is used in the implementation of the GetColorResolvingParent and GetRGBColorResolvingParent methods. It is also called from the SetColor and CreateBrush methods in the TWinControl descendant.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Color"/>
          <link id="TControl.Font"/>
          <link id="TControl.ParentColor"/>
          <link id="TControl.Parent"/>
          <link id="TControl.GetColorResolvingParent"/>
          <link id="TControl.GetRGBColorResolvingParent"/>
          <link id="TWinControl.SetColor"/>
          <link id="TWinControl.CreateBrush"/>
          <link id="#lcl.graphics.TColor">TColor</link>
          <link id="#lcl.graphics.TDefaultColorType">TDefaultColorType</link>
        </seealso>
      </element>
      <element name="TControl.GetDefaultColor.Result">
        <short>TColor value for the specified color type.</short>
      </element>
      <element name="TControl.GetDefaultColor.DefaultColorType">
        <short>Identifies the color type needed in the return value (brush or font).</short>
      </element>

      <element name="TControl.GetColorResolvingParent">
        <short>
          Returns the color of the control while resolving clDefault and ParentColor.
        </short>
        <descr>
          <p>
            <var>GetColorResolvingParent</var> is a convenience routine used to obtain the Color for the control while resolving clDefault. It will never return clDefault, but it might return a non-RGB color. To obtain a purely RGB result use GetRGBColorResolvingParent.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Color"/>
          <link id="TControl.GetDefaultColor"/>
          <link id="TControl.ParentColor"/>
          <link id="TControl.GetRGBColorResolvingParent"/>
        </seealso>
      </element>

      <element name="TControl.GetRGBColorResolvingParent">
        <short>Returns a RGB value for the color of the control.</short>
        <descr>
          <p>
            This convenience routine will allow to obtain the Color of the control while resolving clDefault, ParentColor and system color indexes and returns a TColor value.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Color"/>
          <link id="TControl.GetDefaultColor"/>
          <link id="TControl.ParentColor"/>
          <link id="TControl.GetColorResolvingParent"/>
        </seealso>
      </element>

      <element name="TControl.GetSidePosition">
        <short>The client coordinate of the given side.</short>
      </element>
      <element name="TControl.GetSidePosition.Result">
        <short/>
      </element>
      <element name="TControl.GetSidePosition.Side">
        <short/>
      </element>

      <element name="TControl.CNPreferredSizeChanged">
        <short>Message handler for preferred size changed.</short>
      </element>

      <element name="TControl.InvalidatePreferredSize">
        <short>
          Marks the preferred size as invalid for this control and all parents (implies that we will look for another).
        </short>
      </element>

      <element name="TControl.GetAnchorsDependingOnParent">
        <short>Returns the sides which are anchored to the Parent.</short>
      </element>
      <element name="TControl.GetAnchorsDependingOnParent.Result">
        <short/>
      </element>
      <element name="TControl.GetAnchorsDependingOnParent.WithNormalAnchors">
        <short/>
      </element>

      <element name="TControl.DisableAutoSizing">
        <short>
          Disables automatic sizing; implies that the default size is accepted, or sizing is done manually.
        </short>
      </element>

      <element name="TControl.EnableAutoSizing">
        <short>Turns on (enables) automatic sizing.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.UpdateBaseBounds">
        <short>Update the basic boundaries of the control - essential if there has been a lot of re-sizing.</short>
      </element>
      <element name="TControl.UpdateBaseBounds.StoreBounds">
        <short/>
      </element>
      <element name="TControl.UpdateBaseBounds.StoreParentClientSize">
        <short/>
      </element>
      <element name="TControl.UpdateBaseBounds.UseLoadedValues">
        <short/>
      </element>

      <element name="TControl.BaseBounds">
        <short>The rectangle with the designed bounds for the control.</short>
        <descr>
          <p>
            The current Bounds can change, due to scaling, anchoring or auto-sizing.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Anchors"/>
          <link id="TControl.AnchorSide"/>
          <link id="TControl.AutoSize"/>
          <link id="TControl.SetBoundsKeepBase"/>
        </seealso>
      </element>

      <element name="TControl.ReadBounds">
        <short>
          Reflects the Bounds for the Control read during LCL component streaming.
        </short>
        <descr>
          <p>
            <var>ReadBounds</var> is a read-only <var>TRect</var> property used when the values for the Top, Left, Height and Width properties are set during LCL component streaming. When ComponentState contains <var>csLoading</var>, changes to these properties cause the new values to be applied to ReadBounds prior to calling the SetBounds method. The internal ControlFlags are also updated to indicate that the property value has been loaded using LCL component  streaming.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Left"/>
          <link id="TControl.Top"/>
          <link id="TControl.Width"/>
          <link id="TControl.Height"/>
          <link id="TControl.SetBounds"/>
          <link id="TControl.BaseBounds"/>
          <link id="TControlFlag"/>
        </seealso>
      </element>

      <element name="TControl.BaseParentClientSize">
        <short>The Parent's client size, for which the BaseBounds are valid.</short>
        <descr>
          <p>
            BaseBounds and BaseParentClientSize determine the distance to keep from Parent's sides, when a side is anchored to the Parent (akLeft...), and the Parent is resized.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TControl.WriteLayoutDebugReport">
        <short>Used for debugging.</short>
      </element>
      <element name="TControl.WriteLayoutDebugReport.Prefix">
        <short/>
      </element>

      <element name="TControl.AutoAdjustLayout">
        <short>Applies an automatic adjustment layout policy to the control.</short>
        <descr>
          <p>
            AutoAdjustLayout can be used to alter PPI settings, scale the control, or apply changes to height or width without scaling.
          </p>
          <p>
            AMode indicates the layout policy applied in the method, and the actions performed to achieve the task.
          </p>
          <p>
            Scaling factors are calculated (when needed) for both horizontal (X-axis) and vertical (Y-axis ) adjustments. The factors may represent changes to the PPI settings, or changes in the width for the control.
          </p>
          <p>
            AutoAdjustLayout temporarily disables auto-sizing, and calls DoAutoAdjustLayout to apply the scaling factors or size changes.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TControl.AutoAdjustLayout.AMode">
        <short/>
      </element>
      <element name="TControl.AutoAdjustLayout.AFromPPI">
        <short/>
      </element>
      <element name="TControl.AutoAdjustLayout.AToPPI">
        <short/>
      </element>
      <element name="TControl.AutoAdjustLayout.AOldFormWidth">
        <short/>
      </element>
      <element name="TControl.AutoAdjustLayout.ANewFormWidth">
        <short/>
      </element>

      <element name="TControl.ShouldAutoAdjust">
        <short>
          Indicates whether the height and/or width for a control can be automatically adjusted.
        </short>
        <descr>
          <p>
            In TControl, both AWidth and AHeight are set to <b>True</b> when the AutoSize property has not been enabled.
          </p>
        </descr>
        <seealso>
          <link id="TControl.AutoSize"/>
        </seealso>
      </element>
      <element name="TControl.ShouldAutoAdjust.AWidth">
        <short><b>True</b> if the width can be auto-adjusted.</short>
      </element>
      <element name="TControl.ShouldAutoAdjust.AHeight">
        <short><b>True</b> if the height can be auto-adjusted.</short>
      </element>

      <element name="TControl.FixDesignFontsPPI">
        <short>Corrects the font size for High-DPI-aware applications.</short>
        <descr>
          <p>
            FixDesignFontsPPI is a method used to adjust the font size when the design-time PPI (Pixels per Inch) setting differs from the run-time PPI setting for the font in the control.  It calls DoFixDesignFontPPI to restore the value in ADesignTimePPI to the Font reference passed as an argument to to the method. The font height is scaled using the factor represented by TFont.PixelsPerInch/ADesignTimePPI.
          </p>
          <p>
            This method does not trigger a CM_PARENTFONTCHANGED message in the Parent control.
          </p>
          <p>
            In TControl, this action is performed for the Font property. In descendent class, additional properties with a font reference may also be adjusted using the method.
          </p>
          <p>
            FixDesignFontsPPI is called when scaling is enabled, and the Form which hosts the control calls its Loaded method when LCL streaming is completed.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TControl.FixDesignFontsPPI.ADesignTimePPI">
        <short>Design-time PPI setting applied for the font size adjustment.</short>
      </element>

      <element name="TControl.ScaleFontsPPI">
        <short>Resizes a font to the specified Pixels per Inch setting.</short>
        <descr>
        <p>
            ScaleFontsPPI is a method used to resize a font in the control to the specified display density (Pixels per Inch) using the scaling factor in AProportion (when needed).
        </p>
          <p>
            A font may need to be scaled when the run-time PPI setting for the screen differs from the design-time value applied to the font. If the font height is not assigned at run-time, its height is set to the value in TFont.PixelsPerInch / Screen.PixelsPerInch.
          </p>
          <p>
            When AToPPI has a positive non-zero value, it is stored in the TFont.PixelsPerInch property for the font. Otherwise, the existing TFont.PixelsPerInch value is adjusted using the scaling factor in AProportion.
          </p>
          <p>
            ScaleFontsPPI may be overridden in descendent controls to call the method for its child controls.
          </p>
          <p>
            ScaleFontsPPI is called form the AutoAdjustLayout method.
          </p>
        </descr>
        <seealso>
          <link id="TControl.AutoAdjustLayout"/>
          <link id="TControl.ShouldAutoAdjust"/>
        </seealso>
      </element>
      <element name="TControl.ScaleFontsPPI.AToPPI">
        <short>PPI setting to apply to the font.</short>
      </element>
      <element name="TControl.ScaleFontsPPI.AProportion">
        <short>Scaling factor applied to the font height.</short>
      </element>

      <element name="TControl.Create">
        <short>Constructor for the class instance.</short>
        <descr>
          <p>
            Create is the overridden constructor for the class instance. Create calls the inherited constructor using TheOwner as the owner for the class instance. Resources are allocated in the method for members in the class instance, and the default values are set for the following properties:
          </p>
          <ul>
            <li>Align</li>
            <li>Anchors</li>
            <li>BaseBounds</li>
            <li>CaptureMouseButtons</li>
            <li>Color</li>
            <li>ControlStyle</li>
            <li>Cursor</li>
            <li>DesktopFont</li>
            <li>DragCursor</li>
            <li>Enabled</li>
            <li>FloatingDockSiteClass</li>
            <li>Font</li>
            <li>HelpType</li>
            <li>IsControl</li>
            <li>ParentBidiMode</li>
            <li>ParentColor</li>
            <li>ParentFont</li>
            <li>ParentShowHint</li>
            <li>Visible</li>
            <li>WindowProc</li>
          </ul>
          <remark>
            Create ensures that auto-sizing is disabled until the class instance is fully realized. Auto-sizing is re-enabled on exit from the method.
          </remark>
        </descr>
        <seealso>
          <link id="TControl.Destroy"/>
        </seealso>
      </element>
      <element name="TControl.Create.TheOwner">
        <short>The owning component.</short>
      </element>

      <element name="TControl.Destroy">
        <short>Removes the control from its Parent.</short>
        <descr>
          <p>
            Detaches the control from Parent, removes graphics, frees memory and Operating System handles, pointers etc.
          </p>
        </descr>
        <seealso>
          <link id="#lcl.lclclasses.TLCLComponent.Destroy">TLCLComponent.Destroy</link>
          <link id="#rtl.classes.TComponent.Destroy">TComponent.Destroy</link>
        </seealso>
      </element>

      <element name="TControl.BeforeDestruction">
        <short>
          Performs notifications before the control is destroyed.
        </short>
        <descr>
          <p>
            BeforeDestruction is a method which performs notifications when an object instance is about to be freed. It allows tasks to be performed which maintain a persistent object instance and its  obervers before it is destroyed.
          </p>
          <p>
            BeforeDestruction is an overridden method in TControl, and calls the inherited method on entry to ensure that csDestroying is included in the ComponentState property for the control and any of its child components. It extends the inherited method by calling DoCallNotifyHandler for any handler routines using the chtOnBeforeDestruction type.
          </p>
        </descr>
        <seealso>
          <link id="#rtl.classes.TComponent.BeforeDestruction"/>
          <link id="#rtl.classes.TComponent.Destroying"/>
        </seealso>
      </element>

      <element name="TControl.EditingDone">
        <short>Signals the <var>OnEditingDone</var> event handler.</short>
        <descr>
          <p>
            Called when user has finished editing using the control. This procedure can be used by data links to commit the changes.
          </p>
          <p>For example:</p>
          <ul>
            <li>When focus switches to another control (default).</li>
            <li>When user selected another item.</li>
          </ul>
          <p>
            Each control class can determine which events cause the value(s) to be committed.
          </p>
        </descr>
      </element>

      <element name="TControl.ExecuteDefaultAction">
        <short>Called when the Return key is pressed, signifying the default action.</short>
        <descr>
          <p>
            <var>ExecuteDefaultAction</var> has an empty implementation in <var>TControl</var>. It can be overridden in descendent classes to perform any actions needed for the class type.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TControl.ExecuteCancelAction">
        <short>Called when the Escape key is pressed or the Cancel button is clicked.</short>
        <descr>
          <p>
            <var>ExecuteCancelAction</var> has an empty implementation in <var>TControl</var>. It can be overridden in descendent classes to perform any actions needed for the class type.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TControl.BeginDrag">
        <short>Starts a drag operation for the control (programmatically).</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.BeginDrag.Immediate">
        <short>If <b>False</b>, start dragging only after the mouse has moved.</short>
      </element>
      <element name="TControl.BeginDrag.Threshold">
        <short>
          Minimum mouse movement before delayed dragging starts (in pixels); -1 uses the DragManager default. Ignored when Immediate=<b>True</b>.
        </short>
      </element>

      <element name="TControl.EndDrag">
        <short>Ends a drag operation by notifying the drag manager.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.EndDrag.Drop">
        <short/>
      </element>

      <element name="TControl.BringToFront">
        <short>Brings the control in front of other sibling controls.</short>
        <descr>
          <p>
            <var>BringToFront</var> is a method used to move the control to the top of the Z-Order for its sibling controls. BringToFront calls SetZOrder to change the display order for controls which share a common Parent. BringToFront has no effect when Parent has not been assigned.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Parent"/>
          <link id="TControl.SetZOrder"/>
          <link id="TWinControl.SetChildZPosition"/>
        </seealso>
      </element>

      <element name="TControl.HasParent">
        <short>Returns <b>True</b> if there is a Parent component responsible for streaming.</short>
        <descr>
          <p>
            HasParent is called during streaming to decide if a component has to be streamed by its owner or Parent.
          </p>
        </descr>
        <seealso>
          <link id="#rtl.classes.TComponent.HasParent">TComponent.HasParent</link>
        </seealso>
      </element>
      <element name="TControl.HasParent.Result">
        <short><b>True</b> if there is a Parent.</short>
      </element>

      <element name="TControl.GetParentComponent">
        <short>Returns the value in the Parent property.</short>
        <descr>
          <p>
            <var>GetParentComponent</var> gets the component / control which has the current class instance in its <var>Components</var> property. GetParentComponent is an overridden method in TControl, and re-implements the inherited method. It uses the value in the Parent property as the return value for the method. The inherited method always returns <b>Nil</b>.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Parent"/>
          <link id="#rtl.classes.TComponent.Components">TComponent.Components</link>
        </seealso>
      </element>
      <element name="TControl.GetParentComponent.Result">
        <short>Value in the Parent property.</short>
      </element>

      <element name="TControl.IsParentOf">
        <short>Determines whether this control is a parent of AControl.</short>
        <descr>
          <p>
            <var>IsParentOf</var> is a <var>Boolean</var> function used to determine if the current control instance is ultimately a parent of the control specified in AControl. No actions are performed in the method when AControl has not been assigned (<b>Nil</b>), and the return value is set to <b>False</b>.
          </p>
          <p>
            IsParentOf visits each control in the Parent control hierarchy, and returns <b>True </b> if the current class instance (Self) is found in the tree. The return value is <b>False</b> if the current control instance is not found in the Parent control tree.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Parent"/>
        </seealso>
      </element>
      <element name="TControl.IsParentOf.Result">
        <short><b>True</b> if this control is a parent of AControl.</short>
      </element>
      <element name="TControl.IsParentOf.AControl">
        <short>The initial control examined in the parent control hierarchy.</short>
      </element>

      <element name="TControl.GetTopParent">
        <short>Finds the control that is the top-most Parent in the control hierarchy.</short>
        <descr>
          <p>
            GetTopParent is a TControl function used to get the control which is the top-most or intial Parent in the control hierarchy.
          </p>
          <p>
            GetTopParent visits each of the control instances in the Parent property. The return value is set to control where Parent is unassigned (<b>Nil</b>). The return value is the current control instance (Self) if Parent has not been assigned.
          </p>
          <p>
            GetTopParent is used in methods like ChangeBounds where the parent handles layout or sizing for its child controls. The method is also used in descendent classes, like TWinControl, when  messages are handled which resized, move, or otherwise reposition the windowed control.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TControl.GetTopParent.Result">
        <short>TControl instance which is the top-most Parent in the control hierarchy, or Self.</short>
      </element>

      <element name="TControl.FindSubComponent">
        <short>
          Finds the sub-component with the specified name in the Components property.
        </short>
        <descr>
          <p>
            <var>FindSubComponent</var> is a <var>TComponent</var> function used to get the sub-component with the name specified in AName. FindSubComponent is similar to TComponent.FindComponent, but accepts a prefixed component name in AName. For example: 'LabeledEdit1.EditLabel'.
          </p>
          <p>
            FindSubComponent separates the value in AName into the owner and sub-component names. When a prefix is used, the FindComponent method is called to locate the TComponent instance with the owner name. Its FindComponent method is called to get the component with the sub-component name that is used in the return value. If a prefix is not used, the initial component is used as the return value.
          </p>
          <p>
            The return value is <b>Nil</b> if a component is not found with the specified name.
          </p>
        </descr>
        <seealso>
          <link id="#rtl.classes.TComponent.FindComponent">TComponent.FindComponent</link>
          <link id="#rtl.classes.TComponent.Components">TComponent.Components</link>
        </seealso>
      </element>
      <element name="TControl.FindSubComponent.Result">
        <short>The component with the specified name, or Nil when not found.</short>
      </element>
      <element name="TControl.FindSubComponent.AName">
        <short>Parentage/path for the sub-component to retrieve in the method.</short>
      </element>

      <element name="TControl.IsVisible">
        <short>Gets the effective visibility for the control and all of its Parent controls.</short>
        <descr>
          <p>
            <var>IsVisible</var> calls <var>IsControlVisible</var> to determine if the control has its Visible property set to True. At design-time, ControlStyle is also checked  to ensure that csNoDesignVisible is not used in the style flags. Each of the Parent controls in the hierarchy call their IsVisible method to determine the return value for the method.
          </p>
          <p>
            Use IsEnabled to get the effective enabled state for the control and all of its Parent controls.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Visible"/>
          <link id="TControl.Parent"/>
          <link id="TControl.IsControlVisible"/>
          <link id="TControl.IsEnabled"/>
        </seealso>
      </element>
      <element name="TControl.IsVisible.Result">
        <short><b>True</b> when the control and and all Parent controls are Visible.</short>
      </element>

      <element name="TControl.IsControlVisible">
        <short><b>True</b> if the control is Visible, or is in design mode.</short>
        <descr>
          <p>
            The return value is <b>True</b> when the Visible property is set to <b>True</b>. The value is <b>False</b> at design-time if the ControlStyle property includes the value csNoDesignVisible. IsControlVisible does not check the visibility for parent controls in the control hierarchy.
          </p>
          <p>
            Use IsVisible to consider the visiblity for any Parent controls.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Visible"/>
          <link id="TControl.IsVisible"/>
          <link id="TControl.Parent"/>
        </seealso>
      </element>
      <element name="TControl.IsControlVisible.Result">
        <short>
          <b>True</b> if the Visible property is set and the control is not disabled on the design surface at design-time.
        </short>
      </element>

      <element name="TControl.IsEnabled">
        <short>Returns <b>True</b> if both the control and all of its Parent controls are Enabled.</short>
        <descr>
          <p>
            Returns <b>True</b> when both the control instance and its parent control hierarchy are enabled. Used internally by TGraphicControls for painting and various states during run-time.
          </p>
        </descr>
      </element>
      <element name="TControl.IsEnabled.Result">
        <short><b>True</b> when the control and  all Parent controls are enabled.</short>
      </element>

      <element name="TControl.IsParentColor">
        <short>Provides access to the value in the protected ParentColor property.</short>
        <descr>
          <p>
            Returns the value for the protected ParentColor property. Used in places where we need to check ParentColor property from within the TControl. Needed for widgetset classes.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TControl.IsParentColor.Result">
        <short><b>True</b> when ParentColor is set to <b>True</b>.</short>
      </element>

      <element name="TControl.IsParentFont">
        <short>Provides access to the value in the protected ParentFont property.</short>
        <descr>
          <p>
            Checks the value for the protected ParentFont property. Used in places where we need to check ParentFont from within TControl. Needed for widgetset classes.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TControl.IsParentFont.Result">
        <short><b>True</b> when ParentFont is set to <b>True</b>.</short>
      </element>

      <element name="TControl.FormIsUpdating">
        <short><b>True</b> if the form is being updated.</short>
        <descr>
          <p>
            The return value is <b>True</b> when a value has been assigned to Parent, and its FormIsUpdating method returns <b>True</b>. This causes all assigned Parent controls in the hierachy to be examined to determine the return value.
          </p>
          <p>
            Eventually, one of the Parent controls will be the TCustomForm instance which hosts all of the controls. It sets the return value to <b>True</b> when its internal update counter has a non-zero value. This occurs when the form has called BeginFormUpdate, but has not called EndFormUpdate to complete an update.
          </p>
        </descr>
        <seealso>
          <link id="#lcl.forms.TCustomForm.FormIsUpdating"/>
          <link id="#lcl.forms.TCustomForm.BeginFormUpdate"/>
          <link id="#lcl.forms.TCustomForm.EndFormUpdate"/>
        </seealso>
      </element>
      <element name="TControl.FormIsUpdating.Result">
        <short><b>True</b> if the form is being updated.</short>
      </element>

      <element name="TControl.IsProcessingPaintMsg">
        <short><b>True</b> while painting the control.</short>
        <descr>
          <p>
            As the name implies, the cfProcessingWMPaint flag in FControlFlags is set while a LM_PAINT message is processed, and IsProcessingPaintMsg checks this flag.
          </p>
        </descr>
      </element>
      <element name="TControl.IsProcessingPaintMsg.Result">
        <short><b>True</b> when the control flags contain a value for paint methods.</short>
      </element>

      <element name="TControl.Hide">
        <short>Hides the control by setting the Visible property to <b>False</b>.</short>
        <seealso>
          <link id="TControl.Visible"/>
          <link id="TControl.Show"/>
        </seealso>
      </element>

      <element name="TControl.Refresh">
        <short>Causes the control to be redrawn.</short>
        <descr>
          <p>
            Calls the Repaint method to either draw the clipping rectangle for the control to the handle in the Parent, or invalidate the control area for the next paint operation that occurs when the Parent controls are Visible.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Repaint"/>
        </seealso>
      </element>

      <element name="TControl.Repaint">
        <short>Immediately redraws the control when visible, bypassing the message queue.</short>
        <descr>
          <p>
            Repaint is a method called redraw the control when it is visible. No actions are performed in the method when:
          </p>
          <ul>
            <li>Parent has not been assigned.</li>
            <li>Parent does not have a valid handle.</li>
            <li>ComponentState contains the value csDestroying.</li>
            <li>The effective visibility from IsVisible is <b>False</b>.</li>
          </ul>
          <p>
            When the control is Parented, it is redrawn using the style indicated in ControlStyle. When csOpaque is included, a device context is retrieved and the PaintControl method is called for the clipping rectangle in the Parent control. When csOpaque is omitted, the Invalidate and Update methods are called to request the control to redrawn.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Parent"/>
          <link id="TControl.IsVisible"/>
          <link id="TControl.ControlStyle"/>
          <link id="TControl.Invalidate"/>
          <link id="TControl.Update"/>
          <link id="TWinControl.PaintControls"/>
          <link id="#rtl.classes.TComponent.ComponentState">TComponent.ComponentState</link>
        </seealso>
      </element>

      <element name="TControl.Invalidate">
        <short>
          Force a delayed Repaint of the control, by marking its visible area of the control as invalid.
        </short>
        <descr>
          <p>
            Calls the <var>InvalidateControl</var> method to invalidate the bounds rectangle for the control using the clipping rectangle for the Parent.
          </p>
        </descr>
        <seealso>
          <link id="TControl.InvalidateControl"/>
          <link id="TControl.IsVisible"/>
          <link id="TControl.ControlStyle"/>
          <link id="TControl.Parent"/>
        </seealso>
      </element>

      <element name="TControl.CheckChildClassAllowed">
        <short>Returns <b>True</b> if the class is allowed for child controls.</short>
        <descr>
          <p>
            Only few controls restrict the class of acceptable child controls. E.g. a PageControl only accepts TTabSheet descendants as children.
          </p>
        </descr>
        <errors>
          An EInvalidOperation can be generated (see ExceptionOnInvalid).
        </errors>
      </element>
      <element name="TControl.CheckChildClassAllowed.Result">
        <short><b>True</b> if the class is allowed for child controls.</short>
      </element>
      <element name="TControl.CheckChildClassAllowed.ChildClass">
        <short>The class of the intended child control.</short>
      </element>
      <element name="TControl.CheckChildClassAllowed.ExceptionOnInvalid">
        <short>When <b>True</b>, raise an exception when the class is not allowed.</short>
      </element>

      <element name="TControl.CheckNewParent">
        <short>Checks if this control can become a child of AParent.</short>
        <descr>
          <p>
            This check is performed during SetParent. It calls CheckChildClassAllowed and whether AParent is the current class instance (Self).
          </p>
        </descr>
        <errors>
          An EInvalidOperation occurs when any test fails.
        </errors>
      </element>
      <element name="TControl.CheckNewParent.AParent">
        <short>The new Parent for this control.</short>
      </element>

      <element name="TControl.SendToBack">
        <short>Moves all sibling controls in front of this control.</short>
        <descr>
          <p>
            Use <var>SendToBack</var> to move the control beneath all other sibling controls on the Parent. Only those portions of the control not covered by other controls will be visible.
          </p>
          <p>
            Calls SetZOrder to move the position for the control on the z-axis (depth) to the maximum Integer value for the platform.
          </p>
          <p>
            Use BringToFront to move a control to the top of the Z-axis on the Parent control.
          </p>
          <p>
            Use SetChildZPosition in TWinControl to move a child control to a specific position on the Z-axis where 0 is the top and MaxInt is the bottom of the Z-order.
          </p>
        </descr>
        <seealso>
          <link id="TControl.BringToFront"/>
          <link id="TWinControl.SetChildZPosition"/>
        </seealso>
      </element>

      <element name="TControl.SetTempCursor">
        <short>
          Changes the cursor shape temporarily, preserving the original <link id="TControl.Cursor"/>
        </short>
        <descr>
          <p>
            <var>SetTempCursor</var> is a method used to temporarily change the cursor shape to the <var>TCursor</var> value specified in <var>Value</var>. SetTempCursor calls the overridden method in the <var>Parent</var> control to apply the cursor shape in Value.
          </p>
          <p>
            No actions are performed in the method when Parent has not been assigned.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Parent"/>
          <link id="TWinControl.SetTempCursor"/>
          <link id="TCursor"/>
        </seealso>
      </element>
      <element name="TControl.SetTempCursor.Value">
        <short>The temporary cursor shape for the control.</short>
      </element>

      <element name="TControl.UpdateRolesForForm">
        <short>
          Internal method called by a Form when its DefaultControl or CancelControl has changed.
        </short>
        <descr>
          <p>
            This method is overridden in TCustomButton, where it updates the Cancel and Default properties for the control.
          </p>
        </descr>
        <seealso>
          <link id="TControl.ActiveDefaultControlChanged"/>
        </seealso>
      </element>

      <element name="TControl.ActiveDefaultControlChanged">
        <short>
          Notification of a changed active DefaultControl of a form.
        </short>
        <descr>
          <p>
            When the user pressed ENTER in a form, its DefaultControl will receive a Click event.
          </p>
        </descr>
        <errors>
          Currently NewControl can be Nil, even if it should not be.
        </errors>
      </element>
      <element name="TControl.ActiveDefaultControlChanged.NewControl">
        <short>The new DefaultControl.</short>
      </element>

      <element name="TControl.GetTextBuf">
        <short>Copy the <link id="TControl.Text">Text</link> property into Buffer.</short>
        <descr>
          <p>This method only exists for Delphi compatibility.
          </p>
          <p>Don't use or override it, unless really necessary.
          </p>
        </descr>
        <seealso>
          <link id="TControl.RealGetText"/>
        </seealso>
      </element>
      <element name="TControl.GetTextBuf.Result">
        <short>Length of the copied text.</short>
      </element>
      <element name="TControl.GetTextBuf.Buffer">
        <short>Pointer to the buffer receiving the string.</short>
      </element>
      <element name="TControl.GetTextBuf.BufSize">
        <short>Length of the buffer.</short>
      </element>

      <element name="TControl.GetTextLen">
        <short>The length of Text, here: of Caption.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.GetTextLen.Result">
        <short/>
      </element>

      <element name="TControl.SetTextBuf">
        <short>
          Updates the <link id="TControl.Text">Text</link> property from a PChar buffer.
        </short>
        <descr>
          <p>This method only exists for Delphi compatibility.</p>
          <p>Don't use or override it, unless really necessary.</p>
        </descr>
        <seealso>
          <link id="TControl.RealSetText"/>
        </seealso>
      </element>
      <element name="TControl.SetTextBuf.Buffer">
        <short>Pointer to the buffer containing the zero-terminated text.</short>
      </element>

      <element name="TControl.Perform">
        <short>Calls a message handler directly, bypassing the message queue.</short>
        <descr>
          <p>
            <var>Perform</var> is a method used to pass a message to the processing loop for the control.
          </p>
          <p>
            Values in the Msg, WParam, and LParam arguments are stored in a <var>TLMessage</var> instance and passed as an argument to the routine in the <var>WindowProc</var> property. The return value is the <var>LRESULT</var> returned from the WindowProc routine.
          </p>
        </descr>
        <seealso>
          <link id="TControl.WindowProc"/>
          <link id="TWndMethod"/>
          <link id="#lcl.lmessages.TLMessage">TLMessage</link>
          <link id="#lcl.lcltype.LRESULT">LRESULT</link>
        </seealso>
      </element>
      <element name="TControl.Perform.Result">
        <short>Result value from the WindowProc routine.</short>
      </element>
      <element name="TControl.Perform.Msg">
        <short>Control message constant for the message executed in the method.</short>
      </element>
      <element name="TControl.Perform.WParam">
        <short>Parameter with a handle or Integer value (not necessarily 16-bits any more).</short>
      </element>
      <element name="TControl.Perform.LParam">
        <short>Parameter with a Pointer to its value (not necessarily 32-bits any more).</short>
      </element>

      <element name="TControl.ScreenToClient">
        <short>Converts absolute screen coordinates into client-relative coordinates.</short>
        <descr>
          <p>
            The <var>APoint</var> argument contains the screen coordinates which are converted to client-relative coordinates in the method. The X member has the horizontal coordinate, and the Y member has the vertical coordinate.
          </p>
          <p>
            The return value is a <var>TPoint</var> type which contains the coordinates from APoint with the X and Y members decremented by the corresponding values found in the ClientOrigin for the control.
          </p>
          <remark>
            Accessing the ClientOrigin property raises an EInvalidOperation exception if Parent has not been assigned for the control.
          </remark>
          <p>
            ScreenToClient is used in the implementation of methods like ClientToParent, ParentToClient, and GetMousePosFromMessage. It is also used to convert mouse coordinates during drag and drop, docking, and context menu operations.
          </p>
          <p>
            Use ScreenToControl to convert absolute screen coordinate to control-relative values.
          </p>
          <p>
            Use ClientToScreen to convert client-relative coordinates to absolute screen coordinates. Use ControlToScreen to convert the coordinates in the control to absolute screen coordinates.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Parent"/>
          <link id="TControl.ClientOrigin"/>
          <link id="TControl.ScreenToControl"/>
          <link id="TControl.ClientToScreen"/>
          <link id="TControl.ControlToScreen"/>
          <link id="#rtl.types.TPoint">TPoint</link>
        </seealso>
      </element>
      <element name="TControl.ScreenToClient.Result">
        <short>TPoint instance with the client-relative coordinates for the specified screen coordinates.</short>
      </element>
      <element name="TControl.ScreenToClient.APoint">
        <short>TPoint instance with the screen coordinates converted in the method.</short>
      </element>

      <element name="TControl.ClientToScreen">
        <short>Converts client-relative coordinates to absolute screen coordinates.</short>
        <seealso>
          <link id="TControl.ScreenToClient"/>
          <link id="TControl.ClientOrigin"/>
        </seealso>
      </element>
      <element name="TControl.ClientToScreen.Result">
        <short>TPoint instance with the screen coordinates for the specified client coordinates.</short>
      </element>
      <element name="TControl.ClientToScreen.APoint">
        <short>TPoint instance with the client-relative coordinates converted in the method.</short>
      </element>

      <element name="TControl.ScreenToControl">
        <short>Converts absolute screen coordinates to control-relative coordinates.</short>
        <seealso>
          <link id="TControl.ControlOrigin"/>
          <link id="TControl.ControlToScreen"/>
          <link id="TControl.ScreenToClient"/>
          <link id="TControl.ClientToScreen"/>
        </seealso>
      </element>
      <element name="TControl.ScreenToControl.Result">
        <short/>
      </element>
      <element name="TControl.ScreenToControl.APoint">
        <short/>
      </element>

      <element name="TControl.ControlToScreen">
        <short>Converts control-relative coordinates to absolute screen coordinates.</short>
        <seealso>
          <link id="TControl.ControlOrigin"/>
          <link id="TControl.ScreenToControl"/>
          <link id="TControl.ScreenToClient"/>
          <link id="TControl.ClientToScreen"/>
        </seealso>
      </element>
      <element name="TControl.ControlToScreen.Result">
        <short/>
      </element>
      <element name="TControl.ControlToScreen.APoint">
        <short/>
      </element>

      <element name="TControl.ClientToParent">
        <short>
          Converts the specified client coordinates to the screen coordinates for the specified parent control.
        </short>
        <descr>
          <p>
            <var>ClientToParent</var> is a <var>TPoint</var> function used to convert the client-relative coordinates specified in <var>Point</var> to the screen coordinates for the parent control in <var>AParent</var>. If AParent is unassigned (<b>Nil</b>), the Parent property for the control is used in the method.
          </p>
          <p>
            ClientToParent calls the IsParentOf method in AParent to determine if the control is a child control for AParent. An EInvalidOperation exception is raised if the return value from IsParentOf is <b>False</b>.
          </p>
          <p>
            ClientToParent calls ClientToScreen to get the absolute screen  coordinates for the values in Point. The return value is the TPoint instance returned by converting the client coordinates to screen coordinates, and asking the parent control to convert the values back to client-relative  coordinates for the parent control.
          </p>
          <p>
            ClientToParent is used, for instance, in the TScrollingWinControl.ScrollInView method.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TControl.ClientToParent.Result">
        <short>
          TPoint instance with the client coordinates adjusted to the parent control.
        </short>
      </element>
      <element name="TControl.ClientToParent.Point">
        <short>TPoint instance with the client coordinates for the control.</short>
      </element>
      <element name="TControl.ClientToParent.AParent">
        <short>Parent control with the bounds for the adjusted coordinates.</short>
      </element>

      <element name="TControl.ParentToClient">
        <short>
          Converts the specified client coordinates on a parent control to the client coordinates for the control instance.
        </short>
        <descr>
          <p>
            <var>Point</var> contains the client coordinates relative the parent control <var>AParent</var>. If AParent is not assigned (<b>Nil</b>), the value in the <var>Parent</var> property is used as the value for the argument.
          </p>
          <p>
            ParentToClient calls the <var>IsParentOf</var> method in AParent to determine if the current control is hosted on AParent. An <var>EInvalidOperation</var> exception is raised if the IsParentOf method returns <b>False</b>.
          </p>
          <p>
            The return value is a <var>TPoint</var> instance with client coordinates for the control relative to the client coordinates on AParent.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TControl.ParentToClient.Result">
        <short>TPoint instance with the client coordinates relative the client origin in a parent control.</short>
      </element>
      <element name="TControl.ParentToClient.Point">
        <short>TPoint instance with the coordinates examined and adjusted in the method.</short>
      </element>
      <element name="TControl.ParentToClient.AParent">
        <short>Parent control with the origin used to adjust the client coordinates.</short>
      </element>

      <element name="TControl.GetChildrenRect">
        <short>Get the visible part of a possibly scrolled client area.</short>
        <descr>
          <p>
            If <var>Scrolled</var> is <b>False</b>, the ScrollOffset is ignored, so that the ClientRect is returned. Returns the Client rectangle relative to the left and top for the control. If Scrolled is <b>True</b>, the rectangle is moved by the current scrolling values (for an example see TScrollingWincontrol).
          </p>
        </descr>
      </element>
      <element name="TControl.GetChildrenRect.Result">
        <short>The visible part of the client area.</short>
      </element>
      <element name="TControl.GetChildrenRect.Scrolled">
        <short><b>True</b> forces scrolling taken into account.</short>
      </element>

      <element name="TControl.Show">
        <short>Makes the control visible by setting Visible to <b>True</b>.</short>
        <descr>
          <p>
            Show calls the ShowControl method in the Parent control (when assigned) to ensure that the control instance is visible on the Parent control. Show sets the value in the Visible property to <b>True</b>. The value in the Visible property is not changed at design-time or when csNoDesignVisible  has not been included in the ControlStyle property.
          </p>
          <p>
            Use the Hide method to hide the control on its Parent.
          </p>
          <p>
            Use ShowControl to display a specific sibling control on the Parent.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Visible"/>
          <link id="TControl.Hide"/>
          <link id="TWinControl.ShowControl"/>
        </seealso>
      </element>

      <element name="TControl.Update">
        <short>Redraws invalidated parts of the control immediately.</short>
        <descr>
          <p>
            <var>Update</var> calls the Update method in the Parent control to refresh the window where the control is hosted. No actions are performed in the method when Parent has not been assigned.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Parent"/>
          <link id="TWinControl.Update"/>
          <link id="TWinControl.Handle"/>
        </seealso>
      </element>

      <element name="TControl.HandleObjectShouldBeVisible">
        <short><b>True</b> if the control should be visible, unless it's being destroyed.</short>
        <descr>
          <p>
            HandleObjectShouldBeVisible is a Boolean function which indicates if the control requires a valid handle in its widgetset class instance and should be visible. The return value is set to <b>True</b> when the following conditions are satisfied:
          </p>
          <ul>
            <li>
              Neither the control nor its Handle is being destroyed.
            </li>
            <li>
              IsControlVisible returns <b>True</b> indicating the control is both Visible and not disabled on the form designer at design-time.
            </li>
            <li>
              Parent has been assigned and its HandleObjectShouldBeVisible method returns <b>True</b>.
            </li>
          </ul>
          <p>
            HandleObjectShouldBeVisible is used frequently in widgetset class methods, and indicates that actions like allocating or freeing a handle should be performed. It determined the value for the Visible property in the widget. It also indicates whether the actions in the class method can be performed, or should be ignored.
          </p>
        </descr>
        <seealso>
          <link id="TControl.IsVisible"/>
        </seealso>
      </element>
      <element name="TControl.HandleObjectShouldBeVisible.Result">
        <short/>
      </element>

      <element name="TControl.ParentDestroyingHandle">
        <short>
          Returns <b>True</b> if any parent is destroying its Handle (or handles for its children).
      </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.ParentDestroyingHandle.Result">
        <short/>
      </element>

      <element name="TControl.ParentHandlesAllocated">
        <short>
          Returns <b>True</b> if all Parents have allocated handles, and are not being destroyed.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.ParentHandlesAllocated.Result">
        <short/>
      </element>

      <element name="TControl.InitiateAction">
        <short>Update the action associated with the control through its action link.</short>
        <descr>
          <p>
            Calls the Update method in ActionLink to signal the OnUpdate event handler for the linked TBasicAction instance. No actions are performed in the method when ActionLink has not been assigned.
          </p>
        </descr>
        <seealso>
          <link id="TControl.ActionLink"/>
          <link id="#rtl.classes.TBasicActionLink.Update">TBasicActionLink.Update</link>
          <link id="#rtl.classes.TBasicAction.OnUpdate">TBasicActionLink.OnUpdate</link>
        </seealso>
      </element>

      <element name="TControl.ShowHelp">
        <short>Displays the help associated with the control.</short>
        <descr>
          <p>
            <var>ShowHelp</var> is a method used to display help for the control. Values in HelpType, HelpContext, and HelpKeyword are used to determine which method is called in the Application singleton to display the help content.
          </p>
          <dl>
            <dt>HelpType</dt>
            <dd>
              When set to htContext, the HelpContext method is called for the value in the HelpContext property.
            </dd>
            <dt>HelpKeyword</dt>
            <dd>
              A non-empty value causes the HelpKeyword method to be called using the value in the HelpKeyword property.
            </dd>
            <dt>Default Action</dt>
            <dd>
              Calls the ShowHelp method in the Parent control when none of the other conditions are satisfied.
            </dd>
          </dl>
          <p>
            ShowHelp is called from methods in the the TApplication instance. It occurs when the F1 key is pressed when the control has focus, or when its ShowHelpForObject method is called for a specific control instance.
          </p>
          <p>
            Use the HelpFile property, found on the parent form or in a TApplicationProperties instance, to set the help file with the content displayed in the method.
          </p>
        </descr>
        <seealso>
          <link id="TControl.HelpType"/>
          <link id="TControl.HelpContext"/>
          <link id="TControl.HelpKeyword"/>
          <link id="#lcl.forms.TApplication.HelpContext"/>
          <link id="#lcl.forms.TApplication.HelpKeyword"/>
          <link id="#lcl.forms.TApplication.ShowHelpForObject"/>
          <link id="#lcl.forms.TApplicationProperties.HelpFile"/>
          <link id="#lcl.forms.TCustomForm.HelpFile"/>
        </seealso>
      </element>

      <element name="TControl.HasHelp">
        <short>Indicates whether a HelpKeyword or HelpContext identifier is assigned for the control.</short>
        <descr/>
        <seealso>
          <link id="TControl.HelpType"/>
          <link id="TControl.HelpContext"/>
          <link id="TControl.HelpKeyword"/>
        </seealso>
      </element>
      <element name="TControl.HasHelp.Result">
        <short><b>True</b> when a HelpKeyword or HelpContext has been assigned.</short>
      </element>

      <element link="#lcl.lclclasses.TLCLComponent.RemoveAllHandlersOfObject" name="TControl.RemoveAllHandlersOfObject"/>
      <element name="TControl.RemoveAllHandlersOfObject.AnObject">
        <short/>
      </element>

      <element name="TControl.AddHandlerOnResize">
        <short>Adds or inserts the specified <var>OnResize</var> event handler.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.AddHandlerOnResize.OnResizeEvent">
        <short/>
      </element>
      <element name="TControl.AddHandlerOnResize.AsFirst">
        <short/>
      </element>

      <element name="TControl.RemoveHandlerOnResize">
        <short>Removes the specified <var>OnResize</var> event handler.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.RemoveHandlerOnResize.OnResizeEvent">
        <short/>
      </element>

      <element name="TControl.AddHandlerOnChangeBounds">
        <short>Adds or inserts the specified <var>OnChangeBounds</var> event handler.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.AddHandlerOnChangeBounds.OnChangeBoundsEvent">
        <short/>
      </element>
      <element name="TControl.AddHandlerOnChangeBounds.AsFirst">
        <short/>
      </element>

      <element name="TControl.RemoveHandlerOnChangeBounds">
        <short>Removes the specified <var>OnChangeBounds</var> event handler.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.RemoveHandlerOnChangeBounds.OnChangeBoundsEvent">
        <short/>
      </element>

      <element name="TControl.AddHandlerOnVisibleChanging">
        <short>Adds or inserts the specified <var>OnVisibleChanging</var> event handler.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.AddHandlerOnVisibleChanging.OnVisibleChangingEvent">
        <short/>
      </element>
      <element name="TControl.AddHandlerOnVisibleChanging.AsFirst">
        <short/>
      </element>

      <element name="TControl.RemoveHandlerOnVisibleChanging">
        <short>Removes the specified <var>OnVisibleChanging</var> event handler.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.RemoveHandlerOnVisibleChanging.OnVisibleChangingEvent">
        <short/>
      </element>

      <element name="TControl.AddHandlerOnVisibleChanged">
        <short>Adds or inserts the specified <var>OnVisibleChanged</var> event handler.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.AddHandlerOnVisibleChanged.OnVisibleChangedEvent">
        <short/>
      </element>
      <element name="TControl.AddHandlerOnVisibleChanged.AsFirst">
        <short/>
      </element>

      <element name="TControl.RemoveHandlerOnVisibleChanged">
        <short>Removes the specified <var>OnVisibleChanged</var> event handler.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.RemoveHandlerOnVisibleChanged.OnVisibleChangedEvent">
        <short/>
      </element>

      <element name="TControl.AddHandlerOnEnabledChanged">
        <short>Adds an <var>OnEnabledChanged</var> handler.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.AddHandlerOnEnabledChanged.OnEnabledChangedEvent">
        <short/>
      </element>
      <element name="TControl.AddHandlerOnEnabledChanged.AsFirst">
        <short/>
      </element>

      <element name="TControl.RemoveHandlerOnEnableChanging">
        <short>Removes the specified <var>OnEnabledChanged</var> event handler.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.RemoveHandlerOnEnableChanging.OnEnableChangingEvent">
        <short/>
      </element>

      <element name="TControl.AddHandlerOnKeyDown">
        <short>Adds the specified <var>OnKeyDown</var> event handler.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.AddHandlerOnKeyDown.OnKeyDownEvent">
        <short/>
      </element>
      <element name="TControl.AddHandlerOnKeyDown.AsFirst">
        <short/>
      </element>

      <element name="TControl.RemoveHandlerOnKeyDown">
        <short>Removes the specified <var>OnKeyDown</var> event handler.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.RemoveHandlerOnKeyDown.OnKeyDownEvent">
        <short/>
      </element>

      <element name="TControl.AddHandlerOnBeforeDestruction">
        <short>Adds or inserts the specified <var>OnBeforeDestruction</var> event handler.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.AddHandlerOnBeforeDestruction.OnBeforeDestructionEvent">
        <short/>
      </element>
      <element name="TControl.AddHandlerOnBeforeDestruction.AsFirst">
        <short/>
      </element>

      <element name="TControl.RemoveHandlerOnBeforeDestruction">
        <short>Removes the specified <var>OnBeforeDestruction</var> event handler.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.RemoveHandlerOnBeforeDestruction.OnBeforeDestructionEvent">
        <short/>
      </element>

      <element name="TControl.AddHandlerOnMouseWheel">
        <short>Adds or inserts the specified <var>OnMouseWheel</var> event handler.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.AddHandlerOnMouseWheel.OnMouseWheelEvent">
        <short/>
      </element>
      <element name="TControl.AddHandlerOnMouseWheel.AsFirst">
        <short/>
      </element>

      <element name="TControl.RemoveHandlerOnMouseWheel">
        <short>Removes the specified OnMouseWheel event handler.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.RemoveHandlerOnMouseWheel.OnMouseWheelEvent">
        <short/>
      </element>

      <element name="TControl.AccessibleName">
        <short>Contains the accessible name for the control.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.AccessibleDescription">
        <short>
        Describes the accessibility description for the control, like "a text caption", etc.
        </short>
        <descr>
          The accessible description of the control. This should describe the role of the control, for example for TLabel it could be "a text caption".
        </descr>
        <seealso>
          <link id="TLazAccessibleObject.AccessibleDescription"/>
        </seealso>
      </element>

      <element name="TControl.AccessibleValue">
        <short>
          The accessibility value for the control.
        </short>
        <descr>
          <p>
            The accessible value of the control. For example, for <var>TLabel</var> it would be the same as the <var>Caption</var> property.
          </p>
        </descr>
        <seealso>
          <link id="TLazAccessibleObject.AccessibleValue"/>
        </seealso>
      </element>

      <element name="TControl.AccessibleRole">
        <short>
          The accessibility role for the control which classifies what kind of object in the class instance.
        </short>
        <descr>
          <p>
            See TLazAccessibilityRole for a list of possible values.
          </p>
        </descr>
        <seealso>
          <link id="TLazAccessibilityRole"/>
          <link id="TLazAccessibleObject.AccessibleRole"/>
        </seealso>
      </element>

      <element name="TControl.Action">
        <short>The Action associated with the control.</short>
        <descr>
          <p>
            <var>Action</var> is a <var>TBasicAction</var> property with the action assigned to the control. The value for the property is read from the Action property in ActionLink (when assigned). If ActionLink has not been assigned, the property value is <b>Nil</b>.
          </p>
          <p>
            Assigning an action to the property causes ActionLink to be updated. If the new property value is <b>Nil</b>, the TControlActionLink instance in ActionLink is freed and control style flags are updated to remove the value csActionClient.
          </p>
          <p>
            Conversely, a TControlActionLink instance is created for a non-empty action assignment. Its OnChange event handler is set to the private DoActionChange method in the class instance. Control style flags are updated to include the value csActionClient.
          </p>
          <p>
            Action is used in the Click method to signal its OnExecute event handler when assigned and enabled. Preference is given to the OnClick in the control (when  assigned).
          </p>
          <p>
            Values in the Caption, Enabled, HelpType, and Hint properties can be linked to the Action through the property values in the ActionLink.
          </p>
          <p>
            Use AssignTo to copy property values in the control to a TCustomAction instance.
          </p>
        </descr>
        <seealso>
          <link id="TControl.ActionLink"/>
          <link id="TControl.Enabled"/>
          <link id="TControl.Hint"/>
          <link id="TControl.Click"/>
          <link id="TControl.OnClick"/>
          <link id="TControlActionLink"/>
          <link id="#rtl.classes.TBasicAction">TBasicAction</link>
        </seealso>
      </element>

      <element name="TControl.Align">
        <short>
          Specifies the placement of the control on its Parent control.
        </short>
        <descr>
          <p>
            <var>Align</var> is a <var>TAlign</var> property which specifies how the control is aligned to its parent control. The default value for the property is <var>alNone</var>.
          </p>
          <dl>
            <dt>alNone</dt>
            <dd>
              The control is not aligned. It uses it Top, Left, Height, and Width to place the control in the Parent.
            </dd>
            <dt>alTop</dt>
            <dd>
              Aligns the control to the top of the parent control, and adjusts it Width to fill the Parent control.
            </dd>
            <dt>alBottom</dt>
            <dd>
              Aligns the control to the bottom of the Parent control, and adjusts its Width  to fill the Parent control.
            </dd>
            <dt>alLeft</dt>
            <dd>
              Aligns the control to the left edge of the Parent control, and adjusts its Height to fill the Parent control.
            </dd>
            <dt>alRight</dt>
            <dd>
              Aligns the control to the right edge of the Parent control, and adjusts its Height to fill the Parent control.
            </dd>
            <dt>alClient</dt>
            <dd>
              Aligns the control to fill the unused Height and Width for the Parent control.
            </dd>
            <dt>alCustom</dt>
            <dd>
              Aligns the control by calling the OnAlignInsertBefore or OnAlignPosition event handlers in the Parent control.
            </dd>
          </dl>
        </descr>
        <seealso>
          <link id="TAlign"/>
        </seealso>
      </element>

      <element name="TControl.Anchors">
        <short>The set of anchor definitions for this control.</short>
        <descr>
          <p>
            Anchors is a TAnchors property which contains the edges used to align the position of the control relative to its Parent. Anchors allow the control to be repositioned and/or resized when the parent control is resized. Coordinate values in the control - like Left, Top, Bottom, and Right properties -  are updated when the corresponding edge is anchored to its Parent.
          </p>
          <p>
            The default value for the property is [akLeft, akTop], and indicates that only the Top and Left coordinates are anchored in the parent control.
          </p>
          <p>
            For example:
          </p>
          <dl>
            <dt>
              [akLeft, akRight]
            </dt>
            <dd>
              Causes the relative width for the control to be adjusted when the width of the parent control is changed.
            </dd>
            <dt>
              [akTop, akBottom]
            </dt>
            <dd>
              Causes the relative height for the control to be adjusted when the height of the parent control is changed.
            </dd>
            <dt>
              [akTop, akLeft, akRight]
            </dt>
            <dd>
              Causes the relative width (but not the height) for the control to be adjusted when the parent is resized. Like using the Align property.
            </dd>
            <dt>
              [akTop, akLeft, akBottom, akRight]
            </dt>
            <dd>
              Causes both the height and width to be adjusted when the parent control is resized. Like using alCustom in Align.
            </dd>
          </dl>
          <p>
            Setting a new value for the property causes the UpdateAnchorRules and AdjustSize methods to be called.
          </p>
          <p>
            Values in Anchors are used (along with Align) in the DoAutoAdjustLayout method. They control whether values in Left, Top, Bottom, and Right are calculated using the ClientWidth and ClientHeight for the Parent control. The values in Anchors also used in the HeightIsAnchored and WidthIsAnchored methods.
          </p>
          <p>
            Values in Anchors may be updated when a new value is assigned to the Align property which conflicts with the existing values in the property. They may also be updated when values are assigned to  AnchorSide which cause vertical or horizontal centering to a sibling control (AnchorVerticalCenterTo, AnchorHorizontalCenterTo) or alignment to a companion control (AnchorToCompanion).
          </p>
        </descr>
        <seealso>
          <link id="TAnchors"/>
          <link id="TAnchorKind"/>
          <link id="TControl.Align"/>
          <link id="TControl.AnchorSide"/>
          <link id="TControl.AdjustSize"/>
          <link id="TControl.DoAutoAdjustLayout"/>
          <link id="TControl.ClientHeight"/>
          <link id="TControl.ClientWidth"/>
          <link id="TControl.Parent"/>
        </seealso>
      </element>

      <element name="TControl.AnchorSide">
        <short>Array of anchor definitions, indexed by the control sides.</short>
        <descr>
          <p>
            Valid anchor definitions are flagged in <link id="TControl.Anchors">Anchors</link>.
          </p>
          <p>
            AnchorSide specifies how a side is anchored to other controls (siblings or Parent).
          </p>
          <p>
            Various AnchorAs and AnchorTo methods simplify the establishment of anchors.
          </p>
        </descr>
        <seealso>
          <link id="TAnchorSide"/>
          <link id="TControl.AnchorAsAlign"/>
          <link id="TControl.AnchorToNeighbour"/>
        </seealso>
      </element>
      <element name="TControl.AnchorSide.Kind">
        <short>The anchored side of the control.</short>
      </element>

      <element name="TControl.AutoSize">
        <short>
          Allows automatic adjustment of the size for the control, according to its content.
        </short>
        <descr>
          <p>
            The action performed depends on the concrete control type. For example, a label or button can become bigger or smaller to accommodate a longer or shorter caption.
          </p>
          <p>
            Default value for the property is <b>False</b>, and disables auto-sizing for the control instance.
          </p>
        </descr>
        <seealso>
          <link id="#lcl.controls.Autosize">Using AutoSize</link>
        </seealso>
      </element>

      <element name="TControl.BorderSpacing">
        <short>Determines the inner and outer border spacing for this control.</short>
        <descr>
          <p>
            The outer border determines the minimum distance to sibling controls. The inner border is the space between the BoundsRect and ClientRect for the control.
          </p>
          <p>
            When a control sits in a cell of a table (Grid) control, its horizontal and vertical alignment inside the cell can be specified, too.
          </p>
        </descr>
      </element>

      <element name="TControl.BoundsRect">
        <short>The Top, Left and Bottom, Right for the control, in client coordinates.</short>
        <descr>
          <p>
            The BoundsRect rectangle describes the Top, Left and Bottom, Right coordinates for the control, relative to its parent.
          </p>
          <p>
            The values are based on the Top, Left, Width and Height properties of the control.
          </p>
          <p>
            Set BoundsRect to move and/or resize the control. This can reduce flicker, occurring otherwise when Top, Width etc. are set individually.
          </p>
        </descr>
      </element>

      <element name="TControl.BoundsRectForNewParent">
        <short>
          Temporary BoundsRect, used when the control e.g. is docked into a different Parent.
        </short>
        <descr>
          <p>
            The rectangle describes the placement of the control when its Parent is changed later.
          </p>
          <p>
            Setting the rectangle also sets a flag, that indicates the values are available.
          </p>
        </descr>
      </element>

      <element name="TControl.Caption">
        <short>The text displayed for the control.</short>
        <descr>
          <p>
            Caption is a TCaption property with the text displayed for the control. By default, <var>Caption</var> has the same value as the <var>Name</var> property used for the control. An explicit value can be assigned at design-time using  the Object Inspector, or by the developer in program code.
          </p>
          <p>
            Controls normally use the Caption or Text properties (they are equivalent in TControl) to read or write their textual value. The property value is retrieved using either the RealGetText method, or the GetTextBuf method when it has been overridden in a descendent class. Conversely, the property value is stored using either RealSetText, or an overridden SetTextBuf method in a descendent class.
          </p>
          <p>
            When the value in Caption is changed, a CM_TEXTCHANGED message is performed for the control. Changing the value for the property causes the caption for the HostDockSite to be updated (when assigned).
          </p>
          <p>
            Caption can be used to display an accelerator (or shortcut) key which allows the control (or an associate) to be given focus or executed. The shortcut key is identified by placing an Ampersand (&amp;) character in front of the character used as the accelerator key. Use two Ampersand characters to display a single Ampersand which is not a shortcut key. For example:
          </p>
<code>
{
  var
    ALabel: TLabel;
    Form1: TForm;
    Memo1: TMemo;
    ...
}
ALabel := TLabel.Create(Form1);
ALabel.ShowAccelerator := True;
ALabel.FocusControl := Memo1;
ALabel.Caption := '&amp;Notes &amp;&amp; Comments';
</code>
          <p>
            Displays the 'N' character with an underline indicating the accelerator key. Pressing Alt+N activates the shortcut key and causes the associated TMemo control to be given focus.
          </p>
          <p>
            Set values in Font to specify the typeface, size, color, and style used to display the Caption text.
          </p>
        </descr>
        <seealso>
          <link id="TControl.RealGetText"/>
          <link id="TControl.RealSetText"/>
          <link id="TControl.GetTextBuf"/>
          <link id="TControl.SetTextBuf"/>
          <link id="TControl.Text"/>
          <link id="TControl.Font"/>
        </seealso>
      </element>

      <element name="TControl.CaptureMouseButtons">
        <short>
          Indicates the mouse button(s) which are captured for the control.
        </short>
        <descr>
          <p>
            CaptureMouseButtons is a TCaptureMouseButtons property with the set of mouse buttons which capture events for the control. It contains zero or more values from the TMouseButton enumeration. Up, down, click, double click, triple click, and quad click messages are handled for a mouse button when its value is included in the property.
          </p>
          <p>
            The default value for the property is <b>[mbLeft]</b> and causes events to be handled for the Left mouse button.
          </p>
          <p>
            Mouse capture is enabled for the button(s) when csCaptureMouse is included in the ControlStyle property.
          </p>
          <p>
            ControlStyle and CaptureMouseButtons are used in message handlers which respond to mouse events, like: WMLButtonDDown, WMLButtonUp, WMLButtonDblClk, WMLButtonTripleClk, WMLButtonQuadClk, et. al.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TControl.ClientHeight">
        <short>The height for the client area on the control.</short>
        <descr>
          <p>
            <var>ClientHeight</var> is an <var>Integer</var> property with the number of pixels needed for client area on the control. The property contains the value from the Bottom member in ClientRect. Changing the value for ClientHeight causes SetClientSize to be called to apply the existing ClientWidth and the new value for the property.
          </p>
          <p>
            The value for ClientHeight is not stored or used to set the Height for the control during LCL component streaming. It is used, however, when AutoSizing is restored and when auto-layout policies using Anchors are applied to the control. For example, when Anchors is set to [akBottom] the value in ClientHeight is needed / used.
          </p>
        </descr>
        <seealso>
          <link id="TControl.ClientRect"/>
          <link id="TControl.ClientWidth"/>
          <link id="TControl.AutoSizing"/>
          <link id="TControl.EnableAutoSizing"/>
          <link id="TControl.AutoAdjustLayout"/>
          <link id="TControl.Resize"/>
          <link id="TControl.Anchors"/>
        </seealso>
      </element>

      <element name="TControl.ClientOrigin">
        <short>
          Screen coordinates of the Top, Left pixel (in the client area) of the control.
        </short>
        <descr>
          <p>
            Only <var>TWinControl</var> has a client area. For other controls, ClientOrigin is the same as <var>ControlOrigin</var>. Uses the corresponding property in the <var>Parent</var> control to get the property value, and includes the values in <var>Left</var> and <var>Top</var> to get the effective  origin for the control.
          </p>
          <p>
            An <var>EInvalidOperation</var> exception is raised if Parent has not been assigned when reading the value for the property.
          </p>
          <p>
            Note that this value is the position as stored in the object, not always in sync with the widget.
          </p>
        </descr>
        <errors>
          Raises an EInvalidOperation exception with the message in sParentRequired if Parent has not been assigned when reading the value for the property.
        </errors>
        <seealso>
          <link id="TControl.Parent"/>
          <link id="TControl.Left"/>
          <link id="TControl.Top"/>
          <link id="TControl.ControlOrigin"/>
          <link id="TControl.GetClientOrigin"/>
        </seealso>
      </element>

      <element name="TControl.ClientRect">
        <short>Size of the client area for the control.</short>
        <descr>
          <p>
            Contains  the size for the visual client area in the control. For example, the inner size of a TGroupBox. For a TScrollBox it is the visual size, and not the logical size.
          </p>
          <p>
            The property value is a TRect instance with the Top and Left members set to 0, and the Height and Width members set to the corresponding property values for the control.
          </p>
        </descr>
        <seealso>
          <link id="TControl.GetClientRect"/>
          <link id="TControl.GetLogicalClientRect"/>
          <link id="#rtl.classes.TRect">TRect</link>
        </seealso>
      </element>

      <element name="TControl.ClientWidth">
        <short>The width of the client area for the control.</short>
        <descr>
          <p>
            <var>ClientWidth</var> is an <var>Integer</var> property with the number of pixels need for the width of the client area on the control. The property contains the value from the Right member in ClientRect. Changing the value for ClientWidth causes SetClientSize to be called to apply the new property value and the existing ClientHeight for the control.
          </p>
          <p>
            The value for ClientWidth is not stored or used to set the Width for the control during LCL component streaming. It is used, however, when AutoSizing is restored and when auto-layout policies using Anchors are applied to the control. For example, when Anchors is set to [akRight] the value in ClientWidth is needed / used.
          </p>
        </descr>
        <seealso>
          <link id="TControl.ClientRect"/>
          <link id="TControl.ClientHeight"/>
          <link id="TControl.AutoSizing"/>
          <link id="TControl.EnableAutoSizing"/>
          <link id="TControl.AutoAdjustLayout"/>
          <link id="TControl.Resize"/>
          <link id="TControl.Anchors"/>
        </seealso>
      </element>

      <element name="TControl.Color">
        <short>The background color of the control.</short>
        <descr>
          <p>
            The default value in <var>Color</var> is the same as the value in the parent window <var>Color</var>. If the color is <var>clDefault</var>,  the result will need to be passed through <var>GetDefaultColor</var> to resolve <var>clDefault</var>. Convenience routines which obtain the color by resolving <var>clDefault</var> and <var>ParentColor</var> are also provided as <var>TControl.GetColorResolvingParent</var> and <var>TControl.GetRGBColorResolvingParent</var>.
          </p>
        </descr>
        <seealso>
          <link id="TControl.ParentColor"/>
          <link id="TControl.GetDefaultColor"/>
          <link id="TControl.GetColorResolvingParent"/>
          <link id="TControl.GetRGBColorResolvingParent"/>
          <link id="#lcl.graphics.TColor">TColor</link>
        </seealso>
      </element>

      <element name="TControl.Constraints">
        <short>Contains the minimum and maximum Width and Height for the control.</short>
        <descr>
          <p>
            <var>Constraints</var> is a <var>TSizeConstraints</var> property with the sizing constraints used for the control. Constraints contains properties like MinHeight, MaxHeight, MinWidth, and MaxWidth. They are applied (when assigned) to the corresponding control properties when its bounds or preferred size is changed, and during scaling operations.
          </p>
        </descr>
        <seealso>
          <link id="TControl.ChangeScale"/>
          <link id="TControl.ChangeBounds"/>
          <link id="TControl.GetPreferredSize"/>
          <link id="TSizeConstraints"/>
        </seealso>
      </element>

      <element name="TControl.ControlOrigin">
        <short>The top, left pixel of the control in screen coordinates.</short>
        <descr/>
        <seealso>
          <link id="TControl.ClientOrigin"/>
          <link id="TControl.BoundsRect"/>
        </seealso>
      </element>

      <element name="TControl.ControlState">
        <short>
          Contains state flags which indicate whether the control has been clicked, data is being read, or the control is being re-drawn, etc.
        </short>
        <descr>
          <p>
            <var>ControlState</var> is a <var>TControlState</var> property which contains flags that indicate when actions are detected or handled for the control. It is a set type which contains zero or more values from the TControlStateType enumeration.
          </p>
          <p>
            Values are added to the property when an event is detected. Values are removed from the property in methods which handle the event by performing some action on the control.
          </p>
          <p>
            For more information about the values in the enumeration and their uses and meanings, please refer to <link id="TControlStateType">TControlStateType</link>.
          </p>
        </descr>
        <seealso>
          <link id="TControl.ReadState"/>
          <link id="TControl.Dock"/>
          <link id="TControl.WMLButtonDown"/>
          <link id="TControl.WMLButtonUp"/>
          <link id="TControl.WndProc"/>
          <link id="TControlState"/>
          <link id="TControlStateType"/>
        </seealso>
      </element>

      <element name="TControl.ControlStyle">
        <short>
          Contains style flags which control the features or behaviors enabled for the control.
        </short>
        <descr>
          <p>
            <var>ControlStyle</var> is a <var>TControlStyle</var> property used to enable features or behaviors for a control. Values from the <var>TControlStyleType</var> enumeration are added to the property to enable the corresponding feature supported in the control.
          </p>
          <p>
            Values in ControlStyle are normally assigned in the constructor for a given control class.
          </p>
          <p>
            Some controls implement properties which cause the values in the set to be changed when a new value is assigned to the property. For example, TToolBar.Transparent includes or excludes csOpaque in ControlStyle as needed to reflect the value for the property. Values in the property may also be read and/or updated when methods in the control are called.
          </p>
          <p>
            The visibility for the ControlStyle property is public, so it does not appear in the Lazarus Object Inspector. But it can be updated in program code as needed.
          </p>
          <p>
            See TControlStyleType for more information about values in the enumeration and their intended usage.
          </p>
        </descr>
        <seealso>
          <link id="TControlStyleType"/>
          <link id="TControlStyle"/>
        </seealso>
      </element>

      <element name="TControl.Enabled">
        <short>Determines whether the control reacts on mouse or keyboard input.</short>
        <descr>
          <p>
            <var>Enabled</var> is a <var>Boolean</var> property which indicates whether the control can respond to focus, input, or mouse events. The default value for the property is <b>True</b>. When Enabled is set to <b>False</b>, the control is displayed with a "grayed-out" appearance. It is unable to receive input focus, handle keyboard navigation or input, respond to mouse click events, or execute its Action.
          </p>
          <p>
            Changing the value for the property causes additional actions to be performed. EnabledChanging is called to signal any chtOnEnabledChanging control handlers assigned for the control. The property value is updated, and a CM_ENABLEDCHANGED control message is dispatched for the control. The EnabledChanged method is called to signal any chtOnEnabledChanged control handlers for the control.
          </p>
          <p>
            Use IsEnabled to check the effective enabled state for both the control and its Parent control (when assigned).
          </p>
        </descr>
        <seealso>
          <link id="TControl.EnabledChanging"/>
          <link id="TControl.EnabledChanged"/>
          <link id="TControl.DoCallNotifyHandler"/>
          <link id="TControl.IsEnabled"/>
        </seealso>
      </element>

      <element name="TControl.Font">
        <short>The <link id="#lcl.graphics.TFont">font</link> to be used for text display in this control.</short>
        <descr>
          <p>
            <var>Font</var> is a <var>TFont</var> property with the typeface and display attributes used for  textual values on the control. Use properties in the TFont instance to change attributes like Name (for the typeface), Charset, Color, Height, Orientation (rotation degrees), Pitch, Quality, Size, and Style. Assigning a new TFont instance to the property causes the control to be redrawn.
          </p>
          <remark>
            Some Font attributes may be ignored in TControl descendants. It depends on the drawing style for the specific control, and whether theme services are enabled for text on the control.
          </remark>
          <p>
            The PixelsPerInch property in Font is used to perform font size scaling in methods like Scale96ToFont,  ScaleFontTo96, ScaleScreenToFont, and ScaleFontToScreen.
          </p>
        </descr>
        <seealso>
          <link id="#lcl.graphics.TFont">TFont</link>
        </seealso>
      </element>

      <element name="TControl.IsControl">
        <short>Not used in the current LCL implementation.</short>
        <descr>
          <p>
            IsControl is provided for Delphi code compatibility. It is not used in the current LCL implementation.
          </p>
        </descr>
      </element>

      <element name="TControl.MouseEntered">
        <short><b>True</b> when the mouse has entered the control. (Deprecated)</short>
        <descr>
          Deprecated. Use MouseInClient instead.
        </descr>
        <seealso>
          <link id="TControl.MouseInClient"/>
        </seealso>
      </element>

      <element name="TControl.MouseInClient">
        <short><b>True</b> when the mouse is in the client area for the control.</short>
        <descr>
          <p>
            <var>MouseInClient</var> is a read-only <var>Boolean</var> property which indicates if the mouse pointer has entered the client area for the control. The value for the property is updated when CM_MOUSEENTER or CM_MOUSELEAVE messages are handled for the control. The property value is set to <b>True</b> in CMMouseEnter, and set to <b>False</b> in CMMouseLeave.
          </p>
          <p>
            Use the OnMouseEnter or OnMouseLeave event handlers to perform actions needed when the mouse control messages are handled for the control.
          </p>
        </descr>
        <seealso>
          <link id="TControl.ClientRect"/>
          <link id="TControl.CMMouseEnter"/>
          <link id="TControl.CMMouseLeave"/>
          <link id="TControl.MouseEnter"/>
          <link id="TControl.OnMouseEnter"/>
          <link id="TControl.MouseLeave"/>
          <link id="TControl.OnMouseLeave"/>
        </seealso>
      </element>

      <element name="TControl.OnChangeBounds">
        <short>Event handler signalled when the Bounds of the control have been changed.</short>
        <descr>
          <p>
            <var>OnChangeBounds</var> is signalled from the DoOnChangeBounds method (when assigned). It occurs after the internal control flags have been updated to excelude cfOnChangeBoundsNeeded, and before DoCallNotifyHandler is called to notify handlers for the chtOnChangeBounds type.
          </p>
        </descr>
        <seealso>
          <link id="TControl.ChangeBounds"/>
          <link id="TControl.CheckOnChangeBounds"/>
          <link id="TControl.DoOnChangeBounds"/>
          <link id="TControl.DoCallNotifyHandler"/>
          <link id="#rtl.classes.TNotifyEvent">TNotifyEvent</link>
        </seealso>
      </element>

      <element name="TControl.OnClick">
        <short>Notification handler for mouse clicks.</short>
        <descr>
          <p>
            A mouse click is associated with the default action for a control, and is often the only event handled in user code.
          </p>
          <p>
            The action performed for a click can be specified by a user supplied method, or by selecting an <var>Action</var> from a supplied <var>ActionList</var>.
          </p>
          <p>
            OnClick is signalled (when assigned) from the Click method. It occurs when an Action has not been assigned using the ActionLink for the control. When Action is assigned, the Execute method in  the ActionLink is called.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Action"/>
          <link id="TControl.ActionLink"/>
          <link id="#rtl.classes.TBasicAction">TBasicAction</link>
          <link id="#rtl.classes.TNotifyEvent">TNotifyEvent</link>
        </seealso>
      </element>

      <element name="TControl.OnResize">
        <short>Notification handler for a resize of the control.</short>
        <descr>
          <p>
            This event is triggered after the Width, Height, ClientWidth or ClientHeight of the control has changed, and before the LCL sends the new size to the widgetset. The size of the underlying widget (e.g. unit LCLIntf function GetWindowSize and GetClientRect) may differ from the control's Width/Height/ClientRect during OnResize. During auto-size the size can change multiple times, but only the last change triggers the OnResize.
          </p>
          <p>
            Use OnResize to react on size changes. To also react on moves, use the OnChangeBounds event.
          </p>
          <p>
            If you want to customize the resize behavior, use OnConstrainedResize instead.
          </p>
          <p>
            Common mistake: Keep in mind that ClientWidth and ClientHeight can change even when Width and Height stay the same. For example when the theme changes, the Width and Height remain the same, but the changed frame reduces the ClientWidth and ClientHeight. This does not happen that often under Windows, but it happens quite often on other platforms.
          </p>
          <p>
            Especially it is not sufficient to write only a TForm.OnResize handler to resize all controls on the form. This is a common bug in Delphi applications.
          </p>
        </descr>
        <seealso>
          <link id="TControl.OnConstrainedResize"/>
          <link id="#rtl.classes.TNotifyEvent">TNotifyEvent</link>
        </seealso>
      </element>

      <element name="TControl.OnShowHint">
        <short>Event handler signalled when a hint window is displayed for the control.</short>
        <descr>
          <p>
            OnShowHint is a TControlShowHintEvent property with the event handler signalled when a hint window is displayed for the control. Arguments to the event handler include the control instance for the event notification, and a pointer to the structure with the Hint details for the control.
          </p>
          <p>
            OnShowHint has public visibility in TControl, but may be redeclared in descendent classes to make it visible in the object inspector. An application must implement and assign a handler routine to respond to the event notification.
          </p>
          <p>
            OnShowHint is signalled from the DoOnShowHint method (when assigned), and occurs when the CM_HINTSHOW control message is handled for the control.
          </p>
          <p>
            Set ShowHint to <b>True</b> to enable hint window display using the value(s) in the Hint property.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Hint"/>
          <link id="TControl.ShowHint"/>
          <link id="TControl.DoOnShowHint"/>
          <link id="TControlShowHintEvent"/>
          <link id="THintInfo"/>
          <link id="PHintInfo"/>
        </seealso>
      </element>

      <element name="TControl.Parent">
        <short>The control within which the control is shown.</short>
        <descr>
          <p>When the Parent moves or hides, all its children move or hide together with it.</p>
          <p>Every TControl must have a Parent, else it is never shown.</p>
          <p>The Parent of a floating form is Nil.</p>
          <p>Set the parent last to reduce updates. For example: </p>
<code>
  Button1 := TButton.Create(Self);
  Button1.Name := 'Button1';
  Button1.Caption := 'Click me'; // parent is not set, so it does not update the whole form
  Button1.Parent := Form1; // set parent as last, the LCL now applies all properties
</code>
          <p>
            Delphi/VCL: Parent must be set first under Delphi, because many properties work differently if they are set before or after Handle creation. The LCL applies the properties when the Handle is created.
          </p>
        </descr>
      </element>

      <element name="TControl.PopupMenu">
        <short>
          A context-sensitive menu that pops up when the right mouse button is clicked over this control.
        </short>
        <descr/>
        <seealso>
          <link id="TControl.OnContextPopup"/>
          <link id="TContextPopupEvent"/>
          <link id="#lcl.menus.TPopupMenu">TPopupMenu</link>
        </seealso>
      </element>

      <element name="TControl.ShowHint">
        <short>Enables Hint display for the control.</short>
        <descr>
          <p>
            <var>ShowHint</var> is a <var>Boolean</var> property used to enable or disable display of pop-up Hint text for the control. When set to <b>True</b>, the Hint text is shown when the mouse is hovered over the control. The default value for the property is <b>False</b> and disables Hint text in a pop-up window.
          </p>
          <p>
            Changing the value in ShowHint causes the ParentShowHint property to be set to <b>False</b>. A CM_SHOWHINTCHANGED is performed to apply the new value for the property.
          </p>
          <p>
            Use the Hint property to set the text displayed in the pop-up hint window when ShowHint is enabled. Use the OnShowHint event handler to provide custom text uses in the Hint display.
          </p>
          <p>
            Use the ShowHint property in a TForm instance to enable or disable pop-up hint display for all controls on a given form. Use the ShowHint property in TApplication to enable or disable pop-up hint display for all forms and controls in an application.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Hint"/>
          <link id="TControl.OnShowHint"/>
          <link id="TControl.ParentShowHint"/>
          <link id="#lcl.forms.TForm.ShowHint">TForm.ShowHint</link>
          <link id="#lcl.forms.TApplication.ShowHint">TApplication.ShowHint</link>
        </seealso>
      </element>

      <element name="TControl.Visible">
        <short>Allows the control, and all of its children, to be displayed or hidden.</short>
        <descr>
          <p>
            Visible is set to <b>True</b> by <var>Show</var>, or to <b>False</b> by <var>Hide</var>. Calling these methods is equivalent to setting the Visible property.
          </p>
          <remark>
            Reading the Visible property does not take into account control's parent visibility. Use the IsVisible method to get the real visibility.
          </remark>
        </descr>
        <seealso>
          <link id="TControl.IsVisible"/>
          <link id="TControl.Show"/>
          <link id="TControl.Hide"/>
        </seealso>
      </element>

      <element name="TControl.WndProc">
        <short>The general message handler for this control.</short>
        <descr>
          <p>
            Preprocesses several messages, then calls Dispatch to invoke the applicable message handler.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TControl.WndProc.TheMessage">
        <short>The message to handle.</short>
      </element>

      <element name="TControl.WindowProc">
        <short>The handler for all messages.</short>
        <descr>
          <p>
            WindowProc is set to <link id="TControl.WndProc"/> by default.
          </p>
          <p>
            When you ever change WindowProc, then remember the previous setting and delegate all unhandled messages to that method.
          </p>
        </descr>
        <seealso>
          <link id="TWndMethod"/>
          <link id="#lcl.lmessages.TLMessage">TLMessage</link>
          <link id="TControl.Perform"/>
        </seealso>
      </element>

      <element name="TControl.DockOrientation">
        <short>
          How the control is currently docked. (horizontally, vertically, in a notebook, or not at all).
        </short>
        <descr>
          <p>
            The property value is assigned when the control is inserted into a docking tree during a drag and dock operation. Its value is used when CalculateDockSizes is called to adjust the height or width for the host dock site.
          </p>
        </descr>
        <seealso>
          <link id="TControl.CalculateDockSizes"/>
          <link id="#lcl.ldocktree.TLazDockTree.InsertControl"/>
        </seealso>
      </element>

      <element name="TControl.Floating">
        <short>Determines whether the control is floating (not part of a form).</short>
        <descr/>
        <seealso>
          <link id="TControl.FloatingDockSiteClass"/>
        </seealso>
      </element>

      <element name="TControl.FloatingDockSiteClass">
        <short>The class for a floating host dock site for this control.</short>
        <descr/>
        <seealso>
          <link id="TControl.Floating"/>
        </seealso>
      </element>

      <element name="TControl.HostDockSite">
        <short>
          The host site (TWinControl) into which this control is docked. <b>Nil</b> if not docked.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.LRDockWidth">
        <short>The Width when last docked, with siblings to the left or right.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.TBDockHeight">
        <short>The Height when last docked, with siblings above or below.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.UndockHeight">
        <short>Height for the control when undocked.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.UndockWidth">
        <short>Width for the control when undocked.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControl.UseRightToLeftAlignment">
        <short><b>True</b> when BiDiMode is bdRightToLeft.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.UseRightToLeftAlignment.Result">
        <short/>
      </element>

      <element name="TControl.UseRightToLeftReading">
        <short><b>True</b> when BiDiMode is not bdLeftToRight.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.UseRightToLeftReading.Result">
        <short/>
      </element>

      <element name="TControl.UseRightToLeftScrollBar">
        <short><b>True</b> when scrollbars appear at the left side of the control.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.UseRightToLeftScrollBar.Result">
        <short/>
      </element>

      <element name="TControl.IsRightToLeft">
        <short><b>True</b> when BiDiMode is not bdLeftToRight.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControl.IsRightToLeft.Result">
        <short/>
      </element>

      <element name="TControl.BiDiMode">
        <short>Customization (of text controls) in bidirectional reading environments.
        </short>
        <descr>
          <p>
            In "normal" reading mode (left-to-right, LTR) text entry starts at the left, text is almost left justified, and vertical scrollbars sit at the right side of the control.
          </p>
          <p>
            In right-to-left mode text entry starts at the right, text is almost right justified, and vertical scrollbars sit at the left side of the control.
          </p>
          <p>
            In a bidirectional environment these different placements and adjustments can be configured (swapped) in various (but not all) ways.
          </p>
          <p>
            (Allows RTL languages such as Arabic and Hebrew to be used)
          </p>
          <p>
            Wild guess: The default mode is established by the platform, RTL reading is not supported on all (Windows) platforms.
          </p>
        </descr>
        <seealso>
          <link id="TControl.UseRightToLeftAlignment"/>
          <link id="TControl.UseRightToLeftReading"/>
          <link id="TControl.UseRightToLeftScrollBar"/>
          <link id="TControl.IsRightToLeft"/>
        </seealso>
      </element>

      <element name="TControl.ParentBiDiMode">
        <short>
          Indicates whether the BiDiMode settings in the Parent control are used.
        </short>
        <descr>
          <p>
            When set to <b>True</b>, the BidiMode property from the Parent control is copied into the BiDiMode property for the control. The default value for ParentBiDiMode is <b>True</b>.
          </p>
          <p>
            Changing the value for the property causes a CM_PARENTBIDIMODECHANGED message to be performed to update the control.
          </p>
          <p>
            See BiDiMode or UseRightToLeftAlignment for more information about the use of bidrectional text on the control.
          </p>
        </descr>
        <seealso>
          <link id="TControl.BiDiMode"/>
        </seealso>
      </element>

      <element name="TControl.AnchorSideLeft">
        <short>
          Contains anchor aligment information used to position the control with its left edge  anchored to another control.
        </short>
        <descr>
          <p>
            AnchorSideLeft is a TAnchorSide property with information about the side, type, alignment, and control used to anchor align the class instance. AnchorSideLeft provides access to the array element in AnchorSide stored at the position in akLeft.
          </p>
        </descr>
        <seealso>
          <link id="TControl.AnchorSide"/>
          <link id="TControl.AnchorSideRight"/>
          <link id="TControl.AnchorSideTop"/>
          <link id="TControl.AnchorSideBottom"/>
          <link id="TAnchorKind"/>
        </seealso>
      </element>

      <element name="TControl.AnchorSideTop">
        <short>
          Contains anchor aligment information used to position the control with its top edge  anchored to another control.
        </short>
        <descr>
          <p>
            AnchorSideTop is a TAnchorSide property with information about the side, type, alignment, and control used to anchor align the class instance. AnchorSideTop  provides access to the array element in AnchorSide stored at the position in akTop.
          </p>
        </descr>
        <seealso>
          <link id="TControl.AnchorSide"/>
          <link id="TControl.AnchorSideLeft"/>
          <link id="TControl.AnchorSideRight"/>
          <link id="TControl.AnchorSideBottom"/>
          <link id="TAnchorKind"/>
        </seealso>
      </element>

      <element name="TControl.AnchorSideRight">
        <short>
          Contains anchor aligment information used to position the control with its right  edge anchored to another control.
        </short>
        <descr>
          <p>
            AnchorSideRight is a TAnchorSide property with information about the side, type, alignment, and control used to anchor align the class instance. AnchorSideRight  provides access to the array element in AnchorSide stored at the position in akRight.
          </p>
        </descr>
        <seealso>
          <link id="TControl.AnchorSide"/>
          <link id="TControl.AnchorSideLeft"/>
          <link id="TControl.AnchorSideTop"/>
          <link id="TControl.AnchorSideBottom"/>
          <link id="TAnchorKind"/>
        </seealso>
      </element>

      <element name="TControl.AnchorSideBottom">
        <short>
          Contains anchor aligment information used to position the control with its bottom  edge anchored to another control.
        </short>
        <descr>
          <p>
            AnchorSideTop is a TAnchorSide property with information about the side, type, alignment, and control used to anchor align the class instance. AnchorSideTop  provides access to the array element in AnchorSide stored at the position in akTop.
          </p>
        </descr>
        <seealso>
          <link id="TControl.AnchorSide"/>
          <link id="TControl.AnchorSideLeft"/>
          <link id="TControl.AnchorSideRight"/>
          <link id="TControl.AnchorSideTop"/>
          <link id="TAnchorKind"/>
        </seealso>
      </element>

      <element name="TControl.Cursor">
        <short>Contains the shape for the mouse pointer when the mouse is over the control.</short>
        <descr>
          <p>
            <var>Cursor</var> is a <var>TCursor</var> property with the cursor shape displayed when the mouse pointer is hovered over the control. The default value for the property is crDefault.
          </p>
          <p>
            Changing the value for the property causes a CM_CURSORCHANGED message to be performed to update the control. The value is applied ar run-time when the CMCursorChanged method handles the control message.
          </p>
          <p>
            Use SetTempCursor to display a temporary cursor shape when an action is in progress for the control.
          </p>
        </descr>
        <seealso>
          <link id="TControl.SetTempCursor"/>
          <link id="TControl.DragCursor"/>
          <link id="#lcl.forms.TScreen.Cursors">TScreen.Cursors</link>
          <link id="#lcl.forms.TScreen.RealCursor">TScreen.RealCursor</link>
        </seealso>
      </element>

      <element name="TControl.Left">
        <short>The client coordinate with the left edge for the control.</short>
        <descr>
          <p>
            <var>Left</var> is an <var>Integer</var> property with the coordinate for the left edge of the control relative to its Parent. Changing the value for the property causes SetBounds to be called to apply the new value for the property along with the existing values in Top, Width, and Height.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Height"/>
          <link id="TControl.Top"/>
          <link id="TControl.Width"/>
          <link id="TControl.Parent"/>
          <link id="TControl.SetBounds"/>
          <link id="TControl.ChangeBounds"/>
        </seealso>
      </element>

      <element name="TControl.Height">
        <short>The vertical size for the control.</short>
        <descr>
          <p>
            Height is an Integer property with the vertical size for the control in pixels.
          </p>
          <p>
            Setting a negative value in Height is not allowed, and the property defaults to <b>0</b> (zero). At design-time, setting Height to a value not in the range 0..9999 causes an ELayoutException to be raised (and handled in the IDE).
          </p>
          <p>
            Setting a new value for the property causes SetBounds and ChangeBounds to be called. This ensures that the new value is is the range allowed in Constraints, and that the control is aligned on its Parent using the Anchors for the control.
          </p>
          <p>
            A value assigned to Height is ignored when AutoSize is set to <b>True</b>; the control is automatically adjusted to the size needed for its aligned content.
          </p>
          <p>
            Values in Top, Left, Width, and Height are used to calculate the display area for the control in GetClientRect. They determine the clipping rectangle used when the control is drawn on its Parent.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Left"/>
          <link id="TControl.Top"/>
          <link id="TControl.Width"/>
          <link id="TControl.Parent"/>
          <link id="TControl.GetClientRect"/>
          <link id="TControl.SetBounds"/>
          <link id="TControl.ChangeBounds"/>
        </seealso>
      </element>

      <element name="TControl.Hint">
        <short>The text to show in the Hint window for the control.</short>
        <descr>
          <p>
            Hint is a TTranslateString property with hint text displayed in a pop-up window when the mouse is hovered over the control. The pop-up window is displayed when the  ShowHint property is set to <b>True</b>.
          </p>
          <p>
            Assign a value to Hint to describe the usage or formatting conventions used for the value entered in the control. For example:
          </p>
          <code>Edit1.Hint := 'Start Date in MM/DD/YYYY format';</code>
          <p>
            Hint can be given a value that includes both short and long variants of the hint text. The values are separated by a '|' (Vertical Bar) character in the property. For example:
          </p>
          <code>Edit1.Hint := 'Start Date | Start Date in MM/DD/YYYY format';</code>
          <p>
            The short variant is used in the pop-up hint window for the control. The long variant is assigned to the Application.Hint property, or displayed on a form status bar when its AutoHint property is set to <b>True</b>.
          </p>
          <p>
            As a TTranslateString type, Hint can be localized using the translation facilities built into the LCL and the Lazarus IDE. The property value is written using LCL component streaming when the hint text for the control is not linked to an assigned Action.
          </p>
          <remark>
            Hint is not the same value as the placeholder introduced as the TextHint property in descendent controls.
          </remark>
        </descr>
        <seealso>
          <link id="TControl.ShowHint"/>
          <link id="TControl.ParentShowHint"/>
          <link id="TControl.ActionLink"/>
          <link id="TControlActionLink.IsHintLinked"/>
        </seealso>
      </element>

      <element name="TControl.Top">
        <short>The client coordinate for the top edge of the control.</short>
        <descr>
          <p>
            <var>Top</var> is an <var>Integer</var> property with the coordinate for the top edge of the control relative to its Parent. Changing the value for the property causes SetBounds to be called to apply the new value for the property along with the existing values in Left, Width, and Height.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Height"/>
          <link id="TControl.Left"/>
          <link id="TControl.Width"/>
          <link id="TControl.Parent"/>
          <link id="TControl.SetBounds"/>
          <link id="TControl.ChangeBounds"/>
        </seealso>
      </element>

      <element name="TControl.Width">
        <short>The horizontal size for the control.</short>
        <descr>
          <p>
            <var>Width</var> is an <var>Integer</var> property with the horizontal size for the control in pixels.
          </p>
          <p>
            Setting a negative value in Width is not allowed, and the property defaults to <b>0</b> (zero). At design-time, setting Width to a value not in the range 0..9999 causes an ELayoutException to be raised (and handled in the IDE).
          </p>
          <p>
            Setting a new value for the property causes SetBounds and ChangeBounds to be called. This ensures that the new value is is the range allowed in Constraints, and that the control is aligned on its Parent using the Anchors for the control.
          </p>
          <p>
            A value assigned to Width is ignored when AutoSize is set to <b>True</b>; the control is automatically adjusted to the size needed for its aligned content.
          </p>
          <p>
            Values in Top, Left, Width, and Height are used to calculate the display area for the control in GetClientRect. They determine the clipping rectangle used when the control is drawn on its Parent.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Height"/>
          <link id="TControl.Left"/>
          <link id="TControl.Top"/>
          <link id="TControl.Parent"/>
          <link id="TControl.GetClientRect"/>
          <link id="TControl.SetBounds"/>
          <link id="TControl.ChangeBounds"/>
        </seealso>
      </element>

      <element name="TControl.HelpType">
        <short>Indicates whether context-sensitive Help is selected by numeric ID or keyword.</short>
        <descr>
          <p>
            <var>HelpType</var> is a <var>THelpType</var> property which indicates the mechanism used to locate and display a help topic for the control.
          </p>
          <dl>
            <dt>htKeyword</dt>
            <dd>
              Uses the value in HelpKeyword to locate help content for the control.
            </dd>
            <dt>htContext</dt>
            <dd>
              Uses the numeric identifier in the HelpContext property to locate help content for the control.
            </dd>
          </dl>
          <p>
            The default value for the property is htContext.
          </p>
          <p>
            The value in HelpType is updated when an explicit value is assigned to the HelpKeyword or HelpContext properties.
          </p>
          <p>
            HelpType is used in the ShowHelp method to select the TApplication method called to display the help content. When set to htContext, the HelpContext method in Application is called. When set to htKeyword, the HelpKeyword method in Application is called. If the help request cannot be handled using the values assigned to the control, the ShowHelp method in Parent is called (when assigned).
          </p>
        </descr>
        <seealso>
          <link id="TControl.HelpContext"/>
          <link id="TControl.HelpKeyword"/>
          <link id="#lcl.forms.TApplication.HelpContext">TApplication.HelpContext</link>
          <link id="#lcl.forms.TApplication.HelpKeyword">TApplication.HelpKeyword</link>
          <link id="#lcl.forms.TApplicationProperties.HelpFile">TApplicationProperties.HelpFile</link>
          <link id="#lcl.forms.TCustomForm.HelpFile">TCustomForm.HelpFile</link>
          <link id="#rtl.classes.THelpType">THelpType</link>
        </seealso>
      </element>

      <element name="TControl.HelpKeyword">
        <short>The context-sensitive Help keyword for the control.</short>
        <descr>
          <p>
            <var>HelpKeyword</var> is a <var>String</var> type with the context-sensitive keyword used to locate and display a help topic for the control. When an value is assigned to the property, the HelpType property is set to htKeyword.
          </p>
          <p>
            HelpKeyword is used in the ShowHelp method, and passed as an argument to the HelpKeyword method in the Application singleton.
          </p>
          <p>
            Use HelpContext to specify a numeric context identifier for the help topic displayed for the control.
          </p>
          <p>
            Use the HelpFile property, found on the parent form or in a TApplicationProperties instance, to set the help file with the content for the help topic.
          </p>
        </descr>
        <seealso>
          <link id="TControl.HelpContext"/>
          <link id="TControl.HelpType"/>
          <link id="TControl.ShowHelp"/>
          <link id="#lcl.forms.TApplication.HelpKeyword">TApplication.HelpKeyword</link>
          <link id="#lcl.forms.TApplicationProperties.HelpFile">TApplicationProperties.HelpFile</link>
          <link id="#lcl.forms.TCustomForm.HelpFile">TCustomForm.HelpFile</link>
        </seealso>
      </element>

      <element name="TControl.HelpContext">
        <short>The numeric context-sensitive Help identifier for the control.</short>
        <descr>
          <p>
            HelpContext is an Integer property with the numeric identifier used to locate and display a context-sensitive help topic for the control. The default value for the property is <b>0</b> (zero).
          </p>
          <p>
            Setting a new value for the property causes HelpType to be changed to htContext.
          </p>
          <p>
            HelpContext is used in the ShowHelp method, and passed as an argument to the HelpContext method in the Application singleton.
          </p>
          <p>
            Use HelpKeyword to specify a string value with the help topic displayed for the control.
          </p>
          <p>
            Use the HelpFile property, found on the parent form or in a TApplicationProperties instance, to set the help file with the content for the help topic.
          </p>
        </descr>
        <seealso>
          <link id="TControl.HelpKeyword"/>
          <link id="TControl.HelpType"/>
          <link id="TControl.ShowHelp"/>
          <link id="#lcl.forms.TApplication.HelpKeyword">TApplication.HelpKeyword</link>
          <link id="#lcl.forms.TApplicationProperties.HelpFile">TApplicationProperties.HelpFile</link>
          <link id="#lcl.forms.TCustomForm.HelpFile">TCustomForm.HelpFile</link>
        </seealso>
      </element>

      <element name="TBorderWidth">
        <short>Integer type used for <link id="TWinControl.BorderWidth"/></short>
        <descr>
          <p>
            <var>TBorderWidth</var> is an <var>Integer</var> type with the range of values that can be used as the width for a border on a control. TBorderWidth is the type used to implement the <var>BorderWidth</var> property in <var>TWinControl</var> and descendent classes.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.BorderWidth"/>
        </seealso>
      </element>

      <element name="TGetChildProc">
        <short>Type used for a callback method, to be called for all children of a control.</short>
        <descr/>
        <seealso>
          <link id="TWinControl.GetChildren"/>
        </seealso>
      </element>
      <element name="TGetChildProc.Child">
        <short>The child control.</short>
      </element>

      <element name="TChildControlResizeStyle">
        <short>Defines how child controls are resized / aligned.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TChildControlResizeStyle.crsAnchorAligning">
        <short>Using <link id="TControl.Anchors"/> (Delphi compatible).</short>
        <descr>
          <p>
            Anchors and Align work like Delphi. For example if Anchors property of the control is [akLeft], it means fixed distance between left border of parent's client area. [akRight] means fixed distance between right border of the control and the right border of the parent's client area. When the parent is resized the child is moved to keep the distance. [akLeft,akRight] means fixed distance to left border and fixed distance to right border. When the parent is resized, the controls width is changed (resized) to keep the left and right distance. Same for akTop,akBottom.
          </p>
          <p>
            Align=alLeft for a control means set Left leftmost, Top topmost and maximize Height. The width is kept, if akRight is not set. If akRight is set in the Anchors property, then the right distance is kept and the control's width is resized. If there several controls with Align=alLeft, they will not overlap and be put side by side. Same for alRight, alTop, alBottom. (Always expand 3 sides).
          </p>
          <p>
            Align=alClient. The control will fill the whole remaining space. Setting two children to Align=alClient does only make sense, if you set maximum Constraints.
          </p>
          <p>
            Order: First all alTop children are resized, then alBottom, then alLeft, then alRight and finally alClient.
          </p>
        </descr>
      </element>
      <element name="TChildControlResizeStyle.crsScaleChilds">
        <short>Scale children, keep space between children fixed.</short>
        <descr>
          <p>
            Scale children, keep space between them fixed. Children are resized to their normal / advised size. If there is some space left in the client area of the parent, then the children are scaled to fill the space. You can set maximum Constraints. Then the other children are scaled more.
          </p>
          <p>
            For example: 3 child controls A, B, C with A.Width=10, B.Width=20 and C.Width=30 (total=60). If the Parent's client area has a ClientWidth of 120, then the children are scaled with Factor 2.
          </p>
          <p>
            If B has a maximum constraint width of 30, then first the children will be scaled with 1.5 (A.Width=15, B.Width=30, C.Width=45). Then A and C (15+45=60 and 30 pixel space left) will be scaled by 1.5 again, to a final result of: A.Width=23, B.Width=30, C.Width=67 (23+30+67=120).
          </p>
        </descr>
      </element>
      <element name="TChildControlResizeStyle.crsHomogenousChildResize">
        <short>Enlarge children equally, i.e. by the same amount of pixels.</short>
        <descr>
          <p>
            Enlarge children equally. Children are resized to their normal/adviced size. If there is some space left in the client area of the parent, then the remaining space is distributed equally to each child.
          </p>
          <p>
            For example: 3 child controls A, B, C with A.Width=10, B.Width=20 and C.Width=30 (total=60). If the Parent's client area has a ClientWidth of 120, then 60/3=20 is added to each Child.
          </p>
          <p>
            If B has a maximum constraint width of 30, then first 10 is added to all children (A.Width=20, B.Width=30, C.Width=40). Then A and C (20+40=60 and 30 pixel space left) will get 30/2=15 additional, resulting in: A.Width=35, B.Width=30, C.Width=55 (35+30+55=120).
          </p>
        </descr>
      </element>
      <element name="TChildControlResizeStyle.crsHomogenousSpaceResize">
        <short>Enlarge space between children equally.</short>
        <descr>
          <p>
            Enlarge space between children equally. Children are resized to their normal/adviced size. If there is some space left in the client area of the parent, then the space between the children is expanded.
          </p>
          <p>
            For example: 3 child controls A, B, C with A.Width=10, B.Width=20 and C.Width=30 (total=60). If the Parent's client area has a ClientWidth of 120, then there will be 60/2=30 space between A and B and between B and C.
          </p>
        </descr>
      </element>
      <element name="TChildControlResizeStyle.crsSameSize">
        <short>Each child gets the same size (maybe one pixel difference).</short>
        <descr>
          <remark>
            Not implemented in the current LCL version.
          </remark>
          <p>
            Set each child to the same size (maybe one pixel difference). The client area is divided by the number of controls and each control gets the same size. The remainder is distributed to the first children.
          </p>
        </descr>
      </element>

      <element name="TControlChildrenLayout">
        <short>Defines the logic used to wrap child controls.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlChildrenLayout.cclNone">
        <short>No wrapping.</short>
      </element>
      <element name="TControlChildrenLayout.cclLeftToRightThenTopToBottom">
        <short>
          Arranges controls in a row filled from left to right, and then top to bottom. Uses the value in BiDiMode; when it contains bdRightToLeft the horizontal direction is reversed (Right to Left).
        </short>
      </element>
      <element name="TControlChildrenLayout.cclTopToBottomThenLeftToRight">
        <short>Arranges controls in columns, from top to bottom and then left to right.</short>
      </element>

      <element name="TControlChildSizing">
        <short>How child controls are sized relative to their parent.</short>
        <descr>
          <p>
            <var>TControlChildSizing</var> is a <var>TPersistent</var> descendant which provides properties and methods used to layout, align, and resize child controls relative to their parent. Properties are provide which define the horizontal and vertical spacing between controls, the preferred direction controls are aligned, and whether controls are scaled to fit in the parent control.
          </p>
          <p>
            See <link id="TChildControlResizeStyle"/> and <link id="TControlChildrenLayout"/> for details about the enumeration values used in the properties.
          </p>
        </descr>
        <seealso>
          <link id="TChildControlResizeStyle"/>
          <link id="TControlChildrenLayout"/>
        </seealso>
      </element>

      <element name="TControlChildSizing.FControl"/>
      <element name="TControlChildSizing.FControlsPerLine"/>
      <element name="TControlChildSizing.FEnlargeHorizontal"/>
      <element name="TControlChildSizing.FEnlargeVertical"/>
      <element name="TControlChildSizing.FHorizontalSpacing"/>
      <element name="TControlChildSizing.FLayout"/>
      <element name="TControlChildSizing.FLeftRightSpacing"/>
      <element name="TControlChildSizing.FOnChange"/>
      <element name="TControlChildSizing.FShrinkHorizontal"/>
      <element name="TControlChildSizing.FShrinkVertical"/>
      <element name="TControlChildSizing.FTopBottomSpacing"/>
      <element name="TControlChildSizing.FVerticalSpacing"/>

      <element link="#lcl.controls.TControlChildSizing.ControlsPerLine" name="TControlChildSizing.SetControlsPerLine"/>
      <element name="TControlChildSizing.SetControlsPerLine.AValue">
        <short/>
      </element>

      <element link="#lcl.controls.TControlChildSizing.EnlargeHorizontal" name="TControlChildSizing.SetEnlargeHorizontal"/>
      <element name="TControlChildSizing.SetEnlargeHorizontal.AValue">
        <short/>
      </element>

      <element link="#lcl.controls.TControlChildSizing.EnlargeVertical" name="TControlChildSizing.SetEnlargeVertical"/>
      <element name="TControlChildSizing.SetEnlargeVertical.AValue">
        <short/>
      </element>

      <element link="#lcl.controls.TControlChildSizing.HorizontalSpacing" name="TControlChildSizing.SetHorizontalSpacing"/>
      <element name="TControlChildSizing.SetHorizontalSpacing.AValue">
        <short/>
      </element>

      <element link="#lcl.controls.TControlChildSizing.Layout" name="TControlChildSizing.SetLayout"/>
      <element name="TControlChildSizing.SetLayout.AValue">
        <short/>
      </element>

      <element link="#lcl.controls.TControlChildSizing.LeftRightSpacing" name="TControlChildSizing.SetLeftRightSpacing"/>
      <element name="TControlChildSizing.SetLeftRightSpacing.AValue">
        <short/>
      </element>

      <element link="#lcl.controls.TControlChildSizing.ShrinkHorizontal" name="TControlChildSizing.SetShrinkHorizontal"/>
      <element name="TControlChildSizing.SetShrinkHorizontal.AValue">
        <short/>
      </element>

      <element link="#lcl.controls.TControlChildSizing.ShrinkVertical" name="TControlChildSizing.SetShrinkVertical"/>
      <element name="TControlChildSizing.SetShrinkVertical.AValue">
        <short/>
      </element>

      <element link="#lcl.controls.TControlChildSizing.TopBottomSpacing" name="TControlChildSizing.SetTopBottomSpacing"/>
      <element name="TControlChildSizing.SetTopBottomSpacing.AValue">
        <short/>
      </element>

      <element link="#lcl.controls.TControlChildSizing.VerticalSpacing" name="TControlChildSizing.SetVerticalSpacing"/>
      <element name="TControlChildSizing.SetVerticalSpacing.AValue">
        <short/>
      </element>

      <element name="TControlChildSizing.Change">
        <short>
          Notifies the Control and invokes the <var>OnChange</var> handler.
        </short>
        <descr/>
        <seealso>
          <link id="TWinControl.DoChildSizingChange"/>
        </seealso>
      </element>

      <element name="TControlChildSizing.Create">
        <short>Constructor for the class instance.</short>
        <descr>
          <p>
            <var>Create</var> is the constructor for the class instance. Create calls the inherited constructor, and sets the default values for properties including:
          </p>
          <dl>
            <dt>Control</dt>
            <dd>Set to the value in the OwnerControl argument</dd>
            <dt>Layout</dt>
            <dd>Set to cclNone</dd>
            <dt>EnlargeHorizontal, EnlargeVertical, ShrinkHorizontal, ShrinkVertical</dt>
            <dd>Set to crsAnchorAligning</dd>
          </dl>
        </descr>
      </element>
      <element name="TControlChildSizing.Create.OwnerControl">
        <short>Control which owns the class instance.</short>
      </element>

      <element name="TControlChildSizing.Assign">
        <short>
          Copies property values from the specified persistent object into the current class instance.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlChildSizing.Assign.Source">
        <short>Persistent object with the property values copied in the method.</short>
      </element>

      <element name="TControlChildSizing.AssignTo">
        <short>
          Copies property values from the current class instance to the specified persistent object.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlChildSizing.AssignTo.Dest">
        <short>Persistent object where the property values are stored.</short>
      </element>

      <element name="TControlChildSizing.IsEqual">
        <short>
          Determines whether the specified sizing contains the same values as the current class instance.
        </short>
        <descr>
          <p>
            <var>IsEqual</var> is a <var>Boolean</var> function used to determine whether the <var>TControlChildSizing</var> instance in <var>Sizing</var> contains the same values as the current class instance. <var>IsEqual</var> compares the following properties to determine the return value:
          </p>
          <ul>
            <li>EnlargeHorizontal</li>
            <li>EnlargeVertical</li>
            <li>ShrinkHorizontal</li>
            <li>EnlargeHorizontal</li>
            <li>ShrinkVertical</li>
            <li>EnlargeVertical</li>
            <li>ShrinkHorizontal</li>
            <li>ShrinkVertical</li>
            <li>ControlsPerLine</li>
            <li>Layout</li>
            <li>LeftRightSpacing</li>
            <li>TopBottomSpacing</li>
            <li>HorizontalSpacing</li>
            <li>VerticalSpacing</li>
          </ul>
          <p>
            The return value is <b>True</b> when the properties contain equivalent values in both class instances.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TControlChildSizing.IsEqual.Result">
        <short>
          <b>True</b> when the specified sizing contains the same values as the current class instance.
        </short>
      </element>
      <element name="TControlChildSizing.IsEqual.Sizing">
        <short>TControlChildSizing class instance compared in the method.</short>
      </element>

      <element name="TControlChildSizing.SetGridSpacing">
        <short>Set all spacing to the same value.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlChildSizing.SetGridSpacing.Spacing">
        <short/>

      </element>
      <element name="TControlChildSizing.Control">
        <short>The <var>Control</var> to which childsizing applies.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlChildSizing.ControlsPerLine">
        <short>Number of controls per line.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlChildSizing.EnlargeHorizontal">
        <short>Various ways to fit controls into the available Width.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlChildSizing.EnlargeVertical">
        <short>Various ways to fit controls into the available Height.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlChildSizing.HorizontalSpacing">
        <short>Minimum space between children.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlChildSizing.Layout">
        <short>Allows to also arrange the child controls in rows or columns.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlChildSizing.LeftRightSpacing">
        <short>Minimum distance between children and client border.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlChildSizing.OnChange">
        <short>Event handler for any change in the data.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlChildSizing.ShrinkHorizontal">
        <short>Various ways to fit controls into the available Width.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlChildSizing.ShrinkVertical">
        <short>Various ways to fit controls into the available Height.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlChildSizing.TopBottomSpacing">
        <short>Minimum distance between children and client border.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlChildSizing.VerticalSpacing">
        <short>Minimum space between children.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControlActionLink">
        <short>Alias for the TControlActionLink type.</short>
        <descr>
          <p>
            Since HelpContext and HelpKeyword are properties of TControl, this class is obsolete. To maintain compatibility with existing code, its declaration is aliased to TControlActionLink.
          </p>
        </descr>
        <seealso>
          <link id="TControlActionLink"/>
        </seealso>
      </element>

      <element name="TWinControlActionLinkClass">
        <short>
          Class type used to create new instances of TWinControlActionLink.
        </short>
        <descr/>
        <seealso>
          <link id="TWinControlActionLink"/>
        </seealso>
      </element>

      <element name="TWinControlFlag">
        <short>State flags of TWinControl.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControlFlag.wcfClientRectNeedsUpdate">
        <short>Client rectangle has been invalidated and needs to be updated.</short>
      </element>
      <element name="TWinControlFlag.wcfColorChanged">
        <short>The Color property in s control has been changed.</short>
      </element>
      <element name="TWinControlFlag.wcfFontChanged">
        <short>Set when the font was changed before handle creation.</short>
      </element>
      <element name="TWinControlFlag.wcfAllAutoSizing">
        <short>Set during DoAllAutosize.</short>
      </element>
      <element name="TWinControlFlag.wcfAligningControls">
        <short>Set when the AlignControls method is called.</short>
      </element>
      <element name="TWinControlFlag.wcfEraseBackground">
        <short>Set in the method Paint before the LM_ERASEBKGND message is performed.</short>
      </element>
      <element name="TWinControlFlag.wcfCreatingHandle">
        <short>Set while constructing the handle of this control.</short>
      </element>
      <element name="TWinControlFlag.wcfInitializing">
        <short>Set while initializing during handle creation.</short>
      </element>
      <element name="TWinControlFlag.wcfCreatingChildHandles">
        <short>Set while constructing the handles of the children.</short>
      </element>
      <element name="TWinControlFlag.wcfRealizingBounds">
        <short>Set inside RealizeBoundsRecursive.</short>
      </element>
      <element name="TWinControlFlag.wcfBoundsRealized">
        <short>
          Set before bounds are sent to the widget; used to suppress subsequent size messages sent by the widget.
        </short>
      </element>
      <element name="TWinControlFlag.wcfUpdateShowing">
        <short>Set before a visible control and its children are updated during auto-sizing.</short>
      </element>
      <element name="TWinControlFlag.wcfHandleVisible">
        <short>Set when a control is visible and not obscured on its parent.</short>
      </element>
      <element name="TWinControlFlag.wcfAdjustedLogicalClientRectValid">
        <short>Set when the adjusted ClientRect is valid.</short>
        <seealso>
          <link id="TWinControl.GetAdjustedLogicalClientRect"/>
        </seealso>
      </element>
      <element name="TWinControlFlag.wcfKillIntfSetBounds">
        <short>
          Set when the LCL interface has already called SetBounds during size and move operations. Prevents a loop.
        </short>
      </element>
      <element name="TWinControlFlag.wcfDesignerDeleting">
        <short>Only used for TCustomPairSplitter / TPairSplitter.</short>
      </element>
      <element name="TWinControlFlag.wcfSpecialSubContro">
        <short>Only used for TCustomPairSplitter / TPairSplitter.</short>
      </element>

      <element name="TWinControlFlags">
        <short>Set of TWinControlFlag enumeration values.</short>
        <descr>
          <p>
            <var>TWinControlFlags</var> is a set type used to store zero (0) or more values from the <var>TWinControlFlag</var> enumeration. TWinControlFlags is the type used to implement an internal member in TWinControl. Values are added to and removed from the set as needed in <var>TWinControl</var> methods.
          </p>
        </descr>
        <seealso>
          <link id="TWinControlFlag"/>
          <link id="TWinControl"/>
        </seealso>
      </element>

      <element name="TControlAtPosFlag">
        <short>
          Flags for finding a control at a given (client) position.
        </short>
        <descr>
          <p>
            TControlAtPosFlag is an enumeration type with values that indicate the mechanism used to locate a control at a given client position.
          </p>
          <p>
            Values from the enumeration are stored in the TControlAtPosFlags type.
          </p>
          <p>
            TControlAtPosFlag enumeration values are used in the implementation of the ControlAtPos method in TWinControl, and in the FindControlAtPosition function.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.ControlAtPos"/>
          <link id="FindControlAtPosition"/>
        </seealso>
      </element>
      <element name="TControlAtPosFlag.capfAllowDisabled">
        <short>Include disabled controls when set.</short>
      </element>
      <element name="TControlAtPosFlag.capfAllowWinControls">
        <short>Include both TWinControls and TControl instances when set.</short>
      </element>
      <element name="TControlAtPosFlag.capfOnlyClientAreas">
        <short>Checks for hits are limited to the client area when set.</short>
      </element>
      <element name="TControlAtPosFlag.capfRecursive">
        <short>Recurse into grand-children controls when set.</short>
      </element>
      <element name="TControlAtPosFlag.capfHasScrollOffset">
        <short>Scroll offset is already included in the coordinates when set.</short>
      </element>
      <element name="TControlAtPosFlag.capfOnlyWinControls">
        <short>Include only TWinControls (and ignore TControls) when set.</short>
      </element>

      <element name="TControlAtPosFlags">
        <short>Set type used to store values from the TControlAtPosFlag enumeration.</short>
        <descr>
          <p>
            Passed as an argument to the ControlAtPos method in TWinControl. Used internally in the implementation of the FindControlAtPosition routine.
          </p>
        </descr>
        <seealso>
          <link id="TControlAtPosFlag"/>
          <link id="TWinControl.ControlAtPos"/>
          <link id="FindControlAtPosition"/>
        </seealso>
      </element>

      <element name="TAlignInfo">
        <short>Used in custom alignment (alCustom).</short>
        <descr>
          <p>
            This record was added for compatibility with Delphi releases after Version 7. It is used in CustomInsertBefore and CustomAlignPosition methods and handlers.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.CustomAlignPosition"/>
          <link id="TWinControl.CustomAlignInsertBefore"/>
        </seealso>
      </element>

      <element name="TAlignInfo.AlignList">
        <short>The list of controls currently being aligned.</short>
      </element>

      <element name="TAlignInfo.ControlIndex">
        <short>Index of current control.</short>
      </element>

      <element name="TAlignInfo.Align">
        <short>The kind of alignment currently processed (always alCustom).</short>
      </element>

      <element name="TAlignInfo.Scratch">
        <short>For internal use.</short>
      </element>

      <element name="TAlignInsertBeforeEvent">
        <short>Type of an OnAlignInsertBefore handler.</short>
        <descr>
          The handler determines the order used to align both controls.
        </descr>
        <seealso>
          <link id="TWinControl.CustomAlignInsertBefore"/>
        </seealso>
      </element>
      <element name="TAlignInsertBeforeEvent.Result">
        <short><b>True</b> if Control2 shall be placed before Control1 is placed.</short>
      </element>
      <element name="TAlignInsertBeforeEvent.Sender">
        <short>The Parent control.</short>
      </element>
      <element name="TAlignInsertBeforeEvent.Control1">
        <short/>
      </element>
      <element name="TAlignInsertBeforeEvent.Control2">
        <short/>
      </element>

      <element name="TAlignPositionEvent">
        <short>Type of an OnAlignPosition handler.</short>
        <descr>
          <p>
            Specified an event handler which positions the Control using the specified coordinates and  alignment information.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.CustomAlignPosition"/>
        </seealso>
      </element>
      <element name="TAlignPositionEvent.Sender">
        <short>TWinControl generating the event notification.</short>
      </element>
      <element name="TAlignPositionEvent.Control">
        <short>The control to position.</short>
      </element>
      <element name="TAlignPositionEvent.NewLeft">
        <short>New Left coordinate for the control.</short>
      </element>
      <element name="TAlignPositionEvent.NewTop">
        <short>New Top coordinate for the control.</short>
      </element>
      <element name="TAlignPositionEvent.NewWidth">
        <short>New Width for the control.</short>
      </element>
      <element name="TAlignPositionEvent.NewHeight">
        <short>New Height for the control.</short>
      </element>
      <element name="TAlignPositionEvent.AlignRect">
        <short>The remaining ClientRect.</short>
      </element>
      <element name="TAlignPositionEvent.AlignInfo">
        <short>Information about the current align process.</short>
      </element>

      <element name="TWinControlEnumerator">
        <short>Implements an enumerator for TWinControl instances.</short>
        <descr>
          <p>
            <var>TWinControlEnumerator</var> is a class used to implement an enumerator for <var>TWinControl</var> class instances. TWinControlEnumerator provides support the enumerator interface through its <var>GetCurrent</var> and <var>MoveNext</var> methods.
          </p>
          <p>
            <var>TWinControlEnumerator</var> is the type returned by the <var>GetEnumeratorControls</var> and <var>GetEnumeratorControlsReverse</var> functions in <var>TWinControl</var>.
          </p>
        </descr>
        <seealso>
          <link id="TWinControlEnumerator.Current"/>
          <link id="TWinControlEnumerator.MoveNext"/>
          <link id="TWinControl.GetEnumeratorControls"/>
          <link id="TWinControl.GetEnumeratorControlsReverse"/>
        </seealso>
      </element>

      <element name="TWinControlEnumerator.FIndex">
        <short>Member with the current position for the enumerator.</short>
      </element>
      <element name="TWinControlEnumerator.FLowToHigh">
        <short>Member which indicates the order for the enumerator.</short>
      </element>
      <element name="TWinControlEnumerator.FParent">
        <short>Member with the Parent for the enumerated values.</short>
      </element>

      <element name="TWinControlEnumerator.GetCurrent">
        <short>Gets the current enumerator value.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControlEnumerator.GetCurrent.Result">
        <short>The enumerator instance.</short>
      </element>

      <element name="TWinControlEnumerator.Create">
        <short>Constructor for the class instance.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControlEnumerator.Create.Parent">
        <short>Control which is the Parent for the enumerator.</short>
      </element>
      <element name="TWinControlEnumerator.Create.aLowToHigh">
        <short>The enumerator uses ascending order when <b>True</b> (default).</short>
      </element>

      <element name="TWinControlEnumerator.GetEnumerator">
        <short>Gets the enumerator for the class.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControlEnumerator.GetEnumerator.Result">
        <short/>
      </element>

      <element name="TWinControlEnumerator.MoveNext">
        <short>
          Moves to the next value using the ordering in effect for the enumerator.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControlEnumerator.MoveNext.Result">
        <short>Next value for the enumerator.</short>
      </element>

      <element name="TWinControlEnumerator.Current">
        <short>Gets the current value for the enumerator.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl">
        <short>
          Implements a windowed control which can contain other child controls.
        </short>
        <descr>
          <p>
            <var>TWinControl</var> is a <var>TControl</var> descendant which implements a base class for controls that can contain child controls. The name reflects the fact that (on Windows platforms) the controls are based on OS-provided widgets, which have window Handles.
          </p>
          <p>
            TWinControl extends the ancestor class with new properties, methods, and events which are specific to the windowed control. It also provides overridden methods which re-implement the functionality for some inherited methods. The properties, methods, and event fall into categories like:
          </p>
          <ul>
            <li>Hi-DPI Awareness and Scaling</li>
            <li>Control, Window, and Notification Message Handlers</li>
            <li>Keyboard and Mouse Message Handlers</li>
            <li>Drag and Drop, Drag and Dock</li>
            <li>Sizing, Positioning, and Alignment</li>
            <li>Alternate Constructors and Class Functions used to create TWinControl Instances</li>
            <li>Forward and Reverse Enumerators for Child Controls</li>
          </ul>
          <p>
            TWinControl is often used as the ancestor for control classes defined in the LCL. For example: TButtonControl, TCustomCalendar, TCustomComboBox, TCustomControl, TCustomEdit, TCustomGroupBox, TCustomListBox, TCustomListView, TCustomPage, TCustomPairSplitter, TCustomProgressBar, TCustomRubberBand, TCustomScrollBar, TCustomStaticText, TCustomTabControl, TCustomTrackBar, TPreviewFileControl, and TStatusBar.
          </p>
        </descr>
        <seealso>
          <link id="TControl"/>
        </seealso>
      </element>

      <element name="TWinControl.FAlignOrder"/>
      <element name="TWinControl.FBorderWidth"/>
      <element name="TWinControl.FBoundsLockCount"/>

      <element name="TWinControl.FBoundsRealized">
        <short>
          The bounds as sent to the widget. Used to suppress feedback messages from the widget.
        </short>
      </element>

      <element name="TWinControl.FBorderStyle"/>
      <element name="TWinControl.FBrush"/>
      <element name="TWinControl.FAdjustClientRectRealized"/>
      <element name="TWinControl.FAdjustClientRect"/>
      <element name="TWinControl.FChildSizing"/>
      <element name="TWinControl.FControls"/>
      <element name="TWinControl.FOnGetDockCaption"/>
      <element name="TWinControl.FDefWndProc"/>
      <element name="TWinControl.FDockClients"/>
      <element name="TWinControl.FClientWidth"/>
      <element name="TWinControl.FClientHeight"/>
      <element name="TWinControl.FDockManager"/>
      <element name="TWinControl.FFlipped"/>
      <element name="TWinControl.FOnAlignInsertBefore"/>
      <element name="TWinControl.FOnAlignPosition"/>
      <element name="TWinControl.FOnDockDrop"/>
      <element name="TWinControl.FOnDockOver"/>
      <element name="TWinControl.FOnGetSiteInfo"/>
      <element name="TWinControl.FOnKeyDown"/>
      <element name="TWinControl.FOnKeyPress"/>
      <element name="TWinControl.FOnKeyUp"/>
      <element name="TWinControl.FOnEnter"/>
      <element name="TWinControl.FOnExit"/>
      <element name="TWinControl.FOnUnDock"/>
      <element name="TWinControl.FOnUTF8KeyPress"/>
      <element name="TWinControl.FParentDoubleBuffered"/>
      <element name="TWinControl.FParentWindow"/>
      <element name="TWinControl.FRealizeBoundsLockCount"/>
      <element name="TWinControl.FHandle"/>
      <element name="TWinControl.FTabOrder"/>
      <element name="TWinControl.FTabList"/>
      <element name="TWinControl.FTabStop"/>
      <element name="TWinControl.FShowing"/>
      <element name="TWinControl.FDockSite"/>
      <element name="TWinControl.FUseDockManager"/>

      <element name="TWinControl.AlignControl">
        <short>Aligns the control and its child controls.</short>
        <descr>
          <p>
            <var>AlignControl</var> is a procedure used to align the control (and its child controls) relative to the control specified in <var>AControl</var>. AControl can contain the value <b>Nil</b> to indicate a containing control is not used to align the control instance.
          </p>
          <p>
            AlignControl calls <var>DisableAlign</var> on entry, and <var>EnableAlign</var> prior to exiting from the method.
          </p>
          <remark>
            No actions are performed in the method when the control is being freed (the value csDestroying is in ComponentState).
          </remark>
          <p>
            AlignControl gets the client rectangle used to display the control, and calls <var>AdjustClientRect</var> to allocate border spacing when needed. <var>AlignControls</var> is called to align child controls relative to the control in AControl using the calculated client rectangle. Some widgetsets update their client rectangle when the first child is positioned; a second call to AlignControls is made if the client rectangle is altered in the initial call to the method.
          </p>
          <p>
            AlignControl is used in the implementation of the <var>DoAllAutoSize</var> method in <var>TControl</var>.
          </p>
        </descr>
        <seealso>
          <link id="TControl.DoAllAutoSize"/>
        </seealso>
      </element>
      <element name="TWinControl.AlignControl.AControl">
        <short>
          Control which provides the relative position for the control and its children.
        </short>
      </element>

      <element name="TWinControl.DoubleBufferedIsStored">
        <short>Implements the storage specifier for the DoubleBuffered property.</short>
        <descr>
          <p>Contains <b>True</b> when a parent control has not enabled its DoubleBuffered property.</p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.DoubleBufferedIsStored.Result">
        <short/>
      </element>

      <element link="#lcl.controls.TWinControl.Brush" name="TWinControl.GetBrush"/>
      <element name="TWinControl.GetBrush.Result">
        <short/>
      </element>

      <element link="#lcl.controls.TWinControl.Controls" name="TWinControl.GetControl"/>
      <element name="TWinControl.GetControl.Result">
        <short/>
      </element>
      <element name="TWinControl.GetControl.Index">
        <short/>
      </element>

      <element link="#lcl.controls.TWinControl.ControlCount" name="TWinControl.GetControlCount"/>
      <element name="TWinControl.GetControlCount.Result">
        <short/>
      </element>

      <element link="#lcl.controls.TWinControl.DockClientCount" name="TWinControl.GetDockClientCount"/>
      <element name="TWinControl.GetDockClientCount.Result">
        <short/>
      </element>

      <element link="#lcl.controls.TWinControl.DockClients" name="TWinControl.GetDockClients"/>
      <element name="TWinControl.GetDockClients.Result">
        <short/>
      </element>
      <element name="TWinControl.GetDockClients.Index">
        <short/>
      </element>

      <element link="#lcl.controls.TWinControl.Handle" name="TWinControl.GetHandle"/>
      <element name="TWinControl.GetHandle.Result">
        <short/>
      </element>

      <element link="#lcl.controls.TWinControl.IsResizing" name="TWinControl.GetIsResizing"/>
      <element name="TWinControl.GetIsResizing.Result">
        <short/>
      </element>

      <element name="TWinControl.GetIsSpecialSubControl">
        <short>Gets the value for the IsSpecialSubControl property.</short>
        <descr/>
        <seealso>
          <link id="TWinControl.IsSpecialSubControl"/>
        </seealso>
      </element>
      <element name="TWinControl.GetIsSpecialSubControl.Result">
        <short>Value for the property.</short>
      </element>

      <element link="#lcl.controls.TWinControl.TabOrder" name="TWinControl.GetTabOrder"/>
      <element name="TWinControl.GetTabOrder.Result">
        <short/>
      </element>

      <element name="TWinControl.GetVisibleDockClientCount">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.GetVisibleDockClientCount.Result">
        <short/>
      </element>

      <element link="#lcl.controls.TWinControl.ChildSizing" name="TWinControl.SetChildSizing"/>
      <element name="TWinControl.SetChildSizing.AValue">
        <short/>
      </element>

      <element name="TWinControl.SetDesignerDeleting">
        <short>Sets the value for the DesignerDeleting property.</short>
        <descr/>
        <seealso>
          <link id="TWinControl.DesignerDeleting"/>
        </seealso>
      </element>
      <element name="TWinControl.SetDesignerDeleting.AValue">
        <short>New value for the DesignerDeleting property.</short>
      </element>

      <element link="#lcl.controls.TWinControl.DockSite" name="TWinControl.SetDockSite"/>
      <element name="TWinControl.SetDockSite.NewDockSite">
        <short/>
      </element>

      <element link="#lcl.controls.TWinControl.Handle" name="TWinControl.SetHandle"/>
      <element name="TWinControl.SetHandle.NewHandle">
        <short>New value for the Handle property.</short>
      </element>

      <element link="#lcl.controls.TWinControl.BorderWidth" name="TWinControl.SetBorderWidth"/>
      <element name="TWinControl.SetBorderWidth.Value">
        <short>New value for the BorderWidth property.</short>
      </element>

      <element name="TWinControl.SetParentDoubleBuffered">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.SetParentDoubleBuffered.Value">
        <short/>
      </element>

      <element link="#lcl.controls.TWinControl.ParentWindow" name="TWinControl.SetParentWindow"/>
      <element name="TWinControl.SetParentWindow.AValue">
        <short>New value for the ParentWindow property.</short>
      </element>

      <element link="#lcl.controls.TWinControl.TabOrder" name="TWinControl.SetTabOrder"/>
      <element name="TWinControl.SetTabOrder.NewTabOrder">
        <short>New value for the TabOrder property.</short>
      </element>

      <element link="#lcl.controls.TWinControl.TabStop" name="TWinControl.SetTabStop"/>
      <element name="TWinControl.SetTabStop.NewTabStop">
        <short/>
      </element>

      <element link="#lcl.controls.TWinControl.UseDockManager" name="TWinControl.SetUseDockManager"/>
      <element name="TWinControl.SetUseDockManager.AValue">
        <short>New value for the TabStop property.</short>
      </element>

      <element name="TWinControl.UpdateTabOrder">
        <short>
          Places a control at the specified position in the tab order for Controls.
        </short>
        <descr>
          <p>
            UpdateTabOrder is a procedure used to place the current control at the position in NewTabOrder in its Parent control. Causes the TabOrder for child controls in Parent to be re-sequenced as needed.
          </p>
          <p>
            No actions are performed in the method when Parent is unassigned (contains Nil).
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.UpdateTabOrder.NewTabOrder">
        <short>New tab order for the current control.</short>
      </element>

      <element name="TWinControl.Insert">
        <short>
          Inserts or appends the specified control to the list of child controls.
        </short>
        <descr>
          <p>
            Insert is an overloaded procedure used to insert or append the control specified in AControl to the list of child controls in the class instance. An overloaded variant has an Index argument which specifies the position in the list.
         </p>
         <p>
           No actions are performed in the method when AControl has not been assigned (contains <b>Nil</b>).
         </p>
         <p>
           Insert raises an exception if AControl already has an assigned Parent, or when AControl is the same as the current class instance.
         </p>
         <p>
           The ListInsert routine is called to store AControl in the Controls property at the position contained in Index. If AControl is a TWinControl instance, it is added to the internal list which maintains the tab order for child controls. At design-time, the TabStop property in AControl is automatically set to <b>True</b> when its CanTab property is enabled.
         </p>
         <p>
           Insert sets the Parent property in AControl to the current control instance.
         </p>
         <p>
           Inserts checks to see whether auto-sizing has been disabled in the AControl argument. When disabled in the child control, it is also disabled in the current class instance.
         </p>
         <p>
           Insert is used in the implementation for the InsertControl method.
         </p>
        </descr>
        <errors>
          <p>
            Raises an EInvalidOperation exception when the inserted control already has a Parent.
          </p>
          <p>
            Raises an EInvalidOperation exception when the inserted control is the same as the current class instance. Uses the exception message in rsAControlCanNotHaveItselfAsParent.
          </p>
        </errors>
        <seealso>
          <link id="TControl.Parent"/>
          <link id="TWinControl.Controls"/>
          <link id="TWinControl.InsertControl"/>
          <link id="TControl.DisableAutoSizing"/>
          <link id="ListInsert"/>
        </seealso>
      </element>
      <element name="TWinControl.Insert.AControl">
        <short>Control to insert or append as a child control.</short>
      </element>
      <element name="TWinControl.Insert.Index">
        <short>Position where the new control is stored in the Controls property.</short>
      </element>

      <element name="TWinControl.Remove">
        <short>
          Removes the specified control from the list of child Controls for the class instance.
        </short>
        <descr>
          <p>
            Remove is a procedure used to remove the control in AControl from the list of child Controls for the class instance. No actions are performed in the method when AControl has not been assigned (contains <b>Nil</b>).
          </p>
          <p>
            Remove ensures that the value in AControl is removed from the Controls property, and the internal list used to determine alignment order of the child controls. When AControl is a TWinControl instance, it is removed from the internal tab order list for child controls.
          </p>
          <p>
            Remove sets the Parent property in AControl to Nil.
          </p>
          <p>
            Remove checks to see whether auto-sizing has been disabled in the AControl argument. When disabled in the child control, it is re-enabled for the current class instance.
          </p>
          <p>
            Remove is used in the implementation of the RemoveControl method.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.Controls"/>
          <link id="TControl.Parent"/>
          <link id="TWinControl.RemoveControl"/>
          <link id="TControl.EnableAutoSizing"/>
        </seealso>
      </element>
      <element name="TWinControl.Remove.AControl">
        <short>Control removed from the list of child Controls in the class instance.</short>
      </element>

      <element name="TWinControl.AlignNonAlignedControls"/>
      <element name="TWinControl.AlignNonAlignedControls.ListOfControls"/>
      <element name="TWinControl.AlignNonAlignedControls.BoundsModified"/>

      <element name="TWinControl.CreateControlAlignList">
        <short>
          Fills the list with the child controls which must be realigned.
        </short>
        <descr>
          <p>
            The list is initialized with all child controls which have the given alignment and are visible.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.AlignControls"/>
        </seealso>
      </element>
      <element name="TWinControl.CreateControlAlignList.TheAlign">
        <short>List all controls with this alignment.</short>
      </element>
      <element name="TWinControl.CreateControlAlignList.AlignList">
        <short/>
      </element>
      <element name="TWinControl.CreateControlAlignList.StartControl">
        <short/>
      </element>

      <element name="TWinControl.UpdateAlignIndex"/>
      <element name="TWinControl.UpdateAlignIndex.aChild"/>

      <element name="TWinControl.FDoubleBuffered">
        <short>Member used to store the value for the DoubleBuffered property.</short>
      </element>

      <element name="TWinControl.FWinControlFlags">
        <short>Contains various window control state flags.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.WSRegisterClass">
        <short>Registers the class instance for use in the widgetset.</short>
        <descr>
          <p>
            No actions are performed in the method when the class type has already been registered in the widgetset.
          </p>
          <p>
            Calls the inherited method on entry to ensure that the TControl class type has been registered in the widgetset. Calls the widgetset routine used to register the TWinControl class type.
          </p>
          <p>
            Registers properties in TWinControl which are ignored during LCL component streaming. These are Delphi / VCL compatibility properties like ParentDoubleBuffered, ImeMode, and ImeName. They are not used in the LCL.
          </p>
        </descr>
        <seealso>
          <link id="TControl.WSRegisterClass"/>
          <link id="#lcl.lclclasses.TLCLComponent.WSRegisterClass">TLCLComponent.WSRegisterClass</link>
        </seealso>
      </element>

      <element name="TWinControl.AdjustClientRect">
        <short>
          Override this method when the ClientRect for a control differs from the default value.
        </short>
        <descr>
          <p>
            In TWinControl, the virtual method has an empty implementation. It can be overridden in descendent classes to perform actions needed for the class type. Such as:
          </p>
          <ul>
            <li>
              Shrink or grow the client rectangle to account for added or removed borders or bezels.
            </li>
            <li>
              Reserve space for companion controls or user interface elements.
            </li>
            <li>
              Set state or configuration flags which affect the client rectangle for the class.
            </li>
          </ul>
          <p>
            AdjustClientRect can be called often, especially during auto-sizing and anchoring operations. Do not use expensive code here, or cache the resulting client rectangle for subsequent access.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.GetAdjustedLogicalClientRect"/>
        </seealso>
      </element>
      <element name="TWinControl.AdjustClientRect.ARect">
        <short>The client rectangle examined and updated in the method.</short>
      </element>

      <element name="TWinControl.GetAdjustedLogicalClientRect">
        <short>
          Returns the adjusted logical ClientRect, using the cached value when available.
        </short>
        <descr/>
        <seealso>
          <link id="TControl.ClientRect"/>
          <link id="TWinControl.AdjustClientRect"/>
          <link id="TWinControlFlag"/>
        </seealso>
      </element>
      <element name="TWinControl.GetAdjustedLogicalClientRect.ARect">
        <short/>
      </element>

      <element name="TWinControl.AlignControls">
        <short>Repositions and resizes the control and child controls.</short>
        <descr>
          <p>
            <var>AlignControls</var> is a method used to reposition and resize the specified control and the children in its Controls property. This includes using the DockManager (when assigned and enabled) to reserve space for docked controls in the client rectangle. It uses settings in the Align, Anchor, BorderSpacing, ChildSizing, and Constraints properties to determine the actions needed in the method for each of the controls.
          </p>
          <p>
            AlignControls checks and updates the windowed control flags prior to starting the operation. No actions are performed in the method when wcfAligningControls is already included in the control flags.
          </p>
          <p>
            The ControlsAligned method is called when the method is completed, and the control flags are updated to remove the value wcfAligningControls.
          </p>
          <p>
            AlignControls is called from the private AlignControl method after the client rectangle has been adjusted and the logical display area for the control has been determined. AlignControl is the boss; AlignControls performs the heavy lifting.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.Controls"/>
          <link id="TWinControl.DoAdjustClientRectChange"/>
          <link id="TControl.DoAllAutoSize"/>
          <link id="TWinControlFlag"/>
        </seealso>
      </element>
      <element name="TWinControl.AlignControls.AControl">
        <short>Control examined and updated in the method.</short>
      </element>
      <element name="TWinControl.AlignControls.RemainingClientRect">
        <short>The available space, becomes remaining space on exit.</short>
      </element>

      <element name="TWinControl.CustomAlignInsertBefore">
        <short>
          Returns the placement order of custom-aligned child controls, using the <var>OnAlignInsertBefore</var> handler.
        </short>
        <seealso>
          <link id="TAlignInsertBeforeEvent"/>
        </seealso>
      </element>
      <element name="TWinControl.CustomAlignInsertBefore.Result">
        <short><b>True</b> if Control2 should be placed before Control1.</short>
      </element>
      <element name="TWinControl.CustomAlignInsertBefore.AControl1">
        <short/>
      </element>
      <element name="TWinControl.CustomAlignInsertBefore.AControl2">
        <short/>
      </element>

      <element name="TWinControl.CustomAlignPosition">
        <short>
          Returns the aligned position for a custom-aligned child control, using the <var>OnAlignPosition</var> event handler.
        </short>
        <descr>
          <p>
            The derived coordinates take into account the anchoring for <var>AControl</var>.
          </p>
          <p>
            The <var>OnAlignPosition</var> handler can update the coordinates as required.
          </p>
        </descr>
        <seealso>
          <link id="TAlignInsertBeforeEvent"/>
        </seealso>
      </element>
      <element name="TWinControl.CustomAlignPosition.AControl">
        <short>The control to be placed.</short>
      </element>
      <element name="TWinControl.CustomAlignPosition.ANewLeft">
        <short/>
      </element>
      <element name="TWinControl.CustomAlignPosition.ANewTop">
        <short/>
      </element>
      <element name="TWinControl.CustomAlignPosition.ANewWidth">
        <short/>
      </element>
      <element name="TWinControl.CustomAlignPosition.ANewHeight">
        <short/>
      </element>
      <element name="TWinControl.CustomAlignPosition.AlignRect">
        <short>
          The remaining client area, within which the control can be placed.
        </short>
      </element>
      <element name="TWinControl.CustomAlignPosition.AlignInfo">
        <short>Information about the current align process.</short>
      </element>

      <element name="TWinControl.DoAlignChildControls">
        <short>
          Override this method to position / align all child controls for the specified control.
        </short>
        <descr>
          <p>
            DoAlignChildControls always returns False in TWinControl. It can be overridden in descendent classes to perform any actions needed, and to set the return value to True to avoid the default handling performed in AlignControls.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.AlignControls"/>
        </seealso>
      </element>
      <element name="TWinControl.DoAlignChildControls.Result">
        <short><b>True</b> when all controls have been placed.</short>
      </element>
      <element name="TWinControl.DoAlignChildControls.TheAlign">
        <short>The alignment of all given controls.</short>
      </element>
      <element name="TWinControl.DoAlignChildControls.AControl">
        <short>Control with child controls and client rectangle used in the method.</short>
      </element>
      <element name="TWinControl.DoAlignChildControls.AControlList">
        <short>The controls to be placed.</short>
      </element>
      <element name="TWinControl.DoAlignChildControls.ARect">
        <short>The unused client rectangle available for the child controls.</short>
      </element>

      <element name="TWinControl.DoChildSizingChange">
        <short>
          Called after a change in ChildSizing information to trigger further processing.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.DoChildSizingChange.Sender">
        <short/>
      </element>

      <element name="TWinControl.InvalidatePreferredChildSizes">
        <short>Flags the preferred sizes of all child controls as invalid (recursively).</short>
        <seealso>
          <link id="TWinControlFlag"/>
          <link id="TControlFlag"/>
        </seealso>
      </element>

      <element name="TWinControl.CanTab">
          <short>Indicates whether the Tab key can be used for keyboard navigation in the control.</short>
          <descr>
            <p>
              CanTab is an overridden method in TWinControl. The return value is <b>True</b> if the control is eligible to receive input focus. It must have a parent form and be both visible and enabled.
            </p>
            <p>
              Set TabStop to indicate the control is omitted in the tab order for the parent form.
            </p>
          </descr>
          <seealso>
            <link id="TWinControl.CanFocus"/>
            <link id="TWinControl.SelectNext"/>
            <link id="TWinControl.Focused"/>
            <link id="TControl.CanTab"/>
          </seealso>
        </element>
      <element name="TWinControl.CanTab.Result">
        <short/>
      </element>

      <element name="TWinControl.IsClientHeightStored">
        <short>Implements the storage specifier for the ClientHeight property.</short>
        <descr>
          <p>
            Re-implements the method inherited from TControl.
          </p>
        </descr>
        <seealso>
          <link id="#lcl.controls.TControl.ClientHeight">TControl.ClientHeight</link>
        </seealso>
      </element>
      <element name="TWinControl.IsClientHeightStored.Result">
        <short><b>True</b> if ControlCount has a non-zero value.</short>
      </element>

      <element name="TWinControl.IsClientWidthStored">
        <short>Implements the storage specifier for the ClientWidth property.</short>
        <descr>
          <p>
            Re-implements the method inherited from TControl.
          </p>
        </descr>
        <seealso>
          <link id="#lcl.controls.TControl.ClientWidth">TControl.ClientWidth</link>
        </seealso>
      </element>
      <element name="TWinControl.IsClientWidthStored.Result">
        <short><b>True</b> if ControlCount has a non-zero value.</short>
      </element>

      <element name="TWinControl.DoSendShowHideToInterface">
        <short>Sends the new Visible state to the widgetset class instance.</short>
        <descr>
          <p>
            Called from the CMShowingChanged method.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.CMShowingChanged"/>
        </seealso>
      </element>

      <element name="TWinControl.ControlsAligned">
        <short>Called from AlignControls when alignment for the control is completed.</short>
        <descr>
          <p>
            ControlsAligned has an empty implementation in the current LCL version.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TWinControl.DoSendBoundsToInterface">
        <short>Sends the new bounds for the control to the widgetset class instance.</short>
        <descr>
          Called from RealizeBounds.
        </descr>
        <seealso>
          <link id="TWinControlFlag"/>
        </seealso>
      </element>

      <element name="TWinControl.RealizeBounds">
        <short>
          Checks for changes in BoundsRect, and sends the new bounds to the widget.
        </short>
        <descr>
          <p>
            Calls DoSendBoundsToInterface to update the widget.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TWinControl.RealizeBoundsRecursive">
        <short>
          Sends changed BoundsRects to the widget, for both the control and all child controls.
        </short>
        <descr/>
        <seealso>
          <link id="TWinControl.RealizeBounds"/>
          <link id="TWinControlFlag"/>
        </seealso>
      </element>

      <element name="TWinControl.InvalidateBoundsRealized">
        <short>Resets the realized bounds rectangle for the control.</short>
        <descr>
          <p>
            Creates a new, empty TRect instance for the internal member passed to the widgetset class. Used in widgetset methods which apply changes to the Font for the control.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TWinControl.CreateSubClass">
        <short>An empty implementation in the current LCL version.</short>
        <descr>
          <p>
            An empty implementation in the current LCL version.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.CreateSubClass.Params">
        <short>Creation parameters for the subclass.</short>
      </element>
      <element name="TWinControl.CreateSubClass.ControlClassName">
        <short>Class name for the control added as a subclass.</short>
      </element>

      <element link="" name="TWinControl.DoConstraintsChange">
        <short>Notifies the widgetset class instance when Constraints are changed.</short>
        <descr>
          <p>
            DoConstraintsChange is an overridden method in TWinControl, and calls the inherited method on entry to size and position child controls to Constraints. Calls the ConstraintsChange method in the widgetset class instance when its Handle has been allocated.
          </p>
          <p>
            DoConstraintsChange is called from the TSizeConstraints.Change method before it signals the OnChange event handler in the constraints class instance.
          </p>
        </descr>
        <seealso>
          <link id="#lcl.controls.TControl.DoConstraintsChange">TControl.DoConstraintsChange</link>
        </seealso>
      </element>
      <element name="TWinControl.DoConstraintsChange.Sender">
        <short>Object (TWinControl) instance for the change notification.</short>
      </element>

      <element name="TWinControl.DoSetBounds">
        <short>
          Updates the size and extent of the control as well as its ClientRect.
        </short>
        <descr>
          <p>
            Changing the ClientRect here, to the most probable size, reduces unnecessary resize messages.
          </p>
          <p>
            Normally, the ClientWidth / ClientHeight are adjusted automatically by the widget. But it is up to the widget when this will be done. GTK, for example, just puts resize requests in a queue. The LCL would resize the child components immediately after the GTK procedure to adjust the ClientRect. On complex forms with lots of nested controls, this would result in thousands of resize messages.
          </p>
        </descr>
        <seealso>
          <link id="TControl.DoSetBounds"/>
        </seealso>
      </element>
      <element name="TWinControl.DoSetBounds.ALeft">
        <short/>
      </element>
      <element name="TWinControl.DoSetBounds.ATop">
        <short/>
      </element>
      <element name="TWinControl.DoSetBounds.AWidth">
        <short/>
      </element>
      <element name="TWinControl.DoSetBounds.AHeight">
        <short/>
      </element>

      <element name="TWinControl.DoAutoSize">
        <short>
          Shrinks or enlarges the control to accommodate its children.
        </short>
        <descr>
          <p>
            Because this method is frequently overridden, the LCL calls the <link id="TControl.AdjustSize"/> method instead; it checks whether DoAutoSize really should be called right now.
          </p>
          <p>
            DoAutoSize performs the following:
          </p>
          <ul>
            <li>Checks whether Autosize is permitted</li>
            <li>Checks for unaligned child components and aligns them as best it can</li>
            <li>Moves the constrained (aligned) child components to the correct position</li>
            <li>Adjusts the size of the client rectangle</li>
            <li>Adjusts the bounds of the whole control</li>
          </ul>
        </descr>
        <seealso>
          <link id="TControl.DoAutoSize"/>
        </seealso>
      </element>

      <element name="TWinControl.DoAllAutoSize">
        <short>
          Performs actions to resize and align the control and all of its children.
        </short>
        <descr>
          <p>
            DoAllAutoSize is an overridden method in TWinControl.
          </p>
          <p>
            No actions are performed in the method when wcfAllAutoSizing has already been included in the window control flags; in other words, the method has already been called. No actions are performed when AutoSizeDelayed returns <b>True</b>.
          </p>
          <p>
            DoAllAutoSize checks to ensure that a Handle has been allocated for the control, and that it and its Parent are Visible. If AutoSizing is not possible, the flag is removed from the control and its children and the method is exited.
          </p>
          <p>
            DoAllAutoSize calls the inherited method to change the bounds, invalidate the preferred size, and update flags for the control. RealizeBoundsRecursive is called to update the bounds for the all child controls. The child controls are made visible first, and then the current control instance.
          </p>
          <p>
            DoAllAutoSize is called from the AdjustSize and EnableAutoSizing methods.
          </p>
        </descr>
        <errors>
          <p>
            The inherited method raises an EInvalidOperation exception if Parent has not been assigned for the control.
          </p>
          <p>
            Raises a catchable exception when cfAutoSizeNeeded is already included in the control flags when the method is called.
          </p>
        </errors>
        <seealso>
          <link id="TControl.DoAllAutoSize"/>
          <link id="TControl.Parent"/>
          <link id="TControl.AutoSizingAll"/>
        </seealso>
      </element>

      <element name="TWinControl.AllAutoSized">
        <short>Called from DoAllAutoSize after all bounds are computed for the control.</short>
        <descr/>
        <seealso>
          <link id="#lcl.forms.TCustomForm.AllAutoSized">TCustomForm.AllAutoSized</link>
        </seealso>
      </element>

      <element name="TWinControl.CalculatePreferredSize">
        <short>
          Override this method to return a different preferred height and/or width for auto-sizing.
        </short>
        <descr>
          <p>
            Calls the inherited method to calculate the default / preferred width and height for a <var>TWinControl</var> instance. It is used by the LCL auto-sizing algorithms as the default size. Only positive values are valid. Negative or 0 (Zero) values are treated as undefined, and the LCL uses other values to perform auto-sizing.
          </p>
          <p>
            <var>TWinControl</var> overrides this:
          </p>
          <ul>
            <li>If there are child components, their total preferred size is calculated</li>
            <li>If this value cannot be computed (e.g. the children depend too much on their
              parent clientrect), then the interface is asked for the preferred size</li>
          </ul>
          <p>
            For example the preferred size of a <var>TButton</var> is the size, where the label fits exactly. This relies on the current theme and widgetset.
          </p>
          <p>
            This value is independent of constraints and siblings, only the inner parts are relevant for the calculates values.
          </p>
          <p>
            <var>WithThemeSpace</var> adds space for stacking when set to <b>True</b>. For example: <var>TRadioButton</var> has a minimum size. But for stacking multiple TRadioButtons there should be space around each control. This space is theme- dependent, so it is passed as a parameter to the widgetset.
          </p>
        </descr>
        <seealso>
          <link id="TControl.CalculatePreferredSize"/>
        </seealso>
      </element>
      <element name="TWinControl.CalculatePreferredSize.PreferredWidth">
        <short/>
      </element>
      <element name="TWinControl.CalculatePreferredSize.PreferredHeight">
        <short/>
      </element>
      <element name="TWinControl.CalculatePreferredSize.WithThemeSpace">
        <short>Indicates if additional space is reserved for theme services.</short>
      </element>

      <element name="TWinControl.GetPreferredSizeClientFrame">
        <short>Calculates the width and height for the frame area around the control.</short>
        <descr>
          <p>
            Calculated as follows:
          </p>
          <ul>
            <li>
              AWidth is the difference between Width and ClientWidth.
            </li>
            <li>
              AHeight is the difference between Height and ClientHeight.
            </li>
          </ul>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.GetPreferredSizeClientFrame.AWidth">
        <short>Width used for the frame around the control.</short>
      </element>
      <element name="TWinControl.GetPreferredSizeClientFrame.AHeight">
        <short>Height used for the frame around the control.</short>
      </element>

      <element name="TWinControl.GetChildren">
        <short>
          Calls the specified procedure for each child control with Root as the Owner.
        </short>
        <descr>
          <p>
            Iterates the value in Controls to locate any controls where Root is the Owner of the control  instance. Calls the procedure in Proc using the control instance as an argument. An application must implement an object procedure using the signature in TGetChildProc, and pass the procedure in the Proc argument.
          </p>
        </descr>
        <seealso>
        </seealso>
      </element>
      <element name="TWinControl.GetChildren.Proc">
        <short>The callback procedure.</short>
      </element>
      <element name="TWinControl.GetChildren.Root">
        <short>Owner of the controls passed to the procedure.</short>
      </element>

      <element name="TWinControl.ChildClassAllowed">
        <short>Checks whether the specified class type is allowed as a child control.</short>
        <descr>
          <p>
            ChildClassAllowed is an overridden method in TWinControl used to determine if instances of the class type in ClassType are allowed as child controls. Returns <b>True</b> if the specified  class type is allowed as a child control in the Controls property.
          </p>
          <p>
            In TWinControl, the return value is <b>True</b> when ChildClass has been assigned (not <b>Nil</b>) and the class type is derived from TControl.
          </p>
          <p>
            ChildClassAllowed does not call the inherited method which always returns <b>False</b>.
          </p>
          <p>
            ChildClassAllowed is called from the CheckChildClassAllowed method in TControl.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.Controls"/>
          <link id="TControl.CheckChildClassAllowed"/>
          <link id="TControl.Parent"/>
        </seealso>
      </element>
      <element name="TWinControl.ChildClassAllowed.Result">
        <short><b>True</b> when ChildClass is allowed in Controls.</short>
      </element>
      <element name="TWinControl.ChildClassAllowed.ChildClass">
        <short>Class type examined in the method.</short>
      </element>

      <element name="TWinControl.PaintControls">
        <short>Paints all child controls which do not have a Handle as part of their Parent.</short>
        <descr>
          <p>
            Controls which do <b>not</b> descend from <var>TWinControl</var> have no handle of their own; they are repainted when the parent control is redrawn.
          </p>
          <p>
            No actions are performed in the method when the device context in DC is unassigned (0),  the Handle has not been allocated for the control, or an internal TFPList has not been created to store the child controls in the Controls property.
          </p>
          <p>
            PaintControls tries to locate and paint controls (starting with the control in First) not derived from TWinControl. When First is omitted (<b>Nil</b>) or not found in the internal list, all child controls in the list are examined. The control must be Visible and within the visible client area on the Parent to be painted.
          </p>
          <p>
            Each eligible control is positioned on the device context using the Left and Top properties for the control. Its clipping rectangle is copied to the device context, and an LM_PAINT message is performed on the DC to redraw the parent control.
          </p>
          <p>
            The ControlState property is updated prior to and following the paint operation for each child control to include or exclude the csPaintCopy value.
          </p>
          <p>
            PaintControls is called from the PaintHandler method, and occurs when the WMPaint method handles an LM_PAINT message for a control.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.PaintControls.DC">
        <short>The device context usable for painting child controls.</short>
      </element>
      <element name="TWinControl.PaintControls.First">
        <short>First of the controls in Controls[], which remain to paint.</short>
      </element>

      <element name="TWinControl.PaintHandler">
        <short>Handler for TLMPaint, manages the painting of child controls.</short>
        <descr>
          <p>
            <var>PaintHandler</var> is a method used to apply the LM_PAINT window message in TheMessage to the client rectangle for the control. The device context in TheMessage is used as the target for the paint operation. If the device context is unassigned on entry, the BeginPaint routine in the LCL interface is called to get a device context for the Handle in the control.
          </p>
          <p>
            PaintHandler checks the list of child controls if any of the items are visible, opaque TControl class instances which need to be drawn using the Handle for the control. When found, a clipping rectangle for the child control is calculated on the device context.
          </p>
          <p>
            PaintHandler calls the PaintSite method in the DockManager (when assigned and enabled) to paint the DockSite to the device context. The  PaintControls method is called to force the all child controls to be painted to the device context.
          </p>
          <p>
            PaintHandler calls the EndPaint routine in the LCL interface to free the device context prior to exiting from the method.
          </p>
          <p>
            PaintHandler is called when the WMPaint method receives an LM_PAINT message for the control.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.PaintHandler.TheMessage">
        <short>LM_PAINT window message handled in the method.</short>
      </element>

      <element name="TWinControl.PaintWindow">
        <short>Paints a clipping region for the control on the specified device context.</short>
        <descr>
          <p>
            <var>PaintWindow</var> is a method used to paint a clipping region for the control (or a child control) to the device context in DC.
          </p>
          <p>
            PaintWindow creates a TLMessage instance using the LM_PAINT window message and the specified device context. The DefaultHandler method is called to pass the message to the widgetset class instance (and ultimately its message processing loop).
          </p>
          <p>
            No actions are performed in the method when DC is unassigned (<b>0</b>), the Handle for the control has not been allocated, or the control is being freed.
          </p>
          <p>
            PaintWindow is called from the PaintHandler method.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.PaintWindow.DC">
        <short>Device context with the requested clipping region.</short>
      </element>

      <element name="TWinControl.CreateBrush">
        <short>
          Creates the <link id="TWinControl.Brush">Brush</link>, if not already created.
        </short>
        <descr>
          <p>
            Creates and assigns a <var>TBrush</var> instance used in the <var>Brush</var> property. The brush Color is updated using the resolved value in the Color property. clDefault in Color causes the default brush color value from the widgetset to be used.
          </p>
          <p>
            CreateBrush is called when the value for the Brush property is read, and the member has not yet been assigned.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.Brush"/>
          <link id="TControl.Color"/>
          <link id="TControl.GetDefaultColor"/>
          <link id="#lcl.graphics.TBrush">TBrush</link>
        </seealso>
      </element>

      <element name="TWinControl.ScaleControls">
        <short>Scales values for all child controls.</short>
        <descr>
          <p>
            <var>ScaleControls</var> is a method used to scale the child controls in the Controls property using the specified multiplier and divisor. ScaleControls visits each of the class instances in Controls and calls its ChangeScale method using Multiplier and Divider as arguments.
          </p>
          <p>
            ScaleControls is called from the overridden ChangeScale method. This causes all controls in the hierarchy to apply the scaling factor to values in their Constraints, Font, Left, Top, Right and Bottom properties. For top-level Forms, the values in Left and Top are <b>not</b>  scaled.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.ChangeScale"/>
          <link id="TControl.ChangeScale"/>
          <link id="TControl.UpdateAnchorRules"/>
        </seealso>
      </element>
      <element name="TWinControl.ScaleControls.Multiplier">
        <short>Multiplier applied to a value to achieve a scaling factor.</short>
      </element>
      <element name="TWinControl.ScaleControls.Divider">
        <short>Divisor applied to a value to achieve a scaling factor.</short>
      </element>

      <element name="TWinControl.ChangeScale">
        <short>
          Scales (resizes) the control and all of its child controls.
        </short>
        <descr>
          <p>
            ChangeScale is an overridden method in TWinControl used to ensure that child controls are scaled using the values in the Multiplier and Divider arguments.
          </p>
          <p>
            ChangeScale extends the inherited method by calling DisableAlign before applying the scaling factor. It calls the ScaleControls method to apply Multiplier and Divider to the child controls. It calls the inherited method to apply  scaling to the Bounds, Constraints, and Font in the control.
          </p>
          <p>
            ChangeScale visits each of the control instances in Controls, and calls their UpdateAnchorRules method to update the BaseBounds in the control as needed.
          </p>
          <p>
            EnableAlign is called prior to exiting from the method.
          </p>
        </descr>
        <seealso>
          <link id="TControl.ChangeScale"/>
        </seealso>
      </element>
      <element name="TWinControl.ChangeScale.Multiplier">
        <short>Multiplier applied to a value to achieve a scaling factor.</short>
      </element>
      <element name="TWinControl.ChangeScale.Divider">
        <short>Divisor applied to a value to achieve a scaling factor.</short>
      </element>

      <element name="TWinControl.CMBiDiModeChanged">
        <short>
          Handles a CM_BIDIMODECHANGED control message for the control.
        </short>
        <descr>
          <p>
            CMBiDiModeChanged is an overridden method in TWinControl used to handle a CM_BIDIMODECHANGED control message received for the control. It calls the inherited method on entry to invalidate the control when needed. It extends the inherited method to notify child controls of the change using a CM_PARENTBIDIMODECHANGED message.
          </p>
          <p>
            If a handle has been allocated in the widgetset class instance, its SetBiDiMode method is called to reflect the values from UseRightToLeftAlignment, UseRightToLeftReading, and  UseRightToLeftScrollBar.
          </p>
          <p>
            AdjustSize is called to update the sizes for parent and child controls after the property value has been changed.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.CMBiDiModeChanged.Message">
        <short>Control message examined and handled in the method.</short>
      </element>

      <element name="TWinControl.CMBorderChanged">
        <short>
          Handles a CM_BORDERCHANGED message received for the control.
        </short>
        <descr>
          <p>
            <var>CMBorderChanged</var> ensures that the size and client rectangle are adjusted when a border is added to or removed from the control. It calls DoAdjustClientRectChange and AdjustSize to update values in the control. It calls Invalidate to force the control to be redrawn with the new size and client rectangle.
          </p>
        </descr>
      </element>
      <element name="TWinControl.CMBorderChanged.Message">
        <short>Control message examined and applied in the method.</short>
      </element>

      <element name="TWinControl.CMDoubleBufferedChanged">
        <short>Handler for changes to the DoubleBuffered property.</short>
        <descr>
          <p>
            <var>CMDoubleBufferedChanged</var> is the handler used to process <b>CM_PARENTDOUBLEBUFFEREDCHANGED</b> messages when the value in <var>DoubleBuffered</var> has been been changed.
          </p>
          <p>
            CMDoubleBufferedChanged calls <var>NotifyControls</var> to apply the message in the widgetset class; the value in the Message argument is ignored.
          </p>
          <p>
            CMDoubleBufferedChanged calls <var>Invalidate</var> to cause the control to be redrawn.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.DoubleBuffered"/>
          <link id="TWinControl.NotifyControls"/>
          <link id="TWinControl.Invalidate"/>
        </seealso>
      </element>
      <element name="TWinControl.CMDoubleBufferedChanged.Message">
        <short>Message examined in the method.</short>
      </element>

      <element name="TWinControl.CMEnabledChanged">
        <short>
          Handler for changed <link id="#lcl.Controls.TControl.Enabled">Enabled</link> message; notifies the widgetset.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.CMEnabledChanged.Message">
        <short/>
      </element>

      <element name="TWinControl.CMParentDoubleBufferedChanged">
        <short>
          Handles the CM_PARENTDOUBLEBUFFEREDCHANGED control message for the control (when enabled).
        </short>
        <descr>
          <p>
            Sets the value in ParentDoubleBuffered to <b>True</b>. When Parent is assigned, the value in DoubleBufferred is set to the corresponding value from the Parent control.
          </p>
          <p>
            No actions are performed in the method if ParentDoubleBuffered is already set to <b>False</b>.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.CMParentDoubleBufferedChanged.Message">
        <short>Message handled in the method.</short>
      </element>

      <element name="TWinControl.CMShowingChanged">
        <short>
          Handler for changed <link id="TWinControl.Showing">Showing</link> message; notifies the widgetset.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.CMShowingChanged.Message">
        <short/>
      </element>

      <element name="TWinControl.CMShowHintChanged">
        <short>
          Handler for changed <link id="TControl.ShowHint">ShowHint</link> message; notifies all child controls.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.CMShowHintChanged.Message">
        <short/>
      </element>

      <element name="TWinControl.CMVisibleChanged">
        <short>
          Handles Focus changes, and forces UpdateControlState.
        </short>
        <descr>
          Handler for changed <link id="TControl.Visible">Visible</link> message.
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.CMVisibleChanged.Message">
        <short/>
      </element>

      <element name="TWinControl.CMEnter">
        <short>Handles the CM_ENTER control message for the control.</short>
        <descr>
          <p>
            CM_ENTER and CM_EXIT messages occur when the active control is changed on a form.
          </p>
          <p>
            Calls DoEnter to signal the OnEnter event handler (when assigned).
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.DoEnter"/>
          <link id="TWinControl.OnEnter"/>
        </seealso>
      </element>
      <element name="TWinControl.CMEnter.Message">
        <short>Message handled in the method.</short>
      </element>

      <element name="TWinControl.CMExit">
        <short>Handles the CM_EXIT control message for the control.</short>
        <descr>
          <p>
            CM_ENTER and CM_EXIT messages occur when the active control is changed on a form.
          </p>
          <p>
            Calls DoExit to signal the OnExit event handler (when assigned).
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.DoExit"/>
          <link id="TWinControl.OnExit"/>
        </seealso>
      </element>
      <element name="TWinControl.CMExit.Message">
        <short/>
      </element>

      <element name="TWinControl.WMContextMenu">
        <short>
          Handler for an <link id="TControl.PopupMenu">ContextMenu</link> event; eventually delegates handling to the affected child control.
        </short>
        <descr>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.WMContextMenu.Message">
        <short/>
      </element>

      <element name="TWinControl.WMEraseBkgnd">
        <short>
          Erases the background, when required.
        </short>
        <descr/>
        <seealso>
          <link id="TWinControlFlag"/>
        </seealso>
      </element>
      <element name="TWinControl.WMEraseBkgnd.Message">
        <short/>
      </element>

      <element name="TWinControl.WMNotify">
        <short>Handles (dispatches) notification messages.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.WMNotify.Message">
        <short/>
      </element>

      <element name="TWinControl.WMSetFocus">
        <short>Handler for receiving Focus event.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.WMSetFocus.Message">
        <short/>
      </element>

      <element name="TWinControl.WMKillFocus">
        <short>Handles the LM_KILLFOCUS  message for the control.</short>
        <descr>
          <p>
            <var>WMKillFocus</var> is a method used to handle the LM_KILLFOCUS  control message  received when a control loses focus. WMKillFocus ensures that the <var>EditingDone</var> method is called for the control when the parent form has been assigned and is Active.
          </p>
          <p>
            No actions are performed in the method at design-time, or when the control is being freed.
          </p>
        </descr>
        <seealso>
          <link id="TControl.EditingDone"/>
          <link id="#lcl.forms.GetParentForm">GetParentForm</link>
        </seealso>
      </element>
      <element name="TWinControl.WMKillFocus.Message">
        <short>Message examined in the method.</short>
      </element>

      <element name="TWinControl.WMShowWindow">
        <short>Handler for changed visibility notification.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.WMShowWindow.Message">
        <short/>
      </element>

      <element name="TWinControl.WMEnter">
        <short>Handles the LM_ENTER message for the control.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.WMEnter.Message">
        <short>Message handled in the method.</short>
      </element>

      <element name="TWinControl.WMExit">
        <short>Handles the LM_EXIT message for the control.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.WMExit.Message">
        <short>Message handled in the method.</short>
      </element>

      <element name="TWinControl.WMKeyDown">
        <short>
          Event handler for a key press not handled by the widget; Tries <link id="TWinControl.DoRemainingKeyDown"/>
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.WMKeyDown.Message">
        <short/>
      </element>

      <element name="TWinControl.WMSysKeyDown">
        <short>
          Event handler for system key presses not handled by the widget; tries <link id="TWinControl.DoRemainingKeyDown"/>
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.WMSysKeyDown.Message">
        <short/>
      </element>

      <element name="TWinControl.WMKeyUp">
        <short>
          Event handler for key released, not handled by the widget. Tries <link id="TWinControl.DoRemainingKeyUp"/>.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.WMKeyUp.Message">
        <short/>
      </element>

      <element name="TWinControl.WMSysKeyUp">
        <short>
          Event handler for system key releases not handled by the widget; tries <link id="TWinControl.DoRemainingKeyUp"/>
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.WMSysKeyUp.Message">
        <short/>
      </element>

      <element name="TWinControl.WMChar">
        <short>
          Handler for messages sent by the widget, after it has handled the key press itself.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.WMChar.Message">
        <short/>
      </element>

      <element name="TWinControl.WMSysChar">
        <short>
          Handler for messages sent by the widget, after it has handled the key press itself.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.WMSysChar.Message">
        <short/>
      </element>

      <element name="TWinControl.WMPaint">
        <short>
          Manages paint requests, and handles double buffering.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.WMPaint.Msg">
        <short/>
      </element>

      <element name="TWinControl.WMDestroy">
        <short>
          Handler for widget destroyed message; clears the Handle.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.WMDestroy.Message">
        <short/>
      </element>

      <element name="TWinControl.WMMove">
        <short>
          Handler for widget moved message; updates the Bounds.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.WMMove.Message">
        <short/>
      </element>

      <element name="TWinControl.WMSize">
        <short>
          Event handler for size messages.
        </short>
        <descr>
          <p>
            This method is called whenever <var>Width</var>, <var>Height</var>, <var>ClientWidth</var> or <var>ClientHeight</var> have changed. If the source of the message is the interface, the new size is stored in the internal BoundsRealized member to avoid sending a size message back to the interface.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.WMSize.Message">
        <short/>
      </element>

      <element name="TWinControl.WMWindowPosChanged">
        <short>
          Event handler for size/move messages.
        </short>
        <descr>
          <p>
            This method is called whenever left, top, width, height, clientwidth or clientheight have changed.
          </p>
          <p>
            If the source of the message is the interface, the new size is stored in the internal BoundsRealized member. Avoids sending a size message back to the interface.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.WMWindowPosChanged.Message">
        <short/>
      </element>

      <element name="TWinControl.CNKeyDown">
        <short>
          Handler for a key pushed notification; the message is handled by DoKeyDownBeforeInterface by default.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.CNKeyDown.Message">
        <short/>
      </element>

      <element name="TWinControl.CNSysKeyDown">
        <short>
          Handler for a system key pushed notification; the message is handled by DoKeyDownBeforeInterface by default.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.CNSysKeyDown.Message">
        <short/>
      </element>

      <element name="TWinControl.CNKeyUp">
        <short>
          Handler for a key released notification; the message is handled by DoKeyUpBeforeInterface by default.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.CNKeyUp.Message">
        <short/>
      </element>

      <element name="TWinControl.CNSysKeyUp">
        <short>
          Handler for a system key released notification; the message is handled by DoKeyUpBeforeInterface by default.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.CNSysKeyUp.Message">
        <short/>
      </element>

      <element name="TWinControl.CNChar">
        <short>
          Handler for a key pressed notification; CNChar is sent by the widget before it has handled the key press itself.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.CNChar.Message">
        <short/>
      </element>

      <element name="TWinControl.DoDragMsg">
        <short>Dispatches a drag message, sent by the DragManager.</short>
        <descr>
          <p>
            On dmFindTarget, a TWinControl returns the child control under the mouse, or Self if none is found.
          </p>
          <p>
            All other messages are handled by the inherited <link id="TControl.DoDragMsg"/> method.
          </p>
        </descr>
        <seealso>
          <link id="TControl.DoDragMsg"/>
        </seealso>
      </element>
      <element name="TWinControl.DoDragMsg.Result">
        <short/>
      </element>
      <element name="TWinControl.DoDragMsg.ADragMessage">
        <short/>
      </element>
      <element name="TWinControl.DoDragMsg.APosition">
        <short/>
      </element>
      <element name="TWinControl.DoDragMsg.ADragObject">
        <short/>
      </element>
      <element name="TWinControl.DoDragMsg.ATarget">
        <short/>
      </element>
      <element name="TWinControl.DoDragMsg.ADocking">
        <short/>
      </element>

      <element name="TWinControl.DoDockClientMsg">
        <short>
          Handles a dmDragDock message, when a control has been docked to this site.
        </short>
        <descr>
          <p>
            Called when a control is dropped for docking. Asks the dropped control to Dock itself into this control (adjust HostDockSite etc.). Calls an installed DockManager to adjust the coordinates of the docked control. The Result is always <b>True</b> (unless overridden).
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.DoDockClientMsg.Result">
        <short/>
      </element>
      <element name="TWinControl.DoDockClientMsg.DragDockObject">
        <short/>
      </element>
      <element name="TWinControl.DoDockClientMsg.aPosition">
        <short/>
      </element>

      <element name="TWinControl.DoUndockClientMsg">
        <short>
          Notifies the DockManager of the undock of a client control.
        </short>
        <descr/>
        <seealso>
          <link id="TDockManager.RemoveControl"/>
        </seealso>
      </element>
      <element name="TWinControl.DoUndockClientMsg.Result">
        <short>Always <b>True</b>.</short>
      </element>
      <element name="TWinControl.DoUndockClientMsg.NewTarget">
        <short/>
      </element>
      <element name="TWinControl.DoUndockClientMsg.Client">
        <short/>
      </element>

      <element name="TWinControl.DoAddDockClient">
        <short>Adjust the Parent of a newly docked Client.</short>
        <descr>
          The default action is to set the Parent to the new docksite (this control), so that the client is displayed within the new site.
        </descr>
      </element>
      <element name="TWinControl.DoAddDockClient.Client">
        <short/>
      </element>
      <element name="TWinControl.DoAddDockClient.ARect">
        <short/>
      </element>

      <element name="TWinControl.DockOver">
        <short>Called to check whether this control allows docking and where.
        </short>
        <descr>
          <p>
            Called for messages from the DragManager including: dmEnter, dmLeave, and dmMove. Gets the DockRect to show.
          </p>
          <p>
            Positions the DockRect, and invokes OnDockOver (via DoDockOver).
          </p>
          <p>
            Everything can be overridden using the OnDockOver handler, when assigned.
          </p>
        </descr>
        <seealso>
          <link id="TControl.PositionDockRect"/>
          <link id="TWinControl.OnDockOver"/>
        </seealso>
      </element>
      <element name="TWinControl.DockOver.Source">
        <short/>
      </element>
      <element name="TWinControl.DockOver.X">
        <short/>
      </element>
      <element name="TWinControl.DockOver.Y">
        <short/>
      </element>
      <element name="TWinControl.DockOver.State">
        <short/>
      </element>
      <element name="TWinControl.DockOver.Accept">
        <short>Initially <b>True</b>, set to <b>False</b> to reject an drop.</short>
      </element>

      <element name="TWinControl.DoDockOver">
        <short>Invoke the <link id="TWinControl.OnDockOver">OnDockOver</link> handler.</short>
      </element>
      <element name="TWinControl.DoDockOver.Source">
        <short/>
      </element>
      <element name="TWinControl.DoDockOver.X">
        <short/>
      </element>
      <element name="TWinControl.DoDockOver.Y">
        <short/>
      </element>
      <element name="TWinControl.DoDockOver.State">
        <short/>
      </element>
      <element name="TWinControl.DoDockOver.Accept">
        <short/>
      </element>

      <element name="TWinControl.DoRemoveDockClient">
        <short>
          Override this method to take special actions on removal of an docked client.
        </short>
        <descr>The default implementation does nothing.</descr>
      </element>
      <element name="TWinControl.DoRemoveDockClient.Client">
        <short/>
      </element>

      <element name="TWinControl.DoUnDock">
        <short>
          Notifies an <var>OnUnDock</var> handler and the <var>DockManager</var> of an undocked client control.
        </short>
        <descr>
          <p>
            The <var>OnUnDock</var> handler can deny the undocking request for the control. This can cause problems; instead, the control better should not be draggable.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.DoUndockClientMsg"/>
          <link id="TWinControl.OnUnDock"/>
        </seealso>
      </element>
      <element name="TWinControl.DoUnDock.Result">
        <short>Set to <b>False</b> to deny undocking.</short>
      </element>
      <element name="TWinControl.DoUnDock.NewTarget">
        <short>The new docksite, <b>Nil</b> for floating.</short>
      </element>
      <element name="TWinControl.DoUnDock.Client">
        <short>The control being undocked.</short>
      </element>
      <element name="TWinControl.DoUnDock.KeepDockSiteSize">
        <short/>
      </element>

      <element name="TWinControl.GetSiteInfo">
        <short>Return information about this dock site (InfluenceRect).</short>
        <descr>
          <p>
            The <var>InfluenceRect</var> determines the screen coordinates, within which a drop is accepted. The <var>InfluenceRect</var> is the slightly inflated <var>WindowRect</var> for the dock site, and can be adjusted in the  <var>OnGetSiteInfo</var> event handler.
          </p>
        </descr>
      </element>
      <element name="TWinControl.GetSiteInfo.Client">
        <short>The dragged control.</short>
      </element>
      <element name="TWinControl.GetSiteInfo.InfluenceRect">
        <short>The screen rectangle within which a drop is allowed.</short>
      </element>
      <element name="TWinControl.GetSiteInfo.MousePos">
        <short>The current mouse position.</short>
      </element>
      <element name="TWinControl.GetSiteInfo.CanDock">
        <short>Can be set to <b>False</b> to reject an drop.</short>
      </element>

      <element name="TWinControl.GetParentHandle">
        <short>Gets the handle for the Parent control.</short>
        <descr>
          <p>
            <var>GetParentHandle</var> is a <var>HWND</var> function used to get the handle for the Parent in the current control. The return value contains the handle for the TWinControl instance in Parent (when assigned). When unassigned, the handle in ParentWindow is used as the return value.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Parent"/>
          <link id="TWinControl.ParentWindow"/>
        </seealso>
      </element>
      <element name="TWinControl.GetParentHandle.Result">
        <short>Control or window handle that is the parent for the current control.</short>
      </element>

      <element name="TWinControl.GetTopParentHandle">
        <short>
          Gets the window handle for the parent control at the top of the control hierarchy.
        </short>
        <descr>
          <p>
            GetTopParentHandle is a HWND function used to get the window handle for the first control in the parent control hierarchy. The value in Parent is recursively searched until Parent is not assigned.
          </p>
          <p>
            The return value is the ParentWindow property in the top-most control. If ParentWindow is 0 (the unassigned value), the value in its Handle property is used.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.GetTopParentHandle.Result">
        <short>Window handle for the top-most parent control in the hierarchy.</short>
      </element>

      <element name="TWinControl.ReloadDockedControl">
        <short>Returns the docked control of the specified name.</short>
        <descr>
          <p>This method is used during the restore of the layout of a docksite.</p>
          <p>The control is searched in the controls owned by the owner of the docksite.</p>
          <p>Override to search other places, or to create a control of the requested name.</p>
        </descr>
      </element>
      <element name="TWinControl.ReloadDockedControl.AControlName">
        <short>The name of the control to be docked.</short>
      </element>
      <element name="TWinControl.ReloadDockedControl.AControl">
        <short>The matching control.</short>
      </element>

      <element name="TWinControl.CreateDockManager">
        <short>Returns the DockManager for this control.</short>
        <descr>
          <p>
            If DockManager is <b>Nil</b>, and <var>UseDockManager</var> is <b>True</b>, a new default DockManager is created.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.CreateDockManager.Result">
        <short>The dockmanager for this site, can be <b>Nil</b> for an unmanaged site.</short>
      </element>

      <element name="TWinControl.SetDockManager">
        <short>Sets the value for the DockManager property.</short>
        <descr/>
        <seealso>
          <link id="TWinControl.DockManager"/>
        </seealso>
      </element>
      <element name="TWinControl.SetDockManager.AMgr">
        <short>New value for the DockManager property.</short>
      </element>

      <element name="TWinControl.DoFloatMsg">
        <short>Handler called when the control starts floating.</short>
        <descr>
          <p>
            A TWinControl can be floated as a stand-alone window, unless they request a special FloatingDockSiteClass.
          </p>
        </descr>
        <seealso>
          <link id="TControl.DoFloatMsg"/>
        </seealso>
      </element>
      <element name="TWinControl.DoFloatMsg.ADockSource">
        <short/>
      </element>

      <element name="TWinControl.DoGetDockCaption">
        <short>Returns the dock caption in AControl.</short>
        <descr>
          <p>
            Asks the control for its default dock caption, then allows the OnGetDockCaption handler to adjust the string value.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.GetDockCaption"/>
          <link id="TWinControl.OnGetDockCaption"/>
        </seealso>
      </element>
      <element name="TWinControl.DoGetDockCaption.AControl">
        <short>The control whose dock caption string is requested.</short>
      </element>
      <element name="TWinControl.DoGetDockCaption.ACaption">
        <short>The dock caption to use.</short>
      </element>

      <element name="TWinControl.DoEnter">
        <short>Signals the OnEnter event handler (when assigned) when the control receives focus.</short>
        <descr>
          <p>
            <var>DoEnter</var> is called from the CMEnter method when a CM_ENTER message is received for the control. The event handler allows actions to be performed when the control receives focus, either by using keyboard navigation or by mouse click in the client area for the control.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.OnEnter"/>
          <link id="TWinControl.CMEnter"/>
          <link id="TWinControl.DoExit"/>
          <link id="TWinControl.OnExit"/>
        </seealso>
      </element>

      <element name="TWinControl.DoExit">
        <short>Signals the OnExit event handler (when assigned) when the control loses focus.</short>
        <descr>
          <p>
            <var>DoExit</var> is called from the CMExit method when a CM_EXIT message is received for the control. The event handler allows actions to be performed when the control loses focus, either by using keyboard navigation or by mouse click in the client area for another control.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.OnExit"/>
          <link id="TWinControl.CMExit"/>
          <link id="TWinControl.DoEnter"/>
          <link id="TWinControl.OnEnter"/>
        </seealso>
      </element>

      <element name="TWinControl.DoKeyDownBeforeInterface">
        <short>Handles a KeyDown event before the widget processes the key.
        </short>
        <descr>
          <p>
            Key event handlers are invoked in sequence, until a handler is located which responds to the key.
          </p>
          <p>
            First, all application wide handlers are invoked (<var>TApplication.NotifyKeyDownBeforeHandler</var>).
          </p>
          <p>
            Second, the form handler is invoked when KeyPreview is requested.
          </p>
          <p>
            Third, the DragManager is used to determine the dragging status for the control. It interprets the <b>ESC</b> key as a cancel dragging request, and the <b>CTRL</b> key as a request to ignore drag targets.
          </p>
          <p>
            Finally, the <link id="TWinControl.OnKeyDown"/> user handler is invoked.
          </p>
          <p>
            If none of the  handlers accept / respond to the key, the widgetset class is used to process  the key.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.OnKeyDown"/>
          <link id="#lcl.Forms.TApplication.NotifyKeyDownBeforeHandler">
            TApplication.NotifyKeyDownBeforeHandler</link>
        </seealso>
      </element>
      <element name="TWinControl.DoKeyDownBeforeInterface.Result">
        <short>Set to <b>True</b> when the key was handled.</short>
      </element>
      <element name="TWinControl.DoKeyDownBeforeInterface.Message">
        <short>Message examined in the method.</short>
      </element>
      <element name="TWinControl.DoKeyDownBeforeInterface.IsRecurseCall">
        <short/>
      </element>

      <element name="TWinControl.DoRemainingKeyDown">
        <short>
          Handles key down messages which are not handled by the widget.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.DoRemainingKeyDown.Result">
        <short><b>True</b> if the key was handled.</short>
      </element>
      <element name="TWinControl.DoRemainingKeyDown.Message">
        <short/>
      </element>

      <element name="TWinControl.DoRemainingKeyUp">
        <short>
          Handles key up messages which are not handled by the widget.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.DoRemainingKeyUp.Result">
        <short><b>True</b> if the key was handled.</short>
      </element>
      <element name="TWinControl.DoRemainingKeyUp.Message">
        <short/>
      </element>

      <element name="TWinControl.DoKeyPress">
        <short>
          Performs actions needed to handle a key press message for the control.
        </short>
        <descr>
          <p>
            <var>DoKeyPress</var> is a <var>Boolean</var> function used to handle a key press event received for the control. The return value is <b>True</b> if the character code in the specified Message is handled for the control.
          </p>
          <p>
            DoKeyPress allows a TCustomForm instance in Parent with KeyPreview enabled to handle the notification message using its DoKeyPress method. If the character code is handled, the return value is set and no further actions are performed in the method.
          </p>
          <p>
            The return value is <b>False</b> when standard events have been disabled by including csNoStdEvents in the ControlStyle property.
          </p>
          <p>
            When not disabled, the KeyPress method is called using the character code in Message as an argument. If the character was handled in the OnKeyPress event handler, the return value is <b>True</b>.
          </p>
          <p>
            DoKeyPress is called from the CNChar method when a CN_CHAR control notification message is received for the control.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.OnKeyPress"/>
          <link id="TWinControl.OnUTF8KeyPress"/>
          <link id="TWinControl.DoUTF8KeyPress"/>
          <link id="TWinControl.CNChar"/>
          <link id="TControl.ControlStyle"/>
        </seealso>
      </element>
      <element name="TWinControl.DoKeyPress.Result">
        <short><b>True</b> if the key press was handled for the control.</short>
      </element>
      <element name="TWinControl.DoKeyPress.Message">
        <short>Control Notification message handled in the method.</short>
      </element>

      <element name="TWinControl.DoUTF8KeyPress">
        <short>
          Performs actions needed to handle a UTF-8-encoded key press message for the control.
        </short>
        <descr>
          <p>
            <var>DoUTF8KeyPress</var> is a <var>Boolean</var> function used to handle a key press event for a UTF-8-encoded value received for the control. The return value is <b>True</b> if the character code in the specified Message is handled for the control.
          </p>
          <p>
            DoUTF8KeyPress allows a TCustomForm instance in Parent with KeyPreview enabled to handle the notification message using its DoUTF8KeyPress method. If the character code is handled, the return value is set and no further actions are performed in the method.
          </p>
          <p>
            The return value is <b>False</b> when standard events have been disabled by including csNoStdEvents in the ControlStyle property.
          </p>
          <p>
            When not disabled, the UTF8KeyPress method is called using the character code in Message as an argument. If the character was handled in the OnUTF8KeyPress event handler, the return value is <b>True</b>.
          </p>
          <p>
            At design-time, DoUTF8KeyPress redirects the key event to the active design surface in the Lazarus IDE.
          </p>
          <p>
            DoUTF8KeyPress is called from the IntfUTF8KeyPress method when a CN_CHAR control notification message is received for the control. DoUTF8KeyPress is called after KeyDown has been executed.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.OnUTF8KeyPress"/>
          <link id="TWinControl.IntfUTF8KeyPress"/>
          <link id="TWinControl.OnKeyPress"/>
          <link id="TWinControl.DoKeyPress"/>
          <link id="TWinControl.CNChar"/>
          <link id="TControl.ControlStyle"/>
        </seealso>
      </element>
      <element name="TWinControl.DoUTF8KeyPress.Result">
        <short><b>True</b> if the key was handled.</short>
      </element>
      <element name="TWinControl.DoUTF8KeyPress.UTF8Key">
        <short>UTF-8-encoded character examined in the method.</short>
      </element>

      <element name="TWinControl.DoKeyUpBeforeInterface">
        <short>
          Handles a KeyUp event before the widget processes the key.
        </short>
        <descr>
          <p>
            For details, see the <link id="TWinControl.DoKeyDownBeforeInterface"/> method.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.DoKeyUpBeforeInterface.Result">
        <short><b>True</b> if the key was handled.</short>
      </element>
      <element name="TWinControl.DoKeyUpBeforeInterface.Message">
        <short>Message examined in the method.</short>
      </element>

      <element name="TWinControl.ChildKey">
        <short>Allows a parent form to process a keyboard message in one of its child controls.</short>
        <descr>
          <remark>
            WantChildKey in TCustomForm always returns <b>False</b>.
          </remark>
        </descr>
        <seealso>
          <link id="TWinControl.DoRemainingKeyDown"/>
          <link id="#lcl.forms.TCustomForm.WantChildKey"/>
        </seealso>
      </element>
      <element name="TWinControl.ChildKey.Result">
        <short><b>True</b> if the key message was handled.</short>
      </element>
      <element name="TWinControl.ChildKey.Message">
        <short>Child key message handled in the method.</short>
      </element>

      <element name="TWinControl.SendDialogChar">
        <short>
          Forwards the key message to the parent form to be handled as an accelerator (shortcut) key.
        </short>
        <descr>
          <p>
            No actions are performed in the method when accelerator keys are not enabled for the LCL interface, or when ParentForm is unassigned for the control.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.SendDialogChar.Result">
        <short><b>True</b> if the key was handled.</short>
      </element>
      <element name="TWinControl.SendDialogChar.Message">
        <short/>
      </element>

      <element name="TWinControl.DialogChar">
        <short>Handles the specified key in Message as an accelerator or shortcut  key.</short>
        <descr>
          <p>
            DialogChar is an overridden Boolean function in TWinControl used to handle a character code in Message as an accelerator (or shortcut) key for a control. It re-implements the inherited method which always returns False. In TWinControl, the Message is sent to each of the children in Controls until one of them indicates that it responds to the accelerator key.
          </p>
          <p>
            DialogChar is overridden in descendent classes to perform actions needed when the shortcut key is handled in the method. These classes allow the accelerator key to be defined using the Caption or Shortcut properties. Some examples include:
          </p>
          <ul>
            <li>TCustomGrid  / TGrid</li>
            <li>TCustomButton / TButton</li>
            <li>TCustomLabel / TLabel</li>
            <li>TCustomStaticText / TStaticText</li>
            <li>TCustomSpeedButton / TSpeedButton</li>
          </ul>
        </descr>
        <seealso>
          <link id="#lcl.controls.TControl.DialogChar">TControl.DialogChar</link>
        </seealso>
      </element>
      <element name="TWinControl.DialogChar.Result">
        <short><b>True</b> if the key was handled.</short>
      </element>
      <element name="TWinControl.DialogChar.Message">
        <short>Message with the character examined in the method.</short>
      </element>

      <element name="TWinControl.ControlKeyDown">
        <short>Handles key down events for special navigation keys used in a control.</short>
        <descr>
          <p>
            <var>ControlKeyDown</var> is a method used to detect and handle key down events for navigation keys used in the control. ControlKeyDown calls the corresponding method in TApplication to determine the actions needed for the key and modifier. The application handles Tab and cursor  keys which may affect control or form focus.
          </p>
          <p>
            ControlKeyDown is called from the DoRemainingKeyDown method to handle keys not otherwise handled by a control or its parent forms.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.DoRemainingKeyDown"/>
          <link id="#lcl.forms.TApplication.ControlKeyDown">TApplication.ControlKeyDown</link>
          <link id="#lcl.forms.TApplication.DoTabKey">TApplication.DoTabKey</link>
          <link id="#lcl.forms.TApplication.DoArrowKey">TApplication.DoArrowKey</link>
        </seealso>
      </element>
      <element name="TWinControl.ControlKeyDown.Key">
        <short>Numeric key code examined in the method.</short>
      </element>
      <element name="TWinControl.ControlKeyDown.Shift">
        <short>Shift, Ctrl, or Alt modifier for the key.</short>
      </element>

      <element name="TWinControl.ControlKeyUp">
        <short>Handles key up events for special navigation keys.</short>
        <descr>
          <p>
            <var>ControlKeyUp</var> is a method used to detect and handle key up events for navigation keys used in the control. ControlKeyUp calls the corresponding method in TApplication to determine the actions needed for the key and modifier. The application handles Return (Enter) and Escape keys which may affect control or form focus.
          </p>
          <p>
            ControlKeyUp is called from the DoRemainingKeyUp method to handle keys not otherwise handled by a control or its parent forms.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.DoRemainingKeyUp"/>
          <link id="#lcl.forms.TApplication.ControlKeyUp">TApplication.ControlKeyUp</link>
          <link id="#lcl.forms.TApplication.DoReturnKey">TApplication.DoReturnKey</link>
          <link id="#lcl.forms.TApplication.DoEscapeKey">TApplication.DoEscapeKey</link>
        </seealso>
      </element>
      <element name="TWinControl.ControlKeyUp.Key">
        <short>Numeric key code examined in the method.</short>
      </element>
      <element name="TWinControl.ControlKeyUp.Shift">
        <short>Shift, Ctrl, or Alt modifier for the key.</short>
      </element>

      <element name="TWinControl.KeyDown">
        <short>Signals the OnKeyDown event handler (when assigned).</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.KeyDown.Key">
        <short>Numeric key code examined in the method.</short>
      </element>
      <element name="TWinControl.KeyDown.Shift">
        <short>Shift, Ctrl, or Alt modifier for the key.</short>
      </element>

      <element name="TWinControl.KeyDownBeforeInterface">
        <short>
            Lets the application, parent forms, or control handle key preview before the LCL interface.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.KeyDownBeforeInterface.Key">
        <short>Numeric key code examined in the method.</short>
      </element>
      <element name="TWinControl.KeyDownBeforeInterface.Shift">
        <short>Shift, Ctrl, or Alt modifier for the key.</short>
      </element>

      <element name="TWinControl.KeyDownAfterInterface">
        <short>An empty implementation in the current LCL version.</short>
        <descr>
          <p>
            An empty implementation in the current LCL version.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.KeyDownAfterInterface.Key">
        <short/>
      </element>
      <element name="TWinControl.KeyDownAfterInterface.Shift">
        <short/>
      </element>

      <element name="TWinControl.KeyPress">
        <short>Signals the OnKeyPress event handler (when assigned).</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.KeyPress.Key">
        <short>Character value for the key press event.</short>
      </element>

      <element name="TWinControl.KeyUp">
        <short>Signals the OnKeyUp event handler (when assigned).</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.KeyUp.Key">
        <short>Numeric key code for the key up event.</short>
      </element>
      <element name="TWinControl.KeyUp.Shift">
        <short>Shift, Ctrl, or Alt modifier for the key.</short>
      </element>

      <element name="TWinControl.KeyUpBeforeInterface">
        <short>
          Invokes the <link id="#lcl.Controls.TWinControl.OnKeyUp">OnKeyUp</link> handler.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.KeyUpBeforeInterface.Key">
        <short/>
      </element>
      <element name="TWinControl.KeyUpBeforeInterface.Shift">
        <short/>
      </element>

      <element name="TWinControl.KeyUpAfterInterface">
        <short>An empty implementation in the current LCL version.</short>
        <descr>
          <p>
            An empty implementation in the current LCL version.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.KeyUpAfterInterface.Key">
        <short/>
      </element>
      <element name="TWinControl.KeyUpAfterInterface.Shift">
        <short/>
      </element>

      <element name="TWinControl.UTF8KeyPress">
        <short>Signals the OnUTF8KeyPress event handler (when assigned).</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.UTF8KeyPress.UTF8Key">
        <short>UTF-8-encoded character value for the key press event.</short>
      </element>

      <element name="TWinControl.FindNextControl">
        <short>Returns the preceding or next control in the tab order.</short>
        <descr>
          <p>
            When <var>CurrentControl</var> is <b>Nil</b>, the first control (forward) or last control (backward) in the TabOrder is returned; direction depends on the value in <var>GoForward</var>.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.FindNextControl.Result">
        <short>The (next) control.</short>
      </element>
      <element name="TWinControl.FindNextControl.CurrentControl">
        <short>
          The control which has the focus. If Nil, the first control (forward) or last control (backward) in TabOrder is returned, depending on GoForward.
        </short>
      </element>
      <element name="TWinControl.FindNextControl.GoForward">
        <short> <b>False</b> to find the preceding control.</short>
      </element>
      <element name="TWinControl.FindNextControl.CheckTabStop">
        <short>When <b>True</b> only a control with TabStop enabled is found.</short>
      </element>
      <element name="TWinControl.FindNextControl.CheckParent">
        <short>When <b>True</b> only a control with Parent set to Self is found.</short>
      </element>

      <element name="TWinControl.SelectFirst">
        <short>Returns the first control in the tab order for the parent form.</short>
        <descr/>
        <seealso/>
      </element>

      <element link="#lcl.controls.TControl.RealGetText" name="TWinControl.RealGetText"/>
      <element name="TWinControl.RealGetText.Result">
        <short/>
      </element>

      <element name="TWinControl.GetBorderStyle">
        <short>Gets the value for the BorderStyle property.</short>
        <descr/>
        <seealso>
          <link id="TWinControl.BorderStyle"/>
        </seealso>
      </element>
      <element name="TWinControl.GetBorderStyle.Result">
        <short>Value for the BorderStyle property.</short>
      </element>

      <element name="TWinControl.GetClientOrigin">
        <short>Gets the top, left screen coordinates for the client area in the control.</short>
        <descr>
        </descr>
        <seealso>
          <link id="#lcl.controls.TControl.GetClientOrigin">TControl.GetClientOrigin</link>
        </seealso>
      </element>
      <element name="TWinControl.GetClientOrigin.Result">
        <short>
          TPoint instance with the screen coordinates for the origin of the control.
        </short>
      </element>

      <element name="TWinControl.GetClientRect">
        <short>Gets the value for the ClientRect property.</short>
        <descr>
          <p>
            <var>GetClientRect</var> is an overridden method in TWinControl used to get the value for the ClientRect property. ClientRect contains the visual client area for the control.
          </p>
          <p>
            GetClientRect extends the inherited method to synchronize values in the control with its widgetset class instance using the Handle for the control. It uses values in ComponentState and the control flags for the TWinControl instance to determine the actions needed in the method. If an action cannot be determined, or the handle is not available, values in ClientWidth and ClientHeight are used as the Width and Height in the TRect instance.
          </p>
        </descr>
        <seealso>
          <link id="#lcl.controls.TControl.GetClientRect">TControl.GetClientRect</link>
        </seealso>
      </element>
      <element name="TWinControl.GetClientRect.Result">
        <short>Value for the ClientRect property.</short>
      </element>

      <element name="TWinControl.GetControlOrigin">
        <short>Gets the value for the ControlOrigin property.</short>
        <descr>
          <p>
            <var>GetControlOrigin</var> is overridden in TWinControl to get a window rectangle from the LCL interface. If the Handle for the control has not been allocated, the inherited method is called.
          </p>
          <p>
            Returns the screen coordinates for the Top and Left coordinate 0,0 of the control area. (The top / left pixel of the control on the screen). Note that this value is the position as stored in the interface and is not always in sync with the LCL. When a control is moved, the LCL sets the bounds to the wanted position and sends a move message to the interface. It is up to the interface to handle moves instantly or to queue them.
          </p>
        </descr>
        <seealso>
          <link id="#lcl.controls.TControl.GetControlOrigin">TControl.GetControlOrigin</link>
        </seealso>
      </element>
      <element name="TWinControl.GetControlOrigin.Result">
        <short>TPoint instance with the screen coordinates for the Top and Left properties.</short>
      </element>

      <element name="TWinControl.GetDeviceContext">
        <short>Gets the device context for the control.</short>
        <descr>
          <p>
            <var>GetDeviceContext</var> is an overridden <var>HDC</var> function in TWinControl used to get the device context used for the control.
          </p>
          <p>
            The device context provides a Handle (yes another one) with information about the drawing region on a display or printer. In the LCL, this essentially identifies a clipping rectangle for a given window handle. In TControl, the device context for the WindowHandle in the Parent control is used (because it does not have its own handle). In TWinControl, the Handle for the control is used.
          </p>
          <p>
            GetDevice context calls the GetDC routine in the LCL interface to get a device context for the value in its Handle property. On successful completion of the routine, the return value is also assigned to the WindowHandle argument (which is the member for the WindowHandle property for display purposes).
          </p>
          <p>
            An EOutOfResources exception is raised when GetDC returns an unassigned device context (0).
          </p>
          <p>
            GetDeviceContext re-implements the inherited method.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.GetDeviceContext.Result">
        <short>Device context created for the control, or 0 when unavailable.</short>
      </element>
      <element name="TWinControl.GetDeviceContext.WindowHandle">
        <short>Handle for the control represented in the device context. Updated in the method.</short>
      </element>

      <element name="TWinControl.GetParentBackground">
        <short>Gets the value for the ParentBackground property.</short>
        <descr/>
        <seealso>
          <link id="TWinControl.ParentBackground"/>
        </seealso>
      </element>
      <element name="TWinControl.GetParentBackground.Result">
        <short>Value for the property.</short>
      </element>

      <element name="TWinControl.IsControlMouseMsg">
        <short>Sends the mouse message to a child control.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.IsControlMouseMsg.Result">
        <short><b>True</b> if a child control was found at the mouse coordinates.</short>
      </element>
      <element name="TWinControl.IsControlMouseMsg.TheMessage">
        <short/>
      </element>

      <element name="TWinControl.CreateHandle">
        <short>Creates the Handle for the widget, if not already created.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.CreateParams">
        <short>
          Initializes the window creation parameter record with the settings for the control.
        </short>
        <descr>
          <p>
            <var>CreateParams</var> is a procedure used to initialize and/or update creation parameters in the <var>Params</var> argument. CreateParams is called from the <var>CreateWnd</var> method when the window handle is allocated for the control.
          </p>
          <p>
            CreateParams ensures that values in the <var>TCreateParams</var> record instance contain the values needed for the class instance. The following members in the record are update:
          </p>
          <dl>
            <dt>Caption</dt>
            <dd>Set to the value in the Caption property.</dd>
            <dt>Style</dt>
            <dd>
              Includes flag values: WS_CHILD, WS_CLIPSIBLINGS, WS_CLIPCHILDREN, and WS_TABSTOP when needed.
            </dd>
            <dt>ExStyle</dt>
            <dd>Includes style values needed for the value in ControlStyle and BorderStyle.</dd>
            <dt>WndParent</dt>
            <dd>Set to the handle in ParentWindow, or Parent.Handle when assigned.</dd>
            <dt>X, Y, Width, Height</dt>
            <dd>Set to the property values in the class instance.</dd>
          </dl>
        </descr>
        <seealso>
          <link id="TWinControl.CreateWnd"/>
          <link id="#lcl.lcltype.TCreateParams">TCreateParams</link>
        </seealso>
      </element>
      <element name="TWinControl.CreateParams.Params">
        <short>Create parameters updated in the method.</short>
      </element>

      <element name="TWinControl.CreateWnd">
        <short>Creates the interface object (widget) and assigns the value in Handle.</short>
        <descr>
          <p>
            Raises a catchable debugger exception for various conditions, including:
          </p>
          <ul>
            <li>
              The control, or its <var>Parent</var>, has the value <var>csDestroying</var> in the <var>ComponentState</var> property.
            </li>
            <li>
              The method has been called recursively, as indicated by values in the window control flags.
            </li>
            <li>
              The method has been called at run-time before LCL component streaming has been completed.
            </li>
            <li>
              The <var>Handle</var> was not successfully created in the widgetset class.
            </li>
          </ul>
          <p>
            Ensures that the realized bounds for the control is reset prior to creating the Handle for the control and any child <var>Controls</var>. An <var>EInvalidOperation</var> exception is raised if the handle for the Parent control is not valid when the method is called.
          </p>
          <p>
            Calls the <var>InvalidatePreferredSize</var> method for the control, and any child controls, and calls <var>AdjustSize</var>. If an error occurred while creating the Handle, auto-sizing is not enabled for the control.
          </p>
          <p>
            CreateWnd is called from the <var>CreateHandle</var> method.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.CreateHandle"/>
        </seealso>
      </element>

      <element name="TWinControl.DestroyHandle">
        <short>Destroys the handle for the control and all child controls.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.DestroyWnd">
        <short>Destroys the interface object (widget).</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.DoFlipChildren">
        <short>Flip children horizontally (mirrors the Left position).</short>
        <descr>
          <p>
            Child controls arranged in left-to-right order appear in right-to-left order after flipping. All anchors are adjusted accordingly.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.FlipChildren"/>
        </seealso>
      </element>

      <element name="TWinControl.FinalizeWnd">
        <short>Prepares to remove the window (called before the Handle is destroyed).</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.FixupTabList">
        <short>Assigns sequential TabOrder values to all child controls.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.FontChanged">
        <short>Implements the event handler signalled when the Font has been changed for the control.</short>
        <descr>
          <p>
            FontChanged is an overridden method in TWinControl which implements the handler assigned for OnChange events in the Font for the control. The assignment occurs in the inherited constructor. FontChanged is called when a new value of assigned to the Font property in the control.
          </p>
          <p>
            FontChanged ensures that the widgetset class instance uses the TFont instance in the Sender argument when its handle has been allocated. It also updates the control flags to remove the value wcfFontChanged when the widgetset class has been updated. If the widgetset handle has not been allocated, the value wcfFontChanged is included in the control flags.
          </p>
          <p>
            FontChanged calls the inherited method. NotifyControls is called to notify child controls of the change to their parent font.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.NotifyControls"/>
          <link id="TControl.FontChanged"/>
        </seealso>
      </element>
      <element name="TWinControl.FontChanged.Sender">
        <short>Object instance (TFont) for the event notification.</short>
      </element>

      <element name="TWinControl.InitializeWnd">
        <short>Copies cached control properties to the just created widget.</short>
        <descr>
          <p>
            Called after the Handle is created, and before child handles are created.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TWinControl.Loaded">
        <short>
          Performs actions when a component has been loaded during LCL streaming.
        </short>
        <descr>
          <p>
            Loaded is an overridden method in TWinControl used to perform actions needed when a component has been loaded from a resource during LCL streaming. It extends the inherited method to align and resize it child Controls, as well synchronize property values with those in the widgetset class instance when its handle has been allocated.
          </p>
          <p>
            Loaded calls the inherited method to update the BaseBounds for control, and to apply property values dependent on the Parent control.
          </p>
          <p>
            Loaded calls FixupTabList to populate an internal list with child Controls ordered by their TabOrder property.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Loaded"/>
        </seealso>
      </element>

      <element name="TWinControl.FormEndUpdated">
        <short>
          Realizes all cached changes after a bulk update of the form. Calls the inherited <var>FormEndUpdated</var> method, then informs each child control.
        </short>
        <descr/>
        <seealso>
          <link id="TControl.FormEndUpdated"/>
        </seealso>
      </element>

      <element name="TWinControl.MainWndProc">
        <short> The message handler for the control.</short>
        <descr>
          <p>
            Used for controls which need features not yet supported by the LCL. MainWndProc has an empty implementation in TWinControl.
          </p>
        </descr>
        <seealso>
          <link id="#lcl.forms.TApplication">TApplication</link>
        </seealso>
      </element>
      <element name="TWinControl.MainWndProc.Msg">
        <short>Message handled in the method.</short>
      </element>

      <element name="TWinControl.ParentFormHandleInitialized">
        <short>
          Called after all child handles for the ParentForm are created; notifies all children of the end of the handle creation phase.
        </short>
        <descr/>
        <seealso>
          <link id="TControl.ParentFormHandleInitialized"/>
        </seealso>
      </element>

      <element name="TWinControl.ChildHandlesCreated">
        <short>
          Called after all child handles have been created; resets wcfCreatingChildHandles.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.GetMouseCapture">
        <short>Gets the value for the MouseCapture property.</short>
        <descr>
          <p>
            GetMouseCapture is a Boolean function used to get the value for the MouseCapture property. It is overridden in TWinControl to ensure that the Handle for the control has been allocated. The return value is <b>True</b> when HandleAllocated returns <b>True</b>, and GetCaptureControl returns the current class instance.
          </p>
        </descr>
        <seealso>
          <link id="TControl.MouseCapture"/>
          <link id="TControl.GetMouseCapture"/>
          <link id="GetCaptureControl"/>
        </seealso>
      </element>
      <element name="TWinControl.GetMouseCapture.Result">
        <short>Value for the MouseCapture property.</short>
      </element>

      <element name="TWinControl.RealSetText">
        <short>Sets the text / caption for the control.</short>
        <descr>
          <p>
            <var>RealSetText</var> is an overridden method in TWinControl. It ensures that the new value is applied to the widgetset class when its Handle has been allocated, and the control size is adjusted when needed/enabled. The inherited method is called to apply AValue to the Text and/or Caption properties for the control.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.WSSetText"/>
          <link id="TControl.Caption"/>
          <link id="TControl.Text"/>
          <link id="TControl.RealSetText"/>
          <link id="TControl.RealGetText"/>
          <link id="TControl.AdjustSize"/>
        </seealso>
      </element>
      <element name="TWinControl.RealSetText.AValue">
        <short>New value for the text / caption for the control.</short>
      </element>

      <element name="TWinControl.RemoveFocus">
        <short>Notifies the parent Form when the control cannot be focused.</short>
        <descr>
          <p>
            <var>RemoveFocus</var> is a method used to notify the parent form when the control cannot be focused. RemoveFocus is called from methods like Destroy and RemoveControl, where the control will no  longer exist on the parent form. It is also called from methods like CMEnabledChanged and CMVisibleChanged, where the parent form should no longer allow the control to be focused.
          </p>
          <p>
            RemoveFocus calls GetParentForm to get the parent form instance, and calls its DefocusControl method to ensure that the control is removed as the ActiveControl (when assigned).
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.CMEnabledChanged"/>
          <link id="TWinControl.CMVisibleChanged"/>
          <link id="TWinControl.RemoveControl"/>
          <link id="TWinControl.Destroy"/>
          <link id="#lcl.forms.TCustomForm.DefocusControl">TCustomForm.DefocusControl</link>
          <link id="#lcl.forms.TCustomForm.ActiveControl">TCustomForm.ActiveControl</link>
          <link id="#lcl.forms.GetParentForm">GetParentForm</link>
        </seealso>
      </element>
      <element name="TWinControl.RemoveFocus.Removing">
        <short>True if the control is being freed, False when it is not enabled or not visible.</short>
      </element>

      <element name="TWinControl.SendMoveSizeMessages">
        <short>Sends Move or Size messages using the window message processing loop.</short>
        <descr>
          <p>
            Send Move and Size messages through the LCL message paths. This simulates the VCL behavior and has no real effect.
          </p>
        </descr>
        <seealso>
          <link id="#lcl.controls.TControl.SendMoveSizeMessages">TControl.SendMoveSizeMessages</link>
        </seealso>
      </element>
      <element name="TWinControl.SendMoveSizeMessages.SizeChanged">
        <short/>
      </element>
      <element name="TWinControl.SendMoveSizeMessages.PosChanged">
        <short/>
      </element>

      <element name="TWinControl.SetBorderStyle">
        <short>Sets the value for the BorderStyle property.</short>
        <descr>
          <p>
            Notifies the widgetset class instance of the new property value when its handle has been allocated.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.BorderStyle"/>
        </seealso>
      </element>
      <element name="TWinControl.SetBorderStyle.NewStyle">
        <short>New value for the BorderStyle property.</short>
      </element>

      <element name="TWinControl.SetColor">
        <short>Sets the value for the Color property.</short>
        <descr>
          <p>
            SetColor is an overridden method in TWinControl used to set the value for the Color property. It calls the inherited method on entry, and ensures that the new property value is applied to the internal TBrush instance used in the control. This includes translating the value clDefault to the actual brush color used for the platform.
          </p>
          <p>
            If the Handle has been allocated for the control, the widgetset class is updated. Otherwise, control flags are updated to include the value wcfColorChanged.
          </p>
          <p>
            The NotifyControls method is called to send the CM_PARENTCOLORCHANGED control message to the child controls.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Color"/>
          <link id="TControl.SetColor"/>
        </seealso>
      </element>
      <element name="TWinControl.SetColor.Value">
        <short/>
      </element>

      <element name="TWinControl.SetChildZPosition">
        <short>
          Updates the position of the child control in the Z plane (i.e. front-to-back).
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.SetChildZPosition.AChild">
        <short>Control to locate and move in the method.</short>
      </element>
      <element name="TWinControl.SetChildZPosition.APosition">
        <short>New ordinal position for the control in the Controls property.</short>
      </element>

      <element name="TWinControl.SetParentBackground">
        <short>Sets the value for the ParentBackground property.</short>
        <descr/>
        <seealso>
          <link id="TWinControl.ParentBackground"/>
        </seealso>
      </element>
      <element name="TWinControl.SetParentBackground.AParentBackground">
        <short>New value for the ParentBackground property.</short>
      </element>

      <element name="TWinControl.ShowControl">
        <short>Displays the control on its Parent.</short>
        <descr>
          <p>
            <var>ShowControl</var> is a method used to display the control on its Parent. When Parent has been assigned, its ShowControl is called. This is repeated until a control without an assigned Parent is encountered.
          </p>
          <p>
            ShowControl is called from the Show method in a control instance. It occurs before the Visible property is set to True, and forces each of the parent controls to become visible before setting the value in the control.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Parent"/>
          <link id="TControl.Show"/>
        </seealso>
      </element>
      <element name="TWinControl.ShowControl.AControl">
        <short>A control to display. Ignored in this method.</short>
      </element>

      <element name="TWinControl.UpdateControlState">
        <short>
          Updates the visible state for the control, and notifies the widgetset class when available.
        </short>
        <descr>
          <p>
            Calls AdjustSize when the Handle has been allocated for the control and the control is  logically visible in the client area for the parent. This causes DoAllAutoSize and UpdateShowing to be called. If the control is not visible, UpdateShowing is called to hide the control.
          </p>
          <p>
            Called from the SetParentWindow method.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TWinControl.UpdateShowing">
        <short>
          Updates the Showing property with the visibility for the control, its Parents, and its child controls.
        </short>
        <descr>
          <p>
            <var>UpdateShowing</var> is a method used to determine the visibility for the Handle in the control. It calls HandleObjectShouldBeVisible to check the handle state and visibility for both the control and each of its Parent controls. If the control should be showing and Handle has not already been allocated, CreateHandle is called.
          </p>
          <p>
            When child controls exist in the Controls property, they are visited to call the UpdatingShowing method for each of the TWinControl instances.
          </p>
          <p>
            If an auto-sizing request is not active, a CM_SHOWINGCHANGED message is performed to apply the new visibility for the control(s). The Showing property is updated prior to exiting from the method.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.Showing"/>
          <link id="TWinControl.CreateHandle"/>
          <link id="TWinControl.AutoSizeDelayed"/>
          <link id="TWinControl.AutoSizePhases"/>
          <link id="TControl.HandleObjectShouldBeVisible"/>
        </seealso>
      </element>

      <element name="TWinControl.WndProc">
        <short>
          Adds special handling for focus and input messages, and notifies the DockManager.
        </short>
        <descr>
          <p>
            Handles the following messages:
          </p>
          <dl>
            <dt>LM_SETFOCUS</dt>
            <dd>Gets the parent form and show this control as focused</dd>
            <dt>LM_KILLFOCUS</dt>
            <dd>Removes focus from this control</dd>
            <dt>LM_NCHITTEST</dt>
            <dd>Checks the transparency for the control, etc.</dd>
            <dt>Mouse messages</dt>
            <dd>Sent to the DockManager</dd>
          </dl>
        </descr>
        <seealso>
          <link id="TControl.WndProc"/>
        </seealso>
      </element>
      <element name="TWinControl.WndProc.Message">
        <short/>
      </element>

      <element name="TWinControl.WSSetText">
        <short>
          Sets the value for the Text property in the widgetset class.
        </short>
        <descr>
          <p>
            Calls the SetText method in the widgetset class instance.
          </p>
          <p>
            WSSetText is called from the Loaded and InitializeWnd methods after the control has finished loading using the LCL streaming mechanism or created its window handle. It is also called from RealSetText to apply a new value for the Caption property to the Text for the control.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.WSSetText.AText">
        <short>The text to send.</short>
      </element>

      <element name="TWinControl.WindowHandle">
        <short>
          For internal use; allows direct access to the Handle for the control, bypassing any getter/setter methods.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.BorderStyle">
        <short>
          Indicates the border style displayed around the control.
        </short>
        <descr>
          <p>
            BorderStyle is a TBorderStyle property which indicates whether borders are drawn for the control. bsSingle indicates that borders are drawn for the control. The default value for the property is bsNone, and indicates that borders are not drawn for the control.
          </p>
          <p>
            Changing the value for the property causes the widgetset class to be updated when the Handle has been allocated for the control.
          </p>
          <p>
            BorderStyle is used in the CreateParams method. It causes the WS_EX_CLIENTEDGE extended window style flag to be included in the control when the property is set to bsSingle.
          </p>
          <p>
            BorderStyle is used along with BorderWidth in descendent classes which allow their borders to be drawn with a raised or lowered appearance.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.BorderWidth"/>
          <link id="TBorderStyle"/>
          <link id="TFormBorderStyle"/>
        </seealso>
      </element>

      <element name="TWinControl.OnGetSiteInfo">
        <short>
          Provides information about the DockSite for the control.
        </short>
        <descr>
          <p>
            The handler can adjust the <var>InfluenceRect</var>, within which mouse moves are recognized by this control. The handler also can deny any drops, depending on the dragging operation for the control.
          </p>
          <p>
            <var>OnGetSiteInfo</var> occurs before the <var>OnDockOver</var> event handler.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.OnDockOver"/>
        </seealso>
      </element>

      <element name="TWinControl.OnGetDockCaption">
        <short>
          This handler can provide a special DockCaption, different than the Caption default.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.ParentBackground">
        <short>Indicates if the control uses the background for its Parent control.</short>
        <descr>
          <p>
            <var>ParentBackground</var> is a <var>Boolean</var> property which indicates if the background for the <var>Parent</var> control is drawn as the background for the current control instance.
          </p>
          <p>
            ParentBackground is <b>True</b> when <var>csParentBackground</var> is included in the <var>ControlStyle</var> property. Setting the value in ParentBackground causes ControlStyle to be updated to include or exclude the csParentBackground enumeration value; it is included when <b>True</b>.
          </p>
        </descr>
        <seealso>
          <link id="TControl.ControlStyle"/>
          <link id="TControl.Parent"/>
          <link id="TControlStyleType"/>
          <link id="TControlStyle"/>
        </seealso>
      </element>

      <element name="TWinControl.BorderWidth">
        <short>Width of the Border around the control; default is zero.</short>
        <descr>
          <p>
            <var>BorderWidth</var> is a <var>TBorderWidth</var> property which contains the size for a border drawn on the control. The default value for the property is 0 (zero). Changing the value for the property causes a CM_BORDERCHANGED control message to be sent to the processing loop for the control.
          </p>
          <p>
            BorderWidth is significant when BorderStyle is set to bsSingle. Descendent classes, which allow their borders to be drawn using a raised or lowered appearance, may use the property value when the control is drawn. It indicates the amount of space to reserve for the borders in the bounds rectangle for the control.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.BorderStyle"/>
        </seealso>
      </element>

      <element name="TWinControl.BoundsLockCount">
        <short>
          For internal use: When greater than zero, updates to the BoundsRect are blocked.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.Brush">
        <short>
          The Brush used to paint the background for the control.
        </short>
        <descr>
          <p>
            <var>Brush</var> is a read-only TBrush property which provides the tool used to paint the interior of the control. The value in Brush is allocated and configured in the CreateBrush method, called when the value for the property is read but has not been assigned.
          </p>
          <p>
            The Color property in Brush is updated when a new value is assigned to the Color property in the control.
          </p>
          <p>
            Brush is used in the EraseBackground method and provides the Handle used to draw the background rectangle for the control.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.CreateBrush"/>
          <link id="TWinControl.EraseBackground"/>
          <link id="TControl.Color"/>
          <link id="#lcl.graphics.TBrush">TBrush</link>
        </seealso>
      </element>

      <element name="TWinControl.CachedClientHeight">
        <short>
          The intended ClientHeight, as sent to the widgetset class.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.CachedClientWidth">
        <short>
          The intended ClientWidth, as sent to the widgetset class.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.ChildSizing">
        <short>
          Parameters for child control arrangement and spacing.
        </short>
        <descr>
          <p>
            ChildSizing is a TControlChildSizing property which contains the class used to apply sizing and layout for  child controls in the control instance.
          </p>
        </descr>
        <seealso>
          <link id="TControlChildSizing"/>
        </seealso>
      </element>

      <element name="TWinControl.ControlCount">
        <short>
          The number of child controls in the Controls property.
        </short>
        <descr>
          <p>
            <var>ControlCount</var> is a read-only Integer property which contains the number of child controls stored in the indexed Controls property.
          </p>
          <p>
            The value is updated when control instances are created using the current class instance as the Parent for the control. The value is used in the AlignControls method when the Controls are positioned, aligned, and resized. It is also used to determine whether additional actions are needed in methods like DoChildSizingChange, InvalidatePreferredChildSizes, DoAutoSize, and DoAllAutoSize.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.Controls"/>
          <link id="TWinControl.AlignControls"/>
        </seealso>
      </element>

      <element name="TWinControl.Controls">
        <short>Provides indexed access to the child controls for the class instance.</short>
        <descr>
          <p>
            <var>Controls</var> is a read-only indexed <var>TControl</var> property which provides access to child controls by their ordinal position in the list.
          </p>
          <p>
            The Index argument contains the ordinal position for the requested child control, and must be in the range 0..ControlCount-1. The index also indicates the display or tab order for the child controls. The physical order for the controls  in the list my be changed when the FixupTabList method is called during LCL component streaming.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.ControlCount"/>
        </seealso>
      </element>
      <element name="TWinControl.Controls.Index">
        <short>Ordinal position for the child control requested in the property value.</short>
      </element>

      <element name="TWinControl.DefWndProc">
        <short>
          The default WndProc on Windows widgetset and platforms.
        </short>
      </element>

      <element name="TWinControl.DockClientCount">
        <short>The number of clients docked into this control.</short>
        <descr>
          <p>
            The docked controls can be accessed in<link id="TWinControl.DockClients">DockClients[]</link>.
          </p>
          <p>
            <var>DockClientCount</var> is equivalent to DockClients.Count, but handles the special case when DockClients is <b>Nil</b>.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.DockClients"/>
        </seealso>
      </element>

      <element name="TWinControl.DockClients">
        <short>The indexed list of controls docked into this control.</short>
        <descr/>
        <seealso>
          <link id="TWinControl.DockClientCount"/>
        </seealso>
      </element>
      <element name="TWinControl.DockClients.Index">
        <short>Index of the requested docked client.</short>
      </element>

      <element name="TWinControl.DockManager">
        <short>The docking layout manager for this control.</short>
        <descr>
          <p>
            A <var>DockSite</var> can be managed (using a <var>DockManager</var>),  or unmanaged (positioning docked controls in the event handlers). The <var>DockManager</var> determines the placement for docked controls by setting <var>DropOnControl</var> and <var>DropAlign</var> before the drop, and by resizing and positioning the control when it's dropped.
          </p>
          <p>
            A <var>DockManager</var> is used only when <var>UseDockManager</var> is set to <b>True</b>. Setting <var>UseDockManager</var> to <b>True</b> creates the  <var>DockManager</var> using the <var>DefaultDockManagerClass</var> for this DockSite, if not previously assigned.
          </p>
          <p>
            An unmanaged DockSite, without a DockManager, can handle the placement of dropped controls in the <var>OnDockOver</var> and <var>OnDockDrop</var> event handlers.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.UseDockManager"/>
          <link id="TWinControl.DockSite"/>
          <link id="TWinControl.OnDockDrop"/>
          <link id="TWinControl.OnDockOver"/>
          <link id="TDockManager"/>
        </seealso>
      </element>

      <element name="TWinControl.DockSite">
        <short>
          Allows controls to be drag-dock'd into this control.
        </short>
        <descr>
          <p>
            A DockSite reacts on controls dragged over this control, signals acceptance and where a dragged control would be dropped.
          </p>
          <remark>
            A DockSite should initially be empty, not containing any child controls.
          </remark>
        </descr>
        <seealso>
          <link id="TWinControl.DockManager"/>
          <link id="TWinControl.UseDockManager"/>
        </seealso>
      </element>

      <element name="TWinControl.DoubleBuffered">
        <short>Allows to reduce flicker in the painting of the control.</short>
        <descr>
          <p>
            <var>Paint</var> requests are typically buffered in the message queue. When a paint message arrives, all elements of the control are drawn onto the screen, according to their type, style, state and content.
          </p>
          <p>
            This can cause flicker, when stacked controls wipe out preceding paintings, e.g. when unchanged text is erased from the screen before it is painted again, when it takes some time to retrieve the text of list entries, or wrapping long text at the current control boundaries. Owner-drawing also can cause noticeable flicker.
          </p>
          <p>
            To reduce such flicker, <var>DoubleBuffered</var> controls use a bitmap buffer into which all painting is redirected. When the bitmap has been updated, a paint request is queued for the control. When that paint request is received again, the prepared bitmap is output in one fast BitBlt transfer, eliminating any flicker.
          </p>
          <p>
            All this happens automatically when <var>DoubleBuffered</var> is set to <b>True</b>; no additional changes are required in application or custom control code.
          </p>
        </descr>
      </element>

      <element name="TWinControl.Handle">
        <short>
          A reference handle to the widgetset class instance associated with this control.
        </short>
        <descr>
          <p>
            <var>Handle</var> is a <var>HWND</var> property which represents the handle to the widgetset class instance for the control. It provides a bi-directional communication mechanism between an LCL component and the native control on a given platform or widgetset. Handle has a non-zero value when it has been allocated for the widget.
          </p>
          <p>
            Read access to the property value calls the HandleNeeded method to create the handle if it does not already exist in the control (and its Parent controls). When the property value is changed, the InvalidatePreferredSize method is called to update control flags and clear the cached size for the control.
          </p>
          <p>
            Use HandleAllocated to check Handle for a non-zero value. Use HandleNeeded when the LCL component needs to ensure that the control and Parent controls have an assigned Handle. Or call CreateHandle.
          </p>
          <p>
            Use WindowHandle to access the unique identifier for a device context used in drawing operations for the widgetset class.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.HandleAllocated"/>
          <link id="TWinControl.HandleNeeded"/>
          <link id="TWinControl.CreateHandle"/>
          <link id="TWinControl.CreateWnd"/>
          <link id="TWinControl.WindowHandle"/>
          <link id="TWinControl.ParentHandlesAllocated"/>
        </seealso>
      </element>

      <element name="TWinControl.IsFlipped">
        <short>Used in Carbon and Cocoa widgetsets</short>
        <descr>
          <p>
            IsFlipped is a read-only Boolean property. It is used in the Carbon and Cocoa widgetsets for the macOS platforms.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TWinControl.IsResizing">
        <short>
          Indicates if the control is changing its size after the BeginUpdateBounds method has been called.
        </short>
        <descr>
          <p>
            <var>IsResizing</var> is a read-only <var>Boolean</var> property which indicates if SetBounds has been called to resize the control, but the action has not been completed. An internal bounds lock counter is used to track the progress of a resize operation. It is incremented when <var>BeginUpdateBounds</var> is called and decremented in the <var>EndUpdateBounds</var> method. The property value is <b>True</b> when the internal bounds lock counter has a non-zero value.
          </p>
          <p>
            IsResizing is used when a designer surface in the Lazarus IDE tries to select one of its components. It prevents the selection if the SetBounds operation is still in progress (IsResizing is <b>True</b>).
          </p>
         </descr>
        <seealso>
          <link id="TWinControl.BeginUpdateBounds"/>
          <link id="TWinControl.EndUpdateBounds"/>
          <link id="TWinControl.SetBounds"/>
          <link id="TControl.SetBounds"/>
        </seealso>
      </element>

      <element name="TWinControl.TabOrder">
        <short>
          Indicates the navigation order for the control when the user presses the Tab or Shift+Tab key.
        </short>
        <descr>
          <p>
            <var>TabOrder</var> is a <var>TTabOrder</var> with a numeric value which indicates the navigation order for the control when the user presses the Tab or Shift+Tab key. The default value for the property is -1 and indicates that an explicit value has not been assigned.
          </p>
          <p>
            Each TWinControl has an internal list used to maintain the tab order for its child Controls. When TabOrder is -1 for a given child control, it added to the end of the tab order list. A non-zero value forces the control to be stored at that ordinal position in the tab order list. Setting a new value for the property causes the private UpdateTabOrder method to be called to maintain the sequence for the child controls.
          </p>
          <p>
            Use TabStop to indicate if the control can be focused using tab order navigation request.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.TabStop"/>
        </seealso>
      </element>

      <element name="TWinControl.TabStop">
        <short>
          Allows the user to navigate to / from the control by pressing the Tab or Shift+Tab keys.
        </short>
        <descr>
          <p>
            <var>TabStop</var> is a <var>TabStop</var> property which indicates if the control can be focused when using the <b>Tab</b> or <b>Shift+Tab</b> keys to navigate between controls on a form. The default value for the property is <b>False</b>. At design-time, the Lazarus IDE sets the value to <b>True</b> in newly created control instances.
          </p>
          <p>
            When set to <b>True</b>, the windows style flags are updated to include the value WS_TABSTOP in the CreateParams method.
          </p>
          <p>
            Changing the value for the property causes the internal tab order list to be updated, and a CM_TABSTOPCHANGED control message is performed for the control.
          </p>
          <p>
            TabStop is used in methods like FindNextControl, and may be updated in methods like Insert.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.TabOrder"/>
          <link id="TWinControl.FindNextControl"/>
          <link id="TWinControl.CanTab"/>
          <link id="TWinControl.CanFocus"/>
          <link id="TControl.IsControlVisible"/>
          <link id="TControl.Visible"/>
          <link id="TControl.Enabled"/>
        </seealso>
      </element>

      <element name="TWinControl.OnAlignInsertBefore">
        <short>
          Event handler signalled to determine the order and placement for custom-aligned child controls.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.OnAlignPosition">
        <short>
          Event handler signalled to determines the position for custom-aligned child controls.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.OnDockDrop">
        <short>Notification handler for the drop of a control to be docked.</short>
      </element>

      <element name="TWinControl.OnDockOver">
        <short>
          Event handler for moves of a control over this docksite; determines acceptance or rejection of an possible drop.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.OnEnter">
        <short>
          Handler for control receiving the focus.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.OnExit">
        <short>
          Handler for control loosing the focus; This is a good place for checking the finished user input.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.OnKeyDown">
        <short>
          Handler for keyboard key pressed.
        </short>
        <descr>
          <p>
            This handler can filter keys, for special use in e.g. non-textual controls. The handler receives all keystrokes, including control and other non-visual keys. Keys are encoded as <b>virtual</b> keys, with separate active modifier keys.
          </p>
          <p>
            Text input should be checked in an OnKeyPress handler.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.OnKeyUp"/>
          <link id="TWinControl.OnKeyPress"/>
        </seealso>
      </element>

      <element name="TWinControl.OnKeyPress">
        <short>
          Handler for a character entered by the user.
        </short>
        <descr>
          <p>
            This handler only receives characters, not control or other special key codes. Control keys should be handled by an <var>OnKeyDown</var> handler instead. The handler can also be used to convert the character into a different one.
          </p>
          <remark>
            We recommend using <var>OnUTF8KeyPress</var> to prevent data loss. Characters are converted from UTF-8 to the system encoding in <var>OnKeyPressEvent</var>, with possible loss of characters outside the <b>ANSI</b> codepage.
          </remark>
        </descr>
        <seealso>
          <link id="TWinControl.OnKeyDown"/>
          <link id="TWinControl.OnUTF8KeyPress"/>
        </seealso>
      </element>

      <element name="TWinControl.OnKeyUp">
        <short>Event handler signalled when a key up event has occurred for the control.</short>
        <descr>
          <p>
            Unlike OnKeyDown, this event occurs only once for auto-repeated keys.
          </p>
          <p>
            For details see <link id="TWinControl.OnKeyDown"/>.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.OnKeyDown"/>
          <link id="TWinControl.OnKeyPress"/>
        </seealso>
      </element>

      <element name="TWinControl.OnUnDock">
        <short>Event handler signalled before a control is undocked from its DockSite.</short>
        <descr>
          <p>
            <var>OnUnDock</var> is a <var>TUnDockEvent</var> property with the event handler signalled before a control is undocked from its DockSite. The event handler arguments identify the control with the DockSite, the client control which will become undocked, the control that has the new dock site, and a Boolean which indicates if the operation is allowed.
          </p>
          <p>
            The event handler can be used to disallow undocking by setting the Boolean argument to False in the handler routine.
          </p>
          <p>
            OnUnDock is signalled from the DoUnDock method.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.DoUnDock"/>
        </seealso>
      </element>

      <element name="TWinControl.OnUTF8KeyPress">
        <short>
          Handler for a character entered by the user.
        </short>
        <descr>
          <p>
            This handler receives characters codes only, not control or other special key codes. Control keys should be handled by an <var>OnKeyDown</var> handler instead. The event handler can also convert the character code into a different value.
          </p>
          <p>
            While <link id="TWinControl.OnKeyPress">OnKeyPress</link> receives only <b>ANSI</b> characters (with possible loss of characters outside the <b>ANSI</b> codepage), the <var>OnUTF8KeyPress</var> handler receives the <b>UTF-8</b>-encoded character code.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.OnKeyPress"/>
          <link id="TWinControl.OnKeyDown"/>
        </seealso>
      </element>

      <element name="TWinControl.ParentDoubleBuffered">
        <short>Value for the DoubleBuffered property in a Parent control.</short>
        <descr>
          <p>
            <var>ParentDoubleBuffered</var> is a <var>Boolean</var> property which indicates the value for the DoubleBuffered property in the Parent control. The default value for the property is <b>True</b>. Changing the value for the property causes a CM_PARENTDOUBLEBUFFEREDCHANGED message to be performed (for the control) when Parent has been assigned.
          </p>
          <p>
            To disable double buffering for a single control, make sure both DoubleBuffered and ParentDoubleBuffered are set to <b>False</b>.
          </p>
          <p>
            Double buffering is a technique used to reduce screen flicker when controls are redrawn. It uses an additional off-screen buffer to perform drawing operations, and transfers the content to the on-screen buffer when completed.
          </p>
          <p>
            DoubleBuffered and ParentDoubleBuffered are implemented for the Win32 platform/widgetset. It is implemented for TWinControl (and descendants) and TApplication. In TApplication, the setting is applied to all forms and controls when assigned before the forms and controls are created.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.DoubleBuffered"/>
          <link id="TControl.Parent"/>
        </seealso>
      </element>

      <element name="TWinControl.ParentWindow">
        <short>The window Handle for the Parent widget.</short>
        <descr>
          <p>
            ParentWindow is a HWND property with the window Handle for the Parent widget. A new value assigned to the property is ignored when Parent has already been assigned.
          </p>
          <p>
            The property value is assigned when the CreateParented constructor or the CreateParentedControl class function is used to create a new TWinControl instance. Setting the property to <b>0</b> (zero) causes the handle to be destroyed. <b>0</b> is the unassigned handle value.
          </p>
          <p>
            ParentWindow is used in the the CreateWnd method to form an association between the Handle in the widgetset class instance and the window handle value for a control.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.GetParentHandle"/>
          <link id="TWinControl.GetTopParentHandle"/>
          <link id="TWinControl.CreateParented"/>
          <link id="TWinControl.CreateParentedControl"/>
          <link id="TWinControl.CreateWnd"/>
          <link id="TControl.Parent"/>
        </seealso>
      </element>

      <element name="TWinControl.Showing">
        <short>
          Cached visibility for the widget. Not necessarily in sync with the widget.
        </short>
        <descr>
          <p>
            <var>Showing</var> is a read-only <var>Boolean</var> property with the visibility for the Handle in a control or its Parent. The value for the property is assigned in the UpdateShowing method when the control hierarchy is checked for valid and Visible window handles for the control or its Parents. Showing may be updated when the DoAllAutoSize or UpdateControlState methods are called.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.UpdateShowing"/>
          <link id="TWinControl.Handle"/>
          <link id="TWinControl.DoAllAutoSize"/>
          <link id="TWinControl.UpdateControlState"/>
          <link id="TWinControl.CMShowingChanged"/>
          <link id="TControl.Visible"/>
        </seealso>
      </element>

      <element name="TWinControl.UseDockManager">
        <short>
          Determines whether a DockManager is used for this DockSite.
        </short>
        <descr>
          <p>
            When <var>UseDockManager</var> is set to <b>True</b>, and DockSite is also set to <b>True</b>, a <var>DockManager</var> is created automatically. When set to <b>False</b>, an existing <var>DockManager</var> is ignored. </p>
          <p>
            If you want to use a special DockManager, install it before setting <var>UseDockManager</var> to <b>True</b>.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.DockSite"/>
          <link id="TWinControl.DockManager"/>
          <link id="TWinControl.CreateDockManager"/>
        </seealso>
      </element>

      <element name="TWinControl.DesignerDeleting">
        <short>
          Indicates whether the wcfDesignerDeleting flag is included  in the flags for the control.
        </short>
        <descr>
          <p>
            <var>DesignerDeleting</var> is a <var>Boolean</var> property which indicates if the wcfDesignerDeleting is includes in the control flags for the TWinControl instance. When set to <b>True</b>, wcfDesignerDeleting is included in the control flag values. When set to <b>False</b>, it is removed. Used in TPairSplitter only.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TWinControl.IsSpecialSubControl">
        <short>Indicates if the control has the wcfSpecialSubControl control flag.</short>
        <descr>
          <p>
            <var>IsSpecialSubControl</var> is a read-only <var>Boolean</var> property. Its vale is <b>True</b>  when wcfSpecialSubControl has been included in the WinControlFlags for the control. Used in <var>TCustomPairSplitter</var> only.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TWinControl.VisibleDockClientCount">
        <short>The number of visible docked controls.</short>
        <seealso>
          <link id="TWinControl.DockClientCount"/>
          <link id="TWinControl.DockClients"/>
        </seealso>
      </element>

      <element name="TWinControl.AutoSizePhases">
        <short>Translates control state flags into AutoSizePhases.</short>
        <descr>
          <p>
            The return value is a <var>TControlAutoSizePhases</var> set type. It is populated with values from the <var>TControlAutoSizePhase</var> enumeration based on window control flags and other internal members in the class instance. When Parent has been assigned, the values are derived by calling AutoSizePhases in Parent.
          </p>
          <p>
            AutoSizePhases is called from methods like DoAutoSize and UpdateShowing. It is also called from window messgae handlers like WMMove, WMSize, and WMWindowPosChanged.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.DoAutoSize"/>
          <link id="TWinControl.UpdateShowing"/>
          <link id="TWinControl.WMMove"/>
          <link id="TWinControl.WMSize"/>
          <link id="TWinControl.WMWindowPosChanged"/>
          <link id="TControl.Parent"/>
          <link id="TControlAutoSizePhases"/>
          <link id="TControlAutoSizePhase"/>
        </seealso>
      </element>
      <element name="TWinControl.AutoSizePhases.Result">
        <short>Set withe auto-size phase values enabled for the control.</short>
      </element>

      <element name="TWinControl.AutoSizeDelayed">
        <short>
          Returns <b>True</b> if auto-sizing has been delayed until some other process is completed.
        </short>
        <descr>
          <p>
            <var>AutoSizeDelayed</var> is an overridden Boolean function in TWinControl. It returns True when auto-sizing cannot or should not be performed at the current time, or when the value in  Showing cannot be changed.
          </p>
          <p>
            In TWinControl, it checks the ControlState flags for the value csDestroyingHandle when determining the return value for the method. AutoSizeDelayed calls the inherited method, and sets the return value to True if either condition is True.
          </p>
          <p>
            The value from AutoSizeDelayed is used in methods like DoAllAutoSize and UpdateShowing.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.Showing"/>
          <link id="TWinControl.UpdateShowing"/>
          <link id="TWinControl.DoAllAutoSize"/>
          <link id="TControl.ControlState"/>
          <link id="TControl.AutoSizeDelayed"/>
        </seealso>
      </element>
      <element name="TWinControl.AutoSizeDelayed.Result">
        <short><b>True</b> if auto-sizing cannot be performed at the current time.</short>
      </element>

      <element name="TWinControl.AutoSizeDelayedReport" link="#lcl.controls.TControl.AutoSizeDelayedReport"/>
      <element name="TWinControl.AutoSizeDelayedReport.Result" link="#lcl.controls.TControl.AutoSizeDelayedReport.Result"/>

      <element name="TWinControl.AutoSizeDelayedHandle">
        <short>
          Returns <b>True</b> if AutoSize should be skipped / delayed because of its handle.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.BeginUpdateBounds">
        <short>
          Starts an update to the Bounds property; disables SetBounds by incrementing  BoundsLockCount.
        </short>
        <descr/>
        <seealso>
          <link id="TWinControl.EndUpdateBounds"/>
        </seealso>
      </element>

      <element name="TWinControl.EndUpdateBounds">
        <short>
          Ends an update to the Bounds property; decrements BoundsLockCount and eventually calls SetBounds.
        </short>
        <descr/>
        <seealso>
          <link id="TWinControl.BeginUpdateBounds"/>
        </seealso>
      </element>

      <element name="TWinControl.LockRealizeBounds">
        <short>
          Disables sending bounds to the widget, by incrementing the internal FRealizeBoundsLockCount.
        </short>
        <descr/>
        <seealso>
          <link id="TWinControl.UnlockRealizeBounds"/>
        </seealso>
      </element>

      <element name="TWinControl.UnlockRealizeBounds">
        <short>
          Enables sending bounds to the widget again, eventually updates the widget.
        </short>
        <descr/>
        <seealso>
          <link id="TWinControl.LockRealizeBounds"/>
        </seealso>
      </element>

      <element name="TWinControl.ControlAtPos">
        <short>Get the child control at the given client position.</short>
        <descr>
          <p>WinControls are found before Controls (if overlapping).</p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.ControlAtPos.Result">
        <short>The found control, <b>Nil</b> if none found.</short>
      </element>
      <element name="TWinControl.ControlAtPos.Pos">
        <short>The client coordinates.</short>
      </element>
      <element name="TWinControl.ControlAtPos.AllowDisabled">
        <short>Allow finding disabled controls.</short>
      </element>
      <element name="TWinControl.ControlAtPos.AllowWinControls">
        <short>Allow finding TWinControls, in addition to TControls.</short>
      </element>
      <element name="TWinControl.ControlAtPos.OnlyClientAreas">
        <short>Only search in client areas.</short>
      </element>
      <element name="TWinControl.ControlAtPos.Flags">
        <short>Encoded Allow... conditions.</short>
      </element>

      <element name="TWinControl.ContainsControl">
        <short>
          Returns <b>True</b> if the control is a parent for the specified control.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.ContainsControl.Result">
        <short><b>True</b> when we are a parent of Control.</short>
      </element>
      <element name="TWinControl.ContainsControl.Control">
        <short>The control examined as a child control.</short>
      </element>

      <element name="TWinControl.DoAdjustClientRectChange">
        <short>
          Asks the widget if ClientRect has changed since the last AlignControl execution; calls AdjustSize on change.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.DoAdjustClientRectChange.InvalidateRect">
        <short/>
      </element>

      <element name="TWinControl.InvalidateClientRectCache">
        <short>
          The ClientRect is cached; call this procedure to invalidate the cache, so that the next ClientRect value is fetched from the widgetset class.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.InvalidateClientRectCache.WithChildControls">
        <short>Also invalidate all child controls, if <b>True</b>.</short>
      </element>

      <element name="TWinControl.ClientRectNeedsInterfaceUpdate">
        <short>
          The ClientRect is cached - check if the cache is valid.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.ClientRectNeedsInterfaceUpdate.Result">
        <short><b>True</b> if update needed.</short>
      </element>

      <element name="TWinControl.SetBounds">
        <short>Sets the control bounds and adjusts child and docked controls.</short>
        <descr>
          <p>
            <var>SetBounds</var> is an overridden method in TWinControl. used to set the bounds for the control to the values in the ALeft, ATop, AWidth, and AHeight arguments.
          </p>
          <p>
            No actions are performed in the method when the internal BoundsLockCount member has a non-zero value. In other words, when BeginUpdateBounds has been called and EndUpdateBounds has not been called.
          </p>
          <p>
            At design-time, SetBounds checks to ensure that negative is not present in the Width or Height properties when the user has changed the bounds for the control.
          </p>
          <p>
            SetBounds calls DisableAutoSizing to reduce the overhead for recomputing/moving/resizing when the bounds are changed. The inherited method is called to apply the new values in ALeft, ATop, AWidth, and AHeight. EnableAutoSizing is called to re-enable auto-sizing when the operation has been completed.
          </p>
          <p>
            SetBounds is called when any one of these Left, Top, Width or Height properties, or the BoundsRect property has been changed.
          </p>
          <p>
            Keep in mind that the given aLeft, aTop, aWidth, aHeight might not be valid and will be changed by the LCL before applied.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.BeginUpdateBounds"/>
          <link id="TWinControl.EndUpdateBounds"/>
          <link id="TControl.SetBounds"/>
          <link id="TControl.ChangeBounds"/>
          <link id="TControl.DisableAutoSizing"/>
          <link id="TControl.EnableAutoSizing"/>
        </seealso>
      </element>
      <element name="TWinControl.SetBounds.aLeft">
        <short>The X coordinate for the left side of the control.</short>
      </element>
      <element name="TWinControl.SetBounds.aTop">
        <short>The Y coordinate for the left side of the control.</short>
      </element>
      <element name="TWinControl.SetBounds.aWidth">
        <short>The width for the control.</short>
      </element>
      <element name="TWinControl.SetBounds.aHeight">
        <short>The height for the control.</short>
      </element>

      <element name="TWinControl.GetChildrenRect">
        <short>
          Returns the Client rectangle relative to the controls left, top.
        </short>
        <descr>
          <p>
            If Scrolled is <b>True</b>, the rectangle is moved by the current scrolling values
            (for an example see TScrollingWincontrol).
          </p>
        </descr>
        <seealso>
          <link id="#lcl.controls.TControl.GetChildrenRect">TControl.GetChildrenRect</link>
        </seealso>
      </element>
      <element name="TWinControl.GetChildrenRect.Result">
        <short/>
      </element>
      <element name="TWinControl.GetChildrenRect.Scrolled">
        <short/>
      </element>

      <element name="TWinControl.DisableAlign">
        <short>Disables auto-sizing when aligning the control and its parent.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.EnableAlign">
        <short>Re-enables auto-sizing after aligning the control and its parent.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TWinControl.ReAlign">
        <short>Adjusts the size and placement for the control and all of its children.</short>
        <descr>
          <p>
            Calls the inherited AdjustSize method.
          </p>
        </descr>
        <seealso>
          <link id="TControl.AdjustSize"/>
        </seealso>
      </element>

      <element name="TWinControl.ScrollBy_WS">
        <short>Scrolls the control using the handle for the widgetset class.</short>
        <descr/>
        <errors>
          Raises an Exception if the handle has not been allocated for the widgetset class instance. Raised with the message 'TWinControl.ScrollBy_WS: Handle not allocated'.
        </errors>
        <seealso>
          <link id="TWinControl.HandleAllocated"/>
        </seealso>
      </element>
      <element name="TWinControl.ScrollBy_WS.DeltaX">
        <short/>
      </element>
      <element name="TWinControl.ScrollBy_WS.DeltaY">
        <short/>
      </element>

      <element name="TWinControl.ScrollBy">
        <short>Scrolls the control (and all child controls) by the specified amounts.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.ScrollBy.DeltaX">
        <short>Increment for Left.</short>
      </element>
      <element name="TWinControl.ScrollBy.DeltaY">
        <short>Increment for Top.</short>
      </element>

      <element link="#lcl.controls.TControl.WriteLayoutDebugReport" name="TWinControl.WriteLayoutDebugReport"/>
      <element name="TWinControl.WriteLayoutDebugReport.Prefix">
        <short/>
      </element>

      <element name="TWinControl.AutoAdjustLayout">
        <short>
          Automatically adjusts the size and layout for the control (and all of its children).
        </short>
        <descr>
          <p>
            <var>AutoAdjustLayout</var> is an overridden procedure used to automatically adjust the size and layout for the control. All children in the <var>Controls</var> property also call their AutoAdjustLayout method, and the inherited method is called to adjust and resize the current control instance.
          </p>
          <p>
            AutoAdjustLayout calls DisableAutoSizing on entry, and EnableAutoSizing prior to exit from the method.
          </p>
        </descr>
        <seealso>
          <link id="TControl.AutoAdjustLayout"/>
          <link id="TControl.DisableAutoSizing"/>
          <link id="TControl.EnableAutoSizing"/>
          <link id="TControl.DoAutoAdjustLayout"/>
          <link id="TWinControl.Controls"/>
        </seealso>
      </element>
      <element name="TWinControl.AutoAdjustLayout.AMode">
        <short>Layout mode applied in the method.</short>
      </element>
      <element name="TWinControl.AutoAdjustLayout.AFromPPI">
        <short/>
      </element>
      <element name="TWinControl.AutoAdjustLayout.AToPPI">
        <short/>
      </element>
      <element name="TWinControl.AutoAdjustLayout.AOldFormWidth">
        <short/>
      </element>
      <element name="TWinControl.AutoAdjustLayout.ANewFormWidth">
        <short/>
      </element>

      <element name="TWinControl.FixDesignFontsPPIWithChildren">
        <short>
          Fixes the design-time PPI settings for the control font, and applies the changes to child controls.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.FixDesignFontsPPIWithChildren.ADesignTimePPI">
        <short/>
      </element>

      <element name="TWinControl.Create">
        <short>Constructor for the class instance.</short>
        <descr>
          <p>
            Create is the overridden constructor for the class instance. Create calls the inherited method using TheOwner as the owner for the class instance. Create allocates resources needed in the class instance, and sets the default values for the following properties:
          </p>
          <dl>
            <dt>ParentDoubleBuffered</dt>
            <dd>Set to <b>True</b></dd>
            <dt>ChildSizing</dt>
            <dd>Sets DoChildSizingChange as the OnChange event handler</dd>
            <dt>Brush</dt>
            <dd>
              Set to Nil; few controls require a brush, and it is created on DoRemainingKeyDown
            </dd>
            <dt>TabOrder</dt>
            <dd>Set to -1</dd>
            <dt>TabStop</dt>
            <dd>Set to <b>False</b></dd>
          </dl>
          <p>
            Create calls the InvalidateClientRectCache method to invalidate a cached client rectangle, and to force the value to be read from the LCL interface.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.InvalidateClientRectCache"/>
        </seealso>
      </element>
      <element name="TWinControl.Create.TheOwner">
        <short>Owner of the class instance.</short>
      </element>

      <element name="TWinControl.CreateParented">
        <short>Constructor for a control that is the child of the given widget.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.CreateParented.AParentWindow">
        <short/>
      </element>

      <element name="TWinControl.CreateParentedControl" link="#lcl.controls.TWinControl.CreateParented"/>
      <element name="TWinControl.CreateParentedControl.Result" link="#lcl.controls.TWinControl.CreateParented.Result"/>
      <element name="TWinControl.CreateParentedControl.AParentWindow" link="#lcl.controls.TWinControl.CreateParented.AParentWindow"/>

      <element name="TWinControl.Destroy">
        <short>Destructor for the class instance.</short>
        <descr>
          <p>
            <var>Destroy</var> is the overridden destructor for the class instance.
          </p>
          <p>
            Destroy call RemoveFocus to ensure that the control cannot receive focus from a Parent control. If a handle has been allocated for the windowed control, the DestroyHandle method is called.
          </p>
          <p>
            Destroy iterates over Controls to remove the value in the Parent property for each child control, and to remove an assigned HostDockSite. It does not actually free the child Controls; they are freed by the owner of the control instance (usually a TForm instance).
          </p>
          <p>
            Destroy ensures that any controls in the DockClients property remove the current class instance from their host dock site.
          </p>
          <p>
            Destroy frees resources allocated in the constructor, or in other class methods, including the DockManager and DockCients. Destroy calls the inherited destructor prior to exiting from the method.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Parent"/>
          <link id="TWinControl.Controls"/>
          <link id="TWinControl.RemoveControl"/>
          <link id="TWinControl.DockManager"/>
          <link id="TWinControl.DockClients"/>
          <link id="TControl.HostDockSite"/>
        </seealso>
      </element>

      <element name="TWinControl.DockDrop">
        <short>
          Handler for a DragManager dmDragDrop message, sent when a dragged control has been dropped onto this docksite.
        </short>
        <descr>
          <p>
            Asks the dropped control to dock itself into this docksite, updates its Parent, HostDockSite, and the DockClients for the old and new DockSite.
          </p>
          <p>
            When a DockManager is installed, it is used to position the docked control (InsertControl).
          </p>
          <p>
            Finally, an OnDockDrop event is signalled.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.DoDockClientMsg"/>
          <link id="TWinControl.OnDockDrop"/>
          <link id="TDragDockObject"/>
        </seealso>
      </element>
      <element name="TWinControl.DockDrop.DragDockObject">
        <short/>
      </element>
      <element name="TWinControl.DockDrop.X">
        <short/>
      </element>
      <element name="TWinControl.DockDrop.Y">
        <short/>
      </element>

      <element name="TWinControl.CanFocus">
        <short>Is this control allowed to receive the focus when parent form is visible?</short>
        <descr>
          <p>
            Checks if the control can get focus when parent form is visible, i.e. if all its parents except the form are visible and enabled.
          </p>
          <p>A possible usage:</p>
<code>
if FormFoo.EditBar.CanFocus then
  FormFoo.ActiveControl := FormFoo.EditBar;
</code>
          <remark>
            CanFocus returns <b>True</b> even if the parent form is not actually visible, and a subsequent SetFocus call could throw an exception. Use <var>CanSetFocus</var> in this case.
          </remark>
        </descr>
        <seealso>
          <link id="TWinControl.CanSetFocus"/>
          <link id="TWinControl.SetFocus"/>
          <link id="TWinControl.CanFocus"/>
        </seealso>
      </element>
      <element name="TWinControl.CanFocus.Result">
        <short/>
      </element>

      <element name="TWinControl.CanSetFocus">
        <short>Is this control allowed to receive the focus?</short>
        <descr>
          <p>
            Checks if the control can receive focus, i.e. if all its parents are visible and enabled.
          </p>
          <p>A possible usage:</p>
<code>
if MyControl.CanSetFocus then
   MyControl.SetFocus;
</code>
          <p>
            <var>CanSetFocus</var> should be preferred over <var>CanFocus</var> if used in CanSetFocus/SetFocus combination because it checks also if the parent form can receive focus and thus prevents the "cannot focus an invisible window" LCL exception.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.CanFocus"/>
          <link id="TWinControl.SetFocus"/>
        </seealso>
      </element>
      <element name="TWinControl.CanSetFocus.Result">
        <short/>
      </element>

      <element name="TWinControl.GetControlIndex">
        <short>
          Finds the position for the specified control in the Controls property.
        </short>
        <descr>
          <p>
            Calls the <var>IndexOf</var> method in Controls to find the child control in AControl. The return value contains the ordinal position in Controls where AControl is stored, or -1 when not found or Controls has not been assigned.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.Controls"/>
          <link id="#rtl.classes.TFPList.IndexOf">TFPList.IndexOf</link>
        </seealso>
      </element>
      <element name="TWinControl.GetControlIndex.Result">
        <short>The ordinal position in Controls, -1 if not found.</short>
      </element>
      <element name="TWinControl.GetControlIndex.AControl">
        <short>The child control to locate in the method.</short>
      </element>

      <element link="#lcl.controls.TWinControl.SetChildZPosition" name="TWinControl.SetControlIndex"/>
      <element name="TWinControl.SetControlIndex.AControl">
        <short/>
      </element>
      <element name="TWinControl.SetControlIndex.NewIndex">
        <short/>
      </element>

      <element name="TWinControl.Focused">
        <short>Checks whether the control has focus.</short>
        <descr>
          <p>
            <var>Focused</var> is a <var>Boolean</var> function which indicates whether the control can be and is the currently focused control. The return value is True when the control can become focused during tab order navigation, has a valid Handle, and is the currently focused control in the widgetset class instance.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.CanTab"/>
          <link id="FindOwnerControl"/>
        </seealso>
      </element>
      <element name="TWinControl.Focused.Result">
        <short><b>True</b> when the control has focus.</short>
      </element>

      <element name="TWinControl.PerformTab">
        <short>Changes the focus to the next (or preceding) control.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.PerformTab.Result">
        <short><b>True</b> when the focus has been transferred.</short>
      </element>
      <element name="TWinControl.PerformTab.ForwardTab">
        <short>
          The direction of Tab movement; <b>True</b> for the next control in the TabOrder, <b>False</b> for the preceding control.
        </short>
      </element>

      <element name="TWinControl.FindChildControl">
        <short>Finds a child control with the specified name.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.FindChildControl.Result">
        <short><b>True</b> when the control has been found.</short>
      </element>
      <element name="TWinControl.FindChildControl.ControlName">
        <short>The Name of the control to find.</short>
      </element>

      <element name="TWinControl.SelectNext">
        <short>Transfers the focus to the next child control.</short>
        <descr>
          <p>
            The search wraps around on the boundaries of the TabOrder array. When no next control can be found, the focus remains unchanged.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.FindNextControl"/>
        </seealso>
      </element>
      <element name="TWinControl.SelectNext.CurControl">
        <short>The control which is assumed to have the focus.</short>
      </element>
      <element name="TWinControl.SelectNext.GoForward">
        <short> <b>False</b> when the control preceding CurControl shall be found.</short>
      </element>
      <element name="TWinControl.SelectNext.CheckTabStop">
        <short>When <b>True</b>, only select a control that can receive the focus.</short>
      </element>

      <element link="#lcl.controls.TControl.SetTempCursor" name="TWinControl.SetTempCursor"/>
      <element name="TWinControl.SetTempCursor.Value">
        <short/>
      </element>

      <element name="TWinControl.BroadCast">
        <short>
          Posts the specified message to all of the child controls.
        </short>
        <descr>
          <p>
            Allows the specified method to be handled by one of the child Controls. The ToAllMessage argument is untyped; any TLMessage descendant can be passed as the value for the argument.
          </p>
          <p>
            The method name is a misnomer. Broadcast implies delivery of the message simultaneously to all of the recipients. Actually, it is more like a telegraph. The message is posted sequentially to child controls until one of them handles the message using its WindowProc method.
          </p>
          <p>
            Use NotifyControls to post a message with a specific message identifier constant to child Controls in the class instance.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.NotifyControls"/>
        </seealso>
      </element>
      <element name="TWinControl.BroadCast.ToAllMessage">
        <short>The message sent in the method.</short>
      </element>

      <element name="TWinControl.NotifyControls">
        <short>Sends a message to all child controls.</short>
        <descr>
          <p>
            Calls the BroadCast method to deliver a TLMessage instance with the identifier in Msg.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.BroadCast"/>
        </seealso>
      </element>
      <element name="TWinControl.NotifyControls.Msg">
        <short>The message ID.</short>
      </element>

      <element name="TWinControl.DefaultHandler">
        <short>Handles all messages that the control doesn't fully handle itself.</short>
        <descr>
          <p>
            This implementation sends the message to the widget's message handler.
          </p>
          <p>
            Override this method to implement your own message handling. If the message Result is non-zero, the message already has been handled; otherwise, set the Result to a non-zero value (depending on the message ID) when the message has been handled.
          </p>
        </descr>
        <seealso>
          <link id="#rtl.system.TObject.DefaultHandler">TObject.DefaultHandler</link>
        </seealso>
      </element>
      <element name="TWinControl.DefaultHandler.AMessage">
        <short>The message to process.</short>
      </element>

      <element link="#lcl.controls.TControl.GetTextLen" name="TWinControl.GetTextLen"/>
      <element name="TWinControl.GetTextLen.Result">
        <short/>
      </element>

      <element name="TWinControl.Invalidate">
        <short>Schedules a repaint request.</short>
        <descr>
          <p>
            <var>Invalidate</var> is an overridden method in TWinControl. It re-implements the inherited method to call the Invalidate method in the widgetset class instance when its Handle has been allocated. It does not call the inherited method.
          </p>
        </descr>
        <seealso>
          <link id="TControl.Invalidate"/>
        </seealso>
      </element>

      <element name="TWinControl.AddControl">
        <short>Tells the widgetset to add a Handle object representing the current control.</short>
        <descr>
        </descr>
        <seealso/>
      </element>

      <element name="TWinControl.InsertControl">
        <short>Inserts the specified control into the Controls property.</short>
      </element>
      <element name="TWinControl.InsertControl.AControl">
        <short>The control to insert.</short>
      </element>
      <element name="TWinControl.InsertControl.Index">
        <short>Insert at index (optional).</short>
      </element>

      <element name="TWinControl.RemoveControl">
        <short>Removes the specified control from the Controls property.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.RemoveControl.AControl">
        <short>The control to remove.</short>
      </element>

      <element name="TWinControl.GetEnumeratorControls">
        <short>Gets an enumerator for the Controls property.</short>
        <descr>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.GetEnumeratorControls.Result">
        <short>The TWinControlEnumerator instance.</short>
      </element>

      <element name="TWinControl.GetEnumeratorControlsReverse">
        <short>Gets a reverse-order enumerator for the Controls property.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.GetEnumeratorControlsReverse.Result">
        <short>The TWinControlEnumerator instance.</short>
      </element>

      <element link="#lcl.controls.TControl.Repaint" name="TWinControl.Repaint"/>
      <element link="#lcl.controls.TControl.Update" name="TWinControl.Update"/>

      <element name="TWinControl.SetFocus">
        <short>
          Ensures that the control or window handle has focus.
        </short>
        <descr>
          <p>
            <var>SetFocus</var> is a procedure used to give focus to the current control. SetFocus calls <var>GetParentForm</var> for the control instance, and uses its <var>FocusControl</var> method to change the focused control.
          </p>
          <p>
            If the parent Form is unassigned (contains <b>Nil</b>), the LCL interface is used to change focus to the handle for the control. No actions are performed in the method when Form is unassigned and the control does not have an allocated handle.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TWinControl.FlipChildren">
        <short>
          Flip children horizontally. That means mirroring the Left position and anchoring.
        </short>
        <descr>
          <p>
            Child controls arranged in left-to-right order appear in right-to-left order after flipping. All anchors are adjusted accordingly.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.DoFlipChildren"/>
        </seealso>
      </element>
      <element name="TWinControl.FlipChildren.AllLevels">
        <short>Flip recursive?</short>
      </element>

      <element name="TWinControl.ScaleBy" link="#lcl.controls.TWinControl.ChangeScale"/>
      <element name="TWinControl.ScaleBy.Multiplier" link="#lcl.controls.TWinControl.ChangeScale.Multiplier"/>
      <element name="TWinControl.ScaleBy.Divider" link="#lcl.controls.TWinControl.ChangeScale.Divider"/>

      <element name="TWinControl.GetDockCaption">
        <short>Returns the docking caption for the specified control.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.GetDockCaption.Result">
        <short>String the docking caption for the control.</short>
      </element>
      <element name="TWinControl.GetDockCaption.AControl">
        <short>Control instance examined in the method.</short>
      </element>

      <element name="TWinControl.UpdateDockCaption">
        <short>Updates the Caption to reflect the names for the docked clients.</short>
        <descr>
          <p>
            Called when this is a HostDockSite and either the list of docked clients have changed, or one of their captions has changed.
          </p>
          <p>
            If the control is being undocked, but still is in the DockClients list, it is excluded from the docking caption and the Exclude argument is set to <b>True</b>.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.UpdateDockCaption.Exclude">
        <short>Control to exclude from the DockCaption.</short>
      </element>

      <element name="TWinControl.GetTabOrderList">
        <short>Fill the list with all TabStop controls, recursing into child controls.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.GetTabOrderList.List">
        <short>The list to which the controls shall be added.</short>
      </element>

      <element name="TWinControl.HandleAllocated">
        <short>
          Checks whether a handle for the widget has been allocated for the control.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.HandleAllocated.Result">
        <short><b>True</b> when a widget exists and its Handle is not <b>Nil</b>.</short>
      </element>

      <element name="TWinControl.ParentHandlesAllocated">
        <short>Returns <b>True</b> if all Parents have handles allocated, and are not being destroyed.</short>
        <descr>
          <p>
            ParentHandlesAllocated is an overridden method in TWinControl which checks whether Handles are valid for all controls in the component hierarchy for the current control.
          </p>
          <p>
            ParentHandlesAllocated visits each of the controls, starting with the current class instance, and checks whether the control has an allocated handle and is not being destroyed. It navigates to the next Parent control in the hierarchy, and exits when the Parent control is unassigned.
          </p>
          <p>
            The return value is <b>True</b> when all of the controls in the hierarchy have an allocated Handle and are not being destroyed. The return value is <b>False</b> if any control is found in the hierarchy that does not have a valid handle allocated, or ComponentState indicates its handle is being freed.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.HandleAllocated"/>
          <link id="TWinControl.Handle"/>
          <link id="TControl.Parent"/>
          <link id="TControl.ParentHandlesAllocated"/>
        </seealso>
      </element>
      <element name="TWinControl.ParentHandlesAllocated.Result">
        <short><b>True</b> when all of the controls in the Parent hierarchy have a valid handle.</short>
      </element>

      <element name="TWinControl.HandleNeeded">
        <short>
          Call this method when your code requires a valid Handle for this control.
        </short>
        <descr>
          <p>
            An attempt is made to create a widget, when not already done.
          </p>
          <remark>
            In certain situations it may be impossible to create a widget right now!
          </remark>
        </descr>
        <seealso/>
      </element>

      <element name="TWinControl.BrushCreated">
        <short>
          Indicates whether a Brush has been created for the control.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.BrushCreated.Result">
        <short><b>True</b> when a Brush has been created.</short>
      </element>

      <element name="TWinControl.EraseBackground">
        <short>
          Fills the display rectangle for the control with the color and pattern in Brush.
        </short>
        <descr>
          <p>
            EraseBackground is called during Paint requests from the WMEraseBkgnd method, which provides a valid device context in the DC argument. No actions are performed in the method when DC contains 0 (unassigned).
          </p>
          <p>
            The FillRect routine is called to perform the operation using the Width, Height, and the handle in the Brush property.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.Brush"/>
          <link id="TControl.Height"/>
          <link id="TControl.Width"/>
        </seealso>
      </element>
      <element name="TWinControl.EraseBackground.DC">
        <short>The device context to use; may be clipped to a certain shape.</short>
      </element>

      <element name="TWinControl.IntfUTF8KeyPress">
        <short>
          Called by the interface after the navigation and specials keys are handled;
          i.e. after KeyDown but before KeyPress.
        </short>
        <descr>
          <p>
            Essentially expands a repeat count into multiple keystrokes. Cannot be used for SysKeys.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.IntfUTF8KeyPress.Result">
        <short><b>True</b> when multiple keystrokes have been processed.</short>
      </element>
      <element name="TWinControl.IntfUTF8KeyPress.UTF8Key">
        <short>The UTF-8 encoding of the character.</short>
      </element>
      <element name="TWinControl.IntfUTF8KeyPress.RepeatCount">
        <short>Must be greater than zero, the exact value is ignored.</short>
      </element>
      <element name="TWinControl.IntfUTF8KeyPress.SystemKey">
        <short>Must be <b>False</b>, else nothing happens.</short>
      </element>

      <element name="TWinControl.IntfGetDropFilesTarget">
        <short>Searches for a Parent form that can be used as a file drop target.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TWinControl.IntfGetDropFilesTarget.Result">
        <short>
          The TCustomForm instance that allows file drop actions, or Nil when file drag/drop is not supported.
        </short>
      </element>

      <element name="TWinControl.PaintTo">
        <short>Paints the control using the handle for the widgetset class.</short>
        <descr>
          <p>
            <var>PaintTo</var> is a procedure used to draw the control using the handle for the widgetset class. An overloaded variant is provided which uses the handle in a <var>TCanvas</var> instance as the target for the drawing operation.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.PaintTo.DC">
        <short>Device context (or Handle) used for the operation.</short>
      </element>
      <element name="TWinControl.PaintTo.X">
        <short>Horizontal coordinate where the control is drawn.</short>
      </element>
      <element name="TWinControl.PaintTo.Y">
        <short>Vertical coordinate where the control is drawn.</short>
      </element>
      <element name="TWinControl.PaintTo.ACanvas">
        <short>TCanvas instance with the handle used in the operation.</short>
      </element>

      <element name="TWinControl.SetShape">
        <short>Specifies the non-rectangular shape of the widget.</short>
        <descr>
          <p>
            SetShape is an overloaded procedure used to set the shape for the control to the non-rectangular value in AShape. The overloaded methods allow AShape to be either a TBitmap or a TRegion value.
          </p>
          <p>
            When TBitmap is used, the widgetset class calls its SetShape method to apply the TBitmap handle to the handle for the widget. No actions are performed in the method when a handle has not been allocated for the widgetset class.
          </p>
          <p>
            When TRegion is used,  SetWindowRgn in the LCL interface is called to apply the region in AShape to the handle for the control.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TWinControl.SetShape.AShape">
        <short>Shape for the control; TBitmap or TRegion in overloaded methods.</short>
      </element>

      <element name="TGraphicControl">
        <short>
          <var>TGraphicControl</var> is the base class for all lightweight controls.
        </short>
        <descr>
          <p>
            <var>TGraphicControl</var> supports simple lightweight controls that do not need the ability to accept keyboard input,  and do not contain other controls. Since lightweight controls do not wrap GUI widgets, they use fewer resources than controls based on <var>TWinControl</var>. If you want to accept keyboard input, or need to support child controls, use a <var>TCustomControl</var> instead.
          </p>
          <p>
            <var>TGraphicControl</var> provides a <var>Canvas</var> property for access to the control's drawing surface and a virtual <var>Paint</var> method and an <var>OnPaint</var> handler, called in response to paint requests received by the parent control.
          </p>
          <p>
            Override the Paint method, or supply your own <var>OnPaint</var> handler, to do the actual drawing of the control.
          </p>
        </descr>
        <seealso>
          <link id="TCustomControl"/>
          <link id="TGraphicControl.Paint"/>
          <link id="TGraphicControl.OnPaint"/>
          <link id="#lcl.graphics.TCanvas">TCanvas</link>
        </seealso>
      </element>

      <element name="TGraphicControl.FCanvas"/>
      <element name="TGraphicControl.FOnPaint"/>

      <element name="TGraphicControl.WMPaint">
        <short>Handles a LM_PAINT message for the control.</short>
      </element>
      <element name="TGraphicControl.WMPaint.Message">
        <short>Message handled in the method.</short>
      </element>

      <element name="TGraphicControl.WSRegisterClass" link="#lcl.lclclasses.TLCLComponent.WSRegisterClass"/>

      <element name="TGraphicControl.FontChanged">
        <short>Performs actions needed when the Font for the control has been changed.</short>
        <descr>
          <p>
            <var>FontChanged</var> is an overridden method in TGraphicControl used to perform actions needed when the Font for the control has been changed. It is the routine used as the OnChange event handler for the Font property, and is assigned in the inherited constructor for the class instance.
          </p>
          <p>
            Sender contains the object instance for the event notification, and is provided to maintain compatibility with the TNotifyEvent signature for the event handler. It is not used in TGraphicControl, but is passed as an argument to the inherited method.
          </p>
          <p>
            FontChanged ensures that the new value for the Font property is also applied to the Canvas for the control. This includes the PixelsPerInch setting for the Font. FontChanged calls the inherited method prior to exit.
          </p>
        </descr>
        <seealso>
          <link id="TControl.FontChanged"/>
          <link id="TControl.Font"/>
          <link id="TControl.Create"/>
          <link id="#lcl.graphics.TFont.PixelsPerInch">TFont.PixelsPerInch</link>
        </seealso>
      </element>
      <element name="TGraphicControl.FontChanged.Sender">
        <short>Object instance for the event notification.</short>
      </element>

      <element name="TGraphicControl.Paint">
        <short>
          Implements the default handler used to draw the control.
        </short>
        <descr>
          <p>
            <var>Paint</var> is a method which causes the control to be drawn using the drawing mechanism for the control. In TGraphicControl, like TCustomControl, the OnPaint event handler is used (when assigned). Assign a routine to the OnPaint handler to perform the drawing operations needed for the control.
          </p>
        </descr>
        <seealso>
          <link id="TGraphicControl.OnPaint"/>
        </seealso>
      </element>

      <element name="TGraphicControl.DoOnChangeBounds">
        <short>Performs action needed when the bounds for the control have been changed.</short>
        <descr>
          <p>
            <var>DoOnChangeBounds</var> is an overridden method in TGraphicControl. It calls the inherited method on entry to update control flags and signal OnChangeBounds event handlers for the control. The Handle in Canvas is freed prior to exiting from the method. The handle is re-allocated the next time it is accessed.
          </p>
          <p>
            DoOnChangeBounds is called when the component is loaded using the LCL streaming mechanism, and from the ChangeBounds method when the control is resized.
          </p>
        </descr>
        <seealso>
          <link id="TGraphicControl.Canvas"/>
          <link id="TControlCanvas.FreeHandle"/>
          <link id="TControl.DoOnChangeBounds"/>
          <link id="TControl.OnChangeBounds"/>
          <link id="TControl.ChangeBounds"/>
          <link id="TControl.LoadedAll"/>
          <link id="TControlFlag"/>
        </seealso>
      </element>

      <element name="TGraphicControl.DoOnParentHandleDestruction">
        <short>Performs actions when the handle for the parent control is freed.</short>
        <descr>
          <p>
            <var>DoOnParentHandleDestruction</var> is overridden in <var>TGraphicControl</var> to re-implement the method in the ancestor class. It ensures that Handle for the Canvas is freed when the parent handler is destroyed.
          </p>
        </descr>
        <seealso>
          <link id="TGraphicControl.Canvas"/>
          <link id="TControlCanvas.FreeHandle"/>
          <link id="TControl.DoOnParentHandleDestruction"/>
        </seealso>
      </element>

      <element name="TGraphicControl.OnPaint">
        <short>
          Event handler signalled to paint the control.
        </short>
        <descr>
          <p>
            OnPaint is a TNotifyEvent with the event handler signalled to paint the control. Applications must implement and assign a routine to the event handler to perform the drawing operation. TGraphicControl does not provide a default drawing mechanism.
          </p>
          <p>
            Use the Canvas for the control to perform drawing operations. The Font and Brush in Canvas are automatically configured to use values assigned to the corresponding properties in the control. BorderStyle, however, is not automatically applied. Use the Pen in Canvas as needed to draw the BorderStyle for the control.
          </p>
          <p>
            OnPaint is signalled (when assigned) from the Paint method.
          </p>
        </descr>
        <seealso>
          <link id="TGraphicControl.Canvas"/>
          <link id="TGraphicControl.Paint"/>
          <link id="TControl.Font"/>
          <link id="TControl.Color"/>
          <link id="TWinControl.BorderStyle"/>
        </seealso>
      </element>

      <element name="TGraphicControl.CMCursorChanged">
        <short>Handles the CM_CURSORCHANGED message for the control.</short>
        <descr>
          <p>
            CMCursorChanged is an overridden method in TGraphicControl.  It ensures that the control is Visible before the temporary cursor shape is changed.
          </p>
          <p>
            <var>Visible</var> must be set to <b>True</b>, and the <var>Parent</var> control (with the window handle) must be assigned before the control can be displayed. No actions are performed in the method if Visible is <b>False</b>, or Parent is <b>Nil</b>.
          </p>
          <p>
            In addition, the mouse must be over the control to apply the cursor shape using <var>SetTempCursor</var> and the value in the <var>Cursor</var> property.
          </p>
        </descr>
        <seealso>
          <link id="TControl.CMCursorChanged"/>
          <link id="TControl.Visible"/>
          <link id="TControl.Parent"/>
          <link id="TControl.Cursor"/>
          <link id="TControl.SetTempCursor"/>
        </seealso>
      </element>

      <element name="TGraphicControl.Create">
        <short>Constructor for the class instance.</short>
        <descr>
          <p>
            Create is the overridden constructor for the class instance. It calls the inherited method on entry using AOwner as the owner of the class instance. Create allocates a TControlCanvas instance used for the Canvas property.
          </p>
        </descr>
        <seealso>
          <link id="TGraphicControl.Canvas"/>
          <link id="TControlCanvas"/>
          <link id="TControl.Create"/>
        </seealso>
      </element>
      <element name="TGraphicControl.Create.AOwner">
        <short>Owner of the class instance.</short>
      </element>

      <element name="TGraphicControl.Destroy">
        <short>Destructor for the class instance.</short>
        <descr>
          <p>
            Destroy is the overridden destructor for the class instance. It  ensures that resources allocated for the Canvas property are freed. It calls the inherited destructor prior to exiting from the method.
          </p>
        </descr>
        <seealso>
          <link id="TGraphicControl.Canvas"/>
        </seealso>
      </element>

      <element name="TGraphicControl.Canvas">
        <short>A clipped window into the parent Canvas.</short>
        <descr>
          <p>
            Don't paint on the entire Canvas! Instead use the dimensions of the <var>TGraphicControl</var> stored in the <var>ClientRect</var>.
          </p>
          <p>
            If you ask for the <var>Canvas.Width</var> or <var>Canvas.Height</var>, you are actually getting the Canvas dimensions from the Parent control.
          </p>
        </descr>
        <seealso>
          <link id="TControl.ClientRect"/>
          <link id="TControl.ClientWidth"/>
          <link id="TControl.ClientHeight"/>
          <link id="TControl.BoundsRect"/>
          <link id="#lcl.graphics.TCanvas">TCanvas</link>
        </seealso>
      </element>

      <element name="TCustomControl">
        <short>
          The base class for windowed controls which paint themselves.
        </short>
        <descr>
          <p>
            In contrast to <var>TGraphicControl</var>, a <var>TCustomControl</var> can accept keyboard input (and receive Focus), and can have child controls.
          </p>
          <p>
            Override the Paint method or supply your own OnPaint handler, to do the actual drawing of the control.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl"/>
          <link id="TGraphicControl"/>
        </seealso>
      </element>

      <element name="TCustomControl.FCanvas"/>
      <element name="TCustomControl.FOnPaint"/>

      <element link="#lcl.lclclasses.TLCLComponent.WSRegisterClass" name="TCustomControl.WSRegisterClass"/>

      <element name="TCustomControl.WMPaint">
        <short>Handles LM_PAINT messages for the control.</short>
        <descr>
          <p>
            Re-implements the method from the ancestor class to update ControlState prior to handling the specified Message. Includes the value csCustomPaint in ControlState before calling the inherited method. Removes csCustomPaint from ControlState after the message has been handled.
          </p>
          <p>
            No actions are performed in the method when the control is being freed, or when a Handle has not been allocated for the control.
          </p>
        </descr>
        <seealso>
          <link id="TWinControl.WMPaint"/>
        </seealso>
      </element>
      <element name="TCustomControl.WMPaint.Message">
        <short>Message handled in the method.</short>
      </element>

      <element name="TCustomControl.DestroyWnd">
        <short>Destroys the handle for the Canvas and the interface object.</short>
        <descr>
          <p>
            DestroyWnd is an overridden method in TCustomControl. It ensures that the Handle in Canvas is freed before calling the inherited method.
          </p>
        </descr>
        <seealso>
          <link id="TCustomControl.Canvas"/>
          <link id="TWinControl.DestroyWnd"/>
          <link id="TControlCanvas.FreeHandle"/>
        </seealso>
      </element>

      <element name="TCustomControl.PaintWindow">
        <short>The Paint handler plug-in, intercepting paint requests.</short>
        <descr>
          <p>
            <var>PaintWindow</var> is an overridden method in TCustomControl. It ensures that Canvas has an allocated Handle which matches the device context specified in the DC argument. If the Canvas handle does not match DC, the value in the argument is assigned to Canvas.
          </p>
          <p>
            PaintWindow calls the Paint method to signal the OnPaint event handler (when assigned).
          </p>
          <p>
            If Handle value in Canvas was changed in the method, it is reset to 0 (unassigned) prior to exit.
          </p>
          <p>
            PaintWindow does not call the inherited method.
          </p>
        </descr>
        <seealso>
          <link id="TCustomControl.Canvas"/>
          <link id="TCustomControl.Paint"/>
          <link id="TCustomControl.OnPaint"/>
          <link id="TWinControl.PaintWindow"/>
        </seealso>
      </element>
      <element name="TCustomControl.PaintWindow.DC">
        <short>The Device Context used to draw on the Canvas.</short>
      </element>

      <element name="TCustomControl.FontChanged">
        <short>Performs actions needed when the Font for the control has been changed.</short>
        <descr>
          <p>
            FontChanged is an overridden method in TCustomControl used to perform actions needed when the Font for the control has been changed. It is the routine used as the OnChange event handler for the Font property, and is assigned in the inherited constructor for the class instance.
          </p>
          <p>
            Sender contains the object instance for the event notification, and is provided to maintain compatibility with the TNotifyEvent signature for the event handler. It is not used in TGraphicControl, but is passed as an argument to the inherited method.
          </p>
          <p>
            FontChanged ensures that the new value for the Font property is also applied to the Canvas for the control. This includes the PixelsPerInch setting for the Font. FontChanged calls the inherited method prior to exit.
          </p>
        </descr>
        <seealso>
          <link id="TControl.FontChanged"/>
          <link id="TControl.Font"/>
          <link id="TControl.Create"/>
          <link id="#lcl.graphics.TFont.PixelsPerInch">TFont.PixelsPerInch</link>
        </seealso>
      </element>
      <element name="TCustomControl.FontChanged.Sender">
        <short>Object instance (TControl) for the event notification.</short>
      </element>

      <element name="TCustomControl.SetColor">
        <short>Sets the value for the Color property</short>
        <descr>
          <p>
            SetColor is an overridden method in TCustomControl used to set the value in the Color property. It calls the inherited method on entry, and applies the new color value to the Brush in the control Canvas.
          </p>
        </descr>
        <seealso>
          <link id="#lcl.controls.TControl.Color">TControl.Color</link>
          <link id="#lcl.controls.TWinControl.SetColor">TWinControl.SetColor</link>
        </seealso>
      </element>
      <element name="TCustomControl.SetColor.Value">
        <short>New value for the Color property.</short>
      </element>

      <element name="TCustomControl.Paint">
        <short>
          Implements the default handler used to draw the control.
        </short>
        <descr>
          <p>
            Paint is a method which causes the control to be drawn using the drawing mechanism for the control. In TCustomControl, like TGraphicControl, the OnPaint event handler is used (when assigned). Assign a routine to the OnPaint handler to perform the drawing operations needed for the control.
          </p>
          <p>
            Paint called from the PaintWindow method, and occurs when a LM_PAINT message is handled for the control.
          </p>
        </descr>
        <seealso>
          <link id="TCustomControl.OnPaint"/>
          <link id="TCustomControl.PaintWindow"/>
          <link id="TCustomControl.WMPaint"/>
        </seealso>
      </element>

      <element name="TCustomControl.Create">
        <short>Constructor for the class instance.</short>
        <descr>
          <p>
            Create is the overridden constructor for the class instance, and calls the inherited constructor on entry. Create allocates resources for the TControlCanvas instance used in the Canvas property.
          </p>
        </descr>
        <seealso>
          <link id="TCustomControl.Canvas"/>
          <link id="TControlCanvas"/>
        </seealso>
      </element>
      <element name="TCustomControl.Create.AOwner">
        <short>Owner for the class instance.</short>
      </element>

      <element name="TCustomControl.Destroy">
        <short>Destructor for the class instance.</short>
        <descr>
          <p>
            Destroy is the overridden destructor for the class instance.
          </p>
          <p>
            It calls RemoveFocus to prevent the Parent control from giving focus to the free control. It destroys the Handle for the control, and ensures that the control is removed as a Parent or DockSite for its child controls. It does not free the child controls; they are freed by their owner.
          </p>
          <p>
            Controls in the DockClient property are updated to remove the class instance from the HostDockSite property in the docking clients.
          </p>
          <p>
            Destroy frees resource allocated in the constructor, and calls the inherited method proper to exit.
          </p>
        </descr>
        <seealso>
          <link id="TCustomControl.Canvas"/>
        </seealso>
      </element>

      <element name="TCustomControl.Canvas">
        <short>
          The drawing surface for the control.
        </short>
        <descr>
          <p>
            Canvas is a TCanvas property which contains the drawing surface for the control. Resources for the property are allocated in the constructor for the class instance. A TControlCanvas descendant is created and assigned to the member for the property. The Handle for the Canvas is updated when PaintWindow is called for a specific device context.
          </p>
          <p>
            Changing values in the Font or Color properties causes settings in Canvas to be updated. A new value assigned to Font is also assigned to the Canvas in the control, and includes the PixelsPerInch setting for the Font. A new value assigned to Color is applied to the Brush in Canvas. A value assigned to BorderStyle must be handled in the routine assigned to the OnPaint event handler.
          </p>
        </descr>
        <seealso>
          <link id="TCustomControl.Canvas"/>
          <link id="TCustomControl.OnPaint"/>
          <link id="TWinControl.BorderStyle"/>
          <link id="TControl.Font"/>
          <link id="TControlCanvas"/>
          <link id="#lcl.graphics.TCanvas">TCanvas</link>
        </seealso>
      </element>

      <element name="TCustomControl.BorderStyle" link="#lcl.controls.TWinControl.BorderStyle"/>

      <element name="TCustomControl.OnPaint">
        <short>
          Event handler signalled to paint the control.
        </short>
        <descr>
          <p>
            OnPaint is a TNotifyEvent property with the event handler signalled to draw the control on its Canvas. An object procedure which draws all aspects of the control must be implemented and assigned to the property.
          </p>
          <p>
            The Sender argument provides access to properties and methods for the control instance. It must be cast to a TCustomControl to access members for the class type.
          </p>
          <p>
            Use Canvas to render the control in the event handler. The values from Font and Color are already applied to the corresponding properties in Canvas. The BorderStyle property must be applied in code for the handler.
          </p>
          <p>
            OnPaint is signalled from the Paint method.
          </p>
        </descr>
        <seealso>
          <link id="TCustomControl.Paint"/>
          <link id="TCustomControl.Canvas"/>
          <link id="TControl.Font"/>
          <link id="TControl.Color"/>
          <link id="TWinControl.BorderStyle"/>
        </seealso>
      </element>

      <element name="TImageList">
        <short>
          Implements a multi-resolution container for images used in an application.
        </short>
        <descr>
          <p>
            TImageList is a TDragImageList descendant, and sets the visibility for properties in ancestor classes (like TCustomImageList). As a <link id="TDragImageList">TDragImageList</link> descendant, it provides support for using images in the list during drag-and-drop or drag-and-dock operations. Most of the features and functionality for the list are inherited from the <link id="#lcl.imglist.TCustomImageList">TCustomImageList</link> class.
          </p>
        </descr>
        <seealso>
          <link id="TDragImageList"/>
          <link id="#lcl.imglist.TCustomImageList">TCustomImageList</link>
        </seealso>
      </element>

      <element link="#lcl.imglist.TCustomImageList.AllocBy" name="TImageList.AllocBy"/>
      <element link="#lcl.imglist.TCustomImageList.BlendColor" name="TImageList.BlendColor"/>
      <element link="#lcl.imglist.TCustomImageList.BkColor" name="TImageList.BkColor"/>
      <element link="#lcl.imglist.TCustomImageList.DrawingStyle" name="TImageList.DrawingStyle"/>
      <element link="#lcl.imglist.TCustomImageList.Height" name="TImageList.Height"/>
      <element link="#lcl.imglist.TCustomImageList.ImageType" name="TImageList.ImageType"/>
      <element link="#lcl.imglist.TCustomImageList.Masked" name="TImageList.Masked"/>
      <element link="#lcl.imglist.TCustomImageList.Scaled" name="TImageList.Scaled"/>
      <element link="#lcl.imglist.TCustomImageList.ShareImages" name="TImageList.ShareImages"/>
      <element link="#lcl.imglist.TCustomImageList.Width" name="TImageList.Width"/>
      <element link="#lcl.imglist.TCustomImageList.OnChange" name="TImageList.OnChange"/>
      <element link="#lcl.imglist.TCustomImageList.OnGetWidthForPPI" name="TImageList.OnGetWidthForPPI"/>

      <element name="TControlPropertyStorage">
        <short>
          Implements the abstract ancestor class used to get the property list for a control.
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TControlPropertyStorage.GetPropertyList">
        <short>
          Parses the <link id="TControl.SessionProperties"/> string into the given list.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlPropertyStorage.GetPropertyList.List">
        <short/>
      </element>

      <element name="TDockZone">
        <short>
          Represents a node in a <link id="#lcl.controls.TDockTree">TDockTree</link>
      </short>
        <descr>
          <p>
            It encapsulates a dock zone, containing either other zones or a single control.
          </p>
          <p>
            This implementation is specific to <link id="TDockTree"/>. Another DockManager can (and should) use its own class instead.
          </p>
        </descr>
        <seealso>
          <link id="TDockTree"/>
        </seealso>
      </element>

      <element name="TDockZone.FChildControl"/>
      <element name="TDockZone.FChildCount"/>
      <element name="TDockZone.FFirstChildZone"/>
      <element name="TDockZone.FTree"/>
      <element name="TDockZone.FParentZone"/>
      <element name="TDockZone.FOrientation"/>
      <element name="TDockZone.FNextSibling"/>
      <element name="TDockZone.FPrevSibling"/>
      <element name="TDockZone.FBounds"/>

      <element name="TDockZone.GetHeight">
        <short>Gets the value for the Height property.</short>
        <descr/>
        <seealso>
          <link id="TDockZone.Height"/>
        </seealso>
      </element>
      <element name="TDockZone.GetHeight.Result">
        <short>Value for the Height property.</short>
      </element>

      <element name="TDockZone.GetLeft">
        <short>Gets the value for the Left property.</short>
        <descr/>
        <seealso>
          <link id="TDockZone.Left"/>
        </seealso>
      </element>
      <element name="TDockZone.GetLeft.Result">
        <short>Gets the value for the Left property.</short>
      </element>

      <element name="TDockZone.GetLimitBegin">
        <short>Gets the value for the LimitBegin property.</short>
        <descr/>
        <seealso>
          <link id="TDockZone.LimitBegin"/>
        </seealso>
      </element>
      <element name="TDockZone.GetLimitBegin.Result">
        <short>Value for the LimitBegin property.</short>
      </element>

      <element name="TDockZone.GetLimitSize">
        <short>Gets the value for the LimitSize property.</short>
        <descr/>
        <seealso>
          <link id="TDockZone.LimitSize"/>
        </seealso>
      </element>
      <element name="TDockZone.GetLimitSize.Result">
        <short>Value for the LimitSize property.</short>
      </element>

      <element name="TDockZone.GetTop">
        <short>Gets the value for the Top property.</short>
        <descr/>
        <seealso>
          <link id="TDockZone.Top"/>
        </seealso>
      </element>
      <element name="TDockZone.GetTop.Result">
        <short>Value for the Top property.</short>
      </element>

      <element name="TDockZone.GetVisible">
        <short>Gets the value for the Visible property.</short>
        <descr/>
        <seealso>
          <link id="TDockZone.Visible"/>
        </seealso>
      </element>
      <element name="TDockZone.GetVisible.Result">
        <short>Value for the Visible property.</short>
      </element>

      <element name="TDockZone.GetVisibleChildCount">
        <short>Gets the value for the VisibleChildCount property.</short>
        <descr/>
        <seealso>
          <link id="TDockZone.VisibleChildCount"/>
        </seealso>
      </element>
      <element name="TDockZone.GetVisibleChildCount.Result">
        <short>Value for the VisibleChildCount property.</short>
      </element>

      <element name="TDockZone.GetWidth">
        <short>Gets the value for the Width property.</short>
        <descr/>
        <seealso>
          <link id="TDockZone.Width"/>
        </seealso>
      </element>
      <element name="TDockZone.GetWidth.Result">
        <short>Value for the Width property.</short>
      </element>

      <element name="TDockZone.SetLimitBegin">
        <short>Sets the value for the LimitBegin property.</short>
        <descr/>
        <seealso>
          <link id="TDockZone.LimitBegin"/>
        </seealso>
      </element>
      <element name="TDockZone.SetLimitBegin.AValue">
        <short>New value for the LimitBegin property.</short>
      </element>

      <element name="TDockZone.SetLimitSize">
        <short>New value for the LimitSize property.</short>
        <descr/>
        <seealso>
          <link id="TDockZone.LimitSize"/>
        </seealso>
      </element>
      <element name="TDockZone.SetLimitSize.AValue">
        <short>New value for the LimitSize property.</short>
      </element>

      <element name="TDockZone.SetHeight">
        <short>Sets the value for the Height property.</short>
        <descr/>
        <seealso>
          <link id="TDockZone.Height"/>
        </seealso>
      </element>
      <element name="TDockZone.SetHeight.AValue">
        <short>New value for the Height property.</short>
      </element>

      <element name="TDockZone.SetLeft">
        <short>Sets the value for the Left property.</short>
        <descr/>
        <seealso>
          <link id="TDockZone.Left"/>
        </seealso>
      </element>
      <element name="TDockZone.SetLeft.AValue">
        <short>New value for the Left property.</short>
      </element>

      <element name="TDockZone.SetTop">
        <short>Sets the value for the Top property.</short>
        <descr/>
        <seealso>
          <link id="TDockZone.Top"/>
        </seealso>
      </element>
      <element name="TDockZone.SetTop.AValue">
        <short>New value for the Top property.</short>
      </element>

      <element link="#lcl.controls.TDockZone.Width" name="TDockZone.SetWidth">
        <short>Sets the value for the Width property.</short>
        <descr/>
        <seealso>
          <link id="TDockZone.Width"/>
        </seealso>
      </element>
      <element name="TDockZone.SetWidth.AValue">
        <short>New value for the Width property.</short>
      </element>

      <element name="TDockZone.Create">
        <short>Constructor for the class instance.</short>
        <descr>
          <p>
            Stores values passed in the TheTree and TheChild arguments to the Tree and ChildControl property. Sets the initial bounds for the dock zone to an empty rectangle.  This causes the Top, Left, Width, and Height properties to contain 0 (zero).
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TDockZone.Create.TheTree">
        <short>The dock tree to which this zone belongs.</short>
      </element>
      <element name="TDockZone.Create.TheChildControl">
        <short>The control in this zone (or Nil when unassigned).</short>
      </element>

      <element name="TDockZone.FindZone">
        <short>Returns the dock zone containing the given control.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDockZone.FindZone.Result">
        <short>The zone containing AControl as ChildControl.</short>
      </element>
      <element name="TDockZone.FindZone.AControl">
        <short>Control to locate in the dock tree.</short>
      </element>

      <element name="TDockZone.FirstVisibleChild">
        <short>The first visible child zone.</short>
        <descr/>
        <seealso>
          <link id="TDockZone.Visible"/>
        </seealso>
      </element>
      <element name="TDockZone.FirstVisibleChild.Result">
        <short/>
      </element>

      <element name="TDockZone.GetNextVisibleZone">
        <short>The next visible zone.</short>
        <descr/>
        <seealso>
          <link id="TDockZone.Visible"/>
        </seealso>
      </element>
      <element name="TDockZone.GetNextVisibleZone.Result">
        <short>The zone, or <b>Nil</b> if none found.</short>
      </element>

      <element name="TDockZone.NextVisible">
        <short>The next visible zone.</short>
        <descr/>
        <seealso>
          <link id="TDockZone.Visible"/>
        </seealso>
      </element>
      <element name="TDockZone.NextVisible.Result">
        <short/>
      </element>

      <element name="TDockZone.PrevVisible">
        <short>The preceding visible zone.</short>
        <descr/>
        <seealso>
          <link id="TDockZone.Visible"/>
        </seealso>
      </element>
      <element name="TDockZone.PrevVisible.Result">
        <short/>
      </element>

      <element name="TDockZone.AddSibling">
        <short>Inserts NewZone as preceding or following sibling.</short>
        <descr/>
      </element>
      <element name="TDockZone.AddSibling.NewZone">
        <short>The zone to add.</short>
      </element>
      <element name="TDockZone.AddSibling.InsertAt">
        <short>How to add the zone.</short>
      </element>

      <element name="TDockZone.AddAsFirstChild">
        <short>Adds the given zone as the first child.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDockZone.AddAsFirstChild.NewChildZone">
        <short>The zone to add.</short>
      </element>

      <element name="TDockZone.AddAsLastChild">
        <short>Adds the given zone as the last child.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDockZone.AddAsLastChild.NewChildZone">
        <short>The zone to add.</short>
      </element>

      <element name="TDockZone.ReplaceChild">
        <short>
          Replace the <var>OldChild</var> zone by <var>NewChild</var>.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDockZone.ReplaceChild.OldChild">
        <short>The zone to unlink.</short>
      </element>
      <element name="TDockZone.ReplaceChild.NewChild">
        <short>The zone to link in place of OldChild.</short>
      </element>

      <element name="TDockZone.GetLastChild">
        <short>The last child zone.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDockZone.GetLastChild.Result">
        <short/>
      </element>

      <element name="TDockZone.GetIndex">
        <short>Calculates the index of the zone within its parent zone.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDockZone.GetIndex.Result">
        <short/>
      </element>

      <element name="TDockZone.Remove">
        <short>Unlinks the given child zone.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDockZone.Remove.ChildZone">
        <short/>
      </element>

      <element name="TDockZone.ChildControl">
        <short>The control docked in this zone.</short>
        <descr>
          A zone can contain nothing, a control, or child zones.
        </descr>
        <seealso/>
      </element>

      <element name="TDockZone.ChildCount">
        <short>The number of child zones.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDockZone.FirstChild">
        <short>The first child zone.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDockZone.Height">
        <short>The height of the zone.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDockZone.Left">
        <short>The left coordinate of the zone.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDockZone.LimitBegin">
        <short>The free coordinate of the DockZone (Left or Top).</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDockZone.LimitSize">
        <short>The free size of the DockZone (Width or Height).</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDockZone.Orientation">
        <short>
          Whether docking is oriented vertically, horizontally, in pages, or not at all.
        </short>
        <descr>
          <ul>
            <li>doNoOrient: zone contains a TControl and no child zones.</li>
            <li>doHorizontal: zone's children are stacked top-to-bottom.</li>
            <li>doVertical: zone's children are arranged left-to-right.</li>
            <li>doPages: zone's children are pages arranged left-to-right.</li>
          </ul>
        </descr>
        <seealso>
          <link id="TDockOrientation"/>
        </seealso>
      </element>

      <element name="TDockZone.Parent">
        <short>The parent zone in the DockTree.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDockZone.Top">
        <short>The top coordinate for the dock zone.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDockZone.Tree">
        <short>The dock tree of which this dock zone is a part.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDockZone.Visible">
        <short>
          A zone is visible if it contains a visible control, or if any child zone is visible.
        </short>
        <descr/>
        <seealso>
          <link id="TDockZone.VisibleChildCount"/>
        </seealso>
      </element>

      <element name="TDockZone.VisibleChildCount">
        <short>The number of visible child zones.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDockZone.Width">
        <short>The width of this zone.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDockZone.NextSibling">
        <short>The next sibling zone.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDockZone.PrevSibling">
        <short>The preceding sibling zone.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDockZoneClass">
        <short>Class of <link id="TDockZone"/></short>
      </element>

      <element name="TForEachZoneProc">
        <short>The type for a ForEachZone callback procedure, currently unused.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TForEachZoneProc.Zone">
        <short>The iterated zone.</short>
      </element>

      <element name="TDockTreeFlag">
        <short>Represents flag values used in TDockTree.</short>
        <descr/>
        <seealso>
          <link id="TDockTree"/>
        </seealso>
      </element>
      <element name="TDockTreeFlag.dtfUpdateAllNeeded">
        <short/>
      </element>

      <element name="TDockTreeFlags">
        <short>Set type used to store values from the TDockTreeFlag enumeration.</short>
        <descr/>
        <seealso>
          <link id="TDockTreeFlag"/>
        </seealso>
      </element>

      <element name="TDockTree">
        <short>A docking manager for tree-style layouts.</short>
        <descr>
          <p>
            A tree-style layout is organized in layers of a specific (horizontal or vertical) orientation. Every node in the tree is either a container for other nodes, or represents a zone with a single docked control. All child zones of an node have the same DockOrientation.
          </p>
          <p>
            The following documentation is copied from the Controls unit. It is of historical interest only, since it effectively describes the AnchorDocking, implemented in TCustomAnchoredDockManager. AnchorDocking is not related to visual drag-dock procedures, it merely is an attempt to implement just an layout manager.
          </p>
          <remark>
            The TLazDockTree implementation never was finished, due to problems with the anchor "docking" mechanism. Use the EasyDockManager (examples/dockmanager) instead.
          </remark>
          <p>
            This is an abstract class. A real implementation is e.g. in ldocktree.pas.
          </p>
          <p>
            Docking means here: Combining several windows to one. A window can here be a TCustomForm or a floating control (undocked) or a TDockForm. A window can be docked to another to the left, right, top, bottom or "into". The docking source window will be resized, to fit to the docking target window.
          </p>
          <p>
            Example1: Docking "A" (source window) left to "B" (target window)
          </p>
<code>
+---+    +-----+
| A | -&gt; |  B  |
|   |    |     |
+---+    +-----+
</code>
          <p>
            Result: A new docktree will be created. Height of "A" will be resized to the height of "B". A splitter will be inserted between "A" and "B". And all three are children of the newly created TLazDockForm of the newly created TDockTree.
          </p>
<code>
+------------+
|+---+|+----+|
|| A ||| B  ||
||   |||    ||
|+---+|+----+|
+------------+
</code>
          <ul>
            <li>If "A" or "B" were floating controls, the floating dock sites are freed.</li>
            <li>
              If "A" or "B" were forms, their decorations (title bars and borders) are replaced by docked decorations.
            </li>
            <li>
              If "A" had a TDockTree, it is freed and its child dockzones are merged to the docktree of "B".
            </li>
          </ul>
          <p>
            Analog for docking "C" left to "A":
          </p>
<code>
+------------------+
|+---+|+---+|+----+|
|| C ||| A ||| B  ||
||   |||   |||    ||
|+---+|+---+|+----+|
+------------------+
</code>
          <p>
            Example2: Docking A into B
          </p>
<code>
+-----+
|     |  +---+
|  B &lt;+--| A |
|     |  +---+
+-----+
</code>
          <p>
            Result: A new docktree will be created. "A" will be resized to the size of "B". Both will be put into a TLazDockPages control which is the child of the newly created TDockTree.
          </p>
<code>
+-------+
|[B][A] |
|+-----+|
||     ||
||  A  ||
||     ||
|+-----+|
+-------+
</code>
          <p>
            Every DockZone has siblings and children. Siblings can either be:
          </p>
          <ul>
            <li>horizontally (left to right, splitter),</li>
            <li>vertically (top to bottom, splitter), </li>
            <li>or upon each other (as notebook pages).</li>
          </ul>
          <p>
            <b>InsertControl</b> - undock a control and dock it into the dock site.
            For example, to dock Form1 left to a Form2:
          </p>
          <code>InsertControl(Form1,alLeft,Form2);</code>
          <p>
            To dock into a TDockPage, use:
          </p>
          <code>Align=alCustom;</code>
          <p>
            <b>PositionDockRect</b> - calculates where a control would be placed, if it would
            be docked via InsertControl.
          </p>
          <p>
            <b>RemoveControl</b> - removes a control from the dock site.
          </p>
          <p>
            <b>GetControlBounds</b> - TODO: for Delphi compatibility.
          </p>
          <p>
            <b>ResetBounds</b> - TODO: for Delphi compatibility.
          </p>
          <p>
            <b>SetReplacingControl</b> - TODO: for Delphi compatibility.
          </p>
          <p>
            <b>PaintSite</b> - TODO: for Delphi compatibility.
          </p>
        </descr>
        <seealso>
          <link id="TDockManager"/>
        </seealso>
      </element>

      <element name="TDockTree.FBorderWidth">
        <short>The width of the border around a dock zone.</short>
        <descr/>
        <seealso/>
      </element>

      <element link="#lcl.controls.TDockTree.DockSite" name="TDockTree.FDockSite"/>
      <element link="#lcl.controls.TDockTree.DockZoneClass" name="TDockTree.FDockZoneClass"/>
      <element name="TDockTree.FFlags"/>
      <element link="#lcl.controls.TDockTree.BeginUpdate" name="TDockTree.FUpdateCount"/>

      <element name="TDockTree.DeleteZone">
        <short>Destroys the zone and its child zones.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDockTree.DeleteZone.Zone">
        <short/>
      </element>

      <element link="#lcl.controls.TDockTree.DockSite" name="TDockTree.SetDockSite"/>
      <element name="TDockTree.SetDockSite.AValue">
        <short/>
      </element>

      <element link="#lcl.controls.TDockTree.RootZone" name="TDockTree.FRootZone"/>

      <element name="TDockTree.HitTest">
        <short>
          Returns the control and the part of the dockzone at the given coordinates.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDockTree.HitTest.Result">
        <short>The docked control.</short>
      </element>
      <element name="TDockTree.HitTest.MousePos">
        <short>The client coordinates.</short>
      </element>
      <element name="TDockTree.HitTest.HTFlag">
        <short>Returns the zone part at MousePos.</short>
      </element>

      <element name="TDockTree.PaintDockFrame">
        <short>Paints the dock header of the zone containing AControl.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDockTree.PaintDockFrame.ACanvas">
        <short/>
      </element>
      <element name="TDockTree.PaintDockFrame.AControl">
        <short/>
      </element>
      <element name="TDockTree.PaintDockFrame.ARect">
        <short/>
      </element>

      <element name="TDockTree.UpdateAll">
        <short>
          Updates the internal TDockTreeFlags to reflect the update status for the control
        </short>
        <descr>
          <p>
            <var>UpdateAll</var> is a procedure used to update the internal <var>TDockTreeFlags</var> member to reflect the current update status for the control. UpdateAll checks an internal counter, incremented in <var>BeginUpdate</var>, to see if <var>dtfUpdateAllNeeded</var> needs to be included in or excluded from the set of flag values. It is included when the update count is greater than <b>0</b> (<b>zero</b>). Otherwise, it is excluded from the set.
          </p>
          <p>
            UpdateAll is called from the <var>EndUpdate</var> method.
          </p>
        </descr>
        <seealso>
          <link id="TDockTree.BeginUpdate"/>
          <link id="TDockTree.EndUpdate"/>
          <link id="TDockTreeFlags"/>
          <link id="TDockTreeFlag"/>
        </seealso>
      </element>

      <element link="#lcl.controls.TDockTree.DockZoneClass" name="TDockTree.SetDockZoneClass"/>
      <element name="TDockTree.SetDockZoneClass.AValue">
        <short/>
      </element>

      <element name="TDockTree.Create">
        <short>Constructor for the class instance.</short>
        <descr>
          <p>
            Create is the overridden constructor for the class instance. TheDockSite contains the windowed control handled in the docking tree. Create calls the inherited constructor using TheDockSite as the owner for the class instance.
          </p>
          <p>
            Creates allocates resources needed for the RootZone property, and sets the value for its border width to 4.
          </p>
        </descr>
        <seealso>
          <link id="TDockTree.RootZone"/>
          <link id="TDockManager"/>
        </seealso>
      </element>
      <element name="TDockTree.Create.TheDockSite">
        <short>The window control to be managed.</short>
      </element>

      <element name="TDockTree.Destroy">
        <short>Destructor for the class instance.</short>
        <descr>
          <p>
            Frees resources allocated to the RootZone property, and calls the inherited destructor.
          </p>
        </descr>
        <seealso/>
      </element>

      <element name="TDockTree.BeginUpdate">
        <short>Starts an update process for the class instance.</short>
        <descr>
          <p>
            <var>BeginUpdate</var> is an overridden method in TDockTree. It increments the internal update counter for the class. It is used to consolidate calls to the UpdateAll method until the internal counter reaches zero (0).
          </p>
        </descr>
        <seealso>
          <link id="TDockManager.BeginUpdate"/>
          <link id="TDockManager.EndUpdate"/>
          <link id="TDockTree.UpdateAll"/>
        </seealso>
      </element>

      <element name="TDockTree.EndUpdate">
        <short>Finishes an update process for the class instance.</short>
        <descr>
          <p>
            <var>EndUpdate</var> is an overridden method in TDockTree. BeginUpdate and EndUpdate are used to consolidate calls to the <var>UpdateAll</var> method. EndUpdate decrements the internal update counter, and when it reaches zero (0) calls UpdateAll to remove dtfUpdateAllNeeded from the docking tree flags.
          </p>
        </descr>
        <seealso>
          <link id="TDockManager.EndUpdate"/>
          <link id="TDockManager.BeginUpdate"/>
          <link id="TDockTree.UpdateAll"/>
          <link id="TDockTreeFlags"/>
          <link id="TDockTreeFlag"/>
        </seealso>
      </element>

      <element name="TDockTree.AdjustDockRect">
        <short>Adjusts the zone rectangle for AControl.</short>
        <descr>
          <p>
            ARect initially describes the dockzone into which the control is docked. From that area the zone decoration is excluded, so that ARect describes the area reserved for the docked control.
          </p>
          <p>
            AdjustDockRect is not part of the general docking model. It can implemented and used for any purpose in a dock tree manager. Most docking managers will replace it by a method with more arguments, that allow to identify the zone and its properties immediately.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TDockTree.AdjustDockRect.AControl">
        <short/>
      </element>
      <element name="TDockTree.AdjustDockRect.ARect">
        <short/>
      </element>

      <element link="#lcl.controls.TDockManager.GetControlBounds" name="TDockTree.GetControlBounds"/>
      <element name="TDockTree.GetControlBounds.AControl">
        <short/>
      </element>
      <element name="TDockTree.GetControlBounds.ControlBounds">
        <short/>
      </element>

      <element name="TDockTree.InsertControl">
        <short>
          Positions <var>DropCtl</var> relative <var>Control</var>, using the alignment specified by <var>InsertAt</var>.
        </short>
        <descr>
          <p>
            <var>InsertControl</var> determines the layout and appearance of the just docked control, forcing a repaint of the container control if necessary.
          </p>
          <p>
            When <var>SetReplacingControl</var> has been called with a non-Nil Control before, the dropped control only should replace that control.
          </p>
          <p>
            A tree docking manager organizes the docksite into layers of horizontal or vertical orientation. As long as no more than one control is docked into a docksite, the tree has no orientation at all. The second docked control determines the orientation of the docksite and the dock tree. All further drops are either isogonal (in direction of the zone orientation) or orthogonal (opposite to the zone orientation). On an isogonal drop a new leaf zone is created for the dropped control, as a sibling of the already existing child zones. On an orthogonal drop the zone containing the DropControl becomes the root of another subtree, whose initial members are the leaf zones for <var>Control</var> and <var>DropCtl</var>.
          </p>
          <p>
            One value of <var>InsertAt</var> (<var>alCustom</var>) is reserved for notebook docking, where <var>DropCtl</var> is replaced by a tabbed notebook, and <var>Control</var> and <var>DropCtl</var> are moved into pages of the notebook. The notebook is a docksite of its own, further drops into the notebook are handled by the notebook itself, the <var>DockManager</var> of the host docksite is not involved.
          </p>
        </descr>
        <seealso>
          <link id="TDockManager.RemoveControl"/>
        </seealso>
      </element>
      <element name="TDockTree.InsertControl.AControl">
        <short>The control beneath which to place DropControl.</short>
      </element>
      <element name="TDockTree.InsertControl.InsertAt">
        <short>How to insert DropControl.</short>
      </element>
      <element name="TDockTree.InsertControl.DropControl">
        <short>The control to add.</short>
      </element>

      <element name="TDockTree.LoadFromStream">
        <short>Has an empty implementation in TDockTree.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDockTree.LoadFromStream.SrcStream">
        <short/>
      </element>

      <element name="TDockTree.MessageHandler">
        <short>Has an empty implementation in TDockTree.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TDockTree.MessageHandler.Sender">
        <short/>
      </element>
      <element name="TDockTree.MessageHandler.Message">
        <short/>
      </element>

      <element name="TDockTree.PositionDockRect" link="#lcl.controls.TDockManager.PositionDockRect"/>
      <element name="TDockTree.PositionDockRect.AClient">
        <short/>
      </element>
      <element name="TDockTree.PositionDockRect.DropCtl">
        <short/>
      </element>
      <element name="TDockTree.PositionDockRect.DropAlign">
        <short/>
      </element>
      <element name="TDockTree.PositionDockRect.DockRect">
        <short/>
      </element>

      <element link="#lcl.controls.TDockManager.RemoveControl" name="TDockTree.RemoveControl"/>
      <element name="TDockTree.RemoveControl.AControl">
        <short/>
      </element>

      <element link="#lcl.controls.TDockManager.SaveToStream" name="TDockTree.SaveToStream"/>
      <element name="TDockTree.SaveToStream.DestStream">
        <short/>
      </element>

      <element link="#lcl.controls.TDockManager.SetReplacingControl" name="TDockTree.SetReplacingControl"/>
      <element name="TDockTree.SetReplacingControl.AControl">
        <short/>
      </element>

      <element link="#lcl.controls.TDockManager.ResetBounds" name="TDockTree.ResetBounds"/>
      <element name="TDockTree.ResetBounds.Force">
        <short/>
      </element>

      <element link="#lcl.controls.TDockManager.PaintSite" name="TDockTree.PaintSite"/>
      <element name="TDockTree.PaintSite.DC">
        <short/>
      </element>

      <element name="TDockTree.DumpLayout">
        <short>Stores the layout in an file.</short>
      </element>
      <element name="TDockTree.DumpLayout.FileName">
        <short/>
      </element>

      <element name="TDockTree.DockZoneClass">
        <short>The class of all dock zones in this tree.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDockTree.DockSite">
        <short>
          The parent control whose docked clients are managed
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TDockTree.RootZone">
        <short>The root zone for the DockTree.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="DockSplitterClass">
        <short>Class type used to create new splitter class instances.</short>
        <descr>
          <p>
            Normally contains a reference to the <var>TSplitter</var> class, as assigned in the initialization section for the <file>extctrls.pp</file> unit.
          </p>
        </descr>
        <seealso>
          <link id="#lcl.extctrls.TSplitter">TSplitter</link>
        </seealso>
      </element>

      <element name="TMouse">
        <short>Provides access to properties of the Mouse.</short>
        <descr>
          <p>
            Contains information about the current mouse position, whether messages are captured by a window, whether it is dragging an object, and how far the mouse must move before a control starts dragging. TMouse is the type used for the Mouse global unit variable.
          </p>
        </descr>
        <seealso>
          <link id="Mouse"/>
        </seealso>
      </element>

      <element name="TMouse.FWheelScrollLines"/>

      <element link="#lcl.controls.TMouse.Capture" name="TMouse.SetCapture"/>
      <element name="TMouse.SetCapture.Value">
        <short/>
      </element>

      <element link="#lcl.controls.TMouse.Capture" name="TMouse.GetCapture"/>
      <element name="TMouse.GetCapture.Result">
        <short/>
      </element>

      <element link="#lcl.controls.TMouse.CursorPos" name="TMouse.GetCursorPos"/>
      <element name="TMouse.GetCursorPos.Result">
        <short/>
      </element>

      <element link="#lcl.controls.TMouse.IsDragging" name="TMouse.GetIsDragging"/>
      <element name="TMouse.GetIsDragging.Result">
        <short/>
      </element>

      <element link="#lcl.controls.TMouse.CursorPos" name="TMouse.SetCursorPos"/>
      <element name="TMouse.SetCursorPos.AValue">
        <short/>
      </element>

      <element link="#lcl.controls.TMouse.WheelScrollLines" name="TMouse.GetWheelScrollLines"/>
      <element name="TMouse.GetWheelScrollLines.Result">
        <short/>
      </element>

      <element link="#lcl.controls.TMouse.DragImmediate" name="TMouse.GetDragImmediate"/>
      <element name="TMouse.GetDragImmediate.Result">
        <short/>
      </element>

      <element link="#lcl.controls.TMouse.DragImmediate" name="TMouse.SetDragImmediate"/>
      <element name="TMouse.SetDragImmediate.AValue">
        <short/>
      </element>

      <element link="#lcl.controls.TMouse.DragThreshold" name="TMouse.GetDragThreshold"/>
      <element name="TMouse.GetDragThreshold.Result">
        <short/>
      </element>

      <element link="#lcl.controls.TMouse.DragThreshold" name="TMouse.SetDragThreshold"/>
      <element name="TMouse.SetDragThreshold.AValue">
        <short/>
      </element>

      <element name="TMouse.Capture">
        <short>Handle for the control with mouse capture.</short>
        <descr/>
      </element>

      <element name="TMouse.CursorPos">
        <short>The screen position for the mouse cursor.</short>
        <descr/>
      </element>

      <element name="TMouse.IsDragging">
        <short><b>True</b> while dragging an object.</short>
        <descr/>
        <seealso/>
      </element>

      <element name="TMouse.WheelScrollLines">
        <short>
          The number of lines to scroll with every notch or unit on the mouse wheel
        </short>
        <descr/>
        <seealso/>
      </element>

      <element name="TMouse.DragImmediate">
        <short>
          Does dragging start immediately (True), or only after a mouse move?
        </short>
        <descr/>
      </element>

      <element name="TMouse.DragThreshold">
        <short>
          The minimum distance the mouse must move before dragging starts (in delayed mode)
        </short>
        <descr>
          <p>
            The default value is 5 (pixels).
          </p>
        </descr>
      </element>

      <element name="AnchorAlign">
        <short>Array with sets of anchors used for a given alignment option.</short>
        <descr>
          <p>
            <var>AnchorAlign</var> is an array constant that contains elements with <var>TAnchors</var> set values. Values in AnchorAlign are indexed by <var>TAlign</var> enumeration values. This allows the TAlign value to retrieve the set of Anchors used for the specified align option. For example:
          </p>
<code>
AControl.Align := AnchorAlign[alRight]; // contains [akRight, akTop, akBottom]
</code>
        </descr>
        <seealso/>
      </element>

      <element name="MainAlignAnchor">
        <short/>
        <descr/>
        <seealso/>
      </element>

      <element name="OppositeAnchor">
        <short/>
        <descr/>
        <seealso/>
      </element>

      <element name="ClockwiseAnchor">
        <short/>
        <descr/>
        <seealso/>
      </element>

      <element name="DefaultSideForAnchorKind">
        <short/>
        <descr/>
        <seealso/>
      </element>

      <element name="AnchorReferenceSide">
        <short/>
        <descr/>
        <seealso/>
      </element>

      <element link="FindControlAtPosition" name="FindDragTarget">
        <short>Gets the drag target at the specified screen position.</short>
        <descr>
          <p>
            Disabled controls <b>should</b> be excluded, but are not due to an bug in <var>FindControlAtPosition</var>.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="FindDragTarget.Result">
        <short>The control at Position; <b>Nil</b> if none.</short>
      </element>
      <element name="FindDragTarget.Position">
        <short>The screen position.</short>
      </element>
      <element name="FindDragTarget.AllowDisabled">
        <short>Also finds disabled controls, if <b>True</b>.</short>
      </element>

      <element name="FindControlAtPosition">
        <short>
          Gets the control at the specified screen position.
        </short>
        <descr>
          <p>
            <var>FindControlAtPosition</var> is a <var>TControl</var> function used to get the control at the specified screen position. When <var>AllowDisabled</var> is <b>True</b>, a disabled control can also be located in the routine. In the current implementation, AllowDisabled is ignored (assumed to be <b>True</b>). First a window at the given screen position is searched, then a control within it.
          </p>
        </descr>
        <seealso>
          <link id="TControl"/>
          <link id="FindLCLWindow"/>
          <link id="TWinControl.ControlAtPos"/>
          <link id="TControlAtPosFlag"/>
        </seealso>
      </element>
      <element name="FindControlAtPosition.Result">
        <short>The control found at the specified Position; <b>Nil</b> when not found.</short>
      </element>
      <element name="FindControlAtPosition.Position">
        <short>The screen position examined in the routine.</short>
      </element>
      <element name="FindControlAtPosition.AllowDisabled">
        <short>Finds disabled controls when <b>True</b>.</short>
      </element>

      <element name="FindLCLWindow">
        <short>
          Find the window and its owning control at the given screen coordinates.
        </short>
        <descr>
          <p>
            <var>FindLCLWindow</var> is a <var>TWinControl</var> function used to find the window (and its owner control) at the specified screen coordinates.
          </p>
          <p>
            FindLCLWindow gets the Handle for the window and checks to ensure it is enabled. When it is not enabled, or <var>AllowDisabled</var> is <b>False</b>, parent handles are examined until a suitable window is located. FindOwnerControl is called for the handle to get the return value. The return value is <b>Nil</b> if a Window was not found at the specified position.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="FindLCLWindow.Result">
        <short>
          The control that owns the window at the specified screen position; <b>Nil</b> when a window is not found.
        </short>
      </element>
      <element name="FindLCLWindow.ScreenPos">
        <short>TPoint with the screen coordinates examined in the routine.</short>
      </element>
      <element name="FindLCLWindow.AllowDisabled">
        <short>Allows a disabled window to be returned.</short>
      </element>

      <element name="FindControl">
        <short>Return the TWinControl for the given Handle.</short>
        <descr>
          <p>
            The result is very interface specific; use FindOwnerControl when Handle may be a non-TWinControl handle
          </p>
        </descr>
        <seealso>
          <link id="FindOwnerControl"/>
        </seealso>
      </element>
      <element name="FindControl.Result">
        <short/>
      </element>
      <element name="FindControl.Handle">
        <short/>
      </element>

      <element name="FindOwnerControl">
        <short>
          Returns the TWinControl for the given Handle; the parent control for a non-TWinControl Handle.
        </short>
        <descr>
          <p>
            Handle can also be a child handle (of a TControl), in which case the returned control is the parent of the desired control. Parent, not Owner as suggested by the function name!
          </p>
          <remark>
            The function recursively tries GetParent(Handle), so the result depends on the implementation (meaning) of a parent handle.
          </remark>
        </descr>
      </element>
      <element name="FindOwnerControl.Result">
        <short/>
      </element>
      <element name="FindOwnerControl.Handle">
        <short/>
      </element>

      <element name="FindLCLControl">
        <short>
          Returns the TControl that currently is visible at a screen position.
        </short>
        <descr>
          The result is not reliable during resizing.
        </descr>
        <seealso/>
      </element>
      <element name="FindLCLControl.Result">
        <short/>
      </element>
      <element name="FindLCLControl.ScreenPos">
        <short/>
      </element>

      <element name="SendAppMessage" link="#LCL.LCLProc.SendApplicationMessage"/>
      <element name="SendAppMessage.Result">
        <short/>
      </element>
      <element name="SendAppMessage.Msg">
        <short/>
      </element>
      <element name="SendAppMessage.WParam">
        <short/>
      </element>
      <element name="SendAppMessage.LParam">
        <short/>
      </element>

      <element name="MoveWindowOrg">
        <short>Moves the origin for a windowed control.</short>
        <descr>
          <p>
            <var>MoveWindowOrg</var> is a procedure used to move the origin for a windowed control to the specified position. <var>dc</var> contains the device context for the Window handle used in the routine. <var>X</var> and <var>Y</var> contain the new coordinates in pixels used as the origin (Left and Top respectively) for canvas drawing operations.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="MoveWindowOrg.dc">
        <short>Device context updated in the routine.</short>
      </element>
      <element name="MoveWindowOrg.X">
        <short>Left coordinate for the new window origin.</short>
      </element>
      <element name="MoveWindowOrg.Y">
        <short>Top coordinate for the new window origin.</short>
      </element>

      <element name="RecreateWnd">
        <short>(Re-)Creates the widgetset class instance for a TWinControl.</short>
        <descr>
          <p>
            This function was originally a member of TWinControl.
          </p>
          <p>
            From a VCL point of view, that made perfectly sense since the VCL knows when a Win32 widget has to be recreated when properties have changed.
          </p>
          <p>
            The LCL, however, does not know when properties values are changed. But the widgetset does. To avoid the old VCL behavior, and to provide a central function for use in the widgetset, it has been moved here.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="RecreateWnd.AWinControl">
        <short/>
      </element>

      <element name="DefaultDockManagerClass">
        <short>
          The default class used to create a DockManager in <link id="TWinControl.CreateDockManager"/>.
        </short>
        <seealso>
          <link id="TDockManager"/>
        </seealso>
      </element>

      <element name="CancelDrag">
        <short>Cancels an active drag operation.</short>
        <descr>
          <p>
            <var>CancelDrag</var> is a procedure used to cancel an active drag operation. <var>CancelDrag</var> calls the <var>DragStop</var> method in the currently active <var>DragManager</var>.
          </p>
          <remark>
            No actions are performed in the routine when DragManager has not been assigned (contains <b>Nil</b>), or when DragManager returns <b>False</b> from its IsDragging method.
          </remark>
        </descr>
        <seealso>
          <link id="DragManager"/>
          <link id="TDragManager.DragStop"/>
          <link id="TDragManager.IsDragging"/>
        </seealso>
      </element>

      <element name="SetCaptureControl">
        <short>
          Set the mouse capture to AWinControl or its child at the given coordinates.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="SetCaptureControl.Control">
        <short/>
      </element>
      <element name="SetCaptureControl.AWinControl">
        <short/>
      </element>
      <element name="SetCaptureControl.Position">
        <short/>
      </element>

      <element name="GetCaptureControl">
        <short>
          Returns the TControl instance with mouse capture enabled.
        </short>
        <descr>
          <p>
            Please note: For the interface, only a Handle for TWinControl can capture the mouse. The LCL extends this to allow TControl to capture the mouse.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="GetCaptureControl.Result">
        <short/>
      </element>

      <element name="NewStyleControls">
        <short>Used in SynEdit.</short>
        <descr>
          <var>NewStyleControls</var> is a <var>Boolean</var> variable. Currently used only by SynEdit in <file>synedit.pp</file>.
        </descr>
        <seealso/>
      </element>

      <element name="Mouse">
        <short>The global TMouse instance for the unit.</short>
        <descr>
          <p>
            Allocated in the initialization section for the unit, and freed in the finalization section.
          </p>
        </descr>
        <seealso>
          <link id="TMouse"/>
        </seealso>
      </element>

      <element name="CursorToString">
        <short>
          Returns a string for the name of the cursor as identified by an integer constant.
        </short>
        <descr>
          Calls CursorToIdent to find correct entry in look-up table.
        </descr>
        <seealso>
          <link id="CursorToIdent"/>
        </seealso>
      </element>
      <element name="CursorToString.Result">
        <short>Returns a string with the name of the cursor type corresponding to the integer constant.</short>
      </element>
      <element name="CursorToString.Cursor">
        <short/>
      </element>

      <element name="StringToCursor">
        <short>
          <var>StringToCursor</var> - returns the cursor value corresponding to the name supplied.
        </short>
        <descr>
          <p>
            <var>StringToCursor</var> - returns the cursor value corresponding to the name supplied.
          </p>
          <p>
            Finds the numeric cursor value corresponding to the name <var>S</var> in the cursor look-up table.
          </p>
        </descr>
      </element>
      <element name="StringToCursor.Result">
        <short>The numeric cursor value from the look-up table.</short>
      </element>
      <element name="StringToCursor.S">
        <short>The name of the cursor for which the numeric value is sought.</short>
      </element>

      <element name="GetCursorValues">
        <short>Calls the specified procedure for each of the cursor identifiers.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="GetCursorValues.Proc">
        <short>String procedure called in the routine. </short>
      </element>

      <element name="CursorToIdent">
        <short>
          Uses look-up table to find cursor identifier corresponding to integer cursor constant.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="CursorToIdent.Result">
        <short>Returns <b>True</b> if a valid entry is found in the look-up table.</short>
      </element>
      <element name="CursorToIdent.Cursor">
        <short/>
      </element>
      <element name="CursorToIdent.Ident">
        <short/>
      </element>

      <element name="IdentToCursor">
        <short>
          Searches the Cursor name table for the given cursor name; returns <b>True</b> if found.
        </short>
        <descr>
          If found, the cursor value (handle) is returned in <var>Cursor</var>.
        </descr>
      </element>
      <element name="IdentToCursor.Result">
        <short>Returns <b>True</b> if a valid entry was found in the look-up table.</short>
      </element>
      <element name="IdentToCursor.Ident">
        <short>The name of the cursor for which the numeric value is sought.</short>
      </element>
      <element name="IdentToCursor.Cursor">
        <short>The numeric value of the named cursor.</short>
      </element>

      <element name="CheckTransparentWindow">
        <short>
          Checks whether the handle for a windowed control (or a parent control) is transparent.
        </short>
        <descr>
          <p>
            CheckTransparentWindow is procedure used to check whether the handle for a windowed control (or a parent control) is transparent. CheckTransparentWindow uses the current mouse position to locate controls or forms under the mouse rectangle. The LM_NCHITTEST message is performed for AWinControl to determine if the handle is drawn transparently. Additional Forms in the Z-Order are visited until an opaque windowed control is located. Parent controls are searched too (when needed).
          </p>
          <p>
            CheckTransparentWindow updates the values in Handle and AWinControl to reflect the results from the search. When an overlayed control is not located, the value in Handle is set to 0, and AWinControl is set to Nil.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="CheckTransparentWindow.Handle">
        <short/>
      </element>
      <element name="CheckTransparentWindow.AWinControl">
        <short/>
      </element>

      <element name="CheckMouseButtonDownUp">
        <short>Checks for multiple mouse click events for the specified control.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="CheckMouseButtonDownUp.Result">
        <short/>
      </element>
      <element name="CheckMouseButtonDownUp.AWinHandle">
        <short/>
      </element>
      <element name="CheckMouseButtonDownUp.AWinControl">
        <short/>
      </element>
      <element name="CheckMouseButtonDownUp.LastMouse">
        <short/>
      </element>
      <element name="CheckMouseButtonDownUp.AMousePos">
        <short/>
      </element>
      <element name="CheckMouseButtonDownUp.AButton">
        <short/>
      </element>
      <element name="CheckMouseButtonDownUp.AMouseDown">
        <short/>
      </element>

      <element name="GetKeyShiftState">
        <short>Gets a set of state values for current modifier keys.</short>
        <descr>
          <p>
            <var>GetKeyShiftState</var> is a <var>TShiftState</var> function used to get a set with the current state values for modifier keys. GetKeyShiftState calls <var>GetKeyState</var> to capture the values in the set for the following virtual keyboard keys:
          </p>
          <dl>
            <dt>VK_CONTROL</dt>
            <dd>Includes ssCtrl when the Control key is pressed</dd>
            <dt>VK_SHIFT</dt>
            <dd>Includes ssShift when the Control key is pressed</dd>
            <dt>VK_MENU</dt>
            <dd>Includes ssAlt when the Alt key is pressed</dd>
            <dt>VK_LWIN or VK_RWIN</dt>
            <dd>Includes ssMeta when one of the WIN keys  (or Alt+GR on Mac) is pressed</dd>
          </dl>
          <p>
            The return value is an empty set (<b>[]</b>) when none of the virtual keys have a non-zero value.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="GetKeyShiftState.Result">
        <short/>
      </element>

      <element name="AdjustBorderSpace">
        <short>Adjusts the space around the border for the control.</short>
        <descr>
          <p>RemainingClientRect: remaining clientrect without CurBorderSpace</p>
          <p>CurBorderSpace: current borderspace around RemainingClientRect</p>
          <p>Left, Top, Right, Bottom: apply these borderspaces to CurBorderSpace</p>
          <p>CurBorderSpace will be set to the maximum of CurBorderSpace and Left, Top, Right, Bottom.</p>
          <p>RemainingClientRect will shrink.</p>
          <p>RemainingClientRect will not shrink to negative size.</p>
        </descr>
        <seealso/>
      </element>
      <element name="AdjustBorderSpace.RemainingClientRect">
        <short/>
      </element>
      <element name="AdjustBorderSpace.CurBorderSpace">
        <short/>
      </element>
      <element name="AdjustBorderSpace.Left">
        <short/>
      </element>
      <element name="AdjustBorderSpace.Top">
        <short/>
      </element>
      <element name="AdjustBorderSpace.Right">
        <short/>
      </element>
      <element name="AdjustBorderSpace.Bottom">
        <short/>
      </element>
      <element name="AdjustBorderSpace.Space">
        <short/>
      </element>

      <element name="IsColorDefault">
        <short>Determines if the color for the control is the system default (GTK).</short>
        <descr>
          <p>
            Used by GTK-based widgetset classes to determine if the color in a control needs to be compares to the SYS_COLOR_BASE value used in the widgetset.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="IsColorDefault.Result">
        <short/>
      </element>
      <element name="IsColorDefault.AControl">
        <short/>
      </element>

      <element name="BidiFlipAlignment">
        <short>Gets the inverse alignment value when BiDiMode is enabled.</short>
        <descr>
          <p>
            Applies to TAlignment value taLeftJustify and taRightJustify. taCenter is always taCenter regardless of BidiMode.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="BidiFlipAlignment.Result">
        <short/>
      </element>
      <element name="BidiFlipAlignment.Alignment">
        <short>TAlignment value converted in the method.</short>
      </element>
      <element name="BidiFlipAlignment.Flip">
        <short><b>True</b> to flip the alignment value when BiDiMode is enabled.</short>
      </element>

      <element name="BidiFlipAnchors">
        <short>
          Swaps left and right anchor side settings for the specified control when BiDiMode is enabled.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="BidiFlipAnchors.Result">
        <short/>
      </element>
      <element name="BidiFlipAnchors.Control">
        <short/>
      </element>
      <element name="BidiFlipAnchors.Flip">
        <short/>
      </element>

      <element name="BidiFlipRect">
        <short>
          Flips the left and right coordinates relative to the ParentRect when Flip is <b>True</b>.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="BidiFlipRect.Result">
        <short/>
      </element>
      <element name="BidiFlipRect.Rect">
        <short/>
      </element>
      <element name="BidiFlipRect.ParentRect">
        <short/>
      </element>
      <element name="BidiFlipRect.Flip">
        <short/>
      </element>

      <element name="ChangeBiDiModeAlignment">
        <short>Flips the value Alignment to reflect the value needed for BiDi mode.</short>
        <descr/>
        <seealso/>
      </element>
      <element name="ChangeBiDiModeAlignment.Alignment">
        <short>TAligment value updated in the method.</short>
      </element>

      <element name="DbgS">
        <short>Converts items of several data types into strings, for debug output.</short>
        <descr/>
        <errors>[The parameters should have unique names, for every type]</errors>
        <seealso/>
      </element>
      <element name="DbgS.Result">
        <short>The string representing the given parameter(s).</short>
      </element>
      <element name="DbgS.a">
        <short>TAlign value converted in the routine.</short>
      </element>
      <element name="DbgS.Anchors">
        <short>Set of TAnchorKind values converted in the routine.</short>
      </element>
      <element name="DbgS.Side">
        <short>Anchor side enumeration value converted in the routine.</short>
      </element>
      <element name="DbgS.p">
        <short>Auto-size phase converted in the routine.</short>
      </element>
      <element name="DbgS.Phases">
        <short>All elements in this set will be shown as a comma-separated list.</short>
      </element>
      <element name="DbgS.cst">
        <short>Control style flag converted in the routine.</short>
      </element>
      <element name="DbgS.cs">
        <short>Set of control style flags converted in the routine.</short>
      </element>
      <element name="DbgS.fs">
        <short>Form style value converted in the routine.</short>
      </element>

      <element name="assign(variant):TCaption">
        <short>
          Declares an assignment operator used to convert a Variant type to a TCaption type.
        </short>
        <descr>
          <p>
            Declares an assignment operator used to convert a TVariant value to a TCaption value during assignment. Casts the value in AVariant to a String type and assigns it as the return value for the operator. For example:
          </p>
<code>
var
  AVariant: Variant;
  AControl: TControl;
  // ...
  AControl.Caption := AVariant;
</code>
        </descr>
        <seealso/>
      </element>
      <element name="Assign.Result">
        <short>TCaption value for the assignment operator.</short>
      </element>
      <element name="Assign.Variant">
        <short>Variant value converted to a TCaption value prior to assignment.</short>
      </element>

      <element name="CompareLazAccessibleObjectsByDataObject">
        <short>
          Compares the specified pointers containing a Lazarus accessibility object and a accessibility object data.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="CompareLazAccessibleObjectsByDataObject.Result">
        <short/>
      </element>
      <element name="CompareLazAccessibleObjectsByDataObject.o1">
        <short/>
      </element>
      <element name="CompareLazAccessibleObjectsByDataObject.o2">
        <short/>
      </element>

      <element name="CompareDataObjectWithLazAccessibleObject">
        <short>
          Compares the specified pointers containing Lazarus accessibility object data and a accessibility object.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="CompareDataObjectWithLazAccessibleObject.Result">
        <short/>
      </element>
      <element name="CompareDataObjectWithLazAccessibleObject.o">
        <short/>
      </element>
      <element name="CompareDataObjectWithLazAccessibleObject.ao">
        <short/>
      </element>

      <element name="Register">
        <short>
          Register the components provided by this unit or package, so that they can be instantiated.
        </short>
        <descr>
          <p>
            <var>Register</var> is a procedure used to register components in this unit in the Lazarus IDE. Register adds the <var>TImageList</var> component on the <b>Common Controls</b> tab. In addition, the <var>TCustomControl</var> and <var>TGraphicControl</var> components are registered without icons.
          </p>
          <p>
            Register can also be used to register the controls required by an application.
          </p>
        </descr>
        <seealso>
          <link id="#rtl.classes.registercomponents">RegisterComponents</link>
        </seealso>
      </element>

      <topic name="AutoSize">
        <short>
          <var>AutoSize</var> - boolean property that permits the size of a control to be adjusted automatically.
        </short>
        <descr>
          <p>
            <var>AutoSize</var> is a boolean property found in many classes; it permits the size of a control to be adjusted automatically to accommodate differences in the text or graphic contained therein, and allows most efficient use of available space
          </p>
          <p>
            Many controls call  <link id="#lcl.controls.TControl.DoAutoSize">TControl.DoAutoSize</link> to perform the actual auto-sizing.
          </p>
          <p>
            IMPORTANT: Many Delphi controls override this method and many call this method directly after setting some properties.
          </p>
          <p>
            During handle creation not all interfaces can create complete Device Contexts which are needed to calculate things like text size.
          </p>
          <p>
            That's why you should always call <link id="#lcl.controls.TControl.AdjustSize">AdjustSize</link> instead of <var>DoAutoSize</var>.
          </p>
          <p>
            <var>TControl.AdjustSize</var> calls <var>DoAutoSize</var> in a smart fashion.
          </p>
          <p>
            During loading and handle creation the calls are delayed.
          </p>
          <p>
            This method is essentially the same as <link id="#lcl.controls.TWinControl.DoAutoSize">TWinControl.DoAutoSize</link>.  But since <var>DoAutoSize</var> is commonly overridden in descendent components,  it is not useful to perform all tests, which can result in too much overhead. To reduce the overhead, the LCL  calls <var>AdjustSize</var> instead.
          </p>
          <p>
            When setting <var>AutoSize</var> to <b>True</b>, the LCL auto-sizes the width and height for the control. This is one of the most complex parts of the LCL, because the result depends on nearly a hundred properties. Let's start with a simple scenario:
          </p>
          <p>
            The LCL will only auto-size the Width or Height if it is free to resize. In other words, the width is not auto-sized if:
          </p>
          <ul>
            <li>
              The left and right side is anchored. You can anchor the sides with the <var>Anchors</var> property or by setting the <var>Align</var> property to <var>alTop</var>, <var>alBottom</var> or <var>alClient</var>
            </li>
            <li>
              The Width and Height are bound by the <var>Constraints</var> properties. The Constraints can also be overridden by the widgetset. For example the WinAPI does not allow resizing the height of a combobox. And the gtk widgetset does not allow resizing the width of a vertical scrollbar
            </li>
          </ul>
          <p>
            The new size is calculated by the protected method <link id="#lcl.controls.TControl.CalculatePreferredSize">TControl.CalculatePreferredSize</link>. This method asks the widgetset for an appropriate Width and Height. For example a <var>TButton</var> has preferred Width and Height. A <var>TComboBox</var> has only a preferred Height. The preferred Width is returned as 0 and so the LCL does not auto-size the Width - it keeps the width unaltered. Finally a <var>TMemo</var> has no preferred Width or Height. Therefore AutoSize has no effect on a TMemo.
          </p>
          <p>
            Some controls override this method. For example the <var>TGraphicControl</var> descendants like <var>TLabel</var> have no window handle and so cannot query the widgetset. They must calculate their preferred Width and Height themselves.
          </p>
          <p>
            The widgetsets must override the <var>GetPreferredSize</var> method for each widget class that has a preferred size (Width or Height or both).
          </p>
          <p><b>Parent.AutoSize</b></p>
          <p>
            The above described the simple explanation. The real algorithm provides far more possibilities and is therefore far more complex.
          </p>
          <p><b>Properties / Methods</b></p>
          <p><b>Left and Top</b></p>
          <p>
            If <var>Parent</var> is not <b>Nil</b> then <var>Left, Top</var> are the pixel distance to the top, left pixel of the parent's client area (not scrolled). Remember the client area is always without the frame and scrollbars of the parent. For Delphi users, some VCL controls like TGroupbox define the client area as the whole control including the frame.  Others do not. The LCL is more consistent, and therefore Delphi incompatible. Left and Top can be negative or bigger than the client area. Some widgetsets define a minimum, and maximum somewhere around 10,000 pixels or more.
          </p>
          <p>
            When the client area is scrolled the Left and Top are kept unchanged.
          </p>
          <p>
            During resizing, or when moving, the Left and Top coordinates are not always in sync with the coordinates for the Handle object.
          </p>
          <p>
            When Parent is unassigned (contains Nil),  Left and Top depend on the widgetset and the window manager. Until Lazarus 0.9.25,  this is typically the screen coordinate of the left, top of the client area for the form. This is Delphi incompatible. It is planned to change this to the Left, Top of the window.
          </p>
          <p><b>Hint:</b></p>
          <p>
            Each time you change Left and Top, the LCL starts the movement  instantly. If you want to change both Left and Top, use the following instead:
          </p>
<code>
with Button1 do
    SetBounds(NewLeft,NewTop,Width,Height);
</code>
          <p><b>Width and Height</b></p>
          <p>
            The Size in pixels must not be negative; most widgetsets do not allow Width and/or Height to be Zero (0). Some controls (on some platforms )define a larger minimum constraint. Instead of sizing a control to Width=0 and/or Height=0, set Visible to <b>False</b>. During resizing and moving, Width and Height are not always in sync with the size of the Handle object.
          </p>
          <p><b>BoundsRect</b></p>
          <p>Same as Bounds(Left,Top,Width,Height).</p>
          <p>Common newbie mistake:</p>
<code>
BoundsRect.Left:=3; // WRONG: common newbie mistake
</code>
          <p>
            This has no effect, because reading BoundsRect is a function. It creates a temporary TRect on the stack.
          </p>
          <p><b>ClientRect</b></p>
          <p>
            Left and Top are always 0,0. Width and Height are the visible size in pixels of the client area. Remember the client area is without the frame and without scrollbars. In a scrollable client area the logical client area can be bigger than the visible.
          </p>
          <p><b>ClientOrigin</b></p>
          <p>
            Returns the screen coordinate of the top left coordinate 0,0 of the client area. Note that this value is the position as stored in the interface and is not always in sync with the LCL. When a control is moved, the LCL sets the bounds to the desired position and sends a move message to the interface. It is up to the interface to handle moves instantly or queued.
          </p>
          <p><b>LCLIntf.GetClientBounds</b></p>
          <p>
            Returns the client bounds of a control. Like ClientRect, but Left and Top are the pixel distances to the control's left, top. For example on a TGroupBox the Left, Top are the width and height of the left and top frame border. Scrolling has no effect on GetClientBounds.
          </p>
          <p><b>LCLIntf.GetWindowRect</b></p>
          <p>
            After the call, ARect will be the control area in screen coordinates. That means, Left and Top will be the screen coordinate of the TopLeft pixel of the Handle object and Right and Bottom will be the screen coordinate of the BottomRight pixel.
          </p>
          <p><b>FBaseBoundsLock: integer</b></p>
          <p>
            Increased/Decreased by LockBaseBounds/UnlockBaseBounds. Used to keep FBaseBounds during SetBounds calls.
          </p>
          <p><b>FBaseParentClientSize: TPoint</b></p>
          <p>
            The Parent.ClientRect size valid for the FBaseBounds. FBaseBounds and FBaseParentClientSize are used to calculate the distance for akRight (akBottom). When the parent is resized, the LCL knows what distance to keep.
          </p>
          <p><b>FBoundsRectForNewParent: TRect</b></p>
          <p>
            When changing the Parent of a control the Handle is recreated and many things can happen. Especially for docking forms the process is too unreliable. Therefore the BoundsRect is saved. The VCL uses a similar mechanism.
          </p>
          <p><b>FLastDoChangeBounds: TRect</b></p>
          <p>
            Used to avoid calling OnChangeBounds with the same coordinates. This reduces user defined auto-sizing.
          </p>
          <p>
            <b>FLastResizeClientHeight: integer</b> <br/>
            <b>FLastResizeClientWidth: integer</b> <br/>
            <b>FLastResizeHeight: integer</b> <br/>
            <b>FLastResizeWidth: integer</b>
          </p>
          <p>
            Used to avoid calling OnResize with the same coordinates. This reduces user
            defined auto-sizing.
          </p>
          <p><b>FLoadedClientSize: TPoint</b></p>
          <p>
            During loading many things are delayed and many things are set and worse: in the wrong order. That's why SetClientWidth/SetClientHeight calls are stored and set at end of loading again. This way the LCL can restore the distances (e.g. akRight) used during designing.
          </p>
          <p><b>FReadBounds: TRect</b></p>
          <p>
            Same as FLoadedClientSize, but for SetLeft, SetTop, SetWidth, SetHeight.
          </p>
          <p><b>SetBoundsRectForNewParent(const AValue: TRect);</b></p>
          <p>Used to set FBoundsRectForNewParent. See above.</p>
          <p>
            <b>procedure SetInitialBounds(aLeft, aTop, aWidth, aHeight: integer); virtual;</b>
          </p>
          <p>A smart version of SetBounds, reducing overhead during creation and loading.</p>
          <p>
            <b>
              procedure UpdateBaseBounds(StoreBounds, StoreParentClientSize, UseLoadedValues: boolean); virtual;
            </b>
          </p>
          <p>Commit current bounds to base bounds.</p>
          <p>
            <b>procedure SetClientHeight(Value: Integer);</b> <br/>
            <b>procedure SetClientSize(Value: TPoint);</b> <br/>
            <b>procedure SetClientWidth(Value: Integer); </b>
          </p>
          <p>
            Exists for Delphi compatibility too. Resizes the control, to get the wanted ClientRect size.
          </p>
          <p>
            <b>procedure ChangeBounds(ALeft, ATop, AWidth, AHeight: integer); virtual;</b>
          </p>
          <p>
            This is the internal SetBounds. Applies constraints, updates base bounds, calls OnChangeBound, OnResize, locks bounds.
          </p>
          <p>
            <b>procedure DoSetBounds(ALeft, ATop, AWidth, AHeight: integer); virtual;</b>
          </p>
          <p>This really sets the FLeft, FTop, FWidth, FHeight private variables.</p>
          <p>
            <b>procedure SetBounds(aLeft, aTop, aWidth, aHeight: integer); virtual;</b>
          </p>
          <p>
            This is the standard procedure overridden by many Delphi controls. TWinControl overrides it too. Ignores calls when bounds are locked; lock the FBoundsRealized to avoid overhead to the interface during auto sizing. ChangeBounds is not locked this way.
          </p>
          <p>
            <b>Function GetClientOrigin: TPoint; virtual;</b>
          </p>
          <p>Screen coordinate of Left, Top of client area.</p>
          <p>
            <b>Function GetClientRect: TRect; virtual;</b>
          </p>
          <p>Size of client area. (always Left=0, Top=0)</p>
          <p>
            <b>Function GetScrolledClientRect: TRect; virtual;</b>
          </p>
          <p>Visible client area in ClientRect.</p>
          <p>
            <b>function GetChildsRect(Scrolled: boolean): TRect; virtual;</b>
          </p>
          <p>
            Returns the Client rectangle relative to the control's Left, Top. If Scrolled is <b>True</b>, the rectangle is moved by the current scrolling values (for an example see TScrollingWincontrol).
          </p>
          <p>
            <b>function GetClientScrollOffset: TPoint; virtual;</b>
          </p>
          <p>Returns the scrolling offset of the client area.</p>
          <p>
            <b>function GetControlOrigin: TPoint; virtual;</b>
          </p>
          <p>
            Returns the screen coordinate of the topleft coordinate 0,0 of the control area. (The topleft pixel of the control on the screen) Note that this value is the position as stored in the interface and is not always in sync with the LCL. When a control is moved, the LCL sets the bounds to the wanted position and sends a move message to the interface. It is up to the interface to handle moves instantly or queued.
          </p>
        </descr>
      </topic>

      <topic name="ControlCoordinates">
        <short>
          The coordinates of a control can be specified or retrieved in various ways
        </short>
        <descr>
          <p>
            The following description applies to members of TControl and TWinControl.
          </p>
          <p>
            Every control has an origin (Top, Left) and extent (Width, Height). The origin is relative to its Parent control (client coordinates) or, for floating controls (forms) with Parent=Nil, relative to the screen.
          </p>
          <p>
            The BoundsRect describes the TopLeft and BottomRight coordinates of the control, relative to its Parent.
          </p>
          <p>
            The BoundsRectForNewParent holds the new coordinates, to be used when the Parent of the control is changed later.
          </p>
          <p>
            The ClientRect describes the internal (client) area of a container control (TWinControl), excluding borders. Its Top and Left are always zero. In a TScrollingWinControl...
          </p>
          <p>
            BaseBounds holds the designed Bounds, to be used e.g. when a scale factor is set later.
          </p>
          <p>
            GetControlOrigin returns the origin in screen coordinates. These values are not always in sync with the <b>True</b> screen position, managed by the widgetset.
          </p>
          <p>
            ScreenToClient returns the client coordinates of an point given in the screen coordinates, i.e. the coordinates relative to the control's client origin.
          </p>
          <p>
            ClientToScreen returns the screen coordinates for an point in client coordinates.
          </p>
        </descr>
      </topic>

      <topic name="AnchoringControls">
        <short>How multiple controls can be aligned and resized together, at run-time.</short>
        <descr>
          <p>
            The tree-style layout of a form allows one to specify table-style areas, with a common width or height of all controls in the same area (using container controls like e.g. TPanel).
          </p>
          <p>
            Delphi introduced control anchoring to the sides of the Parent control. This means when a control in a form has Anchors[akRight]=True, its right side keeps its distance from the right side of its Parent, when its Parent is resized.
          </p>
          <p>
            The default anchors [akLeft,akTop] keep every control anchored to the origin (TopLeft) of their Parent control (of form). This will cause controls to disappear when the form is shrunken, or the user has to scroll through the form's client area.
          </p>
          <p>
            When a control shall e.g. use the available space, left over to its right, Anchors=[akLeft,akRight] will result in a variable-width control.
          </p>
          <p>
            The Align property allows one to stack controls at their Parent's sides, e.g. all controls with Align=alTop are stacked at the top of their Parent. The remaining space in the Parent can be occupied by a single control, of Align=alClient.
          </p>
          <p>
            Both Anchors and Align are tightly coupled, changing one property will affect the other one. This is harmless in so far, as the IDE (form designer) keeps all adjustments in sync, free of conflicts.
          </p>
          <p>
            Some people found this approved layout method too restrictive, and too complicated to use, and now LCL controls <b>also</b> can be anchored <b>freely</b> to each other. This layout management is traditionally referred to as "Anchor Docking", even if it is not related to docking at all.
          </p>
          <remark>
            This freedom requires that the GUI designer is responsible for consistent anchor specifications, which do not result in unresolvable cyclic references or other contradictions.
          </remark>
          <p>
            Anchor docking allows one to anchor every side of a control to an arbitrary side of another control, i.e. the left side of an Edit control can be anchored to the right side of its associated Label.
          </p>
          <p>
            <b>Example1</b>
          </p>
          <p>
            If you want to have the top of B the same as the top of C:
          </p>
<pre>
+-----+  +-----+
|  B  |  |  C  |
|     |  +-----+
+-----+
</pre>
          <p>
            use:
          </p>
<code>
B.AnchorSide[akTop].Control:=C;
B.AnchorSide[akTop].Side:=asrTop;
</code>
          <p>
            When you want to have a gap between both controls, set e.g. B.Borderspacing.Right to the desired amount. Setting C.Borderspacing.Left will have the same effect, and both can be used together; the resulting gap then reflects the maximum value of both properties.
          </p>
          <p>
            BorderSpacing is in effect even for controls without special anchoring, when AutoSize is used.
          </p>
          <p>
            Anchor docking also allows one to center a control relative to another control.
          </p>
          <p>
            <b>Example2</b>
          </p>
          <p>
            For centering A relative to B:
          </p>
<pre>
+-------+
|       | +---+
|   B   | | A |
|       | +---+
+-------+
</pre>
          <p>
            use:
          </p>
<code>
A.AnchorSide[akTop].Side:=asrCenter;
A.AnchorSide[akTop].Control:=B;
</code>
          <p>
            Or use this, it's equivalent:
          </p>
<code>
A.AnchorSide[akBottom].Side:=asrCenter;
A.AnchorSide[akBottom].Control:=B;
</code>
          <p>
            TControlChildSizing and TControlChildrenLayout offers additional means for aligning and separating controls.
          </p>
        </descr>
      </topic>

    </module>
    <!-- Controls -->
  </package>
</fpdoc-descriptions>
