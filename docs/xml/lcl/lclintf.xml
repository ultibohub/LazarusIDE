<?xml version="1.0" encoding="UTF-8"?>
<fpdoc-descriptions>
<package name="lcl">
<!--
====================================================================
LCLIntf
====================================================================
-->
<module name="LCLIntf">
<short>Contains WinAPI-like functions for Delphi compatibility.</short>
<descr>
<p>
This unit was created for Delphi compatibility. It contains selected 
functions from the Delphi Windows unit, which finally are implemented in the 
widgetsets.
</p>
<p>
<b>For LCL users:</b>
</p>
<p>
The functions can be used to make porting of Delphi applications easier, and 
are not 100% emulating WinAPI functions, not even under windows. They were 
implemented and tested with some common Delphi libraries. The LCL contains 
many extra functions that the Delphi VCL does not have.
</p>
<remark>
Some functions are not exactly Delphi or WinAPI compatible.
</remark>
<p>
For example: Instead of using the common Windows functions SaveDC and 
RestoreDC use the Canvas.SaveHandleState and Canvas.RestoreHandleState.
</p>
</descr>

<!-- unresolved type references -->
<element name="Windows"/>
<element name="ShellApi"/>
<element name="LazUTF16"/>
<element name="Unix"/>
<element name="MacOSAll"/>
<element name="CocoaAll"/>
<element name="Math"/>
<element name="Classes"/>
<element name="SysUtils"/>
<element name="Types"/>
<element name="LCLType"/>
<element name="LCLProc"/>
<element name="LMessages"/>
<element name="LCLStrConsts"/>
<element name="InterfaceBase"/>
<element name="GraphType"/>
<element name="FileUtil"/>
<element name="LazFileUtils"/>
<element name="UTF8Process"/>
<element name="LazUTF8"/>
<element name="LazSysUtils"/>
<element name="Maps"/>

<element name="Arc">
<short>Draws an elliptical curve.</short>
<descr>
<p>Use Arc to draw an elliptically curved line with the current Pen.</p>
<p>
The angles Angle16Deg and Angle16DegLength are measure in 1/16th of a degree. 
For example, a full circle equals 5760 (16*360). Positive values of 
Angle16Deg and Angle16DegLength mean counter-clockwise rotation while 
negative values mean a clockwise direction, from the point of view of who 
looks at the screen.
</p>
<p>
Zero degrees is at the 3 o'clock position (right).
</p>
</descr>
<seealso/>
</element>
<element name="Arc.Result">
<short/>
</element>
<element name="Arc.DC">
<short/>
</element>
<element name="Arc.Left">
<short/>
</element>
<element name="Arc.Top">
<short/>
</element>
<element name="Arc.Right">
<short/>
</element>
<element name="Arc.Bottom">
<short/>
</element>
<element name="Arc.Angle16Deg">
<short>
The starting angle in 1/16 degrees, starting right and continuing 
counter-clockwise.
</short>
</element>
<element name="Arc.Angle16DegLength">
<short>
The length of the arc. A positive value indicates that it goes 
counter-clockwise from the start angle and a negative value that it goes 
clockwise.
</short>
</element>

<element name="AngleChord">
<short>Draws a filled Chord described by two angles.</short>
<descr>
<p>
AngleChord is a Lazarus addition, similar to the Windows API Chord, but uses 
angles to control the location of the chord inside the ellipse instead of two 
points like the Windows API Chord.
</p>
<p>
A Chord is a section of an ellipse between two angles (angle1 and angle2), 
closed by a straight line (secant). It's equivalent to a Pie without the 
triangle between the arc and the center of the ellipse.
</p>
<p>
The curve part of the chord is defined by the ellipse which fits in the 
bounding rectangle specified by the coordinates x1, y1, x2 and y2.
</p>
<p>
The Chord is outlined by the current Pen and filled with the current Brush.
</p>
</descr>
<seealso>
<link id="#lcl.LCLIntf.Pie">LCLIntf.Pie</link>
<link id="#lcl.Graphics.TCanvas.Chord">Graphics.TCanvas.Chord</link>
<link id="#lcl.Graphics.TCanvas.Pie">Graphics.TCanvas.Pie</link>
</seealso>
</element>
<element name="AngleChord.Result">
<short><b>False</b> on failure.</short>
</element>
<element name="AngleChord.DC">
<short/>
</element>
<element name="AngleChord.x1">
<short/>
</element>
<element name="AngleChord.y1">
<short/>
</element>
<element name="AngleChord.x2">
<short/>
</element>
<element name="AngleChord.y2">
<short/>
</element>
<element name="AngleChord.angle1">
<short>
The starting angle in 1/16 degrees, starting right and continuing 
counter-clockwise.
</short>
</element>
<element name="AngleChord.angle2">
<short>
The ending angle in 1/16 degrees, starting right and continuing 
counter-clockwise.
</short>
</element>

<element name="BeginPaint">
<short>Start painting in a window.</short>
<descr>
<p>
This function is for use in WM_PAINT handlers only. Not all platforms allow 
for painting outside WM_PAINT messages.
</p>
<p>
BeginPaint prepares the specified window for painting and fills a PAINTSTRUCT 
structure with information about the painting.
</p>
</descr>
<seealso/>
</element>
<element name="BeginPaint.Result">
<short>A Device Context for the window, Nil on failure.
</short>
</element>
<element name="BeginPaint.Handle">
<short>The window Handle.</short>
</element>
<element name="BeginPaint.PS">
<short>Will receive painting information.</short>
</element>

<element name="BitBlt">
<short>
Copies a section of a Canvas to another one, performing a raster operation 
(ROP).
</short>
<descr>
<p>
This routine implements the equivalent Windows GDI API of the same name in 
all platforms supported by Lazarus. It copies a section of a Canvas to 
another one, without any stretching. It allows one to select the kind of 
operation which should be performed to draw the pixels into the destination 
in the parameter ROP. Allowed operations go from simply copying the pixels 
without change to inverting them and also to executing logical operations 
involving the source pixels and the previously existing pixels in the 
destination Canvas.
</p>
<p>
For normal usage one should only use SRCOPY in the ROP parameter, other 
operations may not be supported by all widgetsets.
</p>
<p>
There exist 16 raster operations, according to the possible combinations of 
two (boolean) values. Excluding the NOP case, that doesn't modify the target 
area, the possible values for ROP are:
</p>
<dl>
<dt>BLACKNESS</dt>
<dd>Fills the destination rectangle with black</dd>
<dt>DSTINVERT</dt>
<dd>Inverts the colors of the destination area</dd>
<dt>MERGECOPY</dt>
<dd>Fills the destination area with (Src and Pattern)</dd>
<dt>MERGEPAINT</dt>
<dd>Fills the destination area with (Dst or not Src)</dd>
<dt>NOTSRCCOPY</dt>
<dd>Fills the destination area with (not Src)</dd>
<dt>NOTSRCERASE</dt>
<dd>Fills the destination area with (not (Dst or Src))</dd>
<dt>PATCOPY</dt>
<dd>Fills the destination area with (Pattern)</dd>
<dt>PATINVERT</dt>
<dd>Fills the destination area with (Dst xor Pattern)</dd>
<dt>PATPAINT</dt>
<dd>Fills the destination area with (Dst or (not Src) or Pattern)</dd>
<dt>SRCAND</dt>
<dd>Fills the destination area with (Dst and Src)</dd>
<dt>SRCCOPY</dt>
<dd>Fills the destination area with Src</dd>
<dt>SRCERASE</dt>
<dd>Fills the destination area with ((not Dst) and Src)</dd>
<dt>SRCINVERT</dt>
<dd>Fills the destination area with (Dst xor Src)</dd>
<dt>SRCPAINT</dt>
<dd>
Combines the colors of the source and the destination using the operator OR 
on each pixel
</dd>
<dt>WHITENESS</dt>
<dd>Fills the destination rectangle with white</dd>
</dl>
<p>These flags can be added to above ROPs:</p>
<dl>
<dt>CAPTUREBLT</dt>
<dd>
Includes windows which are on top of the specified Canvas. This option is not 
recommended and is very hard to implement in all supported platforms.
</dd>
<dt>NOMIRRORBITMAP</dt>
<dd>
Prevents the bitmap from being mirrored.
</dd>
</dl>
</descr>
<seealso>
<link id="#lcl.lcltype.BLACKNESS">BLACKNESS</link>
<link id="#lcl.lcltype.DSTINVERT">DSTINVERT</link>
<link id="#lcl.lcltype.MERGECOPY">MERGECOPY</link>
<link id="#lcl.lcltype.MERGEPAINT">MERGEPAINT</link>
<link id="#lcl.lcltype.NOTSRCCOPY">NOTSRCCOPY</link>
<link id="#lcl.lcltype.NOTSRCERASE">NOTSRCERASE</link>
<link id="#lcl.lcltype.PATINVERT">PATINVERT</link>
<link id="#lcl.lcltype.PATPAINT">PATPAINT</link>
<link id="#lcl.lcltype.SRCAND">SRCAND</link>
<link id="#lcl.lcltype.SRCCOPY">SRCCOPY</link>
<link id="#lcl.lcltype.SRCERASE">SRCERASE</link>
<link id="#lcl.lcltype.SRCINVERT">SRCINVERT</link>
<link id="#lcl.lcltype.SRCPAINT">SRCPAINT</link>
<link id="#lcl.lcltype.WHITENESS">WHITENESS</link>
</seealso>
</element>
<element name="BitBlt.Result">
<short><b>False</b> on failure.</short>
</element>
<element name="BitBlt.DestDC">
<short>The destination Device Context.</short>
</element>
<element name="BitBlt.X">
<short>The origin in the destination DC.</short>
</element>
<element name="BitBlt.Y">
<short>The origin in the destination DC.</short>
</element>
<element name="BitBlt.Width">
<short>The image size.</short>
</element>
<element name="BitBlt.Height">
<short>The image size.</short>
</element>
<element name="BitBlt.SrcDC">
<short>The source Device Context.</short>
</element>
<element name="BitBlt.XSrc">
<short>The origin in the source DC.</short>
</element>
<element name="BitBlt.YSrc">
<short>The origin in the source DC.</short>
</element>
<element name="BitBlt.Rop">
<short>The raster operation.</short>
</element>

<element name="CallNextHookEx">
<short>Calls the next procedure in the hook chain.</short>
<descr/>
<seealso/>
</element>
<element name="CallNextHookEx.Result">
<short>Depends on the Hook type.</short>
</element>
<element name="CallNextHookEx.hhk">
<short>Handle of the current hook.</short>
</element>
<element name="CallNextHookEx.ncode">
<short>The Hook code (message ID).</short>
</element>
<element name="CallNextHookEx.WParam">
<short>Message parameter.</short>
</element>
<element name="CallNextHookEx.LParam">
<short>Message parameter.</short>
</element>

<element name="CallWindowProc">
<short>Calls another Window procedure, to handle a message.</short>
<descr/>
<seealso/>
</element>
<element name="CallWindowProc.Result">
<short/>
</element>
<element name="CallWindowProc.lpPrevWndFunc">
<short/>
</element>
<element name="CallWindowProc.Handle">
<short/>
</element>
<element name="CallWindowProc.Msg">
<short/>
</element>
<element name="CallWindowProc.WParam">
<short/>
</element>
<element name="CallWindowProc.LParam">
<short/>
</element>

<element name="ClientToScreen">
<short>
Converts (relative) Client coordinates into absolute Screen coordinates.
</short>
<descr/>
<seealso>
<link id="ScreenToClient"/>
</seealso>
</element>
<element name="ClientToScreen.Result">
<short><b>False</b> on failure.</short>
</element>
<element name="ClientToScreen.Handle">
<short>The window handle with the client area.</short>
</element>
<element name="ClientToScreen.P">
<short>The point to convert.</short>
</element>

<element name="CombineRgn">
<short>Combines two regions.</short>
<descr>
<p>The following parameters are present in this function:</p>
<dl>
<dt>Dest</dt>
<dd>The Handle of a region which will receive the result of the operation</dd>
<dt>Src1</dt>
<dd>One of the two regions to combine</dd>
<dt>Src2</dt>
<dd>The other region to combine</dd>
<dt>fnCombineMode</dt>
<dd>
The method to use to combine the regions. As for the parameter fnCombineMode, 
the following constants from the unit LCLType can be used:
</dd>
<dt>RGN_AND</dt>
<dd>The result is the intersection of the two combined regions.</dd>
<dt>RGN_COPY</dt>
<dd>The result is a copy of the region Src1</dd>
<dt>RGN_DIFF</dt>
<dd>Combines the parts of Src1 that are not part of Src2.</dd>
<dt>RGN_OR</dt>
<dd>The result is the union of the two regions.</dd>
<dt>RGN_XOR</dt>
<dd>
The result is the union of two combined regions except for any overlapping 
areas.
</dd>
</dl>
</descr>
<seealso/>
</element>
<element name="CombineRgn.Result">
<short/>
</element>
<element name="CombineRgn.Dest">
<short>The Handle of the destination region. This region must already exist!
</short>
</element>
<element name="CombineRgn.Src1">
<short>The handle of a region to combine.</short>
</element>
<element name="CombineRgn.Src2">
<short>The handle of a region to combine.</short>
</element>
<element name="CombineRgn.fnCombineMode">
<short>How the regions are combined.</short>
</element>

<element name="CreateBitmap">
<short>Creates a bitmap object.</short>
<descr/>
<seealso/>
</element>
<element name="CreateBitmap.Result">
<short>The bitmap Handle, zero on failure.</short>
</element>
<element name="CreateBitmap.Width">
<short/>
</element>
<element name="CreateBitmap.Height">
<short/>
</element>
<element name="CreateBitmap.Planes">
<short>The number of color planes.</short>
</element>
<element name="CreateBitmap.BitCount">
<short>The number of color bits per pixel and plane.</short>
</element>
<element name="CreateBitmap.BitmapBits">
<short>The bitmap pixels. Scanlines must be word-aligned.</short>
</element>

<element name="CreateBrushIndirect">
<short>Creates a brush object (bitmap).</short>
<descr>
<p>
A brush is used to fill image areas (background...). It has a color and a 
pattern, e.g. BS_SOLID.
</p>
</descr>
<seealso/>
</element>
<element name="CreateBrushIndirect.Result">
<short>The brush Handle, zero on failure.</short>
</element>
<element name="CreateBrushIndirect.LogBrush">
<short>Description of the brush.</short>
</element>

<element name="CreateCaret">
<short>
Creates the Caret (text cursor) for the specified windowed control.
</short>
<descr>
<p>
<var>CreateCaret</var> is a <var>Boolean</var> function used to created the 
caret (or text cursor) displayed on a control when editing is active. 
CreateCaret calls the corresponding routine in the widgetset class to 
initialize the cursor with a given size, or a shape loaded from a bitmap 
image.
</p>
<p>
<var>Handle</var> is the HWND value representing the handle for the windowed 
control which owns and implements the caret.
</p>
<p>
<var>Bitmap</var> is the HBITMAP value with the handle for the bitmap image 
used as the caret shape. When Bitmap is set to 0, a handle is not available 
for the caret shape. When Bitmap is assigned, the values in the Height and 
Width arguments are ignored; the dimensions are determined by the bitmap 
image.
</p>
<p>
The Windows platform attaches special meanings to the values 0 and 1 in the 
Bitmap handle. 0 causes a solid black block with the dimensions in Height and 
Width to be used as the caret shape. 1 causes a solid gray block with the 
dimensions in Height and Width to be used as the caret shape.
</p>
</descr>
<seealso>
<link id="DestroyCaret"/>
<link id="ShowCaret"/>
<link id="HideCaret"/>
<link id="SetCaretPos"/>
<link id="SetCaretPosEx"/>
</seealso>
</element>
<element name="CreateCaret.Result">
<short><b>False</b> on failure.</short>
</element>
<element name="CreateCaret.Handle">
<short>The handle for the windowed control that owns the caret.</short>
</element>
<element name="CreateCaret.Bitmap">
<short>
The handle for the Bitmap with the caret shape, 0 for a solid (black) caret, 
or 1 for a gray caret.
</short>
</element>
<element name="CreateCaret.Width">
<short>The width of the caret.</short>
</element>
<element name="CreateCaret.Height">
<short>The height of the caret.</short>
</element>

<element name="CreateCompatibleBitmap">
<short>Creates a bitmap that is compatible with the given DC.</short>
<descr/>
<seealso/>
</element>
<element name="CreateCompatibleBitmap.Result">
<short>The bitmap handle, zero on failure.</short>
</element>
<element name="CreateCompatibleBitmap.DC">
<short>The Device Context for the bitmap.</short>
</element>
<element name="CreateCompatibleBitmap.Width">
<short>The bitmap width in pixels.</short>
</element>
<element name="CreateCompatibleBitmap.Height">
<short>The bitmap height in pixels.</short>
</element>

<element name="CreateCompatibleDC">
<short>
Creates an memory Device Context, compatible with the device of the given DC.
</short>
<descr/>
<seealso/>
</element>
<element name="CreateCompatibleDC.Result">
<short>The memory DC, zero on failure.</short>
</element>
<element name="CreateCompatibleDC.DC">
<short>The device DC.</short>
</element>

<element name="CreateDIBitmap">
<short>
Creates a Device Dependent Bitmap (DDB) from a Device Independent Bitmap 
(DIB).
</short>
<descr/>
<seealso/>
</element>
<element name="CreateDIBitmap.Result">
<short>The bitmap handle, zero on failure.</short>
</element>
<element name="CreateDIBitmap.DC">
<short>The context for the DDB.</short>
</element>
<element name="CreateDIBitmap.InfoHeader">
<short>The bitmap info header.</short>
</element>
<element name="CreateDIBitmap.dwUsage">
<short/>
</element>
<element name="CreateDIBitmap.InitBits">
<short>An array containing the bitmap pixels.</short>
</element>
<element name="CreateDIBitmap.InitInfo">
<short>CBM_INIT when InitBits contains valid data, else zero.</short>
</element>
<element name="CreateDIBitmap.wUsage">
<short/>
</element>

<element name="CreateDIBSection">
<short>Creates a bitmap into which the application can write.</short>
<descr/>
<seealso/>
</element>
<element name="CreateDIBSection.Result">
<short>The bitmap Handle, zero on failure.</short>
</element>
<element name="CreateDIBSection.DC">
<short>The DC for the bitmap.</short>
</element>
<element name="CreateDIBSection.BitmapInfo">
<short>Contains all information about the bitmap, except the pixels.</short>
</element>
<element name="CreateDIBSection.Usage">
<short>The type of the bitmap colors, e.g. DIB_RGB_COLORS.</short>
</element>
<element name="CreateDIBSection.Bits">
<short>Pointer to the bitmap pixels.</short>
</element>
<element name="CreateDIBSection.SectionHandle">
<short>
Zero or the Handle of a file-mapping object, from which the bitmap is 
initialized (needs CreateFileMapping).
</short>
</element>
<element name="CreateDIBSection.Offset">
<short>The offset to the bitmap bits in the file-mapping object.</short>
</element>

<element name="CreateEllipticRgn">
<short>Creates an elliptic region.</short>
<descr/>
<seealso/>
</element>
<element name="CreateEllipticRgn.Result">
<short>The region Handle, zero on failure.</short>
</element>
<element name="CreateEllipticRgn.X1">
<short/>
</element>
<element name="CreateEllipticRgn.Y1">
<short/>
</element>
<element name="CreateEllipticRgn.X2">
<short/>
</element>
<element name="CreateEllipticRgn.Y2">
<short/>
</element>

<element name="CreateFontIndirect">
<short>Creates a logical font, selectable into any DC.</short>
<descr/>
<seealso>
<link id="CreateFontIndirectEx"/>
</seealso>
</element>
<element name="CreateFontIndirect.Result">
<short>The font handle, zero on failure.</short>
</element>
<element name="CreateFontIndirect.LogFont">
<short>The font description.</short>
</element>

<element name="CreateFontIndirectEx">
<short>
Creates a logical font, selectable into any DC. Allows for a long font name.
</short>
<descr/>
<seealso>
<link id="CreateFontIndirect"/>
</seealso>
</element>
<element name="CreateFontIndirectEx.Result">
<short>The font handle, zero on failure.</short>
</element>
<element name="CreateFontIndirectEx.LogFont">
<short>The font description.</short>
</element>
<element name="CreateFontIndirectEx.LongFontName">
<short>The font name, can be longer than 32 characters.</short>
</element>

<element name="CreateIconIndirect">
<short>Creates an icon or cursor.</short>
<descr/>
<seealso/>
</element>
<element name="CreateIconIndirect.Result">
<short>The Handle, zero on failure.</short>
</element>
<element name="CreateIconIndirect.IconInfo">
<short/>
</element>

<element name="CreatePalette">
<short>Creates a logical palette, selectable into any DC.</short>
<descr/>
<seealso/>
</element>
<element name="CreatePalette.Result">
<short>The palette Handle, zero on failure.</short>
</element>
<element name="CreatePalette.LogPalette">
<short/>
</element>

<element name="CreatePatternBrush">
<short>Creates a logical brush, selectable into any DC.</short>
<descr>
<p>
The bitmap pattern is repeated for areas of larger width or height, it should 
allow for smooth transitions.
</p>
<p>
Monochrome bitmaps obtain the actual text (0) or background (1) color of the 
DC.
</p>
</descr>
<seealso/>
</element>
<element name="CreatePatternBrush.Result">
<short>The brush handle, zero on failure.</short>
</element>
<element name="CreatePatternBrush.ABitmap">
<short>The bitmap to use for the brush.</short>
</element>

<element name="CreatePenIndirect">
<short>Creates a logical Pen, selectable into any DC.</short>
<descr/>
<seealso/>
</element>
<element name="CreatePenIndirect.Result">
<short>The pen Handle, zero on failure.</short>
</element>
<element name="CreatePenIndirect.LogPen">
<short/>
</element>

<element name="CreatePolygonRgn">
<short>Creates a polygonal region.</short>
<descr>
<p>
The last point in Points is connected to the first point to close the region.
</p>
</descr>
<seealso/>
</element>
<element name="CreatePolygonRgn.Result">
<short>The region Handle, zero on failure.</short>
</element>
<element name="CreatePolygonRgn.Points">
<short>The array of points.</short>
</element>
<element name="CreatePolygonRgn.NumPts">
<short>The number of points in Points.</short>
</element>
<element name="CreatePolygonRgn.FillMode">
<short>Can be ALTERNATE or WINDING.</short>
</element>

<element name="CreateRectRgn">
<short>Creates a rectangular region.</short>
<descr/>
<seealso/>
</element>
<element name="CreateRectRgn.Result">
<short>The region handle, zero on failure.</short>
</element>
<element name="CreateRectRgn.X1">
<short/>
</element>
<element name="CreateRectRgn.Y1">
<short/>
</element>
<element name="CreateRectRgn.X2">
<short/>
</element>
<element name="CreateRectRgn.Y2">
<short/>
</element>

<element name="CreateRoundRectRgn">
<short>Creates a rectangular region with rounded corners.</short>
<descr>
<p>
Creates a rectangular region with rounded corners.
</p>
</descr>
<seealso/>
</element>
<element name="CreateRoundRectRgn.Result">
<short>The region Handle, zero on failure.</short>
</element>
<element name="CreateRoundRectRgn.X1">
<short/>
</element>
<element name="CreateRoundRectRgn.Y1">
<short/>
</element>
<element name="CreateRoundRectRgn.X2">
<short/>
</element>
<element name="CreateRoundRectRgn.Y2">
<short/>
</element>
<element name="CreateRoundRectRgn.nWidthEllipse">
<short>The extent of the ellipse, used for the rounded corners.</short>
</element>
<element name="CreateRoundRectRgn.nHeightEllipse">
<short>The extent of the ellipse, used for the rounded corners.</short>
</element>

<element name="DeleteCriticalSection">
<short>Deletes an un-owned critical section.</short>
<descr/>
<errors>
Results are unpredictable when the section is owned, i. e. has been entered 
but not yet exited.
</errors>
<seealso/>
</element>
<element name="DeleteCriticalSection.CritSection">
<short/>
</element>

<element name="DeleteDC">
<short>Deletes a device context created by CreateDC.</short>
<descr/>
<seealso>
<link id="ReleaseDC"/>
</seealso>
</element>
<element name="DeleteDC.Result">
<short><b>False</b> on failure.</short>
</element>
<element name="DeleteDC.hDC">
<short/>
</element>

<element name="DeleteObject">
<short>Frees a GDI object.</short>
<descr>
<p>
The bitmap used in a pattern brush is not destroyed with the brush.
</p>
</descr>
<errors>
The function fails when the Handle is selected into an DC.
</errors>
<seealso/>
</element>
<element name="DeleteObject.Result">
<short><b>False</b> on failure.</short>
</element>
<element name="DeleteObject.GDIObject">
<short/>
</element>

<element name="DestroyCaret">
<short>Destroys the caret but does not free the bitmap.</short>
<descr/>
<seealso/>
</element>
<element name="DestroyCaret.Result">
<short><b>False</b> on failure.</short>
</element>
<element name="DestroyCaret.Handle">
<short>Handle for the windowed control with the caret.</short>
</element>

<element name="DestroyCursor">
<short>Destroys a mouse cursor.</short>
<descr/>
<seealso/>
</element>
<element name="DestroyCursor.Result">
<short><b>False</b> on failure.</short>
</element>
<element name="DestroyCursor.Handle">
<short>The cursor Handle.</short>
</element>

<element name="DestroyIcon">
<short>Destroys an icon.</short>
<descr/>
<seealso/>
</element>
<element name="DestroyIcon.Result">
<short><b>False</b> on failure.</short>
</element>
<element name="DestroyIcon.Handle">
<short/>
</element>

<element name="DPtoLP">
<short>
Converts an array of Device Points (coordinates) into Logical Points.
</short>
<descr/>
<seealso/>
</element>
<element name="DPtoLP.Result">
<short><b>False</b> on failure.</short>
</element>
<element name="DPtoLP.DC">
<short>
The device context, containing the coordinate mapping information.
</short>
</element>
<element name="DPtoLP.Points">
<short>An array of points.</short>
</element>
<element name="DPtoLP.Count">
<short>The number of points to convert.</short>
</element>

<element name="DrawFrameControl">
<short>
Draws a window frame for a control of the specified type in a given state.
</short>
<descr/>
<seealso/>
</element>
<element name="DrawFrameControl.Result">
<short>
Returns <b>False</b> when the control type is anything other than a button.
</short>
</element>
<element name="DrawFrameControl.DC">
<short>Device context where the operation is performed.</short>
</element>
<element name="DrawFrameControl.Rect">
<short>Rectangle with the bounds for the control.</short>
</element>
<element name="DrawFrameControl.uType">
<short>Identifies the type of control for the frame.</short>
</element>
<element name="DrawFrameControl.uState">
<short>Identifies the state for the control.</short>
</element>

<element name="DrawFocusRect">
<short>Draws a focus rectangle on the specified device context.</short>
<descr/>
<seealso/>
</element>
<element name="DrawFocusRect.Result">
<short/>
</element>
<element name="DrawFocusRect.DC">
<short>Device context for the operation.</short>
</element>
<element name="DrawFocusRect.Rect">
<short>
Coordinates on the device context used to draw the focus rectangle.
</short>
</element>

<element name="DrawEdge">
<short>Draws one or more edges for a rectangle.</short>
<descr/>
<seealso/>
</element>
<element name="DrawEdge.Result">
<short/>
</element>
<element name="DrawEdge.DC">
<short/>
</element>
<element name="DrawEdge.Rect">
<short/>
</element>
<element name="DrawEdge.edge">
<short/>
</element>
<element name="DrawEdge.grfFlags">
<short/>
</element>

<element name="DrawText">
<short>Draws formatted text on the specified device context.</short>
<descr/>
<seealso>
<link id="TextOut"/>
<link id="GetTextMetrics"/>
</seealso>
</element>
<element name="DrawText.Result">
<short>1 on success, 0 when text could not be drawn.</short>
</element>
<element name="DrawText.DC">
<short>Device context used to measure and render the specified Text.</short>
</element>
<element name="DrawText.Str">
<short>Text drawn in the routine.</short>
</element>
<element name="DrawText.Count">
<short>Length of the value in Str; calculated when Count is negative.</short>
</element>
<element name="DrawText.Rect">
<short>Rectangle where the text was drawn.</short>
</element>
<element name="DrawText.Flags">
<short>DrawText flags examined in the routine.</short>
</element>

<element name="EnableScrollBar">
<short>
Enables or disables the arrows of a scroll bar control, or of the scroll bars 
of a window.
</short>
<descr/>
<seealso/>
</element>
<element name="EnableScrollBar.Result">
<short/>
</element>
<element name="EnableScrollBar.Wnd">
<short/>
</element>
<element name="EnableScrollBar.wSBflags">
<short/>
</element>
<element name="EnableScrollBar.wArrows">
<short/>
</element>

<element name="EnableWindow">
<short>
Enables or disables mouse and keyboard input to the specified window or 
control.
</short>
<descr/>
<seealso/>
</element>
<element name="EnableWindow.Result">
<short/>
</element>
<element name="EnableWindow.hWnd">
<short/>
</element>
<element name="EnableWindow.bEnable">
<short/>
</element>

<element name="EndPaint">
<short>Ends painting a window, started with BeginPaint.</short>
<descr/>
<seealso/>
</element>

<element name="EndPaint.Result">
<short/>
</element>

<element name="EndPaint.Handle">
<short/>
</element>

<element name="EndPaint.PS">
<short/>
</element>

<element name="EnterCriticalSection">
<short>Enters a critical section.</short>
<descr/>
<seealso/>
</element>
<element name="EnterCriticalSection.CritSection">
<short/>
</element>

<element name="EnumDisplayMonitors">
<short>
Invokes a callback function for every available display monitor.
</short>
<descr/>
<seealso/>
</element>
<element name="EnumDisplayMonitors.Result">
<short/>
</element>
<element name="EnumDisplayMonitors.hdc">
<short/>
</element>
<element name="EnumDisplayMonitors.lprcClip">
<short/>
</element>
<element name="EnumDisplayMonitors.lpfnEnum">
<short/>
</element>
<element name="EnumDisplayMonitors.dwData">
<short/>
</element>

<element name="EnumFontFamilies">
<short>
Invokes a callback function for every font available on a specified device.
</short>
<descr/>
<seealso/>
</element>
<element name="EnumFontFamilies.Result">
<short/>
</element>
<element name="EnumFontFamilies.DC">
<short/>
</element>
<element name="EnumFontFamilies.Family">
<short/>
</element>
<element name="EnumFontFamilies.EnumFontFamProc">
<short/>
</element>
<element name="EnumFontFamilies.LParam">
<short/>
</element>

<element name="EnumFontFamiliesEx">
<short>
Invokes a callback function for every available font that matches certain 
criteria.
</short>
<descr/>
<seealso/>
</element>
<element name="EnumFontFamiliesEx.Result">
<short/>
</element>
<element name="EnumFontFamiliesEx.DC">
<short/>
</element>
<element name="EnumFontFamiliesEx.lpLogFont">
<short/>
</element>
<element name="EnumFontFamiliesEx.Callback">
<short/>
</element>
<element name="EnumFontFamiliesEx.Lparam">
<short/>
</element>
<element name="EnumFontFamiliesEx.Flags">
<short/>
</element>

<element name="Ellipse">
<short>Draws a filled circle or ellipse, bounded by a rectangle.</short>
<descr/>
</element>
<element name="Ellipse.Result">
<short/>
</element>
<element name="Ellipse.DC">
<short/>
</element>
<element name="Ellipse.x1">
<short/>
</element>
<element name="Ellipse.y1">
<short/>
</element>
<element name="Ellipse.x2">
<short/>
</element>
<element name="Ellipse.y2">
<short/>
</element>

<element name="ExcludeClipRect">
<short>
Excludes a rectangle from the clipping region, i.e. allows one to paint 
within the rectangle.
</short>
<descr/>
<seealso/>
</element>
<element name="ExcludeClipRect.Result">
<short/>
</element>
<element name="ExcludeClipRect.dc">
<short/>
</element>
<element name="ExcludeClipRect.Left">
<short/>
</element>
<element name="ExcludeClipRect.Top">
<short/>
</element>
<element name="ExcludeClipRect.Right">
<short/>
</element>
<element name="ExcludeClipRect.Bottom">
<short/>
</element>

<element name="ExtCreatePen">
<short>Creates a logical pen, selectable into any DC.</short>
<descr/>
<seealso/>
</element>
<element name="ExtCreatePen.Result">
<short/>
</element>
<element name="ExtCreatePen.dwPenStyle">
<short/>
</element>
<element name="ExtCreatePen.dwWidth">
<short/>
</element>
<element name="ExtCreatePen.lplb">
<short/>
</element>
<element name="ExtCreatePen.dwStyleCount">
<short/>
</element>
<element name="ExtCreatePen.lpStyle">
<short/>
</element>

<element name="ExtTextOut">
<short>Draws an string without formatting (single line).</short>
<descr/>
<seealso/>
</element>
<element name="ExtTextOut.Result">
<short/>
</element>
<element name="ExtTextOut.DC">
<short/>
</element>
<element name="ExtTextOut.X">
<short/>
</element>
<element name="ExtTextOut.Y">
<short/>
</element>
<element name="ExtTextOut.Options">
<short/>
</element>
<element name="ExtTextOut.Rect">
<short/>
</element>
<element name="ExtTextOut.Str">
<short/>
</element>
<element name="ExtTextOut.Count">
<short/>
</element>
<element name="ExtTextOut.Dx">
<short/>
</element>

<element name="ExtSelectClipRGN">
<short>Combines the passed Region with the current clipping region.</short>
<descr/>
<seealso/>
</element>
<element name="ExtSelectClipRGN.Result">
<short/>
</element>
<element name="ExtSelectClipRGN.dc">
<short/>
</element>
<element name="ExtSelectClipRGN.rgn">
<short/>
</element>
<element name="ExtSelectClipRGN.Mode">
<short/>
</element>

<element name="FillRect">
<short>Fills a rectangle by using the specified brush.</short>
<descr/>
<seealso/>
</element>
<element name="FillRect.Result">
<short/>
</element>
<element name="FillRect.DC">
<short/>
</element>
<element name="FillRect.Rect">
<short/>
</element>
<element name="FillRect.Brush">
<short/>
</element>

<element name="FillRgn">
<short>Fills a region using the specified brush.</short>
<descr/>
<seealso/>
</element>
<element name="FillRgn.Result">
<short/>
</element>
<element name="FillRgn.DC">
<short/>
</element>
<element name="FillRgn.RegionHnd">
<short/>
</element>
<element name="FillRgn.hbr">
<short/>
</element>

<element name="FloodFill">
<short>Fills an area of the display surface with the current brush.</short>
<descr/>
<seealso/>
</element>
<element name="FloodFill.Result">
<short/>
</element>
<element name="FloodFill.DC">
<short/>
</element>
<element name="FloodFill.X">
<short/>
</element>
<element name="FloodFill.Y">
<short/>
</element>
<element name="FloodFill.Color">
<short/>
</element>
<element name="FloodFill.FillStyle">
<short/>
</element>
<element name="FloodFill.Brush">
<short/>
</element>

<element name="FrameRect">
<short>Draws a border around a rectangle.</short>
<descr/>
<seealso/>
</element>
<element name="FrameRect.Result">
<short/>
</element>
<element name="FrameRect.DC">
<short/>
</element>
<element name="FrameRect.ARect">
<short/>
</element>
<element name="FrameRect.hBr">
<short/>
</element>

<element name="GetActiveWindow">
<short>Returns the Handle of the active window of the calling thread.</short>
<descr/>
<seealso/>
</element>
<element name="GetActiveWindow.Result">
<short/>
</element>

<element name="GetBitmapBits">
<short>Fills an buffer with the bitmap bits.</short>
<descr/>
<seealso/>
</element>
<element name="GetBitmapBits.Result">
<short/>
</element>
<element name="GetBitmapBits.Bitmap">
<short/>
</element>
<element name="GetBitmapBits.Count">
<short/>
</element>
<element name="GetBitmapBits.Bits">
<short/>
</element>

<element name="GetBkColor">
<short>Returns the background color of an device context.</short>
<descr/>
<seealso/>
</element>
<element name="GetBkColor.Result">
<short/>
</element>
<element name="GetBkColor.DC">
<short/>
</element>

<element name="GetCapture">
<short>Returns the window that captures mouse messages.</short>
<descr/>
<seealso/>
</element>
<element name="GetCapture.Result">
<short/>
</element>

<element name="GetCaretPos">
<short>Returns the caret position, in client coordinates.</short>
<descr/>
<seealso/>
</element>
<element name="GetCaretPos.Result">
<short/>
</element>
<element name="GetCaretPos.lpPoint">
<short/>
</element>

<element name="GetClientRect">
<short>
Returns the client rectangle of a control. Left and Top are always 0.
</short>
<descr>
<p>
The client rectangle is the size of the inner area of a control, where the 
child controls are visible.
</p>
<p>
A child control with Align set to alClient will completely fill the 
ClientRect.
</p>
</descr>
<seealso/>
</element>
<element name="GetClientRect.Result">
<short/>
</element>
<element name="GetClientRect.handle">
<short/>
</element>
<element name="GetClientRect.Rect">
<short/>
</element>

<element name="GetClipBox">
<short>
Returns the smallest rectangle which includes the entire clipping region of 
an device context.
</short>
<descr/>
<seealso/>
</element>
<element name="GetClipBox.Result">
<short/>
</element>
<element name="GetClipBox.DC">
<short/>
</element>
<element name="GetClipBox.lpRect">
<short/>
</element>

<element name="GetClipRGN">
<short>Returns the clipping region of an device context.</short>
<descr/>
<seealso/>
</element>
<element name="GetClipRGN.Result">
<short/>
</element>
<element name="GetClipRGN.DC">
<short/>
</element>
<element name="GetClipRGN.RGN">
<short/>
</element>

<element name="GetCursorPos">
<short/>
<descr/>
<seealso/>
</element>
<element name="GetCursorPos.Result">
<short/>
</element>
<element name="GetCursorPos.lpPoint">
<short/>
</element>

<element name="GetCurrentObject">
<short>Returns an currently selected object in an device context.</short>
<descr/>
<seealso/>
</element>
<element name="GetCurrentObject.Result">
<short/>
</element>
<element name="GetCurrentObject.DC">
<short/>
</element>
<element name="GetCurrentObject.uObjectType">
<short/>
</element>

<element name="GetCharABCWidths">
<short>Returns the ABC widths of an range of character codes.</short>
<descr/>
<seealso/>
</element>
<element name="GetCharABCWidths.Result">
<short/>
</element>
<element name="GetCharABCWidths.DC">
<short/>
</element>
<element name="GetCharABCWidths.p2">
<short/>
</element>
<element name="GetCharABCWidths.p3">
<short/>
</element>
<element name="GetCharABCWidths.ABCStructs">
<short/>
</element>

<element name="GetDC">
<short>Returns the handle of an Device Context (DC) for the client area of a 
window.
</short>
<descr/>
<seealso/>
</element>
<element name="GetDC.Result">
<short/>
</element>
<element name="GetDC.hWnd">
<short/>
</element>

<element name="GetDeviceCaps">
<short>Returns various device specific information.</short>
<descr>
<p>
Returns information about any DC (Device Context), which might be the screen 
DC representing the monitor, a control canvas or a off-screen bitmap canvas. 
The following constants can be utilized in the index argument:
</p>
<ul>
<li>HORZSIZE</li>
<li>VERTSIZE</li>
<li>HORZRES</li>
<li>BITSPIXEL</li>
<li>PLANES</li>
<li>SIZEPALETTE</li>
<li>LOGPIXELSX - the DPI in the X axis</li>
<li>LOGPIXELSY - the DPI in the Y axis</li>
<li>VERTRES</li>
<li>NUMRESERVED</li>
</ul>
<p>
An example showing how to obtain the screen DPI for the X axis using 
GetDeviceCaps, which is the method utilized by TScreen.PixelsPerInch:
</p>
<code>
var
  DC: HDC;
begin
  DC := GetDC(0);
  FDPI := GetDeviceCaps(DC,LOGPIXELSX); // DPI in pixels per inch
  ReleaseDC(0, DC);
end;
</code>
</descr>
<seealso>
<link id="#lcl.forms.TScreen.PixelsPerInch">TScreen.PixelsPerInch</link>
<link id="#lcl.lcltype.HORZSIZE">HORZSIZE</link>
<link id="#lcl.lcltype.VERTSIZE">VERTSIZE</link>
<link id="#lcl.lcltype.HORZRES">HORZRES</link>
<link id="#lcl.lcltype.BITSPIXEL">BITSPIXEL</link>
<link id="#lcl.lcltype.PLANES">PLANES</link>
<link id="#lcl.lcltype.SIZEPALETTE">SIZEPALETTE</link>
<link id="#lcl.lcltype.LOGPIXELSX">LOGPIXELSX</link>
<link id="#lcl.lcltype.LOGPIXELSY">LOGPIXELSY</link>
<link id="#lcl.lcltype.VERTRES">VERTRES</link>
<link id="#lcl.lcltype.NUMRESERVED">NUMRESERVED</link>
</seealso>
</element>
<element name="GetDeviceCaps.Result">
<short/>
</element>
<element name="GetDeviceCaps.DC">
<short/>
</element>
<element name="GetDeviceCaps.Index">
<short/>
</element>

<element name="GetDoubleClickTime">
<short>Returns the double-click time, in milliseconds.</short>
<descr/>
<seealso/>
</element>
<element name="GetDoubleClickTime.Result">
<short/>
</element>

<element name="GetDIBits">
<short>Fill an buffer with the bitmap bits.</short>
<descr/>
<seealso/>
</element>
<element name="GetDIBits.Result">
<short/>
</element>
<element name="GetDIBits.DC">
<short/>
</element>
<element name="GetDIBits.Bitmap">
<short>The (device dependent) bitmap handle.</short>
</element>
<element name="GetDIBits.StartScan">
<short/>
</element>
<element name="GetDIBits.NumScans">
<short/>
</element>
<element name="GetDIBits.Bits">
<short>
Pointer to the output buffer, or Nil to get the required dimensions.
</short>
</element>
<element name="GetDIBits.BitInfo">
<short/>
</element>
<element name="GetDIBits.Usage">
<short/>
</element>

<element name="GetFocus">
<short>Returns the handle of the window that has the focus in the current 
thread.
</short>
<descr/>
<seealso/>
</element>
<element name="GetFocus.Result">
<short/>
</element>

<element name="GetFontLanguageInfo">
<short>Returns language information about the currently selected font.</short>
<descr/>
<seealso/>
</element>
<element name="GetFontLanguageInfo.Result">
<short/>
</element>
<element name="GetFontLanguageInfo.DC">
<short/>
</element>

<element name="GetForegroundWindow">
<short>
Returns the window that the user is currently working with, session wide.
</short>
<descr/>
<seealso/>
</element>
<element name="GetForegroundWindow.Result">
<short/>
</element>

<element name="GetIconInfo">
<short>Returns information about an Icon or Cursor.</short>
<descr/>
<seealso/>
</element>
<element name="GetIconInfo.Result">
<short/>
</element>
<element name="GetIconInfo.AIcon">
<short/>
</element>
<element name="GetIconInfo.AIconInfo">
<short/>
</element>

<element name="GetKeyState">
<short>The status of a virtual key.</short>
<descr/>
<seealso/>
</element>

<element name="GetKeyState.Result">
<short/>
</element>

<element name="GetKeyState.nVirtKey">
<short/>
</element>

<element name="GetMapMode">
<short>Returns the mapping mode of an device context.</short>
<descr/>
<seealso/>
</element>

<element name="GetMapMode.Result">
<short/>
</element>

<element name="GetMapMode.DC">
<short/>
</element>

<element name="GetMonitorInfo">
<short>Returns information about an display monitor.</short>
<descr/>
<seealso/>
</element>
<element name="GetMonitorInfo.Result">
<short/>
</element>
<element name="GetMonitorInfo.hMonitor">
<short/>
</element>
<element name="GetMonitorInfo.lpmi">
<short/>
</element>

<element name="GetObject">
<short>Returns information about a graphics object.</short>
<descr/>
<seealso/>
</element>
<element name="GetObject.Result">
<short/>
</element>
<element name="GetObject.GDIObject">
<short/>
</element>
<element name="GetObject.BufSize">
<short/>
</element>
<element name="GetObject.Buf">
<short/>
</element>

<element name="GetPaletteEntries">
<short>Retrieves an range of color entries from a logical palette.</short>
<descr/>
<seealso/>
</element>
<element name="GetPaletteEntries.Result">
<short/>
</element>
<element name="GetPaletteEntries.Palette">
<short/>
</element>
<element name="GetPaletteEntries.StartIndex">
<short/>
</element>
<element name="GetPaletteEntries.NumEntries">
<short/>
</element>
<element name="GetPaletteEntries.PaletteEntries">
<short/>
</element>

<element name="GetParent">
<short>Returns the parent window of a window.</short>
<descr/>
<seealso/>
</element>
<element name="GetParent.Result">
<short/>
</element>
<element name="GetParent.Handle">
<short/>
</element>

<element name="GetProp">
<short>Retrieves an property value for a window.
</short>
<descr/>
<seealso/>
</element>
<element name="GetProp.Result">
<short/>
</element>
<element name="GetProp.Handle">
<short/>
</element>
<element name="GetProp.Str">
<short/>
</element>

<element name="GetRgnBox">
<short>
Returns the bounding rectangle of a region, containing the entire region.
</short>
<descr/>
<seealso/>
</element>
<element name="GetRgnBox.Result">
<short/>
</element>
<element name="GetRgnBox.RGN">
<short/>
</element>
<element name="GetRgnBox.lpRect">
<short/>
</element>

<element name="GetROP2">
<short>The current Foreground Mixing Mode in an device context.</short>
<descr/>
<seealso/>
</element>
<element name="GetROP2.Result">
<short/>
</element>
<element name="GetROP2.DC">
<short/>
</element>

<element name="GetScrollInfo">
<short>
Returns all or selected information about a Scroll Bar.
</short>
<descr/>
<seealso>
<link id="SetScrollInfo"/>
<link id="#lcl.lcltype.tagScrollInfo">tagScrollInfo</link>
</seealso>
</element>
<element name="GetScrollInfo.Result">
<short><b>False</b> on failure.</short>
</element>
<element name="GetScrollInfo.Handle">
<short>The Scroll Bar or window handle.</short>
</element>
<element name="GetScrollInfo.SBStyle">
<short>The Scroll Bar kind.
</short>
</element>
<element name="GetScrollInfo.ScrollInfo">
<short>Receives the values indicated in fMask.</short>
</element>

<element name="GetStockObject">
<short>Retrieves a handle to one of the predefined graphic objects.</short>
<descr/>
<seealso/>
</element>
<element name="GetStockObject.Result">
<short/>
</element>
<element name="GetStockObject.Value">
<short/>
</element>

<element name="GetSysColor">
<short>Retrieves the system color for standard display elements.</short>
<descr/>
<seealso/>
</element>
<element name="GetSysColor.Result">
<short/>
</element>
<element name="GetSysColor.nIndex">
<short/>
</element>

<element name="GetSysColorBrush">
<short>Retrieves a system brush for standard display elements.</short>
<descr/>
<seealso/>
</element>
<element name="GetSysColorBrush.Result">
<short/>
</element>
<element name="GetSysColorBrush.nIndex">
<short/>
</element>

<element name="GetSystemPaletteEntries">
<short>
Retrieves an range of color entries from the system palette for a device.
</short>
<descr/>
<seealso/>
</element>
<element name="GetSystemPaletteEntries.Result">
<short/>
</element>
<element name="GetSystemPaletteEntries.DC">
<short/>
</element>
<element name="GetSystemPaletteEntries.StartIndex">
<short/>
</element>
<element name="GetSystemPaletteEntries.NumEntries">
<short/>
</element>
<element name="GetSystemPaletteEntries.PaletteEntries">
<short/>
</element>

<element name="GetSystemMetrics">
<short>Retrieves various system metrics.</short>
<descr/>
<seealso/>
</element>
<element name="GetSystemMetrics.Result">
<short/>
</element>
<element name="GetSystemMetrics.nIndex">
<short/>
</element>

<element name="GetTextColor">
<short>The current text color in an device context.</short>
<descr/>
<seealso/>
</element>
<element name="GetTextColor.Result">
<short/>
</element>
<element name="GetTextColor.DC">
<short/>
</element>

<element name="GetTextExtentExPoint">
<short>
Calculates the number of characters, that fit into some horizontal space.
</short>
<descr/>
<seealso/>
</element>
<element name="GetTextExtentExPoint.Result">
<short/>
</element>
<element name="GetTextExtentExPoint.DC">
<short/>
</element>
<element name="GetTextExtentExPoint.Str">
<short/>
</element>
<element name="GetTextExtentExPoint.Count">
<short/>
</element>
<element name="GetTextExtentExPoint.MaxWidth">
<short/>
</element>
<element name="GetTextExtentExPoint.MaxCount">
<short/>
</element>
<element name="GetTextExtentExPoint.PartialWidths">
<short/>
</element>
<element name="GetTextExtentExPoint.Size">
<short/>
</element>

<element name="GetTextExtentPoint">
<short>Computes the display width and height of an string.</short>
<descr/>
<seealso/>
</element>
<element name="GetTextExtentPoint.Result">
<short/>
</element>
<element name="GetTextExtentPoint.DC">
<short/>
</element>
<element name="GetTextExtentPoint.Str">
<short/>
</element>
<element name="GetTextExtentPoint.Count">
<short/>
</element>
<element name="GetTextExtentPoint.Size">
<short/>
</element>

<element name="GetTextExtentPoint32">
<short>Computes the display width and height of an string.</short>
<descr/>
<seealso/>
</element>
<element name="GetTextExtentPoint32.Result">
<short/>
</element>
<element name="GetTextExtentPoint32.DC">
<short/>
</element>
<element name="GetTextExtentPoint32.Str">
<short/>
</element>
<element name="GetTextExtentPoint32.Count">
<short/>
</element>
<element name="GetTextExtentPoint32.Size">
<short/>
</element>

<element name="GetTextMetrics">
<short>Retrieves the metrics for the currently selected font.</short>
<descr/>
<seealso/>
</element>
<element name="GetTextMetrics.Result">
<short/>
</element>
<element name="GetTextMetrics.DC">
<short/>
</element>
<element name="GetTextMetrics.TM">
<short/>
</element>

<element name="GetViewPortExtEx">
<short>Returns the size of the viewport of an device context.</short>
<descr/>
<seealso/>
</element>
<element name="GetViewPortExtEx.Result">
<short/>
</element>
<element name="GetViewPortExtEx.DC">
<short/>
</element>
<element name="GetViewPortExtEx.Size">
<short/>
</element>

<element name="GetViewPortOrgEx">
<short>Returns the origin of the viewport of an device context.</short>
<descr/>
<seealso/>
</element>
<element name="GetViewPortOrgEx.Result">
<short/>
</element>
<element name="GetViewPortOrgEx.DC">
<short/>
</element>
<element name="GetViewPortOrgEx.P">
<short/>
</element>

<element name="GetWindowExtEx">
<short>Returns the extent of a window, in logical units.</short>
<descr/>
<seealso/>
</element>
<element name="GetWindowExtEx.Result">
<short/>
</element>
<element name="GetWindowExtEx.DC">
<short/>
</element>
<element name="GetWindowExtEx.Size">
<short/>
</element>

<element name="GetWindowLong">
<short>Returns attributes for the specified window handle.</short>
<descr>
<p>
<var>GetWindowLong</var> is a <var>PtrInt</var> function used to retrieve 
specific attributes for the window represented by Handle. GetWindowLong 
provides access to the corresponding method in the widgetset class instances. 
GetWindowLong is Windows-specific; the implementation for other widgetsets 
simply returns a 0 value. 
</p>
<p>
<var>Handle</var> is the HWND value used as the handle for the Window 
examined in the routine.
</p>
<p>
<var>int</var> is an Integer value which contains the 0-based offset to the 
Cardinal values returned by the routine. 
</p>
<p>
The following values defined in <file>lcltype.pp</file> are allowed in the 
int argument:
</p>
<dl>
<dt>GWL_WNDPROC (-4)</dt>
<dd>
Gets the address or handle for the window procedure.
</dd>
<dt>GWL_HINSTANCE (-6)</dt>
<dd>
Gets the handle for the application.
</dd>
<dt>GWL_HWNDPARENT (-8)</dt>
<dd>
Gets the handle for the parent window (when available).
</dd>
<dt>GWL_ID (-12)</dt>
<dd>
Gets the identifier for the window.
</dd>
<dt>GWL_STYLE (-16)</dt>
<dd>
Gets the style flags for the window.
</dd>
<dt>GWL_EXSTYLE (-20)</dt>
<dd>
Gets the extended style flags for the window.
</dd>
<dt>GWL_USERDATA (-21)</dt>
<dd>
Gets arbitrary user-defined data for the window; the content and use of the 
data is application-specific. The default value is zero (0).
</dd>
</dl>
<p>
The return value contains the attributes for the value requested in 
<var>int</var>. If the function fails, the return value is zero (0). If 
SetWindowLong has not been called to store the specified values, 
GetWindowLong returns zero (0).
</p>
</descr>
<seealso/>
</element>
<element name="GetWindowLong.Result">
<short>
Pointer to the Integer value which represents the attributes for the 
specified window Handle.
</short>
</element>
<element name="GetWindowLong.Handle">
<short>
Handle for the window with attributes retrieved in the routine.
</short>
</element>
<element name="GetWindowLong.int">
<short>
Ordinal position for the attributes retrieved for the window handle.
</short>
</element>

<element name="GetWindowRect">
<short>
Retrieves the bounding rectangle for a window, including the window 
decoration in screen coordinates.
</short>
<descr>
<p>
Retrieves the bounding rectangle of a window, including the window 
decoration. The coordinates are given relative to the upper-left corner of 
the screen in screen.
</p>
<p>
After the call, Rect will be the control area in screen coordinates. That 
means, Left and Top will be the screen coordinate of the TopLeft pixel of the 
Handle object and Right and Bottom will be the screen coordinate of the 
BottomRight pixel.
</p>
</descr>
<seealso>
<link id="GetWindowSize"/>
<link id="SetWindowPos"/>
</seealso>
</element>
<element name="GetWindowRect.Result">
<short/>
</element>
<element name="GetWindowRect.Handle">
<short/>
</element>
<element name="GetWindowRect.Rect">
<short/>
</element>

<element name="GetWindowSize">
<short>
Returns the Width and Height of a window, including the window decoration.
</short>
<descr>
<p>
This function is a Lazarus addition and does not exist in the Windows API. It 
returns the Width and Height of a window, including the window decoration. To 
get the size of a form without the window decoration just use 
TCustomForm.Width and TCustomForm.Height or TCustomForm.ClientWidth and 
TCustomForm.ClientHeight.
</p>
</descr>
<seealso>
<link id="GetWindowRect"/>
<link id="#lcl.forms.TForm.ClientWidth">TForm.ClientWidth</link>
<link id="#lcl.forms.TForm.ClientHeight">TForm.ClientHeight</link>
</seealso>
</element>
<element name="GetWindowSize.Result">
<short/>
</element>
<element name="GetWindowSize.Handle">
<short/>
</element>
<element name="GetWindowSize.Width">
<short/>
</element>
<element name="GetWindowSize.Height">
<short/>
</element>

<element name="GetWindowOrgEx">
<short>
Retrieves the window origin of an device context, in logical units.
</short>
<descr/>
<seealso/>
</element>
<element name="GetWindowOrgEx.Result">
<short/>
</element>
<element name="GetWindowOrgEx.dc">
<short/>
</element>
<element name="GetWindowOrgEx.P">
<short/>
</element>

<element name="GradientFill">
<short>Fills rectangle or triangle areas with gradient colors.</short>
<descr/>
<seealso/>
</element>
<element name="GradientFill.Result">
<short/>
</element>
<element name="GradientFill.DC">
<short/>
</element>
<element name="GradientFill.Vertices">
<short/>
</element>
<element name="GradientFill.NumVertices">
<short/>
</element>
<element name="GradientFill.Meshes">
<short/>
</element>
<element name="GradientFill.NumMeshes">
<short/>
</element>
<element name="GradientFill.Mode">
<short/>
</element>

<element name="HideCaret">
<short>Removes the caret from the screen.</short>
<descr/>
<seealso/>
</element>
<element name="HideCaret.Result">
<short/>
</element>
<element name="HideCaret.hWnd">
<short/>
</element>

<element name="IntersectClipRect">
<short>
Shrinks the clipping region of an Device Context to a rectangular boundary, 
e.g. a text area.
</short>
<descr>
The result can be one of the following constants: Error, NullRegion, 
SimpleRegion, ComplexRegion, or Region_Error
</descr>
<seealso>
<link id="#lcl.lcltype.Region_Error">Region_Error</link>
</seealso>
</element>
<element name="IntersectClipRect.Result">
<short>The region type, zero on failure.</short>
</element>
<element name="IntersectClipRect.dc">
<short/>
</element>
<element name="IntersectClipRect.Left">
<short/>
</element>
<element name="IntersectClipRect.Top">
<short/>
</element>
<element name="IntersectClipRect.Right">
<short/>
</element>
<element name="IntersectClipRect.Bottom">
<short/>
</element>

<element name="InvalidateRect">
<short>Marks a display area for repaint.</short>
<descr/>
<seealso/>
</element>
<element name="InvalidateRect.Result">
<short/>
</element>
<element name="InvalidateRect.aHandle">
<short/>
</element>
<element name="InvalidateRect.ARect">
<short/>
</element>
<element name="InvalidateRect.bErase">
<short/>
</element>

<element name="InvalidateRgn">
<short>Marks a display area for repaint.</short>
<descr/>
<seealso/>
</element>
<element name="InvalidateRgn.Result">
<short/>
</element>
<element name="InvalidateRgn.Handle">
<short/>
</element>
<element name="InvalidateRgn.Rgn">
<short/>
</element>
<element name="InvalidateRgn.Erase">
<short/>
</element>

<element name="IsDBCSLeadByte">
<short/>
<descr/>
<seealso/>
</element>
<element name="IsDBCSLeadByte.Result">
<short/>
</element>
<element name="IsDBCSLeadByte.TestChar">
<short/>
</element>

<element name="IsIconic">
<short><b>True</b> when the window is minimized.</short>
<descr/>
<seealso/>
</element>
<element name="IsIconic.Result">
<short/>
</element>
<element name="IsIconic.handle">
<short/>
</element>

<element name="IsWindow">
<short>Checks whether a handle refers to a window.</short>
<descr/>
<seealso/>
</element>
<element name="IsWindow.Result">
<short/>
</element>
<element name="IsWindow.handle">
<short/>
</element>

<element name="IsWindowEnabled">
<short>
Determines whether a window can receive mouse and keyboard input.
</short>
<descr/>
<seealso/>
</element>
<element name="IsWindowEnabled.Result">
<short/>
</element>
<element name="IsWindowEnabled.handle">
<short/>
</element>

<element name="IsWindowVisible">
<short>The definite Visible state of a window.</short>
<descr/>
<seealso/>
</element>
<element name="IsWindowVisible.Result">
<short/>
</element>
<element name="IsWindowVisible.handle">
<short/>
</element>

<element name="IsZoomed">
<short><b>True</b> when the window is maximized.</short>
<descr/>
<seealso/>
</element>
<element name="IsZoomed.Result">
<short/>
</element>
<element name="IsZoomed.handle">
<short/>
</element>

<element name="InitializeCriticalSection">
<short>Initializes a Critical Section object.</short>
<descr/>
<seealso/>
</element>
<element name="InitializeCriticalSection.CritSection">
<short/>
</element>

<element name="LeaveCriticalSection">
<short>Releases a critical section, for use by other threads.</short>
<descr/>
<seealso/>
</element>
<element name="LeaveCriticalSection.CritSection">
<short/>
</element>

<element name="LineTo">
<short>
Draws a line from the current position up to, but not including, the 
specified point.
</short>
<descr/>
<seealso/>
</element>
<element name="LineTo.Result">
<short/>
</element>
<element name="LineTo.DC">
<short/>
</element>
<element name="LineTo.X">
<short/>
</element>
<element name="LineTo.Y">
<short/>
</element>

<element name="LPtoDP">
<short>Converts logical coordinates into device coordinates.</short>
<descr/>
<seealso/>
</element>
<element name="LPtoDP.Result">
<short/>
</element>
<element name="LPtoDP.DC">
<short/>
</element>
<element name="LPtoDP.Points">
<short/>
</element>
<element name="LPtoDP.Count">
<short/>
</element>

<element name="MaskBlt">
<short>
Copies part of an source DC into an destination DC, using the specified 
foreground and background raster operations.
</short>
<descr>
<p>
MaskBlt behaves like BitBlt when no mask bitmap is specified. It does a 
SRCOPY operation when also no ROP is specified. See BitBlt for general 
information about raster operations.
</p>
<p>
Rop contains both a foreground and a background raster operation (see 
MakeROP4). When a (monochrome) mask bitmap is present, its bits select either 
the foreground (1) or background (0) raster operation.
</p>
</descr>
<seealso>
<link id="BitBlt"/>
<link id="MakeROP4"/>
</seealso>
</element>
<element name="MaskBlt.Result">
<short/>
</element>
<element name="MaskBlt.DestDC">
<short/>
</element>
<element name="MaskBlt.X">
<short/>
</element>
<element name="MaskBlt.Y">
<short/>
</element>
<element name="MaskBlt.Width">
<short/>
</element>
<element name="MaskBlt.Height">
<short/>
</element>
<element name="MaskBlt.SrcDC">
<short/>
</element>
<element name="MaskBlt.XSrc">
<short/>
</element>
<element name="MaskBlt.YSrc">
<short/>
</element>
<element name="MaskBlt.Mask">
<short/>
</element>
<element name="MaskBlt.XMask">
<short/>
</element>
<element name="MaskBlt.YMask">
<short/>
</element>
<element name="MaskBlt.Rop">
<short/>
</element>

<element name="MessageBox">
<short>
Displays a modal dialog with the given text, caption, icon and buttons.
</short>
<descr>
<p>
<var>MessageBox</var> is an <var>Integer</var> function used to display a 
modal dialog with the text, caption, icon and buttons specified using the 
arguments to the routine. It provides the common routine in the LCL interface 
used to access the platform-specific implementation of the routine for the 
widgetset class.
</p>
<p>
<var>hWnd</var> contains the handle for the window which is the owner of the 
dialog created and executed in the routine. The default value (0) indicates a 
handle is not available or not assigned for the owner window.
</p>
<p>
<var>lpText</var> is a PChar value with the text displayed on the modal 
dialog. Multi-line text can be used by embedding the end-of-line character 
sequence in the content.
</p>
<p>
<var>lpCaption</var> is a PChar value with the title displayed on the modal 
dialog.
</p>
<p>
<var>uType</var> is a Cardinal value which identifies the content and 
behavior for the modal dialog. It consists of flag values which can be OR'd 
together and passed to the widgetset implementation. uType can contain flag 
values from the following flag groups:
</p>
<p>
<b>Buttons</b> (defined in <file>lcltype.pp</file>)
</p>
<dl>
<dt>MB_OK ($00000000)</dt>
<dd>
Displays an OK button. This is the default behavior for the Windows platform.
</dd>
<dt>MB_OKCANCEL ($00000001)</dt>
<dd>
The message box contains two push buttons: OK and Cancel.
</dd>
<dt>MB_ABORTRETRYIGNORE ($00000002)</dt>
<dd>
Displays Abort, Retry, and Ignore buttons.
</dd>
<dt>MB_YESNOCANCEL ($00000003)</dt>
<dd>
Displays Yes, No, and Cancel buttons.
</dd>
<dt>MB_YESNO ($00000004)</dt>
<dd>
Displays Yes and No buttons.
</dd>
<dt>MB_RETRYCANCEL ($00000005)</dt>
<dd>
Displays Retry and Cancel buttons.
</dd>
<dt>MB_MB_CANCELTRYCONTINUE ($00000006)</dt>
<dd>
Not supported in the current LCL version.
</dd>
<dt>MB_HELP ($00004000)</dt>
<dd>
Displays a Help button on the dialog. Sends a help message to the owner 
window in hWnd when it has a non-zero value.
</dd>
</dl>
<p>
<b>Icons</b> (defined in <file>lcltype.pp</file>)
</p>
<dl>
<dt>MB_ICONSTOP, MB_ICONERROR, MB_ICONHAND ($00000010)</dt>
<dd>
Displays a stop sign icon on the dialog.
</dd>
<dt>MB_ICONQUESTION ($00000020)</dt>
<dd>
Displays a question mark icon on the dialog.
</dd>
<dt>MB_ICONEXCLAMATION, MB_ICONWARNING ($00000030)</dt>
<dd>
Displays an exclamation point icon on the dialog.
</dd>
<dt>MB_ICONINFORMATION, MB_ICONASTERISK ($00000040)</dt>
<dd>
Displays a lowercase "i" icon on the dialog.
</dd>
</dl>
<p>
<b>Default Buttons</b> (defined in <file>lcltype.pp</file>)
</p>
<dl>
<dt>MB_DEFBUTTON1 ($00000000)</dt>
<dd>
The first button is the default button. This is the default unless 
MB_DEFBUTTON2, MB_DEFBUTTON3, or MB_DEFBUTTON4 is specified.
</dd>
<dt>MB_DEFBUTTON2 ($00000100)</dt>
<dd>
The second button is the default button.
</dd>
<dt>MB_DEFBUTTON3 ($00000200)</dt>
<dd>
The third button is the default button.
</dd>
<dt>MB_DEFBUTTON4 ($00000300)</dt>
<dd>
The fourth button is the default button.
</dd>
</dl>
<p>
The return value indicates the button selected on the modal dialog, and can 
be identified using the following Integer constants defined in 
<file>lcltype.pp</file>:
</p>
<ul>
<li>IDOK, ID_OK (1)</li>
<li>IDCANCEL, ID_CANCEL (2)</li>
<li>IDABORT, ID_ABORT (3)</li>
<li>IDRETRY, ID_RETRY (4)</li>
<li>IDIGNORE, ID_IGNORE  (5)</li>
<li>IDYES, ID_YES (6)</li>
<li>IDNO, ID_NO (7)</li>
<li>IDCLOSE, ID_CLOSE (8)</li>
<li>IDHELP, ID_HELP (9)</li>
</ul>
<p>
For example:
</p>
<code>uses LCLIntf, LCLType;
// ...
function ShowResourceNotAvailableMessageBox: Integer;
begin
Result := MessageBox(0,
PChar('Resource not available.'+#10+'Try again?'),
PChar('Account Details'),
MB_ICONWARNING or MB_ABORTRETRYIGNORE or MB_DEFBUTTON2);

case Result of
IDABORT:  // needs to be implemented
IDRETRY:  // needs to be implemented
IDIGNORE: // needs to be implemented
end;
end;
</code>
</descr>
<seealso>
<link id="#lcl.forms.TApplication.MessageBox">TApplication.MessageBox</link>
<link id="#lcl.forms.MessageBoxFunction">MessageBoxFunction</link>
<link id="#lcl.dialogs.DefaultMessageBox">DefaultMessageBox</link>
</seealso>
</element>
<element name="MessageBox.Result">
<short>
Integer value with the modal result for the dialog.
</short>
</element>
<element name="MessageBox.hWnd">
<short>
Handle for the owner window, or 0 (default) when an owner is not available.
</short>
</element>
<element name="MessageBox.lpText">
<short>
Pointer to the character values displayed in the content area for the dialog.
</short>
</element>
<element name="MessageBox.lpCaption">
<short>
Pointer to the character values displayed as the title for the dialog.
</short>
</element>
<element name="MessageBox.uType">
<short>
Flag values which indicate the icon, buttons, and behavior for the dialog.
</short>
</element>

<element name="MonitorFromPoint">
<short>Finds an monitor from screen coordinates.</short>
<descr/>
<seealso/>
</element>
<element name="MonitorFromPoint.Result">
<short/>
</element>
<element name="MonitorFromPoint.ptScreenCoords">
<short/>
</element>
<element name="MonitorFromPoint.dwFlags">
<short/>
</element>

<element name="MonitorFromRect" link="#lcl.InterfaceBase.MonitorFromRect"/>
<element name="MonitorFromRect.Result">
<short/>
</element>
<element name="MonitorFromRect.lprcScreenCoords">
<short/>
</element>
<element name="MonitorFromRect.dwFlags">
<short/>
</element>

<element name="MonitorFromWindow">
<short>Finds the monitor which contains most of the specified window.</short>
<descr/>
<seealso>
<link id="#lcl.forms.TScreen.MonitorFromWindow">TScreen.MonitorFromWindow</link>
</seealso>
</element>
<element name="MonitorFromWindow.Result">
<short/>
</element>
<element name="MonitorFromWindow.hWnd">
<short/>
</element>
<element name="MonitorFromWindow.dwFlags">
<short/>
</element>

<element name="MoveToEx">
<short>Moves the current position to the specified point.</short>
<descr/>
<seealso/>
</element>
<element name="MoveToEx.Result">
<short/>
</element>
<element name="MoveToEx.DC">
<short/>
</element>
<element name="MoveToEx.X">
<short/>
</element>
<element name="MoveToEx.Y">
<short/>
</element>
<element name="MoveToEx.OldPoint">
<short/>
</element>

<element name="OffsetRgn">
<short>
Moves a region by the specified relative offset.
</short>
<descr/>
<seealso/>
</element>
<element name="OffsetRgn.Result">
<short/>
</element>
<element name="OffsetRgn.RGN">
<short/>
</element>
<element name="OffsetRgn.nXOffset">
<short/>
</element>
<element name="OffsetRgn.nYOffset">
<short/>
</element>

<element name="PeekMessage">
<short/>
<descr/>
<seealso/>
</element>

<element name="PeekMessage.Result">
<short/>
</element>

<element name="PeekMessage.lpMsg">
<short/>
</element>

<element name="PeekMessage.Handle">
<short/>
</element>

<element name="PeekMessage.wMsgFilterMin">
<short/>
</element>

<element name="PeekMessage.wMsgFilterMax">
<short/>
</element>

<element name="PeekMessage.wRemoveMsg">
<short/>
</element>

<element name="Pie">
<short>Draws a filled pie-shaped wedge, from an ellipse and two radials.
</short>
<descr/>
<seealso/>
</element>
<element name="Pie.Result">
<short/>
</element>
<element name="Pie.DC">
<short/>
</element>
<element name="Pie.x1">
<short/>
</element>
<element name="Pie.y1">
<short/>
</element>
<element name="Pie.x2">
<short/>
</element>
<element name="Pie.y2">
<short/>
</element>
<element name="Pie.sx">
<short/>
</element>
<element name="Pie.sy">
<short/>
</element>
<element name="Pie.ex">
<short/>
</element>
<element name="Pie.ey">
<short/>
</element>

<element name="PolyBezier">
<short>Draws Bézier curves.</short>
<descr>
<p>
Use Polybezier to draw cubic Bézier curves. The first curve is drawn from 
the first point to the fourth point with the second and third points being 
the control points.
</p>
<p>
If the Continuous flag is <b>True</b> then each subsequent curve requires 
three more points, using the end-point of the previous Curve as its starting 
point, the first and second points being used as its control points, and the 
third point its end-point. If the continuous flag is set to <b>False</b>, 
then each subsequent Curve requires 4 additional points, which are used 
exactly as in the first curve. Any additional points which do not add up to a 
full Bézier(4 for Continuous, 3 otherwise) are ignored. There must be at 
least 4 points for an drawing to occur. 
</p>
<p>
If the Filled Flag is set to <b>True</b> then the resulting Poly-Bézier will 
be drawn as a Polygon.
</p>
</descr>
<seealso/>
</element>
<element name="PolyBezier.Result">
<short/>
</element>
<element name="PolyBezier.DC">
<short/>
</element>
<element name="PolyBezier.Points">
<short/>
</element>
<element name="PolyBezier.NumPts">
<short/>
</element>
<element name="PolyBezier.Filled">
<short/>
</element>
<element name="PolyBezier.Continuous">
<short/>
</element>

<element name="Polygon">
<short>Draws a Polygon.</short>
<descr>
<p>
Use Polygon to draw a closed, many-sided shape on the canvas, using the value 
of Pen. After drawing the complete shape, Polygon fills the shape using the 
value of Brush.
</p>
<p>
The Points parameter is an array of points that give the vertices of the 
polygon. Winding determines how the polygon is filled. When Winding is 
<b>True</b>, Polygon fills the shape using the Winding fill algorithm.
</p>
<p>
When Winding is <b>False</b>, Polygon uses the even-odd (alternative) fill 
algorithm. StartIndex gives the index of the first point in the array to use. 
All points before this are ignored. NumPts indicates the number of points to 
use, starting at StartIndex.
</p>
<p>
If NumPts is -1 (the default), Polygon uses all points from StartIndex to the 
end of the array. The first point is always connected to the last point.
</p>
<p>
To draw a polygon on the canvas, without filling it, use the Polyline method, 
specifying the first point a second time at the end.
</p>
</descr>
<seealso/>
</element>
<element name="Polygon.Result">
<short/>
</element>
<element name="Polygon.DC">
<short/>
</element>
<element name="Polygon.Points">
<short/>
</element>
<element name="Polygon.NumPts">
<short/>
</element>
<element name="Polygon.Winding">
<short/>
</element>

<element name="Polyline">
<short>Draws a sequence of lines.</short>
<descr>
<p>
Use Polyline to connect a set of points on the canvas. If you specify only 
two points, Polyline draws a single line. The Points parameter is an array of 
points to be connected.
</p>
<p>
StartIndex identifies the first point in the array to use. NumPts indicates 
the number of points to use. If NumPts is -1 (the default), PolyLine uses all 
the points from StartIndex to the end of the array. Calling the MoveTo 
function with the value of the first point, and then repeatedly calling 
LineTo with all subsequent points will draw the same image on the canvas.
</p>
<p>
However, unlike LineTo, Polyline does not change the value of PenPos.
</p>
</descr>
<seealso/>
</element>
<element name="Polyline.Result">
<short/>
</element>
<element name="Polyline.DC">
<short/>
</element>
<element name="Polyline.Points">
<short/>
</element>
<element name="Polyline.NumPts">
<short/>
</element>

<element name="PostMessage">
<short>Sends a message to a window.</short>
<descr>
<p>
This method is a thread-safe solution to send messages to windows. Those 
messages will be handled in the message loop of the application and therefore 
can be sent from any thread. They are not immediate, but they will awake the 
main thread if it is waiting for messages. These messages can be handled by 
procedures with the keyword message in the class of a form for example. One 
would then use the handle of this form as the Handle parameter of this 
routine. Custom messages should always have an identification number 
(represented by the parameter Msg) larger then the constant LM_USER. The two 
parameters WParam and LParam will be passed along to the window together with 
the Msg identification number.
</p>
<p>
The difference between SendMessage and PostMessage is the way that they 
return control to the calling thread. With SendMessage control is not 
returned until the window that the message was sent to has completed 
processing the sent message, however with PostMessage control is returned 
immediately.
</p>
</descr>
<seealso>
<link id="#lcl.LCLIntf.SendMessage">LCLIntf.SendMessage</link>
</seealso>
</element>
<element name="PostMessage.Result">
<short/>
</element>
<element name="PostMessage.Handle">
<short/>
</element>
<element name="PostMessage.Msg">
<short/>
</element>
<element name="PostMessage.WParam">
<short/>
</element>
<element name="PostMessage.LParam">
<short/>
</element>

<element name="PtInRegion">
<short>
Determines whether the specified coordinates are within the given region 
handle.
</short>
<descr/>
<seealso/>
</element>
<element name="PtInRegion.Result">
<short/>
</element>
<element name="PtInRegion.RGN">
<short>
Handle for the region examined in the routine.
</short>
</element>
<element name="PtInRegion.X">
<short>
Horizontal coordinate examined in the routine.
</short>
</element>
<element name="PtInRegion.Y">
<short>
Vertical coordinate examined in the routine.
</short>
</element>

<element name="RealizePalette">
<short/>
<descr/>
<seealso/>
</element>
<element name="RealizePalette.Result">
<short/>
</element>
<element name="RealizePalette.DC">
<short/>
</element>

<element name="Rectangle">
<short/>
<descr/>
<seealso/>
</element>
<element name="Rectangle.Result">
<short/>
</element>
<element name="Rectangle.DC">
<short/>
</element>
<element name="Rectangle.X1">
<short/>
</element>
<element name="Rectangle.Y1">
<short/>
</element>
<element name="Rectangle.X2">
<short/>
</element>
<element name="Rectangle.Y2">
<short/>
</element>

<element name="RectVisible">
<short>
Indicates whether the specified rectangle in visible in the clipping region 
for the device context.
</short>
<descr>
<p>
Calls the RectVisible method in TWidgetSet to get the return value for the 
routine.
</p>
</descr>
<seealso/>
</element>
<element name="RectVisible.Result">
<short>
<b>True</b> if the rectangle is visible in the clipping region for the device 
context.
</short>
</element>
<element name="RectVisible.dc">
<short>
Device context examined in the routine.
</short>
</element>
<element name="RectVisible.ARect">
<short>
Rectangle with the coordinates examined on the device context.
</short>
</element>

<element name="RedrawWindow">
<short>Redraws (part of) a window.</short>
<descr/>
<seealso/>
</element>
<element name="RedrawWindow.Result">
<short/>
</element>
<element name="RedrawWindow.Wnd">
<short/>
</element>
<element name="RedrawWindow.lprcUpdate">
<short/>
</element>
<element name="RedrawWindow.hrgnUpdate">
<short/>
</element>
<element name="RedrawWindow.flags">
<short/>
</element>

<element name="ReleaseCapture">
<short>Restores normal mouse input processing, after
<link id="SetCapture"/>.
</short>
<descr/>
<seealso/>
</element>
<element name="ReleaseCapture.Result">
<short/>
</element>

<element name="ReleaseDC">
<short>Releases an Device Context obtained by GetDC.</short>
<descr/>
<seealso>
<link id="DeleteDC"/>
</seealso>
</element>
<element name="ReleaseDC.Result">
<short>Zero on failure.</short>
</element>
<element name="ReleaseDC.hWnd">
<short>The window associated with the DC.</short>
</element>
<element name="ReleaseDC.DC">
<short/>
</element>

<element name="RemoveProp">
<short>Removes a named property from a window.</short>
<descr/>
<seealso/>
</element>
<element name="RemoveProp.Result">
<short/>
</element>
<element name="RemoveProp.Handle">
<short/>
</element>
<element name="RemoveProp.Str">
<short/>
</element>

<element name="RoundRect">
<short>
Draws a rectangle with rounded corners to the specified device context.
</short>
<descr>
<p>
Calls the RoundRect method implemented in the TWidgetSet class.
</p>
</descr>
<seealso/>
</element>
<element name="RoundRect.Result">
<short>Returns <b>True</b> on successful completion of the routine.</short>
</element>
<element name="RoundRect.DC">
<short>Device context where the drawing operation is performed.</short>
</element>
<element name="RoundRect.X1">
<short>Coordinate on the device context for the rectangle.</short>
</element>
<element name="RoundRect.Y1">
<short>Coordinate on the device context for the rectangle.</short>
</element>
<element name="RoundRect.X2">
<short>Coordinate on the device context for the rectangle.</short>
</element>
<element name="RoundRect.Y2">
<short>Coordinate on the device context for the rectangle.</short>
</element>
<element name="RoundRect.RX">
<short>Length of the corner radius applied to the X-axis.</short>
</element>
<element name="RoundRect.RY">
<short>Length of the corner radius applied to the Y-axis.</short>
</element>

<element name="RestoreDC">
<short>Restores a Device Context (DC) to an previously saved state.</short>
<descr/>
<seealso/>
</element>
<element name="RestoreDC.Result">
<short/>
</element>
<element name="RestoreDC.DC">
<short/>
</element>
<element name="RestoreDC.SavedDC">
<short/>
</element>

<element name="SaveDC">
<short>Saves the state of a Device Context in the context stack.</short>
<descr/>
<seealso/>
</element>
<element name="SaveDC.Result">
<short/>
</element>
<element name="SaveDC.DC">
<short/>
</element>

<element name="ScreenToClient">
<short>Converts absolute Screen coordinates into Client relative coordinates.
</short>
<descr/>
<seealso>
<link id="ClientToScreen"/>
</seealso>
</element>
<element name="ScreenToClient.Result">
<short><b>False</b> on failure.</short>
</element>
<element name="ScreenToClient.Handle">
<short>The window with the client area.</short>
</element>
<element name="ScreenToClient.P">
<short>The point to convert.</short>
</element>

<element name="ScrollWindowEx">
<short/>
<descr/>
<seealso/>
</element>

<element name="ScrollWindowEx.Result">
<short/>
</element>

<element name="ScrollWindowEx.hWnd">
<short/>
</element>

<element name="ScrollWindowEx.dx">
<short/>
</element>

<element name="ScrollWindowEx.dy">
<short/>
</element>

<element name="ScrollWindowEx.prcScroll">
<short/>
</element>

<element name="ScrollWindowEx.prcClip">
<short/>
</element>

<element name="ScrollWindowEx.hrgnUpdate">
<short/>
</element>

<element name="ScrollWindowEx.prcUpdate">
<short/>
</element>

<element name="ScrollWindowEx.flags">
<short/>
</element>

<element name="SendMessage">
<short>
Sends a message directed to a specific window to the message pool for the 
application.
</short>
<descr>
<p>
This method is a thread-safe solution to send messages to windows. Those 
messages will be handled in the message loop of the application and therefore 
can be sent from any thread. They are not immediate, but they will awake the 
main thread if it is waiting for messages. These messages can be handled by 
procedures with the keyword message in the class of a form for example. One 
would then use the handle of this form as the HandleWnd parameter of this 
routine. Custom messages should always have an identification number 
(represented by the parameter Msg) larger then the constant LM_USER. The two 
parameters WParam and LParam will be passed along to the window together with 
the Msg identification number.
</p>
<p>
The difference between SendMessage and PostMessage is the way that they 
return control to the calling thread. With SendMessage control is not 
returned until the window that the message was sent to has completed 
processing the sent message, however with PostMessage control is returned 
immediately.
</p>
</descr>
<seealso>
<link id="#lcl.LCLIntf.PostMessage">LCLIntf.PostMessage</link>
</seealso>
</element>
<element name="SendMessage.Result">
<short/>
</element>
<element name="SendMessage.HandleWnd">
<short>The handle of the window to receive the message.</short>
</element>
<element name="SendMessage.Msg">
<short/>
</element>
<element name="SendMessage.WParam">
<short/>
</element>
<element name="SendMessage.LParam">
<short/>
</element>

<element name="SetActiveWindow">
<short>
Sets focus to the specified window, if the application is on top.
</short>
<descr/>
<seealso/>
</element>
<element name="SetActiveWindow.Result">
<short/>
</element>
<element name="SetActiveWindow.Handle">
<short/>
</element>

<element name="SetBkColor">
<short>Sets the current background color of an device context.</short>
<descr/>
<seealso/>
</element>
<element name="SetBkColor.Result">
<short/>
</element>
<element name="SetBkColor.DC">
<short/>
</element>
<element name="SetBkColor.Color">
<short/>
</element>

<element name="SetBkMode">
<short>
Sets the background mix mode (transparency) of an device context.
</short>
<descr/>
<seealso/>
</element>
<element name="SetBkMode.Result">
<short/>
</element>
<element name="SetBkMode.DC">
<short/>
</element>
<element name="SetBkMode.bkMode">
<short/>
</element>

<element name="SetCapture">
<short>Sets the mouse capture to the specified window.</short>
<descr/>
<seealso/>
</element>
<element name="SetCapture.Result">
<short/>
</element>
<element name="SetCapture.AHandle">
<short/>
</element>

<element name="SetCaretPos">
<short>Moves the Caret to the specified coordinates.</short>
<descr/>
<seealso/>
</element>
<element name="SetCaretPos.Result">
<short/>
</element>
<element name="SetCaretPos.X">
<short/>
</element>
<element name="SetCaretPos.Y">
<short/>
</element>

<element name="SetCaretPosEx">
<short>Moves the Caret into a window.</short>
<descr/>
<seealso/>
</element>
<element name="SetCaretPosEx.Result">
<short/>
</element>
<element name="SetCaretPosEx.handle">
<short/>
</element>
<element name="SetCaretPosEx.X">
<short/>
</element>
<element name="SetCaretPosEx.Y">
<short/>
</element>

<element name="SetCursor">
<short>Changes the shape of the mouse cursor.</short>
<descr/>
<seealso/>
</element>
<element name="SetCursor.Result">
<short/>
</element>
<element name="SetCursor.hCursor">
<short/>
</element>

<element name="SetCursorPos">
<short>Changes the position of the mouse cursor.</short>
<descr/>
<seealso/>
</element>
<element name="SetCursorPos.Result">
<short/>
</element>
<element name="SetCursorPos.X">
<short/>
</element>
<element name="SetCursorPos.Y">
<short/>
</element>

<element name="SetMapMode">
<short>Sets the mapping mode of an device context.</short>
<descr/>
<seealso/>
</element>
<element name="SetMapMode.Result">
<short/>
</element>
<element name="SetMapMode.DC">
<short/>
</element>
<element name="SetMapMode.fnMapMode">
<short/>
</element>

<element name="SetMenu">
<short>Assigns a menu to a window.</short>
<descr/>
<seealso/>
</element>
<element name="SetMenu.Result">
<short/>
</element>
<element name="SetMenu.AWindowHandle">
<short/>
</element>
<element name="SetMenu.AMenuHandle">
<short/>
</element>

<element name="SetParent">
<short>Changes the parent of a window.</short>
<descr/>
<seealso/>
</element>
<element name="SetParent.Result">
<short/>
</element>
<element name="SetParent.hWndChild">
<short/>
</element>
<element name="SetParent.hWndParent">
<short/>
</element>


<element name="SetProp">
<short>Adds a property to a window.</short>
<descr/>
<seealso/>
</element>
<element name="SetProp.Result">
<short/>
</element>
<element name="SetProp.Handle">
<short/>
</element>
<element name="SetProp.Str">
<short/>
</element>
<element name="SetProp.Data">
<short/>
</element>

<element name="SetROP2">
<short>Sets the Foreground Mixing Mode in an device context.</short>
<descr/>
<seealso/>
</element>
<element name="SetROP2.Result">
<short/>
</element>
<element name="SetROP2.DC">
<short/>
</element>
<element name="SetROP2.Mode">
<short/>
</element>

<element name="SelectClipRGN">
<short>Sets the ClipRegion of an DeviceContext.</short>
<descr/>
<seealso/>
</element>
<element name="SelectClipRGN.Result">
<short/>
</element>
<element name="SelectClipRGN.DC">
<short/>
</element>
<element name="SelectClipRGN.RGN">
<short/>
</element>

<element name="SelectObject">
<short>Selects an object into an device context.</short>
<descr/>
<seealso/>
</element>
<element name="SelectObject.Result">
<short/>
</element>
<element name="SelectObject.DC">
<short/>
</element>
<element name="SelectObject.GDIObj">
<short/>
</element>

<element name="SelectPalette">
<short/>
<descr/>
<seealso/>
</element>
<element name="SelectPalette.Result">
<short/>
</element>
<element name="SelectPalette.DC">
<short/>
</element>
<element name="SelectPalette.Palette">
<short/>
</element>
<element name="SelectPalette.ForceBackground">
<short/>
</element>

<element name="SetFocus">
<short>Sets the keyboard input focus to the specified window handle.</short>
<descr/>
<seealso/>
</element>
<element name="SetFocus.Result">
<short/>
</element>
<element name="SetFocus.hWnd">
<short/>
</element>

<element name="SetForegroundWindow">
<short>Moves a window in front of all other windows, and activates it.
</short>
<descr/>
<seealso/>
</element>
<element name="SetForegroundWindow.Result">
<short/>
</element>
<element name="SetForegroundWindow.hWnd">
<short/>
</element>

<element name="SetScrollInfo">
<short/>
<descr/>
<seealso/>
</element>

<element name="SetScrollInfo.Result">
<short/>
</element>

<element name="SetScrollInfo.Handle">
<short/>
</element>

<element name="SetScrollInfo.SBStyle">
<short/>
</element>

<element name="SetScrollInfo.ScrollInfo">
<short/>
</element>

<element name="SetScrollInfo.Redraw">
<short/>
</element>

<element name="SetStretchBltMode">
<short>Sets the StrechBlt mode for an device context.</short>
<descr/>
<seealso/>
</element>
<element name="SetStretchBltMode.Result">
<short/>
</element>
<element name="SetStretchBltMode.DC">
<short/>
</element>
<element name="SetStretchBltMode.StretchMode">
<short/>
</element>

<element name="SetSysColors">
<short>
Sets the colors for one or more display elements of window borders and 
desktop.
</short>
<descr/>
<seealso/>
</element>
<element name="SetSysColors.Result">
<short/>
</element>
<element name="SetSysColors.cElements">
<short/>
</element>
<element name="SetSysColors.lpaElements">
<short/>
</element>
<element name="SetSysColors.lpaRgbValues">
<short/>
</element>

<element name="SetTextCharacterExtra">
<short>Sets extra inter-character spacing in text output.</short>
<descr/>
<seealso/>
</element>
<element name="SetTextCharacterExtra.Result">
<short/>
</element>
<element name="SetTextCharacterExtra._hdc">
<short/>
</element>
<element name="SetTextCharacterExtra.nCharExtra">
<short/>
</element>

<element name="SetTextColor">
<short>Sets the text color on a device context.</short>
<descr/>
<seealso/>
</element>
<element name="SetTextColor.Result">
<short/>
</element>
<element name="SetTextColor.DC">
<short/>
</element>
<element name="SetTextColor.Color">
<short/>
</element>

<element name="SetViewPortExtEx">
<short>Sets the extent of the viewport for a device context.</short>
<descr/>
<seealso/>
</element>
<element name="SetViewPortExtEx.Result">
<short/>
</element>
<element name="SetViewPortExtEx.DC">
<short/>
</element>
<element name="SetViewPortExtEx.XExtent">
<short/>
</element>
<element name="SetViewPortExtEx.YExtent">
<short/>
</element>
<element name="SetViewPortExtEx.OldSize">
<short/>
</element>

<element name="SetViewPortOrgEx">
<short>
Sets the device origin corresponding to the window origin (0,0) in an device 
context.
</short>
<descr/>
<seealso/>
</element>
<element name="SetViewPortOrgEx.Result">
<short/>
</element>
<element name="SetViewPortOrgEx.DC">
<short/>
</element>
<element name="SetViewPortOrgEx.NewX">
<short/>
</element>
<element name="SetViewPortOrgEx.NewY">
<short/>
</element>
<element name="SetViewPortOrgEx.OldPoint">
<short/>
</element>

<element name="SetWindowExtEx">
<short>Sets the extent of the window for an device context.</short>
<descr/>
<seealso/>
</element>
<element name="SetWindowExtEx.Result">
<short/>
</element>
<element name="SetWindowExtEx.DC">
<short/>
</element>
<element name="SetWindowExtEx.XExtent">
<short/>
</element>
<element name="SetWindowExtEx.YExtent">
<short/>
</element>
<element name="SetWindowExtEx.OldSize">
<short/>
</element>

<element name="SetWindowLong">
<short>Sets an attribute of a window.</short>
<descr/>
<seealso/>
</element>
<element name="SetWindowLong.Result">
<short/>
</element>
<element name="SetWindowLong.Handle">
<short/>
</element>
<element name="SetWindowLong.Idx">
<short/>
</element>
<element name="SetWindowLong.NewLong">
<short/>
</element>

<element name="SetWindowOrgEx">
<short>Specifies which window point maps to the viewport origin (0,0).</short>
<descr/>
<seealso/>
</element>
<element name="SetWindowOrgEx.Result">
<short/>
</element>
<element name="SetWindowOrgEx.dc">
<short/>
</element>
<element name="SetWindowOrgEx.NewX">
<short/>
</element>
<element name="SetWindowOrgEx.NewY">
<short/>
</element>
<element name="SetWindowOrgEx.OldPoint">
<short/>
</element>

<element name="SetWindowPos">
<short>Changes the size, position, and Z order of a window.</short>
<descr/>
<seealso/>
</element>
<element name="SetWindowPos.Result">
<short/>
</element>
<element name="SetWindowPos.hWnd">
<short/>
</element>
<element name="SetWindowPos.hWndInsertAfter">
<short/>
</element>
<element name="SetWindowPos.X">
<short/>
</element>
<element name="SetWindowPos.Y">
<short/>
</element>
<element name="SetWindowPos.cx">
<short/>
</element>
<element name="SetWindowPos.cy">
<short/>
</element>
<element name="SetWindowPos.uFlags">
<short/>
</element>
<!-- function SetWindowRgn Visibility: default -->
<element name="SetWindowRgn">
<short>Defines the visible region of a window or control.</short>
<descr>
<p>
This function sets the visible region of a window or control. It's parameters 
are:
</p>
<dl>
<dt>hWnd</dt>
<dd>The handle of the window or control</dd>
<dt>hRgn</dt>
<dd>
The handle to the region which contains the visible section of the window or 
control
</dd>
<dt>bRedraw</dt>
<dd>
<b>True</b> if the control or window should be repainted following the call 
of this function, <b>False</b> otherwise. See also the wiki documentation: 
<url 
href="http://wiki.lazarus.freepascal.org/LCL_Tips#Creating_a_non-rectangular_window_or_control">Creating 
a Non-Rectangular Window or Control</url>
</dd>
</dl>
</descr>
<seealso>
<link id="#lcl.Controls.TWinControl.SetShape">TWinControl.SetShape</link>
<link id="#lcl.LCLIntf.CreateRectRgn">LCLIntf.CreateRectRgn</link>
</seealso>
</element>
<element name="SetWindowRgn.Result">
<short/>
</element>
<element name="SetWindowRgn.hWnd">
<short/>
</element>
<element name="SetWindowRgn.hRgn">
<short/>
</element>
<element name="SetWindowRgn.bRedraw">
<short/>
</element>

<element name="ShowCaret">
<short>Shows the Caret (text cursor).</short>
<descr/>
<seealso/>
</element>
<element name="ShowCaret.Result">
<short/>
</element>
<element name="ShowCaret.hWnd">
<short/>
</element>

<element name="ShowScrollBar">
<short>Shows or hides a Scroll Bar.</short>
<descr/>
<seealso/>
</element>
<element name="ShowScrollBar.Result">
<short/>
</element>
<element name="ShowScrollBar.Handle">
<short/>
</element>
<element name="ShowScrollBar.wBar">
<short/>
</element>
<element name="ShowScrollBar.bShow">
<short/>
</element>

<element name="ShowWindow">
<short>Shows a window in an specific state.</short>
<descr/>
<seealso/>
</element>
<element name="ShowWindow.Result">
<short/>
</element>
<element name="ShowWindow.hWnd">
<short/>
</element>
<element name="ShowWindow.nCmdShow">
<short/>
</element>

<element name="StretchBlt">
<short>
Copies a rectangular region into an device context, shrinking or stretching 
it as required.
</short>
<descr/>
<seealso/>
</element>
<element name="StretchBlt.Result">
<short/>
</element>
<element name="StretchBlt.DestDC">
<short/>
</element>
<element name="StretchBlt.X">
<short/>
</element>
<element name="StretchBlt.Y">
<short/>
</element>
<element name="StretchBlt.Width">
<short/>
</element>
<element name="StretchBlt.Height">
<short/>
</element>
<element name="StretchBlt.SrcDC">
<short/>
</element>
<element name="StretchBlt.XSrc">
<short/>
</element>
<element name="StretchBlt.YSrc">
<short/>
</element>
<element name="StretchBlt.SrcWidth">
<short/>
</element>
<element name="StretchBlt.SrcHeight">
<short/>
</element>
<element name="StretchBlt.Rop">
<short/>
</element>

<element name="StretchDIBits">
<short>Copies a rectangular region from a DIB into an device context, 
shrinking or stretching it
as required.
</short>
<descr/>
<seealso/>
</element>
<element name="StretchDIBits.Result">
<short/>
</element>
<element name="StretchDIBits.DC">
<short/>
</element>
<element name="StretchDIBits.DestX">
<short/>
</element>
<element name="StretchDIBits.DestY">
<short/>
</element>
<element name="StretchDIBits.DestWidth">
<short/>
</element>
<element name="StretchDIBits.DestHeight">
<short/>
</element>
<element name="StretchDIBits.SrcX">
<short/>
</element>
<element name="StretchDIBits.SrcY">
<short/>
</element>
<element name="StretchDIBits.SrcWidth">
<short/>
</element>
<element name="StretchDIBits.SrcHeight">
<short/>
</element>
<element name="StretchDIBits.Bits">
<short/>
</element>
<element name="StretchDIBits.BitsInfo">
<short/>
</element>
<element name="StretchDIBits.Usage">
<short/>
</element>
<element name="StretchDIBits.Rop">
<short/>
</element>

<element name="SystemParametersInfo">
<short>Retrieves or sets one of the system-wide parameters.</short>
<descr/>
<seealso/>
</element>
<element name="SystemParametersInfo.Result">
<short/>
</element>
<element name="SystemParametersInfo.uiAction">
<short/>
</element>
<element name="SystemParametersInfo.uiParam">
<short/>
</element>
<element name="SystemParametersInfo.pvParam">
<short/>
</element>
<element name="SystemParametersInfo.fWinIni">
<short/>
</element>

<element name="TextOut">
<short>Draws an string without formatting (single line).</short>
<descr/>
<seealso/>
</element>
<element name="TextOut.Result">
<short/>
</element>
<element name="TextOut.DC">
<short/>
</element>
<element name="TextOut.X">
<short/>
</element>
<element name="TextOut.Y">
<short/>
</element>
<element name="TextOut.Str">
<short/>
</element>
<element name="TextOut.Count">
<short/>
</element>

<element name="UpdateWindow">
<short>Forces an immediate repaint of a window, if required.</short>
<descr/>
<seealso/>
</element>
<element name="UpdateWindow.Result">
<short/>
</element>
<element name="UpdateWindow.Handle">
<short/>
</element>

<element name="WindowFromPoint">
<short>Finds the window containing the specified point.</short>
<descr/>
<seealso/>
</element>
<element name="WindowFromPoint.Result">
<short/>
</element>
<element name="WindowFromPoint.Point">
<short/>
</element>

<element name="AdjustWindowRectEx">
<short/>
<descr/>
<seealso/>
</element>

<element name="AdjustWindowRectEx.Result">
<short/>
</element>

<element name="AdjustWindowRectEx.Rect">
<short/>
</element>

<element name="AdjustWindowRectEx.Style1">
<short/>
</element>

<element name="AdjustWindowRectEx.MenuExist">
<short/>
</element>

<element name="AdjustWindowRectEx.Style2">
<short/>
</element>

<element name="CharLowerBuff">
<short/>
<descr/>
<seealso/>
</element>

<element name="CharLowerBuff.Result">
<short/>
</element>

<element name="CharLowerBuff.pStr">
<short/>
</element>

<element name="CharLowerBuff.Len">
<short/>
</element>

<element name="CopyRect">
<short/>
<descr/>
<seealso/>
</element>

<element name="CopyRect.Result">
<short/>
</element>

<element name="CopyRect.DestRect">
<short/>
</element>

<element name="CopyRect.SrcRect">
<short/>
</element>

<element name="CreateEllipticRgnIndirect">
<short/>
<descr/>
<seealso/>
</element>

<element name="CreateEllipticRgnIndirect.Result">
<short/>
</element>

<element name="CreateEllipticRgnIndirect.ARect">
<short/>
</element>

<element name="CreateFont">
<short/>
<descr/>
<seealso/>
</element>

<element name="CreateFont.Result">
<short/>
</element>

<element name="CreateFont.Height">
<short/>
</element>

<element name="CreateFont.Width">
<short/>
</element>

<element name="CreateFont.Escapement">
<short/>
</element>

<element name="CreateFont.Orientation">
<short/>
</element>

<element name="CreateFont.Weight">
<short/>
</element>

<element name="CreateFont.Italic">
<short/>
</element>

<element name="CreateFont.Underline">
<short/>
</element>

<element name="CreateFont.StrikeOut">
<short/>
</element>

<element name="CreateFont.CharSet">
<short/>
</element>

<element name="CreateFont.OutputPrecision">
<short/>
</element>

<element name="CreateFont.ClipPrecision">
<short/>
</element>

<element name="CreateFont.Quality">
<short/>
</element>

<element name="CreateFont.PitchAndFamily">
<short/>
</element>

<element name="CreateFont.FaceName">
<short/>
</element>

<element name="CreatePen">
<short/>
<descr/>
<seealso/>
</element>

<element name="CreatePen.Result">
<short/>
</element>

<element name="CreatePen.Style">
<short/>
</element>

<element name="CreatePen.Width">
<short/>
</element>

<element name="CreatePen.Color">
<short/>
</element>

<element name="CreateRectRgnIndirect">
<short/>
<descr/>
<seealso/>
</element>
<element name="CreateRectRgnIndirect.Result">
<short/>
</element>
<element name="CreateRectRgnIndirect.ARect">
<short/>
</element>

<element name="CreateSolidBrush">
<short/>
<descr/>
<seealso/>
</element>
<element name="CreateSolidBrush.Result">
<short/>
</element>
<element name="CreateSolidBrush.Color">
<short/>
</element>

<element name="EqualRect">
<short>Returns <b>True</b> when the rectangles are identical.</short>
<descr/>
<seealso/>
</element>
<element name="EqualRect.Result">
<short/>
</element>
<element name="EqualRect.lprc1">
<short/>
</element>
<element name="EqualRect.lprc2">
<short/>
</element>

<element name="GetScrollPos">
<short>Returns the scroll bar position.</short>
<descr>If the scroll bar is not visible, then the return value is 0.</descr>
<seealso/>
</element>
<element name="GetScrollPos.Result">
<short>The position, zero if the scroll bar is not visible.</short>
</element>
<element name="GetScrollPos.Handle">
<short/>
</element>
<element name="GetScrollPos.nBar">
<short/>
</element>

<element name="GetScrollRange">
<short>Returns the minimum and maximum Position values of a Scroll Bar.
</short>
<descr/>
<seealso/>
</element>
<element name="GetScrollRange.Result">
<short/>
</element>
<element name="GetScrollRange.Handle">
<short/>
</element>
<element name="GetScrollRange.nBar">
<short/>
</element>
<element name="GetScrollRange.lpMinPos">
<short/>
</element>
<element name="GetScrollRange.lpMaxPos">
<short/>
</element>

<element name="GetRValue">
<short>Extracts the red color value from a COLORREF.</short>
<descr/>
<seealso/>
</element>
<element name="GetRValue.Result">
<short/>
</element>
<element name="GetRValue.RGB">
<short/>
</element>

<element name="GetGValue">
<short>Extracts the green color value from a COLORREF.</short>
<descr/>
<seealso/>
</element>
<element name="GetGValue.Result">
<short/>
</element>
<element name="GetGValue.RGB">
<short/>
</element>

<element name="GetBValue">
<short>Extracts the blue color value from a COLORREF.</short>
<descr/>
<seealso/>
</element>
<element name="GetBValue.Result">
<short/>
</element>
<element name="GetBValue.RGB">
<short/>
</element>

<element name="GetRGBValues">
<short>Extracts the red, green and blue color values from a COLORREF.</short>
<descr/>
<seealso/>
</element>
<element name="GetRGBValues.RGB">
<short/>
</element>
<element name="GetRGBValues.R">
<short/>
</element>
<element name="GetRGBValues.G">
<short/>
</element>
<element name="GetRGBValues.B">
<short/>
</element>

<element name="GetRGBIntValues">
<short>Extracts the red, green and blue color values from a COLORREF.</short>
<descr/>
<seealso/>
</element>
<element name="GetRGBIntValues.RGB">
<short/>
</element>
<element name="GetRGBIntValues.R">
<short/>
</element>
<element name="GetRGBIntValues.G">
<short/>
</element>
<element name="GetRGBIntValues.B">
<short/>
</element>

<element name="IndexToOverlayMask">
<short>
Converts an imagelist index into an overlay index.
</short>
<descr/>
<seealso/>
</element>
<element name="IndexToOverlayMask.Result">
<short>Ready for combination with another imagelist index.
</short>
</element>
<element name="IndexToOverlayMask.iOverlay">
<short>The imagelist index of the overlay.</short>
</element>

<element name="InflateRect">
<short>
Inflates the rectangle in all directions.
</short>
<descr>
<p>
The deltas are applied to each side, i.e. the width and height increase by 
double delta amount.
</p>
<p>
Positive values inflate, negative values deflate.
</p>
<p>
The rectangle is clipped so that width and height never can become negative.
</p>
<p>
This method can be used to add or subtract a border around the rectangle.
</p>
</descr>
<seealso/>
</element>
<element name="InflateRect.Result">
<short>Always <b>True</b>.</short>
</element>
<element name="InflateRect.ARect">
<short>This rectangle is modified.</short>
</element>
<element name="InflateRect.dx">
<short>The horizontal increase, negative to decrease.</short>
</element>
<element name="InflateRect.dy">
<short>The vertical increase, negative to decrease.</short>
</element>

<element name="IntersectRect">
<short>Intersects SrcRect1 and SrcRect2 into DestRect.</short>
<descr>
<p>
Intersecting means that DestRect will be the overlapping area of SrcRect1 and 
SrcRect2.
</p>
<p>
If SrcRect1 and SrcRect2 do not overlap the Result is <b>False</b>, else 
<b>True</b>.
</p>
</descr>
<seealso/>
</element>
<element name="IntersectRect.Result">
<short><b>False</b> when the rectangles don't overlap.</short>
</element>
<element name="IntersectRect.DestRect">
<short>Receives the intersection.</short>
</element>
<element name="IntersectRect.SrcRect1">
<short/>
</element>
<element name="IntersectRect.SrcRect2">
<short/>
</element>

<element name="IsCharAlphaNumeric">
<short>Checks for ASCII letter or digit characters.</short>
<descr/>
<seealso/>
</element>
<element name="IsCharAlphaNumeric.Result">
<short><b>True</b> when the character is a letter or digit.</short>
</element>
<element name="IsCharAlphaNumeric.c">
<short/>
</element>

<element name="IsRectEmpty">
<short>Returns <b>True</b> if the rectangle is empty.</short>
<descr>
IsEmptyRect returns <b>True</b> if the area of the rectangle is empty, i.e. 
has a zero or negative width or height.
</descr>
<seealso/>
</element>
<element name="IsRectEmpty.Result">
<short><b>True</b> if the rectangle is empty.</short>
</element>
<element name="IsRectEmpty.ARect">
<short/>
</element>

<element name="KillTimer">
<short>Removes an timer.</short>
<descr/>
<seealso>
<link id="SetTimer"/>
</seealso>
</element>
<element name="KillTimer.Result">
<short>Zero on failure!</short>
</element>
<element name="KillTimer.Wnd">
<short>The window handle associated with the timer, can be zero.</short>
</element>
<element name="KillTimer.uIDEvent">
<short>The timer ID.</short>
</element>

<element name="MakeLong">
<short>Copies two words into a double word.</short>
<descr/>
<seealso/>
</element>
<element name="MakeLong.Result">
<short>The combined doubleword.</short>
</element>
<element name="MakeLong.A">
<short>The low word.</short>
</element>
<element name="MakeLong.B">
<short>The high word.</short>
</element>

<element name="MakeROP4">
<short/>
<descr/>
<seealso/>
</element>
<element name="MakeROP4.Result">
<short/>
</element>
<element name="MakeROP4.fore">
<short/>
</element>
<element name="MakeROP4.back">
<short/>
</element>

<element name="MakeWord">
<short>Copies two bytes into a word.</short>
<descr/>
<seealso/>
</element>

<element name="MakeWord.Result">
<short/>
</element>
<element name="MakeWord.A">
<short>The low byte.</short>
</element>
<element name="MakeWord.B">
<short>The high byte.</short>
</element>

<element name="MakeWParam">
<short>
Copies two words into a double word, usable as a message wParam.
</short>
<descr>The result has the size of an pointer.</descr>
<seealso/>
</element>
<element name="MakeWParam.Result">
<short/>
</element>
<element name="MakeWParam.l">
<short>The low word.</short>
</element>
<element name="MakeWParam.h">
<short>The high word.</short>
</element>

<element name="MakeLParam" link="MakeWParam">
<short>
Copies two words into a double word, usable as a message lParam.
</short>
<descr/>
<seealso/>
</element>
<element name="MakeLParam.Result">
<short/>
</element>
<element name="MakeLParam.l">
<short>The low word.</short>
</element>
<element name="MakeLParam.h">
<short>The high word.</short>
</element>

<element name="MakeLResult" link="MakeWParam">
<short>
Copies two words into a double word, usable as a message Result.
</short>
<descr/>
<seealso/>
</element>
<element name="MakeLResult.Result">
<short/>
</element>
<element name="MakeLResult.l">
<short>The low word.</short>
</element>
<element name="MakeLResult.h">
<short>The high word.</short>
</element>

<element name="OffSetRect">
<short>Move Left/Right by dx, Top/Bottom by dy. Return Top and Left are &gt;= 
0.
</short>
<descr/>
<seealso/>
</element>
<element name="OffSetRect.Result">
<short><b>False</b> if resulting Top or Left are negative.</short>
</element>
<element name="OffSetRect.Rect">
<short/>
</element>
<element name="OffSetRect.dx">
<short/>
</element>
<element name="OffSetRect.dy">
<short/>
</element>

<element name="PtInRect">
<short>Checks whether a Point is within a Rect.</short>
<descr>
<p>
Top and Left side are part of the rectangle, but Bottom and Right side are 
outside.
</p>
</descr>
<seealso/>
</element>
<element name="PtInRect.Result">
<short><b>True</b> when Point is within Rect.</short>
</element>
<element name="PtInRect.Rect">
<short/>
</element>
<element name="PtInRect.Point">
<short/>
</element>

<element name="PointToSmallPoint">
<short/>
<descr/>
<seealso/>
</element>

<element name="PointToSmallPoint.Result">
<short/>
</element>

<element name="PointToSmallPoint.P">
<short/>
</element>

<element name="RGB">
<short>Combines Red, Green and Blue values into an TColorRef value.
</short>
<descr>
<p>
The bytes are shifted into place, following the format $00bbggrr, which is 
the format of the
Windows API type COLORREF. Their actual physical order depends on the 
endian-ness of the machine.
</p>
</descr>
<seealso/>
</element>
<element name="RGB.Result">
<short>The combined COLORREF created with the given color channels.</short>
</element>
<element name="RGB.R">
<short>
The value of the red channel. zero indicates no contribution, 255 indicates a 
full red channel.
</short>
</element>
<element name="RGB.G">
<short>The value of the green channel.</short>
</element>
<element name="RGB.B">
<short>The value of the blue channel.</short>
</element>

<element name="ScrollWindow">
<short>Scrolls the content of a window, by a number of pixels.</short>
<descr/>
<seealso>
<link id="ScrollWindowEx"/>
</seealso>
</element>
<element name="ScrollWindow.Result">
<short/>
</element>
<element name="ScrollWindow.hWnd">
<short/>
</element>
<element name="ScrollWindow.XAmount">
<short>Horizontal distance (positive to scroll right).</short>
</element>
<element name="ScrollWindow.YAmount">
<short>Vertical distance (positive to scroll down).</short>
</element>
<element name="ScrollWindow.Rect">
<short>The part of the window, that is to be scrolled.
</short>
</element>
<element name="ScrollWindow.ClipRect">
<short>Pixels falling outside this rectangle are lost.</short>
</element>

<element name="SetRect">
<short>Copies coordinates into a rectangle.</short>
<descr/>
<seealso/>
</element>
<element name="SetRect.Result">
<short>Always <b>True</b>.</short>
</element>
<element name="SetRect.ARect">
<short/>
</element>
<element name="SetRect.xLeft">
<short/>
</element>
<element name="SetRect.yTop">
<short/>
</element>
<element name="SetRect.xRight">
<short/>
</element>
<element name="SetRect.yBottom">
<short/>
</element>

<element name="SetRectEmpty">
<short>Clears the rectangle to all zero coordinates.</short>
<descr/>
<seealso/>
</element>
<element name="SetRectEmpty.Result">
<short>Always <b>True</b>.</short>
</element>
<element name="SetRectEmpty.ARect">
<short/>
</element>

<element name="SetScrollPos">
<short>Changes the Position of an Scroll Bar slider.
</short>
<descr>
The SetScrollPos function sets the position of the scroll box (thumb) in the 
specified scroll bar and, if requested, redraws the scroll bar to reflect the 
new position of the scroll box.
</descr>
<seealso>
<link id="SetScrollInfo"/>
</seealso>
</element>
<element name="SetScrollPos.Result">
<short>The previous Position, zero if invisible.</short>
</element>
<element name="SetScrollPos.Handle">
<short>The Scroll Bar or Window Handle.</short>
</element>
<element name="SetScrollPos.nBar">
<short>
<link id="#lcl.LCLType.SB_CTL">SB_CTL</link>
means a Scroll Bar control.</short>
</element>
<element name="SetScrollPos.nPos">
<short>The new Position.</short>
</element>
<element name="SetScrollPos.bRedraw">
<short><b>True</b> forces a repaint.</short>
</element>

<element name="SetScrollRange">
<short>
Sets the minimum and maximum position values for a scroll bar.
</short>
<descr/>
<seealso>
<link id="SetScrollInfo"/>
</seealso>
</element>
<element name="SetScrollRange.Result">
<short>Always <b>True</b>.</short>
</element>
<element name="SetScrollRange.Handle">
<short/>
</element>
<element name="SetScrollRange.nBar">
<short/>
</element>
<element name="SetScrollRange.nMinPos">
<short/>
</element>
<element name="SetScrollRange.nMaxPos">
<short/>
</element>
<element name="SetScrollRange.bRedraw">
<short/>
</element>

<element name="SetTimer">
<short>Creates or resets an timer for the given time interval.</short>
<descr>
<p>
Every timer has a unique ID, which is reported in the timer message and can 
be used to reset or kill the timer.
</p>
<p>
When the time has elapsed, the callback procedure is invoked. If no procedure 
is given, a WM_TIMER message is sent to the window. If also no window is 
given, the function fails.
</p>
<p>
When the timer already exists, it is reset to the new interval.
</p>
</descr>
<seealso>
<link id="KillTimer"/>
<link id="#lcl.lcltype.TTimerProc">TTimerProc</link>
</seealso>
</element>
<element name="SetTimer.Result">
<short>The timer ID, or zero on failure.</short>
</element>
<element name="SetTimer.Wnd">
<short>The window associated with the timer.</short>
</element>
<element name="SetTimer.nIDEvent">
<short>The ID of the timer, ignored when Wnd is zero.</short>
</element>
<element name="SetTimer.uElapse">
<short>The time interval to wait.</short>
</element>
<element name="SetTimer.lpTimerFunc">
<short>The callback procedure, can be Nil.</short>
</element>

<element name="SmallPointToPoint">
<short>Converts a TSmallPoint value to a TPoint value.</short>
<descr/>
<seealso/>
</element>
<element name="SmallPointToPoint.Result">
<short/>
</element>
<element name="SmallPointToPoint.P">
<short/>
</element>

<element name="SubtractRect">
<short>
Computes the bounding box with the geometric difference between two 
rectangles.
</short>
<descr>
<p>
When the rectangles do not overlap completely in either x or y direction, the 
result is the first rectangle (lprcSrc1).
</p>
<p>
Otherwise the overlapping area is excluded from the first rectangle.
</p>
<p>
The bounding box is the <b>rectangle</b> that covers the entire resulting 
area.
</p>
</descr>
<seealso/>
</element>
<element name="SubtractRect.Result">
<short><b>False</b> when the resulting rectangle is empty.</short>
</element>
<element name="SubtractRect.lprcDst">
<short/>
</element>
<element name="SubtractRect.lprcSrc1">
<short/>
</element>
<element name="SubtractRect.lprcSrc2">
<short>The rectangle to subtract.</short>
</element>

<element name="UnionRect">
<short>Computes the bounding box of the union of two rectangles.
</short>
<descr>
<p>
The bounding box is the <b>rectangle</b> that covers the entire resulting 
area. Here the result covers both rectangles.
</p>
<p>
The rectangles can be disjoint.
</p>
<p>
Rectangles with a zero or negative width or height are treated as empty 
rectangles (ignored).
</p>
</descr>
<seealso/>
</element>
<element name="UnionRect.Result">
<short>
<b>False</b> when the resulting rectangle is empty, i.e. when both source 
rectangles are empty.
</short>
</element>
<element name="UnionRect.DestRect">
<short/>
</element>
<element name="UnionRect.SrcRect1">
<short/>
</element>
<element name="UnionRect.SrcRect2">
<short/>
</element>

<element name="AddEventHandler">
<short/>
<descr/>
<seealso/>
</element>
<element name="AddEventHandler.Result">
<short/>
</element>
<element name="AddEventHandler.AHandle">
<short/>
</element>
<element name="AddEventHandler.AFlags">
<short/>
</element>
<element name="AddEventHandler.AEventHandler">
<short/>
</element>
<element name="AddEventHandler.AData">
<short/>
</element>

<element name="AddProcessEventHandler">
<short/>
<descr/>
<seealso/>
</element>
<element name="AddProcessEventHandler.Result">
<short/>
</element>
<element name="AddProcessEventHandler.AHandle">
<short/>
</element>
<element name="AddProcessEventHandler.AEventHandler">
<short/>
</element>
<element name="AddProcessEventHandler.AData">
<short/>
</element>

<element name="AddPipeEventHandler">
<short/>
<descr/>
<seealso/>
</element>
<element name="AddPipeEventHandler.Result">
<short/>
</element>
<element name="AddPipeEventHandler.AHandle">
<short/>
</element>
<element name="AddPipeEventHandler.AEventHandler">
<short/>
</element>
<element name="AddPipeEventHandler.AData">
<short/>
</element>

<element name="AllocateHWnd">
<short/>
<descr/>
<seealso/>
</element>
<element name="AllocateHWnd.Result">
<short/>
</element>
<element name="AllocateHWnd.Method">
<short/>
</element>

<element name="AskUser">
<short/>
<descr/>
<seealso/>
</element>
<element name="AskUser.Result">
<short/>
</element>
<element name="AskUser.DialogCaption">
<short/>
</element>
<element name="AskUser.DialogMessage">
<short/>
</element>
<element name="AskUser.DialogType">
<short/>
</element>
<element name="AskUser.Buttons">
<short/>
</element>
<element name="AskUser.HelpCtx">
<short/>
</element>

<element name="CallDefaultWndHandler">
<short/>
<descr/>
<seealso/>
</element>

<element name="CallDefaultWndHandler.Sender">
<short/>
</element>

<element name="CallDefaultWndHandler.Message">
<short/>
</element>

<element name="ClipboardFormatToMimeType">
<short/>
<descr/>
<seealso/>
</element>

<element name="ClipboardFormatToMimeType.Result">
<short/>
</element>

<element name="ClipboardFormatToMimeType.FormatID">
<short/>
</element>

<element name="ClipboardGetData">
<short/>
<descr/>
<seealso/>
</element>

<element name="ClipboardGetData.Result">
<short/>
</element>

<element name="ClipboardGetData.ClipboardType">
<short/>
</element>

<element name="ClipboardGetData.FormatID">
<short/>
</element>

<element name="ClipboardGetData.Stream">
<short/>
</element>

<element name="ClipboardGetFormats">
<short/>
<descr/>
<seealso/>
</element>

<element name="ClipboardGetFormats.Result">
<short/>
</element>

<element name="ClipboardGetFormats.ClipboardType">
<short/>
</element>

<element name="ClipboardGetFormats.Count">
<short/>
</element>

<element name="ClipboardGetFormats.List">
<short/>
</element>

<element name="ClipboardGetOwnerShip">
<short/>
<descr/>
<seealso/>
</element>

<element name="ClipboardGetOwnerShip.Result">
<short/>
</element>

<element name="ClipboardGetOwnerShip.ClipboardType">
<short/>
</element>

<element name="ClipboardGetOwnerShip.OnRequestProc">
<short/>
</element>

<element name="ClipboardGetOwnerShip.FormatCount">
<short/>
</element>

<element name="ClipboardGetOwnerShip.Formats">
<short/>
</element>

<element name="ClipboardRegisterFormat">
<short/>
<descr/>
<seealso/>
</element>

<element name="ClipboardRegisterFormat.Result">
<short/>
</element>

<element name="ClipboardRegisterFormat.AMimeType">
<short/>
</element>

<element name="CreateEmptyRegion">
<short/>
<descr/>
<seealso/>
</element>

<element name="CreateEmptyRegion.Result">
<short/>
</element>

<element name="CreatePixmapIndirect">
<short/>
<descr/>
<seealso/>
</element>

<element name="CreatePixmapIndirect.Result">
<short/>
</element>

<element name="CreatePixmapIndirect.Data">
<short/>
</element>

<element name="CreatePixmapIndirect.TransColor">
<short/>
</element>

<element name="CreateRegionCopy">
<short/>
<descr/>
<seealso/>
</element>

<element name="CreateRegionCopy.Result">
<short/>
</element>

<element name="CreateRegionCopy.SrcRGN">
<short/>
</element>

<element name="CreateRubberBand">
<short/>
<descr/>
<seealso/>
</element>
<element name="CreateRubberBand.Result">
<short/>
</element>
<element name="CreateRubberBand.ARect">
<short/>
</element>
<element name="CreateRubberBand.ABrush">
<short/>
</element>

<element name="CreateStandardCursor">
<short/>
<descr/>
<seealso/>
</element>
<element name="CreateStandardCursor.Result">
<short/>
</element>
<element name="CreateStandardCursor.ACursor">
<short/>
</element>

<element name="DCClipRegionValid">
<short/>
<descr/>
<seealso/>
</element>
<element name="DCClipRegionValid.Result">
<short/>
</element>
<element name="DCClipRegionValid.DC">
<short/>
</element>

<element name="DeallocateHWnd">
<short/>
<descr/>
<seealso/>
</element>
<element name="DeallocateHWnd.Wnd">
<short/>
</element>

<element name="DestroyRubberBand">
<short/>
<descr/>
<seealso/>
</element>
<element name="DestroyRubberBand.ARubberBand">
<short/>
</element>

<element name="DrawDefaultDockImage">
<short/>
<descr/>
<seealso/>
</element>
<element name="DrawDefaultDockImage.AOldRect">
<short/>
</element>
<element name="DrawDefaultDockImage.ANewRect">
<short/>
</element>
<element name="DrawDefaultDockImage.AOperation">
<short/>
</element>

<element name="DrawGrid">
<short>
Draws the grid separator lines between columns and rows with the specified 
width and height.
</short>
<descr>
<p>
The current device context is saved on entry, and restored prior to exit.
</p>
</descr>
<seealso/>
</element>
<element name="DrawGrid.DC">
<short>
Device context where the drawing operation is performed.
</short>
</element>
<element name="DrawGrid.R">
<short>
Rectangle with the bounds where the grid is drawn.
</short>
</element>
<element name="DrawGrid.DX">
<short>
Width for the evenly-spaced columns in the grid.
</short>
</element>
<element name="DrawGrid.DY">
<short>
Height for the evenly-spaced rows in the grid.
</short>
</element>

<element name="ExtUTF8Out">
<short/>
<descr/>
<seealso/>
</element>
<element name="ExtUTF8Out.Result">
<short/>
</element>
<element name="ExtUTF8Out.DC">
<short/>
</element>
<element name="ExtUTF8Out.X">
<short/>
</element>
<element name="ExtUTF8Out.Y">
<short/>
</element>
<element name="ExtUTF8Out.Options">
<short/>
</element>
<element name="ExtUTF8Out.Rect">
<short/>
</element>
<element name="ExtUTF8Out.Str">
<short/>
</element>
<element name="ExtUTF8Out.Count">
<short/>
</element>
<element name="ExtUTF8Out.Dx">
<short/>
</element>

<element name="FontIsMonoSpace">
<short>
Indicates whether the specified font handle represents a fixed-pitch typeface.
</short>
<descr>
<remark>
<var>FontIsMonoSpace</var> is not implemented for all widgetsets. For 
example, GTK3 always returns <b>False</b> in the current LCL version (2.3.0). 
However, it is implemented for GTK2.
</remark>
</descr>
<seealso/>
</element>
<element name="FontIsMonoSpace.Result">
<short>
<b>True</b> when the font uses a fixed-pitch typeface.
</short>
</element>
<element name="FontIsMonoSpace.Font">
<short>
Handle for the font examined in the routine.
</short>
</element>

<element name="Frame">
<short/>
<descr/>
<seealso/>
</element>

<element name="Frame.Result">
<short/>
</element>

<element name="Frame.DC">
<short/>
</element>

<element name="Frame.ARect">
<short/>
</element>

<element name="Frame3d">
<short/>
<descr/>
<seealso/>
</element>

<element name="Frame3d.Result">
<short/>
</element>

<element name="Frame3d.DC">
<short/>
</element>

<element name="Frame3d.ARect">
<short/>
</element>

<element name="Frame3d.FrameWidth">
<short/>
</element>

<element name="Frame3d.Style">
<short/>
</element>

<element name="GetAcceleratorString">
<short/>
<descr/>
<seealso/>
</element>

<element name="GetAcceleratorString.Result">
<short/>
</element>

<element name="GetAcceleratorString.AVKey">
<short/>
</element>

<element name="GetAcceleratorString.AShiftState">
<short/>
</element>

<element name="GetCaretRespondToFocus">
<short/>
<descr/>
<seealso/>
</element>

<element name="GetCaretRespondToFocus.Result">
<short/>
</element>

<element name="GetCaretRespondToFocus.handle">
<short/>
</element>

<element name="GetCaretRespondToFocus.ShowHideOnFocus">
<short/>
</element>

<element name="GetClientBounds">
<short/>
<descr/>
<seealso/>
</element>

<element name="GetClientBounds.Result">
<short/>
</element>

<element name="GetClientBounds.handle">
<short/>
</element>

<element name="GetClientBounds.ARect">
<short/>
</element>

<element name="GetCmdLineParamDescForInterface">
<short/>
<descr/>
<seealso/>
</element>

<element name="GetCmdLineParamDescForInterface.Result">
<short/>
</element>

<element name="GetControlConstraints">
<short/>
<descr/>
<seealso/>
</element>

<element name="GetControlConstraints.Result">
<short/>
</element>

<element name="GetControlConstraints.Constraints">
<short/>
</element>

<element name="GetDCOriginRelativeToWindow">
<short/>
<descr/>
<seealso/>
</element>

<element name="GetDCOriginRelativeToWindow.Result">
<short/>
</element>

<element name="GetDCOriginRelativeToWindow.PaintDC">
<short/>
</element>

<element name="GetDCOriginRelativeToWindow.WindowHandle">
<short/>
</element>

<element name="GetDCOriginRelativeToWindow.OriginDiff">
<short/>
</element>

<element name="GetDesignerDC">
<short/>
<descr/>
<seealso/>
</element>

<element name="GetDesignerDC.Result">
<short/>
</element>

<element name="GetDesignerDC.WindowHandle">
<short/>
</element>

<element name="GetDeviceSize">
<short/>
<descr/>
<seealso/>
</element>

<element name="GetDeviceSize.Result">
<short/>
</element>

<element name="GetDeviceSize.DC">
<short/>
</element>

<element name="GetDeviceSize.p">
<short/>
</element>

<element name="GetLCLOwnerObject">
<short/>
<descr/>
<seealso/>
</element>

<element name="GetLCLOwnerObject.Result">
<short/>
</element>

<element name="GetLCLOwnerObject.Handle">
<short/>
</element>

<element name="GetScrollBarSize">
<short/>
<descr/>
<seealso/>
</element>

<element name="GetScrollBarSize.Result">
<short/>
</element>

<element name="GetScrollBarSize.Handle">
<short/>
</element>

<element name="GetScrollBarSize.SBStyle">
<short/>
</element>

<element name="GetScrollbarVisible">
<short/>
<descr/>
<seealso/>
</element>

<element name="GetScrollbarVisible.Result">
<short/>
</element>

<element name="GetScrollbarVisible.Handle">
<short/>
</element>

<element name="GetScrollbarVisible.SBStyle">
<short/>
</element>

<element name="GetWindowRelativePosition">
<short/>
<descr/>
<seealso/>
</element>

<element name="GetWindowRelativePosition.Result">
<short/>
</element>

<element name="GetWindowRelativePosition.Handle">
<short/>
</element>

<element name="GetWindowRelativePosition.Left">
<short/>
</element>

<element name="GetWindowRelativePosition.Top">
<short/>
</element>

<element name="IntfSendsUTF8KeyPress">
<short/>
<descr/>
<seealso/>
</element>

<element name="IntfSendsUTF8KeyPress.Result">
<short/>
</element>

<element name="InvalidateFrame">
<short/>
<descr/>
<seealso/>
</element>

<element name="InvalidateFrame.Result">
<short/>
</element>

<element name="InvalidateFrame.aHandle">
<short/>
</element>

<element name="InvalidateFrame.ARect">
<short/>
</element>

<element name="InvalidateFrame.bErase">
<short/>
</element>

<element name="InvalidateFrame.BorderWidth">
<short/>
</element>

<element name="IsDesignerDC">
<short/>
<descr/>
<seealso/>
</element>
<element name="IsDesignerDC.Result">
<short/>
</element>
<element name="IsDesignerDC.WindowHandle">
<short/>
</element>
<element name="IsDesignerDC.DC">
<short/>
</element>

<element name="MoveWindowOrgEx">
<short/>
<descr/>
<seealso/>
</element>

<element name="MoveWindowOrgEx.Result">
<short/>
</element>

<element name="MoveWindowOrgEx.dc">
<short/>
</element>

<element name="MoveWindowOrgEx.dX">
<short/>
</element>

<element name="MoveWindowOrgEx.dY">
<short/>
</element>

<element name="PromptUser">
<short/>
<descr/>
<seealso/>
</element>

<element name="PromptUser.Result">
<short/>
</element>

<element name="PromptUser.DialogCaption">
<short/>
</element>

<element name="PromptUser.DialogMessage">
<short/>
</element>

<element name="PromptUser.DialogType">
<short/>
</element>

<element name="PromptUser.Buttons">
<short/>
</element>

<element name="PromptUser.ButtonCount">
<short/>
</element>

<element name="PromptUser.DefaultIndex">
<short/>
</element>

<element name="PromptUser.EscapeResult">
<short/>
</element>

<element name="PromptUserAtXY">
<short/>
<descr/>
<seealso/>
</element>

<element name="PromptUserAtXY.Result">
<short/>
</element>

<element name="PromptUserAtXY.DialogCaption">
<short/>
</element>

<element name="PromptUserAtXY.DialogMessage">
<short/>
</element>

<element name="PromptUserAtXY.DialogType">
<short/>
</element>

<element name="PromptUserAtXY.Buttons">
<short/>
</element>

<element name="PromptUserAtXY.ButtonCount">
<short/>
</element>

<element name="PromptUserAtXY.DefaultIndex">
<short/>
</element>

<element name="PromptUserAtXY.EscapeResult">
<short/>
</element>

<element name="PromptUserAtXY.X">
<short/>
</element>

<element name="PromptUserAtXY.Y">
<short/>
</element>

<element name="RadialArc">
<short/>
<descr/>
<seealso/>
</element>
<element name="RadialArc.Result">
<short/>
</element>
<element name="RadialArc.DC">
<short/>
</element>
<element name="RadialArc.left">
<short/>
</element>
<element name="RadialArc.top">
<short/>
</element>
<element name="RadialArc.right">
<short/>
</element>
<element name="RadialArc.bottom">
<short/>
</element>
<element name="RadialArc.sx">
<short/>
</element>
<element name="RadialArc.sy">
<short/>
</element>
<element name="RadialArc.ex">
<short/>
</element>
<element name="RadialArc.ey">
<short/>
</element>

<element name="RadialChord">
<short/>
<descr/>
<seealso/>
</element>
<element name="RadialChord.Result">
<short/>
</element>
<element name="RadialChord.DC">
<short/>
</element>
<element name="RadialChord.x1">
<short/>
</element>
<element name="RadialChord.y1">
<short/>
</element>
<element name="RadialChord.x2">
<short/>
</element>
<element name="RadialChord.y2">
<short/>
</element>
<element name="RadialChord.sx">
<short/>
</element>
<element name="RadialChord.sy">
<short/>
</element>
<element name="RadialChord.ex">
<short/>
</element>
<element name="RadialChord.ey">
<short/>
</element>

<element name="RadialPie">
<short/>
<descr/>
<seealso/>
</element>
<element name="RadialPie.Result">
<short/>
</element>
<element name="RadialPie.DC">
<short/>
</element>
<element name="RadialPie.x1">
<short/>
</element>
<element name="RadialPie.y1">
<short/>
</element>
<element name="RadialPie.x2">
<short/>
</element>
<element name="RadialPie.y2">
<short/>
</element>
<element name="RadialPie.Angle1">
<short/>
</element>
<element name="RadialPie.Angle2">
<short/>
</element>

<element name="RawImage_CreateBitmaps">
<short/>
<descr/>
<seealso/>
</element>
<element name="RawImage_CreateBitmaps.Result">
<short/>
</element>
<element name="RawImage_CreateBitmaps.ARawImage">
<short/>
</element>
<element name="RawImage_CreateBitmaps.ABitmap">
<short/>
</element>
<element name="RawImage_CreateBitmaps.AMask">
<short/>
</element>
<element name="RawImage_CreateBitmaps.ASkipMask">
<short/>
</element>

<element name="RawImage_DescriptionFromBitmap">
<short/>
<descr/>
<seealso/>
</element>
<element name="RawImage_DescriptionFromBitmap.Result">
<short/>
</element>
<element name="RawImage_DescriptionFromBitmap.ABitmap">
<short/>
</element>
<element name="RawImage_DescriptionFromBitmap.ADesc">
<short/>
</element>

<element name="RawImage_DescriptionFromDevice">
<short/>
<descr/>
<seealso/>
</element>
<element name="RawImage_DescriptionFromDevice.Result">
<short/>
</element>
<element name="RawImage_DescriptionFromDevice.ADC">
<short/>
</element>
<element name="RawImage_DescriptionFromDevice.ADesc">
<short/>
</element>

<element name="RawImage_FromBitmap">
<short/>
<descr/>
<seealso/>
</element>
<element name="RawImage_FromBitmap.Result">
<short/>
</element>
<element name="RawImage_FromBitmap.ARawImage">
<short/>
</element>
<element name="RawImage_FromBitmap.ABitmap">
<short/>
</element>
<element name="RawImage_FromBitmap.AMask">
<short/>
</element>
<element name="RawImage_FromBitmap.ARect">
<short/>
</element>

<element name="RawImage_FromDevice">
<short/>
<descr/>
<seealso/>
</element>
<element name="RawImage_FromDevice.Result">
<short/>
</element>
<element name="RawImage_FromDevice.ARawImage">
<short/>
</element>
<element name="RawImage_FromDevice.ADC">
<short/>
</element>
<element name="RawImage_FromDevice.ARect">
<short/>
</element>

<element name="RawImage_QueryDescription">
<short/>
<descr/>
<seealso/>
</element>
<element name="RawImage_QueryDescription.Result">
<short/>
</element>
<element name="RawImage_QueryDescription.AFlags">
<short/>
</element>
<element name="RawImage_QueryDescription.ADesc">
<short/>
</element>

<element name="RegroupMenuItem">
<short/>
<descr/>
<seealso/>
</element>

<element name="RegroupMenuItem.Result">
<short/>
</element>

<element name="RegroupMenuItem.hndMenu">
<short/>
</element>

<element name="RegroupMenuItem.GroupIndex">
<short/>
</element>

<element name="ReleaseDesignerDC">
<short/>
<descr/>
<seealso/>
</element>

<element name="ReleaseDesignerDC.Result">
<short/>
</element>

<element name="ReleaseDesignerDC.hWnd">
<short/>
</element>

<element name="ReleaseDesignerDC.DC">
<short/>
</element>

<element name="RemoveEventHandler">
<short/>
<descr/>
<seealso/>
</element>
<element name="RemoveEventHandler.AHandler">
<short/>
</element>

<element name="RemoveProcessEventHandler">
<short/>
<descr/>
<seealso/>
</element>
<element name="RemoveProcessEventHandler.AHandler">
<short/>
</element>

<element name="RemovePipeEventHandler">
<short/>
<descr/>
<seealso/>
</element>
<element name="RemovePipeEventHandler.AHandler">
<short/>
</element>

<element name="RequestInput">
<short/>
<descr/>
<seealso/>
</element>
<element name="RequestInput.Result">
<short/>
</element>
<element name="RequestInput.InputCaption">
<short/>
</element>
<element name="RequestInput.InputPrompt">
<short/>
</element>
<element name="RequestInput.MaskInput">
<short/>
</element>
<element name="RequestInput.Value">
<short/>
</element>

<element name="SendCachedLCLMessages">
<short/>
<descr/>
<seealso/>
</element>

<element name="DrawSplitter">
<short/>
<descr/>
<seealso/>
</element>

<element name="SetCaretRespondToFocus">
<short/>
<descr/>
<seealso/>
</element>

<element name="SetCaretRespondToFocus.Result">
<short/>
</element>

<element name="SetCaretRespondToFocus.handle">
<short/>
</element>

<element name="SetCaretRespondToFocus.ShowHideOnFocus">
<short/>
</element>

<element name="SetComboMinDropDownSize">
<short/>
<descr/>
<seealso/>
</element>

<element name="SetComboMinDropDownSize.Result">
<short/>
</element>

<element name="SetComboMinDropDownSize.Handle">
<short/>
</element>

<element name="SetComboMinDropDownSize.MinItemsWidth">
<short/>
</element>

<element name="SetComboMinDropDownSize.MinItemsHeight">
<short/>
</element>

<element name="SetComboMinDropDownSize.MinItemCount">
<short/>
</element>

<element name="SetEventHandlerFlags">
<short/>
<descr/>
<seealso/>
</element>
<element name="SetEventHandlerFlags.AHandler">
<short/>
</element>
<element name="SetEventHandlerFlags.NewFlags">
<short/>
</element>

<element name="SetRubberBandRect">
<short/>
<descr/>
<seealso/>
</element>
<element name="SetRubberBandRect.ARubberBand">
<short/>
</element>
<element name="SetRubberBandRect.ARect">
<short/>
</element>

<element name="StretchMaskBlt">
<short/>
<descr/>
<seealso/>
</element>

<element name="StretchMaskBlt.Result">
<short/>
</element>

<element name="StretchMaskBlt.DestDC">
<short/>
</element>

<element name="StretchMaskBlt.X">
<short/>
</element>

<element name="StretchMaskBlt.Y">
<short/>
</element>

<element name="StretchMaskBlt.Width">
<short/>
</element>

<element name="StretchMaskBlt.Height">
<short/>
</element>

<element name="StretchMaskBlt.SrcDC">
<short/>
</element>

<element name="StretchMaskBlt.XSrc">
<short/>
</element>

<element name="StretchMaskBlt.YSrc">
<short/>
</element>

<element name="StretchMaskBlt.SrcWidth">
<short/>
</element>

<element name="StretchMaskBlt.SrcHeight">
<short/>
</element>

<element name="StretchMaskBlt.Mask">
<short/>
</element>

<element name="StretchMaskBlt.XMask">
<short/>
</element>

<element name="StretchMaskBlt.YMask">
<short/>
</element>

<element name="StretchMaskBlt.Rop">
<short/>
</element>

<element name="TextUTF8Out">
<short/>
<descr/>
<seealso/>
</element>
<element name="TextUTF8Out.Result">
<short/>
</element>
<element name="TextUTF8Out.DC">
<short/>
</element>
<element name="TextUTF8Out.X">
<short/>
</element>
<element name="TextUTF8Out.Y">
<short/>
</element>
<element name="TextUTF8Out.Str">
<short/>
</element>
<element name="TextUTF8Out.Count">
<short/>
</element>


<element name="ExcludeClipRgn">
<short/>
<descr/>
<seealso/>
</element>

<element name="ExcludeClipRgn.Result">
<short/>
</element>
<element name="ExcludeClipRgn.dc">
<short/>
</element>
<element name="ExcludeClipRgn.rgn">
<short/>
</element>

<element name="NotifyUser">
<short/>
<descr/>
<seealso/>
</element>
<element name="NotifyUser.DialogMessage">
<short/>
</element>
<element name="NotifyUser.DialogType">
<short/>
</element>

<element name="NotifyUserAtXY">
<short/>
<descr/>
<seealso/>
</element>

<element name="NotifyUserAtXY.DialogMessage">
<short/>
</element>

<element name="NotifyUserAtXY.DialogType">
<short/>
</element>

<element name="NotifyUserAtXY.X">
<short/>
</element>

<element name="NotifyUserAtXY.Y">
<short/>
</element>

<element name="PromptUser">
<short/>
<descr/>
<seealso/>
</element>

<element name="PromptUser.Result">
<short/>
</element>

<element name="PromptUser.DialogMessage">
<short/>
</element>

<element name="PromptUser.DialogType">
<short/>
</element>

<element name="PromptUser.Buttons">
<short/>
</element>

<element name="PromptUser.DefaultIndex">
<short/>
</element>

<element name="PromptUser.EscapeResult">
<short/>
</element>

<element name="PromptUserAtXY">
<short/>
<descr/>
<seealso/>
</element>

<element name="PromptUserAtXY.Result">
<short/>
</element>

<element name="PromptUserAtXY.DialogMessage">
<short/>
</element>

<element name="PromptUserAtXY.DialogType">
<short/>
</element>

<element name="PromptUserAtXY.Buttons">
<short/>
</element>

<element name="PromptUserAtXY.DefaultIndex">
<short/>
</element>

<element name="PromptUserAtXY.EscapeResult">
<short/>
</element>

<element name="PromptUserAtXY.X">
<short/>
</element>

<element name="PromptUserAtXY.Y">
<short/>
</element>

<element name="PredefinedClipboardFormat">
<short/>
<descr/>
<seealso/>
</element>
<element name="PredefinedClipboardFormat.Result">
<short/>
</element>
<element name="PredefinedClipboardFormat.AFormat">
<short/>
</element>

<element name="MsgKeyDataToShiftState">
<short/>
<descr/>
<seealso/>
</element>
<element name="MsgKeyDataToShiftState.Result">
<short/>
</element>
<element name="MsgKeyDataToShiftState.KeyData">
<short/>
</element>

<element name="GetTickCount">
<short>
Number of ticks (milliseconds) elapsed since the computer was started.
</short>
<descr>
<p>
GetTickCount is a DWord function used to get the number of ticks 
(milliseconds) elapsed since the computer was started. GetTickCount calls the 
GetTickCount64 function in LazSysUtils to get the return value.
</p>
</descr>
<seealso/>
</element>
<element name="GetTickCount.Result">
<short>Elapsed ticks (milliseconds).</short>
</element>

<element name="GetTickCount64">
<short>
Number of ticks (milliseconds) elapsed since the computer was started.
</short>
<descr>
<p>
<var>GetTickCount64</var> is a <var>QWord</var> function used to get the 
number of ticks (milliseconds) elapsed since the computer was started. 
GetTickCount64 calls the GetTickCount64 function in LazSysUtils to get the 
return value.
</p>
</descr>
<seealso/>
</element>
<element name="GetTickCount64.Result">
<short>Elapsed ticks (milliseconds).</short>
</element>

<element name="FindDefaultBrowser">
<short>Gets the path to the default browser and its parameters.</short>
<descr/>
<seealso/>
</element>
<element name="FindDefaultBrowser.Result">
<short><b>True</b> the default browser was found for the platform.</short>
</element>
<element name="FindDefaultBrowser.ABrowser">
<short>Qualified path to the executable for the default browser.</short>
</element>
<element name="FindDefaultBrowser.AParams">
<short>
Parameters needed to start the default browser for the platform.
</short>
</element>

<element name="OpenURL">
<short>Open a given URL with the default browser.</short>
<descr>
<p>
The function uses FindDefaultBrowser to find the default browser for the 
platform. If it was found, it is started and the returns value is set to 
<b>True</b>.
</p>
<p>
AURL is passed as parameter to the browser application. AURL must be a URL 
like http://www.lazarus.freepascal.org or file:///tmp/test.txt or 
file://C:\test.txt. AURL is quoted when passed as an argument to ensure that 
space(s) in the path or file name are handled properly.
</p>
</descr>
</element>
<element name="OpenURL.Result">
<short>
<b>True</b> if the browser was found and called to open the URL.
</short>
</element>
<element name="OpenURL.AURL">
<short>URL with the resource to open in the browser.</short>
</element>

<element name="OpenDocument">
<short>
Opens the specified document using the default application for the platform 
or widgetset.
</short>
<descr>
<p>
<var>OpenDocument</var> is a <var>Boolean</var> function used to open the 
document specified in APath using the default application for the platform or 
widget set.
</p>
<p>
The implementation of OpenDocument is platform- and/or WidgetSet-specific. On 
Windows, the OpenURL function is called to open the specified document. For 
UNIX-like platforms, the OpenDocumentWidgetsetImplementation is called when 
assigned. Otherwise, FindFilenameOfCmd is used to check for common Desktop 
Environment applications for the platform. RunCmdFromPath is called to open 
the document using the application.
</p>
<p>
The return value contains <b>True</b> if an application is available to for 
the specified file name. The return value is <b>False</b> if an application 
cannot be found for the specified file, or the file does not exist in the 
given path.
</p>
</descr>
<seealso/>
</element>
<element name="OpenDocument.Result">
<short>
<b>True</b> if an application was found and the document was opened.
</short>
</element>
<element name="OpenDocument.APath">
<short>Full path and file name to open in the routine.</short>
</element>

<element name="TOpenParamStringProc">
<short/>
<descr/>
<seealso/>
</element>
<element name="TOpenParamStringProc.Result">
<short/>
</element>
<element name="TOpenParamStringProc.AString">
<short/>
</element>

<element name="OnShowSelectItemDialogResult">
<short/>
<descr/>
<seealso/>
</element>

<element name="OnListViewDialogResult">
<short/>
<descr/>
<seealso/>
</element>

<element name="OpenURLWidgetsetImplementation">
<short/>
<descr/>
<seealso/>
</element>

<element name="OpenDocumentWidgetsetImplementation">
<short/>
<descr/>
<seealso/>
</element>

</module>
<!-- LCLIntf -->
</package>
</fpdoc-descriptions>
